var cw = Object.defineProperty;
var uw = (e, t, a) => t in e ? cw(e, t, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: a
}) : e[t] = a;
var pt = (e, t, a) => uw(e, typeof t != "symbol" ? t + "" : t, a);
(function () {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) i(o);
  new MutationObserver(o => {
    for (const l of o)
      if (l.type === "childList")
        for (const h of l.addedNodes) h.tagName === "LINK" && h.rel === "modulepreload" && i(h)
  }).observe(document, {
    childList: !0,
    subtree: !0
  });

  function a(o) {
    const l = {};
    return o.integrity && (l.integrity = o.integrity), o.referrerPolicy && (l.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? l.credentials = "include" : o.crossOrigin === "anonymous" ? l.credentials = "omit" : l.credentials = "same-origin", l
  }

  function i(o) {
    if (o.ep) return;
    o.ep = !0;
    const l = a(o);
    fetch(o.href, l)
  }
})();
/**
 * @vue/shared v3.4.37
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
/*! #__NO_SIDE_EFFECTS__ */
function af(e, t) {
  const a = new Set(e.split(","));
  return i => a.has(i)
}
const ka = {},
  zs = [],
  Jr = () => {},
  dw = () => !1,
  Jc = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),
  rf = e => e.startsWith("onUpdate:"),
  ar = Object.assign,
  nf = (e, t) => {
    const a = e.indexOf(t);
    a > -1 && e.splice(a, 1)
  },
  hw = Object.prototype.hasOwnProperty,
  Gt = (e, t) => hw.call(e, t),
  kt = Array.isArray,
  Xs = e => eu(e) === "[object Map]",
  Uv = e => eu(e) === "[object Set]",
  Pt = e => typeof e == "function",
  Ca = e => typeof e == "string",
  Li = e => typeof e == "symbol",
  pa = e => e !== null && typeof e == "object",
  Gv = e => (pa(e) || Pt(e)) && Pt(e.then) && Pt(e.catch),
  qv = Object.prototype.toString,
  eu = e => qv.call(e),
  fw = e => eu(e).slice(8, -1),
  Kv = e => eu(e) === "[object Object]",
  sf = e => Ca(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
  jo = af(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
  tu = e => {
    const t = Object.create(null);
    return a => t[a] || (t[a] = e(a))
  },
  pw = /-(\w)/g,
  dn = tu(e => e.replace(pw, (t, a) => a ? a.toUpperCase() : "")),
  gw = /\B([A-Z])/g,
  Oi = tu(e => e.replace(gw, "-$1").toLowerCase()),
  au = tu(e => e.charAt(0).toUpperCase() + e.slice(1)),
  Hu = tu(e => e ? `on${au(e)}` : ""),
  Ci = (e, t) => !Object.is(e, t),
  uc = (e, ...t) => {
    for (let a = 0; a < e.length; a++) e[a](...t)
  },
  Zv = (e, t, a, i = !1) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      writable: i,
      value: a
    })
  },
  Qd = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
  },
  mw = e => {
    const t = Ca(e) ? Number(e) : NaN;
    return isNaN(t) ? e : t
  };
let Ep;
const Qv = () => Ep || (Ep = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function pr(e) {
  if (kt(e)) {
    const t = {};
    for (let a = 0; a < e.length; a++) {
      const i = e[a],
        o = Ca(i) ? xw(i) : pr(i);
      if (o)
        for (const l in o) t[l] = o[l]
    }
    return t
  } else if (Ca(e) || pa(e)) return e
}
const vw = /;(?![^(]*\))/g,
  bw = /:([^]+)/,
  yw = /\/\*[^]*?\*\//g;

function xw(e) {
  const t = {};
  return e.replace(yw, "").split(vw).forEach(a => {
    if (a) {
      const i = a.split(bw);
      i.length > 1 && (t[i[0].trim()] = i[1].trim())
    }
  }), t
}

function ut(e) {
  let t = "";
  if (Ca(e)) t = e;
  else if (kt(e))
    for (let a = 0; a < e.length; a++) {
      const i = ut(e[a]);
      i && (t += i + " ")
    } else if (pa(e))
      for (const a in e) e[a] && (t += a + " ");
  return t.trim()
}

function Ja(e) {
  if (!e) return null;
  let {
    class: t,
    style: a
  } = e;
  return t && !Ca(t) && (e.class = ut(t)), a && (e.style = pr(a)), e
}
const ww = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
  kw = af(ww);

function Jv(e) {
  return !!e || e === ""
}
const eb = e => !!(e && e.__v_isRef === !0),
  st = e => Ca(e) ? e : e == null ? "" : kt(e) || pa(e) && (e.toString === qv || !Pt(e.toString)) ? eb(e) ? st(e.value) : JSON.stringify(e, tb, 2) : String(e),
  tb = (e, t) => eb(t) ? tb(e, t.value) : Xs(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce((a, [i, o], l) => (a[Yu(i, l) + " =>"] = o, a), {})
  } : Uv(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(a => Yu(a))
  } : Li(t) ? Yu(t) : pa(t) && !kt(t) && !Kv(t) ? String(t) : t,
  Yu = (e, t = "") => {
    var a;
    return Li(e) ? `Symbol(${(a=e.description)!=null?a:t})` : e
  };
/**
 * @vue/reactivity v3.4.37
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
let Xr;
class ab {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Xr, !t && Xr && (this.index = (Xr.scopes || (Xr.scopes = [])).push(this) - 1)
  }
  get active() {
    return this._active
  }
  run(t) {
    if (this._active) {
      const a = Xr;
      try {
        return Xr = this, t()
      } finally {
        Xr = a
      }
    }
  }
  on() {
    Xr = this
  }
  off() {
    Xr = this.parent
  }
  stop(t) {
    if (this._active) {
      let a, i;
      for (a = 0, i = this.effects.length; a < i; a++) this.effects[a].stop();
      for (a = 0, i = this.cleanups.length; a < i; a++) this.cleanups[a]();
      if (this.scopes)
        for (a = 0, i = this.scopes.length; a < i; a++) this.scopes[a].stop(!0);
      if (!this.detached && this.parent && !t) {
        const o = this.parent.scopes.pop();
        o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index)
      }
      this.parent = void 0, this._active = !1
    }
  }
}

function rb(e) {
  return new ab(e)
}

function _w(e, t = Xr) {
  t && t.active && t.effects.push(e)
}

function nb() {
  return Xr
}

function Sw(e) {
  Xr && Xr.cleanups.push(e)
}
let ls;
class of {
  constructor(t, a, i, o) {
    this.fn = t, this.trigger = a, this.scheduler = i, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, _w(this, o)
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      this._dirtyLevel = 1, Mi();
      for (let t = 0; t < this._depsLength; t++) {
        const a = this.deps[t];
        if (a.computed && (Aw(a.computed), this._dirtyLevel >= 4)) break
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), Ii()
    }
    return this._dirtyLevel >= 4
  }
  set dirty(t) {
    this._dirtyLevel = t ? 4 : 0
  }
  run() {
    if (this._dirtyLevel = 0, !this.active) return this.fn();
    let t = wi,
      a = ls;
    try {
      return wi = !0, ls = this, this._runnings++, Pp(this), this.fn()
    } finally {
      Lp(this), this._runnings--, ls = a, wi = t
    }
  }
  stop() {
    this.active && (Pp(this), Lp(this), this.onStop && this.onStop(), this.active = !1)
  }
}

function Aw(e) {
  return e.value
}

function Pp(e) {
  e._trackId++, e._depsLength = 0
}

function Lp(e) {
  if (e.deps.length > e._depsLength) {
    for (let t = e._depsLength; t < e.deps.length; t++) ib(e.deps[t], e);
    e.deps.length = e._depsLength
  }
}

function ib(e, t) {
  const a = e.get(t);
  a !== void 0 && t._trackId !== a && (e.delete(t), e.size === 0 && e.cleanup())
}
let wi = !0,
  Jd = 0;
const sb = [];

function Mi() {
  sb.push(wi), wi = !1
}

function Ii() {
  const e = sb.pop();
  wi = e === void 0 ? !0 : e
}

function lf() {
  Jd++
}

function cf() {
  for (Jd--; !Jd && eh.length;) eh.shift()()
}

function ob(e, t, a) {
  if (t.get(e) !== e._trackId) {
    t.set(e, e._trackId);
    const i = e.deps[e._depsLength];
    i !== t ? (i && ib(i, e), e.deps[e._depsLength++] = t) : e._depsLength++
  }
}
const eh = [];

function lb(e, t, a) {
  lf();
  for (const i of e.keys()) {
    let o;
    i._dirtyLevel < t && (o ?? (o = e.get(i) === i._trackId)) && (i._shouldSchedule || (i._shouldSchedule = i._dirtyLevel === 0), i._dirtyLevel = t), i._shouldSchedule && (o ?? (o = e.get(i) === i._trackId)) && (i.trigger(), (!i._runnings || i.allowRecurse) && i._dirtyLevel !== 2 && (i._shouldSchedule = !1, i.scheduler && eh.push(i.scheduler)))
  }
  cf()
}
const cb = (e, t) => {
    const a = new Map;
    return a.cleanup = e, a.computed = t, a
  },
  Sc = new WeakMap,
  cs = Symbol(""),
  th = Symbol("");

function Hr(e, t, a) {
  if (wi && ls) {
    let i = Sc.get(e);
    i || Sc.set(e, i = new Map);
    let o = i.get(a);
    o || i.set(a, o = cb(() => i.delete(a))), ob(ls, o)
  }
}

function Un(e, t, a, i, o, l) {
  const h = Sc.get(e);
  if (!h) return;
  let p = [];
  if (t === "clear") p = [...h.values()];
  else if (a === "length" && kt(e)) {
    const m = Number(i);
    h.forEach((k, w) => {
      (w === "length" || !Li(w) && w >= m) && p.push(k)
    })
  } else switch (a !== void 0 && p.push(h.get(a)), t) {
    case "add":
      kt(e) ? sf(a) && p.push(h.get("length")) : (p.push(h.get(cs)), Xs(e) && p.push(h.get(th)));
      break;
    case "delete":
      kt(e) || (p.push(h.get(cs)), Xs(e) && p.push(h.get(th)));
      break;
    case "set":
      Xs(e) && p.push(h.get(cs));
      break
  }
  lf();
  for (const m of p) m && lb(m, 4);
  cf()
}

function Cw(e, t) {
  const a = Sc.get(e);
  return a && a.get(t)
}
const Tw = af("__proto__,__v_isRef,__isVue"),
  ub = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Li)),
  Op = Ew();

function Ew() {
  const e = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach(t => {
    e[t] = function (...a) {
      const i = It(this);
      for (let l = 0, h = this.length; l < h; l++) Hr(i, "get", l + "");
      const o = i[t](...a);
      return o === -1 || o === !1 ? i[t](...a.map(It)) : o
    }
  }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => {
    e[t] = function (...a) {
      Mi(), lf();
      const i = It(this)[t].apply(this, a);
      return cf(), Ii(), i
    }
  }), e
}

function Pw(e) {
  Li(e) || (e = String(e));
  const t = It(this);
  return Hr(t, "has", e), t.hasOwnProperty(e)
}
class db {
  constructor(t = !1, a = !1) {
    this._isReadonly = t, this._isShallow = a
  }
  get(t, a, i) {
    const o = this._isReadonly,
      l = this._isShallow;
    if (a === "__v_isReactive") return !o;
    if (a === "__v_isReadonly") return o;
    if (a === "__v_isShallow") return l;
    if (a === "__v_raw") return i === (o ? l ? zw : gb : l ? pb : fb).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(i) ? t : void 0;
    const h = kt(t);
    if (!o) {
      if (h && Gt(Op, a)) return Reflect.get(Op, a, i);
      if (a === "hasOwnProperty") return Pw
    }
    const p = Reflect.get(t, a, i);
    return (Li(a) ? ub.has(a) : Tw(a)) || (o || Hr(t, "get", a), l) ? p : Fa(p) ? h && sf(a) ? p : p.value : pa(p) ? o ? vb(p) : qr(p) : p
  }
}
class hb extends db {
  constructor(t = !1) {
    super(!1, t)
  }
  set(t, a, i, o) {
    let l = t[a];
    if (!this._isShallow) {
      const m = gs(l);
      if (!qs(i) && !gs(i) && (l = It(l), i = It(i)), !kt(t) && Fa(l) && !Fa(i)) return m ? !1 : (l.value = i, !0)
    }
    const h = kt(t) && sf(a) ? Number(a) < t.length : Gt(t, a),
      p = Reflect.set(t, a, i, o);
    return t === It(o) && (h ? Ci(i, l) && Un(t, "set", a, i) : Un(t, "add", a, i)), p
  }
  deleteProperty(t, a) {
    const i = Gt(t, a);
    t[a];
    const o = Reflect.deleteProperty(t, a);
    return o && i && Un(t, "delete", a, void 0), o
  }
  has(t, a) {
    const i = Reflect.has(t, a);
    return (!Li(a) || !ub.has(a)) && Hr(t, "has", a), i
  }
  ownKeys(t) {
    return Hr(t, "iterate", kt(t) ? "length" : cs), Reflect.ownKeys(t)
  }
}
class Lw extends db {
  constructor(t = !1) {
    super(!0, t)
  }
  set(t, a) {
    return !0
  }
  deleteProperty(t, a) {
    return !0
  }
}
const Ow = new hb,
  Mw = new Lw,
  Iw = new hb(!0);
const uf = e => e,
  ru = e => Reflect.getPrototypeOf(e);

function Wl(e, t, a = !1, i = !1) {
  e = e.__v_raw;
  const o = It(e),
    l = It(t);
  a || (Ci(t, l) && Hr(o, "get", t), Hr(o, "get", l));
  const {
    has: h
  } = ru(o), p = i ? uf : a ? ff : sl;
  if (h.call(o, t)) return p(e.get(t));
  if (h.call(o, l)) return p(e.get(l));
  e !== o && e.get(t)
}

function Vl(e, t = !1) {
  const a = this.__v_raw,
    i = It(a),
    o = It(e);
  return t || (Ci(e, o) && Hr(i, "has", e), Hr(i, "has", o)), e === o ? a.has(e) : a.has(e) || a.has(o)
}

function jl(e, t = !1) {
  return e = e.__v_raw, !t && Hr(It(e), "iterate", cs), Reflect.get(e, "size", e)
}

function Mp(e, t = !1) {
  !t && !qs(e) && !gs(e) && (e = It(e));
  const a = It(this);
  return ru(a).has.call(a, e) || (a.add(e), Un(a, "add", e, e)), this
}

function Ip(e, t, a = !1) {
  !a && !qs(t) && !gs(t) && (t = It(t));
  const i = It(this),
    {
      has: o,
      get: l
    } = ru(i);
  let h = o.call(i, e);
  h || (e = It(e), h = o.call(i, e));
  const p = l.call(i, e);
  return i.set(e, t), h ? Ci(t, p) && Un(i, "set", e, t) : Un(i, "add", e, t), this
}

function Rp(e) {
  const t = It(this),
    {
      has: a,
      get: i
    } = ru(t);
  let o = a.call(t, e);
  o || (e = It(e), o = a.call(t, e)), i && i.call(t, e);
  const l = t.delete(e);
  return o && Un(t, "delete", e, void 0), l
}

function Dp() {
  const e = It(this),
    t = e.size !== 0,
    a = e.clear();
  return t && Un(e, "clear", void 0, void 0), a
}

function Ul(e, t) {
  return function (i, o) {
    const l = this,
      h = l.__v_raw,
      p = It(h),
      m = t ? uf : e ? ff : sl;
    return !e && Hr(p, "iterate", cs), h.forEach((k, w) => i.call(o, m(k), m(w), l))
  }
}

function Gl(e, t, a) {
  return function (...i) {
    const o = this.__v_raw,
      l = It(o),
      h = Xs(l),
      p = e === "entries" || e === Symbol.iterator && h,
      m = e === "keys" && h,
      k = o[e](...i),
      w = a ? uf : t ? ff : sl;
    return !t && Hr(l, "iterate", m ? th : cs), {
      next() {
        const {
          value: S,
          done: A
        } = k.next();
        return A ? {
          value: S,
          done: A
        } : {
          value: p ? [w(S[0]), w(S[1])] : w(S),
          done: A
        }
      },
      [Symbol.iterator]() {
        return this
      }
    }
  }
}

function ni(e) {
  return function (...t) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this
  }
}

function Rw() {
  const e = {
      get(l) {
        return Wl(this, l)
      },
      get size() {
        return jl(this)
      },
      has: Vl,
      add: Mp,
      set: Ip,
      delete: Rp,
      clear: Dp,
      forEach: Ul(!1, !1)
    },
    t = {
      get(l) {
        return Wl(this, l, !1, !0)
      },
      get size() {
        return jl(this)
      },
      has: Vl,
      add(l) {
        return Mp.call(this, l, !0)
      },
      set(l, h) {
        return Ip.call(this, l, h, !0)
      },
      delete: Rp,
      clear: Dp,
      forEach: Ul(!1, !0)
    },
    a = {
      get(l) {
        return Wl(this, l, !0)
      },
      get size() {
        return jl(this, !0)
      },
      has(l) {
        return Vl.call(this, l, !0)
      },
      add: ni("add"),
      set: ni("set"),
      delete: ni("delete"),
      clear: ni("clear"),
      forEach: Ul(!0, !1)
    },
    i = {
      get(l) {
        return Wl(this, l, !0, !0)
      },
      get size() {
        return jl(this, !0)
      },
      has(l) {
        return Vl.call(this, l, !0)
      },
      add: ni("add"),
      set: ni("set"),
      delete: ni("delete"),
      clear: ni("clear"),
      forEach: Ul(!0, !0)
    };
  return ["keys", "values", "entries", Symbol.iterator].forEach(l => {
    e[l] = Gl(l, !1, !1), a[l] = Gl(l, !0, !1), t[l] = Gl(l, !1, !0), i[l] = Gl(l, !0, !0)
  }), [e, a, t, i]
}
const [Dw, Nw, Fw, $w] = Rw();

function df(e, t) {
  const a = t ? e ? $w : Fw : e ? Nw : Dw;
  return (i, o, l) => o === "__v_isReactive" ? !e : o === "__v_isReadonly" ? e : o === "__v_raw" ? i : Reflect.get(Gt(a, o) && o in i ? a : i, o, l)
}
const Bw = {
    get: df(!1, !1)
  },
  Hw = {
    get: df(!1, !0)
  },
  Yw = {
    get: df(!0, !1)
  };
const fb = new WeakMap,
  pb = new WeakMap,
  gb = new WeakMap,
  zw = new WeakMap;

function Xw(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0
  }
}

function Ww(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Xw(fw(e))
}

function qr(e) {
  return gs(e) ? e : hf(e, !1, Ow, Bw, fb)
}

function mb(e) {
  return hf(e, !1, Iw, Hw, pb)
}

function vb(e) {
  return hf(e, !0, Mw, Yw, gb)
}

function hf(e, t, a, i, o) {
  if (!pa(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
  const l = o.get(e);
  if (l) return l;
  const h = Ww(e);
  if (h === 0) return e;
  const p = new Proxy(e, h === 2 ? i : a);
  return o.set(e, p), p
}

function Uo(e) {
  return gs(e) ? Uo(e.__v_raw) : !!(e && e.__v_isReactive)
}

function gs(e) {
  return !!(e && e.__v_isReadonly)
}

function qs(e) {
  return !!(e && e.__v_isShallow)
}

function bb(e) {
  return e ? !!e.__v_raw : !1
}

function It(e) {
  const t = e && e.__v_raw;
  return t ? It(t) : e
}

function yb(e) {
  return Object.isExtensible(e) && Zv(e, "__v_skip", !0), e
}
const sl = e => pa(e) ? qr(e) : e,
  ff = e => pa(e) ? vb(e) : e;
class xb {
  constructor(t, a, i, o) {
    this.getter = t, this._setter = a, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new of(() => t(this._value), () => dc(this, this.effect._dirtyLevel === 2 ? 2 : 3)), this.effect.computed = this, this.effect.active = this._cacheable = !o, this.__v_isReadonly = i
  }
  get value() {
    const t = It(this);
    return (!t._cacheable || t.effect.dirty) && Ci(t._value, t._value = t.effect.run()) && dc(t, 4), wb(t), t.effect._dirtyLevel >= 2 && dc(t, 2), t._value
  }
  set value(t) {
    this._setter(t)
  }
  get _dirty() {
    return this.effect.dirty
  }
  set _dirty(t) {
    this.effect.dirty = t
  }
}

function Vw(e, t, a = !1) {
  let i, o;
  const l = Pt(e);
  return l ? (i = e, o = Jr) : (i = e.get, o = e.set), new xb(i, o, l || !o, a)
}

function wb(e) {
  var t;
  wi && ls && (e = It(e), ob(ls, (t = e.dep) != null ? t : e.dep = cb(() => e.dep = void 0, e instanceof xb ? e : void 0)))
}

function dc(e, t = 4, a, i) {
  e = It(e);
  const o = e.dep;
  o && lb(o, t)
}

function Fa(e) {
  return !!(e && e.__v_isRef === !0)
}

function _e(e) {
  return kb(e, !1)
}

function Sl(e) {
  return kb(e, !0)
}

function kb(e, t) {
  return Fa(e) ? e : new jw(e, t)
}
class jw {
  constructor(t, a) {
    this.__v_isShallow = a, this.dep = void 0, this.__v_isRef = !0, this._rawValue = a ? t : It(t), this._value = a ? t : sl(t)
  }
  get value() {
    return wb(this), this._value
  }
  set value(t) {
    const a = this.__v_isShallow || qs(t) || gs(t);
    t = a ? t : It(t), Ci(t, this._rawValue) && (this._rawValue, this._rawValue = t, this._value = a ? t : sl(t), dc(this, 4))
  }
}

function se(e) {
  return Fa(e) ? e.value : e
}
const Uw = {
  get: (e, t, a) => se(Reflect.get(e, t, a)),
  set: (e, t, a, i) => {
    const o = e[t];
    return Fa(o) && !Fa(a) ? (o.value = a, !0) : Reflect.set(e, t, a, i)
  }
};

function _b(e) {
  return Uo(e) ? e : new Proxy(e, Uw)
}

function Gw(e) {
  const t = kt(e) ? new Array(e.length) : {};
  for (const a in e) t[a] = Sb(e, a);
  return t
}
class qw {
  constructor(t, a, i) {
    this._object = t, this._key = a, this._defaultValue = i, this.__v_isRef = !0
  }
  get value() {
    const t = this._object[this._key];
    return t === void 0 ? this._defaultValue : t
  }
  set value(t) {
    this._object[this._key] = t
  }
  get dep() {
    return Cw(It(this._object), this._key)
  }
}
class Kw {
  constructor(t) {
    this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0
  }
  get value() {
    return this._getter()
  }
}

function ol(e, t, a) {
  return Fa(e) ? e : Pt(e) ? new Kw(e) : pa(e) && arguments.length > 1 ? Sb(e, t, a) : _e(e)
}

function Sb(e, t, a) {
  const i = e[t];
  return Fa(i) ? i : new qw(e, t, a)
}
/**
 * @vue/runtime-core v3.4.37
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
function ki(e, t, a, i) {
  try {
    return i ? e(...i) : e()
  } catch (o) {
    nu(o, t, a)
  }
}

function en(e, t, a, i) {
  if (Pt(e)) {
    const o = ki(e, t, a, i);
    return o && Gv(o) && o.catch(l => {
      nu(l, t, a)
    }), o
  }
  if (kt(e)) {
    const o = [];
    for (let l = 0; l < e.length; l++) o.push(en(e[l], t, a, i));
    return o
  }
}

function nu(e, t, a, i = !0) {
  const o = t ? t.vnode : null;
  if (t) {
    let l = t.parent;
    const h = t.proxy,
      p = `https://vuejs.org/error-reference/#runtime-${a}`;
    for (; l;) {
      const k = l.ec;
      if (k) {
        for (let w = 0; w < k.length; w++)
          if (k[w](e, h, p) === !1) return
      }
      l = l.parent
    }
    const m = t.appContext.config.errorHandler;
    if (m) {
      Mi(), ki(m, null, 10, [e, h, p]), Ii();
      return
    }
  }
  Zw(e, a, o, i)
}

function Zw(e, t, a, i = !0) {
  console.error(e)
}
let ll = !1,
  ah = !1;
const fr = [];
let An = 0;
const Ws = [];
let hi = null,
  ts = 0;
const Ab = Promise.resolve();
let pf = null;

function Jt(e) {
  const t = pf || Ab;
  return e ? t.then(this ? e.bind(this) : e) : t
}

function Qw(e) {
  let t = An + 1,
    a = fr.length;
  for (; t < a;) {
    const i = t + a >>> 1,
      o = fr[i],
      l = cl(o);
    l < e || l === e && o.pre ? t = i + 1 : a = i
  }
  return t
}

function gf(e) {
  (!fr.length || !fr.includes(e, ll && e.allowRecurse ? An + 1 : An)) && (e.id == null ? fr.push(e) : fr.splice(Qw(e.id), 0, e), Cb())
}

function Cb() {
  !ll && !ah && (ah = !0, pf = Ab.then(Eb))
}

function Jw(e) {
  const t = fr.indexOf(e);
  t > An && fr.splice(t, 1)
}

function ek(e) {
  kt(e) ? Ws.push(...e) : (!hi || !hi.includes(e, e.allowRecurse ? ts + 1 : ts)) && Ws.push(e), Cb()
}

function Np(e, t, a = ll ? An + 1 : 0) {
  for (; a < fr.length; a++) {
    const i = fr[a];
    if (i && i.pre) {
      if (e && i.id !== e.uid) continue;
      fr.splice(a, 1), a--, i()
    }
  }
}

function Tb(e) {
  if (Ws.length) {
    const t = [...new Set(Ws)].sort((a, i) => cl(a) - cl(i));
    if (Ws.length = 0, hi) {
      hi.push(...t);
      return
    }
    for (hi = t, ts = 0; ts < hi.length; ts++) {
      const a = hi[ts];
      a.active !== !1 && a()
    }
    hi = null, ts = 0
  }
}
const cl = e => e.id == null ? 1 / 0 : e.id,
  tk = (e, t) => {
    const a = cl(e) - cl(t);
    if (a === 0) {
      if (e.pre && !t.pre) return -1;
      if (t.pre && !e.pre) return 1
    }
    return a
  };

function Eb(e) {
  ah = !1, ll = !0, fr.sort(tk);
  try {
    for (An = 0; An < fr.length; An++) {
      const t = fr[An];
      t && t.active !== !1 && ki(t, t.i, t.i ? 15 : 14)
    }
  } finally {
    An = 0, fr.length = 0, Tb(), ll = !1, pf = null, (fr.length || Ws.length) && Eb()
  }
}
let er = null,
  iu = null;

function Ac(e) {
  const t = er;
  return er = e, iu = e && e.type.__scopeId || null, t
}

function Pb(e) {
  iu = e
}

function Lb() {
  iu = null
}

function Qe(e, t = er, a) {
  if (!t || e._n) return e;
  const i = (...o) => {
    i._d && Gp(-1);
    const l = Ac(t);
    let h;
    try {
      h = e(...o)
    } finally {
      Ac(l), i._d && Gp(1)
    }
    return h
  };
  return i._n = !0, i._c = !0, i._d = !0, i
}

function Vs(e, t) {
  if (er === null) return e;
  const a = uu(er),
    i = e.dirs || (e.dirs = []);
  for (let o = 0; o < t.length; o++) {
    let [l, h, p, m = ka] = t[o];
    l && (Pt(l) && (l = {
      mounted: l,
      updated: l
    }), l.deep && vi(h), i.push({
      dir: l,
      instance: a,
      value: h,
      oldValue: void 0,
      arg: p,
      modifiers: m
    }))
  }
  return e
}

function Vi(e, t, a, i) {
  const o = e.dirs,
    l = t && t.dirs;
  for (let h = 0; h < o.length; h++) {
    const p = o[h];
    l && (p.oldValue = l[h].value);
    let m = p.dir[i];
    m && (Mi(), en(m, a, 8, [e.el, p, e, t]), Ii())
  }
}
const fi = Symbol("_leaveCb"),
  ql = Symbol("_enterCb");

function ak() {
  const e = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: new Map
  };
  return Dt(() => {
    e.isMounted = !0
  }), vf(() => {
    e.isUnmounting = !0
  }), e
}
const Kr = [Function, Array],
  Ob = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Kr,
    onEnter: Kr,
    onAfterEnter: Kr,
    onEnterCancelled: Kr,
    onBeforeLeave: Kr,
    onLeave: Kr,
    onAfterLeave: Kr,
    onLeaveCancelled: Kr,
    onBeforeAppear: Kr,
    onAppear: Kr,
    onAfterAppear: Kr,
    onAppearCancelled: Kr
  },
  Mb = e => {
    const t = e.subTree;
    return t.component ? Mb(t.component) : t
  },
  rk = {
    name: "BaseTransition",
    props: Ob,
    setup(e, {
      slots: t
    }) {
      const a = hn(),
        i = ak();
      return () => {
        const o = t.default && Rb(t.default(), !0);
        if (!o || !o.length) return;
        let l = o[0];
        if (o.length > 1) {
          for (const A of o)
            if (A.type !== Nr) {
              l = A;
              break
            }
        }
        const h = It(e),
          {
            mode: p
          } = h;
        if (i.isLeaving) return zu(l);
        const m = Fp(l);
        if (!m) return zu(l);
        let k = rh(m, h, i, a, A => k = A);
        Cc(m, k);
        const w = a.subTree,
          S = w && Fp(w);
        if (S && S.type !== Nr && !as(m, S) && Mb(a).type !== Nr) {
          const A = rh(S, h, i, a);
          if (Cc(S, A), p === "out-in" && m.type !== Nr) return i.isLeaving = !0, A.afterLeave = () => {
            i.isLeaving = !1, a.update.active !== !1 && (a.effect.dirty = !0, a.update())
          }, zu(l);
          p === "in-out" && m.type !== Nr && (A.delayLeave = (E, M, D) => {
            const B = Ib(i, S);
            B[String(S.key)] = S, E[fi] = () => {
              M(), E[fi] = void 0, delete k.delayedLeave
            }, k.delayedLeave = D
          })
        }
        return l
      }
    }
  },
  nk = rk;

function Ib(e, t) {
  const {
    leavingVNodes: a
  } = e;
  let i = a.get(t.type);
  return i || (i = Object.create(null), a.set(t.type, i)), i
}

function rh(e, t, a, i, o) {
  const {
    appear: l,
    mode: h,
    persisted: p = !1,
    onBeforeEnter: m,
    onEnter: k,
    onAfterEnter: w,
    onEnterCancelled: S,
    onBeforeLeave: A,
    onLeave: E,
    onAfterLeave: M,
    onLeaveCancelled: D,
    onBeforeAppear: B,
    onAppear: z,
    onAfterAppear: I,
    onAppearCancelled: N
  } = t, U = String(e.key), W = Ib(a, e), X = (Z, ie) => {
    Z && en(Z, i, 9, ie)
  }, V = (Z, ie) => {
    const fe = ie[1];
    X(Z, ie), kt(Z) ? Z.every(le => le.length <= 1) && fe() : Z.length <= 1 && fe()
  }, ne = {
    mode: h,
    persisted: p,
    beforeEnter(Z) {
      let ie = m;
      if (!a.isMounted)
        if (l) ie = B || m;
        else return;
      Z[fi] && Z[fi](!0);
      const fe = W[U];
      fe && as(e, fe) && fe.el[fi] && fe.el[fi](), X(ie, [Z])
    },
    enter(Z) {
      let ie = k,
        fe = w,
        le = S;
      if (!a.isMounted)
        if (l) ie = z || k, fe = I || w, le = N || S;
        else return;
      let Ee = !1;
      const ye = Z[ql] = ve => {
        Ee || (Ee = !0, ve ? X(le, [Z]) : X(fe, [Z]), ne.delayedLeave && ne.delayedLeave(), Z[ql] = void 0)
      };
      ie ? V(ie, [Z, ye]) : ye()
    },
    leave(Z, ie) {
      const fe = String(e.key);
      if (Z[ql] && Z[ql](!0), a.isUnmounting) return ie();
      X(A, [Z]);
      let le = !1;
      const Ee = Z[fi] = ye => {
        le || (le = !0, ie(), ye ? X(D, [Z]) : X(M, [Z]), Z[fi] = void 0, W[fe] === e && delete W[fe])
      };
      W[fe] = e, E ? V(E, [Z, Ee]) : Ee()
    },
    clone(Z) {
      const ie = rh(Z, t, a, i, o);
      return o && o(ie), ie
    }
  };
  return ne
}

function zu(e) {
  if (su(e)) return e = Gn(e), e.children = null, e
}

function Fp(e) {
  if (!su(e)) return e;
  const {
    shapeFlag: t,
    children: a
  } = e;
  if (a) {
    if (t & 16) return a[0];
    if (t & 32 && Pt(a.default)) return a.default()
  }
}

function Cc(e, t) {
  e.shapeFlag & 6 && e.component ? Cc(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}

function Rb(e, t = !1, a) {
  let i = [],
    o = 0;
  for (let l = 0; l < e.length; l++) {
    let h = e[l];
    const p = a == null ? h.key : String(a) + String(h.key != null ? h.key : l);
    h.type === vt ? (h.patchFlag & 128 && o++, i = i.concat(Rb(h.children, t, p))) : (t || h.type !== Nr) && i.push(p != null ? Gn(h, {
      key: p
    }) : h)
  }
  if (o > 1)
    for (let l = 0; l < i.length; l++) i[l].patchFlag = -2;
  return i
} /*! #__NO_SIDE_EFFECTS__ */
function Ot(e, t) {
  return Pt(e) ? ar({
    name: e.name
  }, t, {
    setup: e
  }) : e
}
const Go = e => !!e.type.__asyncLoader,
  su = e => e.type.__isKeepAlive;

function ik(e, t) {
  Db(e, "a", t)
}

function sk(e, t) {
  Db(e, "da", t)
}

function Db(e, t, a = sr) {
  const i = e.__wdc || (e.__wdc = () => {
    let o = a;
    for (; o;) {
      if (o.isDeactivated) return;
      o = o.parent
    }
    return e()
  });
  if (ou(t, i, a), a) {
    let o = a.parent;
    for (; o && o.parent;) su(o.parent.vnode) && ok(i, t, a, o), o = o.parent
  }
}

function ok(e, t, a, i) {
  const o = ou(t, e, i, !0);
  Ha(() => {
    nf(i[t], o)
  }, a)
}

function ou(e, t, a = sr, i = !1) {
  if (a) {
    const o = a[e] || (a[e] = []),
      l = t.__weh || (t.__weh = (...h) => {
        Mi();
        const p = El(a),
          m = en(t, a, e, h);
        return p(), Ii(), m
      });
    return i ? o.unshift(l) : o.push(l), l
  }
}
const Zn = e => (t, a = sr) => {
    (!cu || e === "sp") && ou(e, (...i) => t(...i), a)
  },
  mf = Zn("bm"),
  Dt = Zn("m"),
  Nb = Zn("bu"),
  lk = Zn("u"),
  vf = Zn("bum"),
  Ha = Zn("um"),
  ck = Zn("sp"),
  uk = Zn("rtg"),
  dk = Zn("rtc");

function hk(e, t = sr) {
  ou("ec", e, t)
}
const Fb = "components";

function Mn(e, t) {
  return Bb(Fb, e, !0, t) || e
}
const $b = Symbol.for("v-ndc");

function Al(e) {
  return Ca(e) ? Bb(Fb, e, !1) || e : e || $b
}

function Bb(e, t, a = !0, i = !1) {
  const o = er || sr;
  if (o) {
    const l = o.type; {
      const p = e_(l, !1);
      if (p && (p === t || p === dn(t) || p === au(dn(t)))) return l
    }
    const h = $p(o[e] || l[e], t) || $p(o.appContext[e], t);
    return !h && i ? l : h
  }
}

function $p(e, t) {
  return e && (e[t] || e[dn(t)] || e[au(dn(t))])
}

function la(e, t, a, i) {
  let o;
  const l = a;
  if (kt(e) || Ca(e)) {
    o = new Array(e.length);
    for (let h = 0, p = e.length; h < p; h++) o[h] = t(e[h], h, void 0, l)
  } else if (typeof e == "number") {
    o = new Array(e);
    for (let h = 0; h < e; h++) o[h] = t(h + 1, h, void 0, l)
  } else if (pa(e))
    if (e[Symbol.iterator]) o = Array.from(e, (h, p) => t(h, p, void 0, l));
    else {
      const h = Object.keys(e);
      o = new Array(h.length);
      for (let p = 0, m = h.length; p < m; p++) {
        const k = h[p];
        o[p] = t(e[k], k, p, l)
      }
    }
  else o = [];
  return o
}

function mr(e, t) {
  for (let a = 0; a < t.length; a++) {
    const i = t[a];
    if (kt(i))
      for (let o = 0; o < i.length; o++) e[i[o].name] = i[o].fn;
    else i && (e[i.name] = i.key ? (...o) => {
      const l = i.fn(...o);
      return l && (l.key = i.key), l
    } : i.fn)
  }
  return e
}

function lt(e, t, a = {}, i, o) {
  if (er.isCE || er.parent && Go(er.parent) && er.parent.isCE) return t !== "default" && (a.name = t), Ze("slot", a, i);
  let l = e[t];
  l && l._c && (l._d = !1), be();
  const h = l && Hb(l(a)),
    p = yt(vt, {
      key: (a.key || h && h.key || `_${t}`) + (!h && i ? "_fb" : "")
    }, h || [], h && e._ === 1 ? 64 : -2);
  return p.scopeId && (p.slotScopeIds = [p.scopeId + "-s"]), l && l._c && (l._d = !0), p
}

function Hb(e) {
  return e.some(t => Ec(t) ? !(t.type === Nr || t.type === vt && !Hb(t.children)) : !0) ? e : null
}
const nh = e => e ? o0(e) ? uu(e) : nh(e.parent) : null,
  qo = ar(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => nh(e.parent),
    $root: e => nh(e.root),
    $emit: e => e.emit,
    $options: e => bf(e),
    $forceUpdate: e => e.f || (e.f = () => {
      e.effect.dirty = !0, gf(e.update)
    }),
    $nextTick: e => e.n || (e.n = Jt.bind(e.proxy)),
    $watch: e => Fk.bind(e)
  }),
  Xu = (e, t) => e !== ka && !e.__isScriptSetup && Gt(e, t),
  fk = {
    get({
      _: e
    }, t) {
      if (t === "__v_skip") return !0;
      const {
        ctx: a,
        setupState: i,
        data: o,
        props: l,
        accessCache: h,
        type: p,
        appContext: m
      } = e;
      let k;
      if (t[0] !== "$") {
        const E = h[t];
        if (E !== void 0) switch (E) {
          case 1:
            return i[t];
          case 2:
            return o[t];
          case 4:
            return a[t];
          case 3:
            return l[t]
        } else {
          if (Xu(i, t)) return h[t] = 1, i[t];
          if (o !== ka && Gt(o, t)) return h[t] = 2, o[t];
          if ((k = e.propsOptions[0]) && Gt(k, t)) return h[t] = 3, l[t];
          if (a !== ka && Gt(a, t)) return h[t] = 4, a[t];
          ih && (h[t] = 0)
        }
      }
      const w = qo[t];
      let S, A;
      if (w) return t === "$attrs" && Hr(e.attrs, "get", ""), w(e);
      if ((S = p.__cssModules) && (S = S[t])) return S;
      if (a !== ka && Gt(a, t)) return h[t] = 4, a[t];
      if (A = m.config.globalProperties, Gt(A, t)) return A[t]
    },
    set({
      _: e
    }, t, a) {
      const {
        data: i,
        setupState: o,
        ctx: l
      } = e;
      return Xu(o, t) ? (o[t] = a, !0) : i !== ka && Gt(i, t) ? (i[t] = a, !0) : Gt(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (l[t] = a, !0)
    },
    has({
      _: {
        data: e,
        setupState: t,
        accessCache: a,
        ctx: i,
        appContext: o,
        propsOptions: l
      }
    }, h) {
      let p;
      return !!a[h] || e !== ka && Gt(e, h) || Xu(t, h) || (p = l[0]) && Gt(p, h) || Gt(i, h) || Gt(qo, h) || Gt(o.config.globalProperties, h)
    },
    defineProperty(e, t, a) {
      return a.get != null ? e._.accessCache[t] = 0 : Gt(a, "value") && this.set(e, t, a.value, null), Reflect.defineProperty(e, t, a)
    }
  };

function vs() {
  return Yb().slots
}

function pk() {
  return Yb().attrs
}

function Yb() {
  const e = hn();
  return e.setupContext || (e.setupContext = c0(e))
}

function Bp(e) {
  return kt(e) ? e.reduce((t, a) => (t[a] = null, t), {}) : e
}
let ih = !0;

function gk(e) {
  const t = bf(e),
    a = e.proxy,
    i = e.ctx;
  ih = !1, t.beforeCreate && Hp(t.beforeCreate, e, "bc");
  const {
    data: o,
    computed: l,
    methods: h,
    watch: p,
    provide: m,
    inject: k,
    created: w,
    beforeMount: S,
    mounted: A,
    beforeUpdate: E,
    updated: M,
    activated: D,
    deactivated: B,
    beforeDestroy: z,
    beforeUnmount: I,
    destroyed: N,
    unmounted: U,
    render: W,
    renderTracked: X,
    renderTriggered: V,
    errorCaptured: ne,
    serverPrefetch: Z,
    expose: ie,
    inheritAttrs: fe,
    components: le,
    directives: Ee,
    filters: ye
  } = t;
  if (k && mk(k, i, null), h)
    for (const Ae in h) {
      const He = h[Ae];
      Pt(He) && (i[Ae] = He.bind(a))
    }
  if (o) {
    const Ae = o.call(a, a);
    pa(Ae) && (e.data = qr(Ae))
  }
  if (ih = !0, l)
    for (const Ae in l) {
      const He = l[Ae],
        De = Pt(He) ? He.bind(a, a) : Pt(He.get) ? He.get.bind(a, a) : Jr,
        Ye = !Pt(He) && Pt(He.set) ? He.set.bind(a) : Jr,
        Je = Oe({
          get: De,
          set: Ye
        });
      Object.defineProperty(i, Ae, {
        enumerable: !0,
        configurable: !0,
        get: () => Je.value,
        set: he => Je.value = he
      })
    }
  if (p)
    for (const Ae in p) zb(p[Ae], i, a, Ae);
  if (m) {
    const Ae = Pt(m) ? m.call(a) : m;
    Reflect.ownKeys(Ae).forEach(He => {
      vr(He, Ae[He])
    })
  }
  w && Hp(w, e, "c");

  function me(Ae, He) {
    kt(He) ? He.forEach(De => Ae(De.bind(a))) : He && Ae(He.bind(a))
  }
  if (me(mf, S), me(Dt, A), me(Nb, E), me(lk, M), me(ik, D), me(sk, B), me(hk, ne), me(dk, X), me(uk, V), me(vf, I), me(Ha, U), me(ck, Z), kt(ie))
    if (ie.length) {
      const Ae = e.exposed || (e.exposed = {});
      ie.forEach(He => {
        Object.defineProperty(Ae, He, {
          get: () => a[He],
          set: De => a[He] = De
        })
      })
    } else e.exposed || (e.exposed = {});
  W && e.render === Jr && (e.render = W), fe != null && (e.inheritAttrs = fe), le && (e.components = le), Ee && (e.directives = Ee)
}

function mk(e, t, a = Jr) {
  kt(e) && (e = sh(e));
  for (const i in e) {
    const o = e[i];
    let l;
    pa(o) ? "default" in o ? l = fa(o.from || i, o.default, !0) : l = fa(o.from || i) : l = fa(o), Fa(l) ? Object.defineProperty(t, i, {
      enumerable: !0,
      configurable: !0,
      get: () => l.value,
      set: h => l.value = h
    }) : t[i] = l
  }
}

function Hp(e, t, a) {
  en(kt(e) ? e.map(i => i.bind(t.proxy)) : e.bind(t.proxy), t, a)
}

function zb(e, t, a, i) {
  const o = i.includes(".") ? r0(a, i) : () => a[i];
  if (Ca(e)) {
    const l = t[e];
    Pt(l) && Xt(o, l)
  } else if (Pt(e)) Xt(o, e.bind(a));
  else if (pa(e))
    if (kt(e)) e.forEach(l => zb(l, t, a, i));
    else {
      const l = Pt(e.handler) ? e.handler.bind(a) : t[e.handler];
      Pt(l) && Xt(o, l, e)
    }
}

function bf(e) {
  const t = e.type,
    {
      mixins: a,
      extends: i
    } = t,
    {
      mixins: o,
      optionsCache: l,
      config: {
        optionMergeStrategies: h
      }
    } = e.appContext,
    p = l.get(t);
  let m;
  return p ? m = p : !o.length && !a && !i ? m = t : (m = {}, o.length && o.forEach(k => Tc(m, k, h, !0)), Tc(m, t, h)), pa(t) && l.set(t, m), m
}

function Tc(e, t, a, i = !1) {
  const {
    mixins: o,
    extends: l
  } = t;
  l && Tc(e, l, a, !0), o && o.forEach(h => Tc(e, h, a, !0));
  for (const h in t)
    if (!(i && h === "expose")) {
      const p = vk[h] || a && a[h];
      e[h] = p ? p(e[h], t[h]) : t[h]
    } return e
}
const vk = {
  data: Yp,
  props: zp,
  emits: zp,
  methods: Xo,
  computed: Xo,
  beforeCreate: kr,
  created: kr,
  beforeMount: kr,
  mounted: kr,
  beforeUpdate: kr,
  updated: kr,
  beforeDestroy: kr,
  beforeUnmount: kr,
  destroyed: kr,
  unmounted: kr,
  activated: kr,
  deactivated: kr,
  errorCaptured: kr,
  serverPrefetch: kr,
  components: Xo,
  directives: Xo,
  watch: yk,
  provide: Yp,
  inject: bk
};

function Yp(e, t) {
  return t ? e ? function () {
    return ar(Pt(e) ? e.call(this, this) : e, Pt(t) ? t.call(this, this) : t)
  } : t : e
}

function bk(e, t) {
  return Xo(sh(e), sh(t))
}

function sh(e) {
  if (kt(e)) {
    const t = {};
    for (let a = 0; a < e.length; a++) t[e[a]] = e[a];
    return t
  }
  return e
}

function kr(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}

function Xo(e, t) {
  return e ? ar(Object.create(null), e, t) : t
}

function zp(e, t) {
  return e ? kt(e) && kt(t) ? [...new Set([...e, ...t])] : ar(Object.create(null), Bp(e), Bp(t ?? {})) : t
}

function yk(e, t) {
  if (!e) return t;
  if (!t) return e;
  const a = ar(Object.create(null), e);
  for (const i in t) a[i] = kr(e[i], t[i]);
  return a
}

function Xb() {
  return {
    app: null,
    config: {
      isNativeTag: dw,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap,
    propsCache: new WeakMap,
    emitsCache: new WeakMap
  }
}
let xk = 0;

function wk(e, t) {
  return function (i, o = null) {
    Pt(i) || (i = ar({}, i)), o != null && !pa(o) && (o = null);
    const l = Xb(),
      h = new WeakSet;
    let p = !1;
    const m = l.app = {
      _uid: xk++,
      _component: i,
      _props: o,
      _container: null,
      _context: l,
      _instance: null,
      version: a_,
      get config() {
        return l.config
      },
      set config(k) {},
      use(k, ...w) {
        return h.has(k) || (k && Pt(k.install) ? (h.add(k), k.install(m, ...w)) : Pt(k) && (h.add(k), k(m, ...w))), m
      },
      mixin(k) {
        return l.mixins.includes(k) || l.mixins.push(k), m
      },
      component(k, w) {
        return w ? (l.components[k] = w, m) : l.components[k]
      },
      directive(k, w) {
        return w ? (l.directives[k] = w, m) : l.directives[k]
      },
      mount(k, w, S) {
        if (!p) {
          const A = Ze(i, o);
          return A.appContext = l, S === !0 ? S = "svg" : S === !1 && (S = void 0), w && t ? t(A, k) : e(A, k, S), p = !0, m._container = k, k.__vue_app__ = m, uu(A.component)
        }
      },
      unmount() {
        p && (e(null, m._container), delete m._container.__vue_app__)
      },
      provide(k, w) {
        return l.provides[k] = w, m
      },
      runWithContext(k) {
        const w = js;
        js = m;
        try {
          return k()
        } finally {
          js = w
        }
      }
    };
    return m
  }
}
let js = null;

function vr(e, t) {
  if (sr) {
    let a = sr.provides;
    const i = sr.parent && sr.parent.provides;
    i === a && (a = sr.provides = Object.create(i)), a[e] = t
  }
}

function fa(e, t, a = !1) {
  const i = sr || er;
  if (i || js) {
    const o = js ? js._context.provides : i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (o && e in o) return o[e];
    if (arguments.length > 1) return a && Pt(t) ? t.call(i && i.proxy) : t
  }
}
const Wb = {},
  Vb = () => Object.create(Wb),
  jb = e => Object.getPrototypeOf(e) === Wb;

function kk(e, t, a, i = !1) {
  const o = {},
    l = Vb();
  e.propsDefaults = Object.create(null), Ub(e, t, o, l);
  for (const h in e.propsOptions[0]) h in o || (o[h] = void 0);
  a ? e.props = i ? o : mb(o) : e.type.props ? e.props = o : e.props = l, e.attrs = l
}

function _k(e, t, a, i) {
  const {
    props: o,
    attrs: l,
    vnode: {
      patchFlag: h
    }
  } = e, p = It(o), [m] = e.propsOptions;
  let k = !1;
  if ((i || h > 0) && !(h & 16)) {
    if (h & 8) {
      const w = e.vnode.dynamicProps;
      for (let S = 0; S < w.length; S++) {
        let A = w[S];
        if (lu(e.emitsOptions, A)) continue;
        const E = t[A];
        if (m)
          if (Gt(l, A)) E !== l[A] && (l[A] = E, k = !0);
          else {
            const M = dn(A);
            o[M] = oh(m, p, M, E, e, !1)
          }
        else E !== l[A] && (l[A] = E, k = !0)
      }
    }
  } else {
    Ub(e, t, o, l) && (k = !0);
    let w;
    for (const S in p)(!t || !Gt(t, S) && ((w = Oi(S)) === S || !Gt(t, w))) && (m ? a && (a[S] !== void 0 || a[w] !== void 0) && (o[S] = oh(m, p, S, void 0, e, !0)) : delete o[S]);
    if (l !== p)
      for (const S in l)(!t || !Gt(t, S)) && (delete l[S], k = !0)
  }
  k && Un(e.attrs, "set", "")
}

function Ub(e, t, a, i) {
  const [o, l] = e.propsOptions;
  let h = !1,
    p;
  if (t)
    for (let m in t) {
      if (jo(m)) continue;
      const k = t[m];
      let w;
      o && Gt(o, w = dn(m)) ? !l || !l.includes(w) ? a[w] = k : (p || (p = {}))[w] = k : lu(e.emitsOptions, m) || (!(m in i) || k !== i[m]) && (i[m] = k, h = !0)
    }
  if (l) {
    const m = It(a),
      k = p || ka;
    for (let w = 0; w < l.length; w++) {
      const S = l[w];
      a[S] = oh(o, m, S, k[S], e, !Gt(k, S))
    }
  }
  return h
}

function oh(e, t, a, i, o, l) {
  const h = e[a];
  if (h != null) {
    const p = Gt(h, "default");
    if (p && i === void 0) {
      const m = h.default;
      if (h.type !== Function && !h.skipFactory && Pt(m)) {
        const {
          propsDefaults: k
        } = o;
        if (a in k) i = k[a];
        else {
          const w = El(o);
          i = k[a] = m.call(null, t), w()
        }
      } else i = m
    }
    h[0] && (l && !p ? i = !1 : h[1] && (i === "" || i === Oi(a)) && (i = !0))
  }
  return i
}
const Sk = new WeakMap;

function Gb(e, t, a = !1) {
  const i = a ? Sk : t.propsCache,
    o = i.get(e);
  if (o) return o;
  const l = e.props,
    h = {},
    p = [];
  let m = !1;
  if (!Pt(e)) {
    const w = S => {
      m = !0;
      const [A, E] = Gb(S, t, !0);
      ar(h, A), E && p.push(...E)
    };
    !a && t.mixins.length && t.mixins.forEach(w), e.extends && w(e.extends), e.mixins && e.mixins.forEach(w)
  }
  if (!l && !m) return pa(e) && i.set(e, zs), zs;
  if (kt(l))
    for (let w = 0; w < l.length; w++) {
      const S = dn(l[w]);
      Xp(S) && (h[S] = ka)
    } else if (l)
      for (const w in l) {
        const S = dn(w);
        if (Xp(S)) {
          const A = l[w],
            E = h[S] = kt(A) || Pt(A) ? {
              type: A
            } : ar({}, A),
            M = E.type;
          let D = !1,
            B = !0;
          if (kt(M))
            for (let z = 0; z < M.length; ++z) {
              const I = M[z],
                N = Pt(I) && I.name;
              if (N === "Boolean") {
                D = !0;
                break
              } else N === "String" && (B = !1)
            } else D = Pt(M) && M.name === "Boolean";
          E[0] = D, E[1] = B, (D || Gt(E, "default")) && p.push(S)
        }
      }
  const k = [h, p];
  return pa(e) && i.set(e, k), k
}

function Xp(e) {
  return e[0] !== "$" && !jo(e)
}
const qb = e => e[0] === "_" || e === "$stable",
  yf = e => kt(e) ? e.map(_n) : [_n(e)],
  Ak = (e, t, a) => {
    if (t._n) return t;
    const i = Qe((...o) => yf(t(...o)), a);
    return i._c = !1, i
  },
  Kb = (e, t, a) => {
    const i = e._ctx;
    for (const o in e) {
      if (qb(o)) continue;
      const l = e[o];
      if (Pt(l)) t[o] = Ak(o, l, i);
      else if (l != null) {
        const h = yf(l);
        t[o] = () => h
      }
    }
  },
  Zb = (e, t) => {
    const a = yf(t);
    e.slots.default = () => a
  },
  Qb = (e, t, a) => {
    for (const i in t)(a || i !== "_") && (e[i] = t[i])
  },
  Ck = (e, t, a) => {
    const i = e.slots = Vb();
    if (e.vnode.shapeFlag & 32) {
      const o = t._;
      o ? (Qb(i, t, a), a && Zv(i, "_", o, !0)) : Kb(t, i)
    } else t && Zb(e, t)
  },
  Tk = (e, t, a) => {
    const {
      vnode: i,
      slots: o
    } = e;
    let l = !0,
      h = ka;
    if (i.shapeFlag & 32) {
      const p = t._;
      p ? a && p === 1 ? l = !1 : Qb(o, t, a) : (l = !t.$stable, Kb(t, o)), h = t
    } else t && (Zb(e, t), h = {
      default: 1
    });
    if (l)
      for (const p in o) !qb(p) && h[p] == null && delete o[p]
  };

function lh(e, t, a, i, o = !1) {
  if (kt(e)) {
    e.forEach((A, E) => lh(A, t && (kt(t) ? t[E] : t), a, i, o));
    return
  }
  if (Go(i) && !o) return;
  const l = i.shapeFlag & 4 ? uu(i.component) : i.el,
    h = o ? null : l,
    {
      i: p,
      r: m
    } = e,
    k = t && t.r,
    w = p.refs === ka ? p.refs = {} : p.refs,
    S = p.setupState;
  if (k != null && k !== m && (Ca(k) ? (w[k] = null, Gt(S, k) && (S[k] = null)) : Fa(k) && (k.value = null)), Pt(m)) ki(m, p, 12, [h, w]);
  else {
    const A = Ca(m),
      E = Fa(m);
    if (A || E) {
      const M = () => {
        if (e.f) {
          const D = A ? Gt(S, m) ? S[m] : w[m] : m.value;
          o ? kt(D) && nf(D, l) : kt(D) ? D.includes(l) || D.push(l) : A ? (w[m] = [l], Gt(S, m) && (S[m] = w[m])) : (m.value = [l], e.k && (w[e.k] = m.value))
        } else A ? (w[m] = h, Gt(S, m) && (S[m] = h)) : E && (m.value = h, e.k && (w[e.k] = h))
      };
      h ? (M.id = -1, Dr(M, a)) : M()
    }
  }
}
const Jb = Symbol("_vte"),
  Ek = e => e.__isTeleport,
  Ko = e => e && (e.disabled || e.disabled === ""),
  Wp = e => typeof SVGElement < "u" && e instanceof SVGElement,
  Vp = e => typeof MathMLElement == "function" && e instanceof MathMLElement,
  ch = (e, t) => {
    const a = e && e.to;
    return Ca(a) ? t ? t(a) : null : a
  },
  Pk = {
    name: "Teleport",
    __isTeleport: !0,
    process(e, t, a, i, o, l, h, p, m, k) {
      const {
        mc: w,
        pc: S,
        pbc: A,
        o: {
          insert: E,
          querySelector: M,
          createText: D,
          createComment: B
        }
      } = k, z = Ko(t.props);
      let {
        shapeFlag: I,
        children: N,
        dynamicChildren: U
      } = t;
      if (e == null) {
        const W = t.el = D(""),
          X = t.anchor = D("");
        E(W, a, i), E(X, a, i);
        const V = t.target = ch(t.props, M),
          ne = t0(V, t, D, E);
        V && (h === "svg" || Wp(V) ? h = "svg" : (h === "mathml" || Vp(V)) && (h = "mathml"));
        const Z = (ie, fe) => {
          I & 16 && w(N, ie, fe, o, l, h, p, m)
        };
        z ? Z(a, X) : V && Z(V, ne)
      } else {
        t.el = e.el, t.targetStart = e.targetStart;
        const W = t.anchor = e.anchor,
          X = t.target = e.target,
          V = t.targetAnchor = e.targetAnchor,
          ne = Ko(e.props),
          Z = ne ? a : X,
          ie = ne ? W : V;
        if (h === "svg" || Wp(X) ? h = "svg" : (h === "mathml" || Vp(X)) && (h = "mathml"), U ? (A(e.dynamicChildren, U, Z, o, l, h, p), wf(e, t, !0)) : m || S(e, t, Z, ie, o, l, h, p, !1), z) ne ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : Kl(t, a, W, k, 1);
        else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
          const fe = t.target = ch(t.props, M);
          fe && Kl(t, fe, null, k, 0)
        } else ne && Kl(t, X, V, k, 1)
      }
      e0(t)
    },
    remove(e, t, a, {
      um: i,
      o: {
        remove: o
      }
    }, l) {
      const {
        shapeFlag: h,
        children: p,
        anchor: m,
        targetStart: k,
        targetAnchor: w,
        target: S,
        props: A
      } = e;
      if (S && (o(k), o(w)), l && o(m), h & 16) {
        const E = l || !Ko(A);
        for (let M = 0; M < p.length; M++) {
          const D = p[M];
          i(D, t, a, E, !!D.dynamicChildren)
        }
      }
    },
    move: Kl,
    hydrate: Lk
  };

function Kl(e, t, a, {
  o: {
    insert: i
  },
  m: o
}, l = 2) {
  l === 0 && i(e.targetAnchor, t, a);
  const {
    el: h,
    anchor: p,
    shapeFlag: m,
    children: k,
    props: w
  } = e, S = l === 2;
  if (S && i(h, t, a), (!S || Ko(w)) && m & 16)
    for (let A = 0; A < k.length; A++) o(k[A], t, a, 2);
  S && i(p, t, a)
}

function Lk(e, t, a, i, o, l, {
  o: {
    nextSibling: h,
    parentNode: p,
    querySelector: m,
    insert: k,
    createText: w
  }
}, S) {
  const A = t.target = ch(t.props, m);
  if (A) {
    const E = A._lpa || A.firstChild;
    if (t.shapeFlag & 16)
      if (Ko(t.props)) t.anchor = S(h(e), t, p(e), a, i, o, l), t.targetStart = E, t.targetAnchor = E && h(E);
      else {
        t.anchor = h(e);
        let M = E;
        for (; M;) {
          if (M && M.nodeType === 8) {
            if (M.data === "teleport start anchor") t.targetStart = M;
            else if (M.data === "teleport anchor") {
              t.targetAnchor = M, A._lpa = t.targetAnchor && h(t.targetAnchor);
              break
            }
          }
          M = h(M)
        }
        t.targetAnchor || t0(A, t, w, k), S(E && h(E), t, A, a, i, o, l)
      } e0(t)
  }
  return t.anchor && h(t.anchor)
}
const xf = Pk;

function e0(e) {
  const t = e.ctx;
  if (t && t.ut) {
    let a = e.children[0].el;
    for (; a && a !== e.targetAnchor;) a.nodeType === 1 && a.setAttribute("data-v-owner", t.uid), a = a.nextSibling;
    t.ut()
  }
}

function t0(e, t, a, i) {
  const o = t.targetStart = a(""),
    l = t.targetAnchor = a("");
  return o[Jb] = l, e && (i(o, e), i(l, e)), l
}
const Dr = Vk;

function Ok(e) {
  return Mk(e)
}

function Mk(e, t) {
  const a = Qv();
  a.__VUE__ = !0;
  const {
    insert: i,
    remove: o,
    patchProp: l,
    createElement: h,
    createText: p,
    createComment: m,
    setText: k,
    setElementText: w,
    parentNode: S,
    nextSibling: A,
    setScopeId: E = Jr,
    insertStaticContent: M
  } = e, D = (F, j, oe, de = null, Ie = null, ue = null, Le = void 0, K = null, ae = !!j.dynamicChildren) => {
    if (F === j) return;
    F && !as(F, j) && (de = J(F), he(F, Ie, ue, !0), F = null), j.patchFlag === -2 && (ae = !1, j.dynamicChildren = null);
    const {
      type: xe,
      ref: Ce,
      shapeFlag: tt
    } = j;
    switch (xe) {
      case Cl:
        B(F, j, oe, de);
        break;
      case Nr:
        z(F, j, oe, de);
        break;
      case hc:
        F == null && I(j, oe, de, Le);
        break;
      case vt:
        le(F, j, oe, de, Ie, ue, Le, K, ae);
        break;
      default:
        tt & 1 ? W(F, j, oe, de, Ie, ue, Le, K, ae) : tt & 6 ? Ee(F, j, oe, de, Ie, ue, Le, K, ae) : (tt & 64 || tt & 128) && xe.process(F, j, oe, de, Ie, ue, Le, K, ae, nt)
    }
    Ce != null && Ie && lh(Ce, F && F.ref, ue, j || F, !j)
  }, B = (F, j, oe, de) => {
    if (F == null) i(j.el = p(j.children), oe, de);
    else {
      const Ie = j.el = F.el;
      j.children !== F.children && k(Ie, j.children)
    }
  }, z = (F, j, oe, de) => {
    F == null ? i(j.el = m(j.children || ""), oe, de) : j.el = F.el
  }, I = (F, j, oe, de) => {
    [F.el, F.anchor] = M(F.children, j, oe, de, F.el, F.anchor)
  }, N = ({
    el: F,
    anchor: j
  }, oe, de) => {
    let Ie;
    for (; F && F !== j;) Ie = A(F), i(F, oe, de), F = Ie;
    i(j, oe, de)
  }, U = ({
    el: F,
    anchor: j
  }) => {
    let oe;
    for (; F && F !== j;) oe = A(F), o(F), F = oe;
    o(j)
  }, W = (F, j, oe, de, Ie, ue, Le, K, ae) => {
    j.type === "svg" ? Le = "svg" : j.type === "math" && (Le = "mathml"), F == null ? X(j, oe, de, Ie, ue, Le, K, ae) : Z(F, j, Ie, ue, Le, K, ae)
  }, X = (F, j, oe, de, Ie, ue, Le, K) => {
    let ae, xe;
    const {
      props: Ce,
      shapeFlag: tt,
      transition: qe,
      dirs: Te
    } = F;
    if (ae = F.el = h(F.type, ue, Ce && Ce.is, Ce), tt & 8 ? w(ae, F.children) : tt & 16 && ne(F.children, ae, null, de, Ie, Wu(F, ue), Le, K), Te && Vi(F, null, de, "created"), V(ae, F, F.scopeId, Le, de), Ce) {
      for (const ft in Ce) ft !== "value" && !jo(ft) && l(ae, ft, null, Ce[ft], ue, de);
      "value" in Ce && l(ae, "value", null, Ce.value, ue), (xe = Ce.onVnodeBeforeMount) && xn(xe, de, F)
    }
    Te && Vi(F, null, de, "beforeMount");
    const $e = Ik(Ie, qe);
    $e && qe.beforeEnter(ae), i(ae, j, oe), ((xe = Ce && Ce.onVnodeMounted) || $e || Te) && Dr(() => {
      xe && xn(xe, de, F), $e && qe.enter(ae), Te && Vi(F, null, de, "mounted")
    }, Ie)
  }, V = (F, j, oe, de, Ie) => {
    if (oe && E(F, oe), de)
      for (let ue = 0; ue < de.length; ue++) E(F, de[ue]);
    if (Ie) {
      let ue = Ie.subTree;
      if (j === ue) {
        const Le = Ie.vnode;
        V(F, Le, Le.scopeId, Le.slotScopeIds, Ie.parent)
      }
    }
  }, ne = (F, j, oe, de, Ie, ue, Le, K, ae = 0) => {
    for (let xe = ae; xe < F.length; xe++) {
      const Ce = F[xe] = K ? pi(F[xe]) : _n(F[xe]);
      D(null, Ce, j, oe, de, Ie, ue, Le, K)
    }
  }, Z = (F, j, oe, de, Ie, ue, Le) => {
    const K = j.el = F.el;
    let {
      patchFlag: ae,
      dynamicChildren: xe,
      dirs: Ce
    } = j;
    ae |= F.patchFlag & 16;
    const tt = F.props || ka,
      qe = j.props || ka;
    let Te;
    if (oe && ji(oe, !1), (Te = qe.onVnodeBeforeUpdate) && xn(Te, oe, j, F), Ce && Vi(j, F, oe, "beforeUpdate"), oe && ji(oe, !0), (tt.innerHTML && qe.innerHTML == null || tt.textContent && qe.textContent == null) && w(K, ""), xe ? ie(F.dynamicChildren, xe, K, oe, de, Wu(j, Ie), ue) : Le || He(F, j, K, null, oe, de, Wu(j, Ie), ue, !1), ae > 0) {
      if (ae & 16) fe(K, tt, qe, oe, Ie);
      else if (ae & 2 && tt.class !== qe.class && l(K, "class", null, qe.class, Ie), ae & 4 && l(K, "style", tt.style, qe.style, Ie), ae & 8) {
        const $e = j.dynamicProps;
        for (let ft = 0; ft < $e.length; ft++) {
          const gt = $e[ft],
            Ct = tt[gt],
            ia = qe[gt];
          (ia !== Ct || gt === "value") && l(K, gt, Ct, ia, Ie, oe)
        }
      }
      ae & 1 && F.children !== j.children && w(K, j.children)
    } else !Le && xe == null && fe(K, tt, qe, oe, Ie);
    ((Te = qe.onVnodeUpdated) || Ce) && Dr(() => {
      Te && xn(Te, oe, j, F), Ce && Vi(j, F, oe, "updated")
    }, de)
  }, ie = (F, j, oe, de, Ie, ue, Le) => {
    for (let K = 0; K < j.length; K++) {
      const ae = F[K],
        xe = j[K],
        Ce = ae.el && (ae.type === vt || !as(ae, xe) || ae.shapeFlag & 70) ? S(ae.el) : oe;
      D(ae, xe, Ce, null, de, Ie, ue, Le, !0)
    }
  }, fe = (F, j, oe, de, Ie) => {
    if (j !== oe) {
      if (j !== ka)
        for (const ue in j) !jo(ue) && !(ue in oe) && l(F, ue, j[ue], null, Ie, de);
      for (const ue in oe) {
        if (jo(ue)) continue;
        const Le = oe[ue],
          K = j[ue];
        Le !== K && ue !== "value" && l(F, ue, K, Le, Ie, de)
      }
      "value" in oe && l(F, "value", j.value, oe.value, Ie)
    }
  }, le = (F, j, oe, de, Ie, ue, Le, K, ae) => {
    const xe = j.el = F ? F.el : p(""),
      Ce = j.anchor = F ? F.anchor : p("");
    let {
      patchFlag: tt,
      dynamicChildren: qe,
      slotScopeIds: Te
    } = j;
    Te && (K = K ? K.concat(Te) : Te), F == null ? (i(xe, oe, de), i(Ce, oe, de), ne(j.children || [], oe, Ce, Ie, ue, Le, K, ae)) : tt > 0 && tt & 64 && qe && F.dynamicChildren ? (ie(F.dynamicChildren, qe, oe, Ie, ue, Le, K), (j.key != null || Ie && j === Ie.subTree) && wf(F, j, !0)) : He(F, j, oe, Ce, Ie, ue, Le, K, ae)
  }, Ee = (F, j, oe, de, Ie, ue, Le, K, ae) => {
    j.slotScopeIds = K, F == null ? j.shapeFlag & 512 ? Ie.ctx.activate(j, oe, de, Le, ae) : ye(j, oe, de, Ie, ue, Le, ae) : ve(F, j, ae)
  }, ye = (F, j, oe, de, Ie, ue, Le) => {
    const K = F.component = Kk(F, de, Ie);
    if (su(F) && (K.ctx.renderer = nt), Zk(K, !1, Le), K.asyncDep) {
      if (Ie && Ie.registerDep(K, me, Le), !F.el) {
        const ae = K.subTree = Ze(Nr);
        z(null, ae, j, oe)
      }
    } else me(K, F, j, oe, Ie, ue, Le)
  }, ve = (F, j, oe) => {
    const de = j.component = F.component;
    if (zk(F, j, oe))
      if (de.asyncDep && !de.asyncResolved) {
        Ae(de, j, oe);
        return
      } else de.next = j, Jw(de.update), de.effect.dirty = !0, de.update();
    else j.el = F.el, de.vnode = j
  }, me = (F, j, oe, de, Ie, ue, Le) => {
    const K = () => {
        if (F.isMounted) {
          let {
            next: Ce,
            bu: tt,
            u: qe,
            parent: Te,
            vnode: $e
          } = F; {
            const xa = a0(F);
            if (xa) {
              Ce && (Ce.el = $e.el, Ae(F, Ce, Le)), xa.asyncDep.then(() => {
                F.isUnmounted || K()
              });
              return
            }
          }
          let ft = Ce,
            gt;
          ji(F, !1), Ce ? (Ce.el = $e.el, Ae(F, Ce, Le)) : Ce = $e, tt && uc(tt), (gt = Ce.props && Ce.props.onVnodeBeforeUpdate) && xn(gt, Te, Ce, $e), ji(F, !0);
          const Ct = Vu(F),
            ia = F.subTree;
          F.subTree = Ct, D(ia, Ct, S(ia.el), J(ia), F, Ie, ue), Ce.el = Ct.el, ft === null && Xk(F, Ct.el), qe && Dr(qe, Ie), (gt = Ce.props && Ce.props.onVnodeUpdated) && Dr(() => xn(gt, Te, Ce, $e), Ie)
        } else {
          let Ce;
          const {
            el: tt,
            props: qe
          } = j, {
            bm: Te,
            m: $e,
            parent: ft
          } = F, gt = Go(j);
          if (ji(F, !1), Te && uc(Te), !gt && (Ce = qe && qe.onVnodeBeforeMount) && xn(Ce, ft, j), ji(F, !0), tt && We) {
            const Ct = () => {
              F.subTree = Vu(F), We(tt, F.subTree, F, Ie, null)
            };
            gt ? j.type.__asyncLoader().then(() => !F.isUnmounted && Ct()) : Ct()
          } else {
            const Ct = F.subTree = Vu(F);
            D(null, Ct, oe, de, F, Ie, ue), j.el = Ct.el
          }
          if ($e && Dr($e, Ie), !gt && (Ce = qe && qe.onVnodeMounted)) {
            const Ct = j;
            Dr(() => xn(Ce, ft, Ct), Ie)
          }(j.shapeFlag & 256 || ft && Go(ft.vnode) && ft.vnode.shapeFlag & 256) && F.a && Dr(F.a, Ie), F.isMounted = !0, j = oe = de = null
        }
      },
      ae = F.effect = new of(K, Jr, () => gf(xe), F.scope),
      xe = F.update = () => {
        ae.dirty && ae.run()
      };
    xe.i = F, xe.id = F.uid, ji(F, !0), xe()
  }, Ae = (F, j, oe) => {
    j.component = F;
    const de = F.vnode.props;
    F.vnode = j, F.next = null, _k(F, j.props, de, oe), Tk(F, j.children, oe), Mi(), Np(F), Ii()
  }, He = (F, j, oe, de, Ie, ue, Le, K, ae = !1) => {
    const xe = F && F.children,
      Ce = F ? F.shapeFlag : 0,
      tt = j.children,
      {
        patchFlag: qe,
        shapeFlag: Te
      } = j;
    if (qe > 0) {
      if (qe & 128) {
        Ye(xe, tt, oe, de, Ie, ue, Le, K, ae);
        return
      } else if (qe & 256) {
        De(xe, tt, oe, de, Ie, ue, Le, K, ae);
        return
      }
    }
    Te & 8 ? (Ce & 16 && Be(xe, Ie, ue), tt !== xe && w(oe, tt)) : Ce & 16 ? Te & 16 ? Ye(xe, tt, oe, de, Ie, ue, Le, K, ae) : Be(xe, Ie, ue, !0) : (Ce & 8 && w(oe, ""), Te & 16 && ne(tt, oe, de, Ie, ue, Le, K, ae))
  }, De = (F, j, oe, de, Ie, ue, Le, K, ae) => {
    F = F || zs, j = j || zs;
    const xe = F.length,
      Ce = j.length,
      tt = Math.min(xe, Ce);
    let qe;
    for (qe = 0; qe < tt; qe++) {
      const Te = j[qe] = ae ? pi(j[qe]) : _n(j[qe]);
      D(F[qe], Te, oe, null, Ie, ue, Le, K, ae)
    }
    xe > Ce ? Be(F, Ie, ue, !0, !1, tt) : ne(j, oe, de, Ie, ue, Le, K, ae, tt)
  }, Ye = (F, j, oe, de, Ie, ue, Le, K, ae) => {
    let xe = 0;
    const Ce = j.length;
    let tt = F.length - 1,
      qe = Ce - 1;
    for (; xe <= tt && xe <= qe;) {
      const Te = F[xe],
        $e = j[xe] = ae ? pi(j[xe]) : _n(j[xe]);
      if (as(Te, $e)) D(Te, $e, oe, null, Ie, ue, Le, K, ae);
      else break;
      xe++
    }
    for (; xe <= tt && xe <= qe;) {
      const Te = F[tt],
        $e = j[qe] = ae ? pi(j[qe]) : _n(j[qe]);
      if (as(Te, $e)) D(Te, $e, oe, null, Ie, ue, Le, K, ae);
      else break;
      tt--, qe--
    }
    if (xe > tt) {
      if (xe <= qe) {
        const Te = qe + 1,
          $e = Te < Ce ? j[Te].el : de;
        for (; xe <= qe;) D(null, j[xe] = ae ? pi(j[xe]) : _n(j[xe]), oe, $e, Ie, ue, Le, K, ae), xe++
      }
    } else if (xe > qe)
      for (; xe <= tt;) he(F[xe], Ie, ue, !0), xe++;
    else {
      const Te = xe,
        $e = xe,
        ft = new Map;
      for (xe = $e; xe <= qe; xe++) {
        const wa = j[xe] = ae ? pi(j[xe]) : _n(j[xe]);
        wa.key != null && ft.set(wa.key, xe)
      }
      let gt, Ct = 0;
      const ia = qe - $e + 1;
      let xa = !1,
        yr = 0;
      const qa = new Array(ia);
      for (xe = 0; xe < ia; xe++) qa[xe] = 0;
      for (xe = Te; xe <= tt; xe++) {
        const wa = F[xe];
        if (Ct >= ia) {
          he(wa, Ie, ue, !0);
          continue
        }
        let Me;
        if (wa.key != null) Me = ft.get(wa.key);
        else
          for (gt = $e; gt <= qe; gt++)
            if (qa[gt - $e] === 0 && as(wa, j[gt])) {
              Me = gt;
              break
            } Me === void 0 ? he(wa, Ie, ue, !0) : (qa[Me - $e] = xe + 1, Me >= yr ? yr = Me : xa = !0, D(wa, j[Me], oe, null, Ie, ue, Le, K, ae), Ct++)
      }
      const xr = xa ? Rk(qa) : zs;
      for (gt = xr.length - 1, xe = ia - 1; xe >= 0; xe--) {
        const wa = $e + xe,
          Me = j[wa],
          rt = wa + 1 < Ce ? j[wa + 1].el : de;
        qa[xe] === 0 ? D(null, Me, oe, rt, Ie, ue, Le, K, ae) : xa && (gt < 0 || xe !== xr[gt] ? Je(Me, oe, rt, 2) : gt--)
      }
    }
  }, Je = (F, j, oe, de, Ie = null) => {
    const {
      el: ue,
      type: Le,
      transition: K,
      children: ae,
      shapeFlag: xe
    } = F;
    if (xe & 6) {
      Je(F.component.subTree, j, oe, de);
      return
    }
    if (xe & 128) {
      F.suspense.move(j, oe, de);
      return
    }
    if (xe & 64) {
      Le.move(F, j, oe, nt);
      return
    }
    if (Le === vt) {
      i(ue, j, oe);
      for (let tt = 0; tt < ae.length; tt++) Je(ae[tt], j, oe, de);
      i(F.anchor, j, oe);
      return
    }
    if (Le === hc) {
      N(F, j, oe);
      return
    }
    if (de !== 2 && xe & 1 && K)
      if (de === 0) K.beforeEnter(ue), i(ue, j, oe), Dr(() => K.enter(ue), Ie);
      else {
        const {
          leave: tt,
          delayLeave: qe,
          afterLeave: Te
        } = K, $e = () => i(ue, j, oe), ft = () => {
          tt(ue, () => {
            $e(), Te && Te()
          })
        };
        qe ? qe(ue, $e, ft) : ft()
      }
    else i(ue, j, oe)
  }, he = (F, j, oe, de = !1, Ie = !1) => {
    const {
      type: ue,
      props: Le,
      ref: K,
      children: ae,
      dynamicChildren: xe,
      shapeFlag: Ce,
      patchFlag: tt,
      dirs: qe,
      cacheIndex: Te
    } = F;
    if (tt === -2 && (Ie = !1), K != null && lh(K, null, oe, F, !0), Te != null && (j.renderCache[Te] = void 0), Ce & 256) {
      j.ctx.deactivate(F);
      return
    }
    const $e = Ce & 1 && qe,
      ft = !Go(F);
    let gt;
    if (ft && (gt = Le && Le.onVnodeBeforeUnmount) && xn(gt, j, F), Ce & 6) Se(F.component, oe, de);
    else {
      if (Ce & 128) {
        F.suspense.unmount(oe, de);
        return
      }
      $e && Vi(F, null, j, "beforeUnmount"), Ce & 64 ? F.type.remove(F, j, oe, nt, de) : xe && !xe.hasOnce && (ue !== vt || tt > 0 && tt & 64) ? Be(xe, j, oe, !1, !0) : (ue === vt && tt & 384 || !Ie && Ce & 16) && Be(ae, j, oe), de && ke(F)
    }(ft && (gt = Le && Le.onVnodeUnmounted) || $e) && Dr(() => {
      gt && xn(gt, j, F), $e && Vi(F, null, j, "unmounted")
    }, oe)
  }, ke = F => {
    const {
      type: j,
      el: oe,
      anchor: de,
      transition: Ie
    } = F;
    if (j === vt) {
      re(oe, de);
      return
    }
    if (j === hc) {
      U(F);
      return
    }
    const ue = () => {
      o(oe), Ie && !Ie.persisted && Ie.afterLeave && Ie.afterLeave()
    };
    if (F.shapeFlag & 1 && Ie && !Ie.persisted) {
      const {
        leave: Le,
        delayLeave: K
      } = Ie, ae = () => Le(oe, ue);
      K ? K(F.el, ue, ae) : ae()
    } else ue()
  }, re = (F, j) => {
    let oe;
    for (; F !== j;) oe = A(F), o(F), F = oe;
    o(j)
  }, Se = (F, j, oe) => {
    const {
      bum: de,
      scope: Ie,
      update: ue,
      subTree: Le,
      um: K,
      m: ae,
      a: xe
    } = F;
    jp(ae), jp(xe), de && uc(de), Ie.stop(), ue && (ue.active = !1, he(Le, F, j, oe)), K && Dr(K, j), Dr(() => {
      F.isUnmounted = !0
    }, j), j && j.pendingBranch && !j.isUnmounted && F.asyncDep && !F.asyncResolved && F.suspenseId === j.pendingId && (j.deps--, j.deps === 0 && j.resolve())
  }, Be = (F, j, oe, de = !1, Ie = !1, ue = 0) => {
    for (let Le = ue; Le < F.length; Le++) he(F[Le], j, oe, de, Ie)
  }, J = F => {
    if (F.shapeFlag & 6) return J(F.component.subTree);
    if (F.shapeFlag & 128) return F.suspense.next();
    const j = A(F.anchor || F.el),
      oe = j && j[Jb];
    return oe ? A(oe) : j
  };
  let Re = !1;
  const Xe = (F, j, oe) => {
      F == null ? j._vnode && he(j._vnode, null, null, !0) : D(j._vnode || null, F, j, null, null, null, oe), j._vnode = F, Re || (Re = !0, Np(), Tb(), Re = !1)
    },
    nt = {
      p: D,
      um: he,
      m: Je,
      r: ke,
      mt: ye,
      mc: ne,
      pc: He,
      pbc: ie,
      n: J,
      o: e
    };
  let Pe, We;
  return {
    render: Xe,
    hydrate: Pe,
    createApp: wk(Xe, Pe)
  }
}

function Wu({
  type: e,
  props: t
}, a) {
  return a === "svg" && e === "foreignObject" || a === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : a
}

function ji({
  effect: e,
  update: t
}, a) {
  e.allowRecurse = t.allowRecurse = a
}

function Ik(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted
}

function wf(e, t, a = !1) {
  const i = e.children,
    o = t.children;
  if (kt(i) && kt(o))
    for (let l = 0; l < i.length; l++) {
      const h = i[l];
      let p = o[l];
      p.shapeFlag & 1 && !p.dynamicChildren && ((p.patchFlag <= 0 || p.patchFlag === 32) && (p = o[l] = pi(o[l]), p.el = h.el), !a && p.patchFlag !== -2 && wf(h, p)), p.type === Cl && (p.el = h.el)
    }
}

function Rk(e) {
  const t = e.slice(),
    a = [0];
  let i, o, l, h, p;
  const m = e.length;
  for (i = 0; i < m; i++) {
    const k = e[i];
    if (k !== 0) {
      if (o = a[a.length - 1], e[o] < k) {
        t[i] = o, a.push(i);
        continue
      }
      for (l = 0, h = a.length - 1; l < h;) p = l + h >> 1, e[a[p]] < k ? l = p + 1 : h = p;
      k < e[a[l]] && (l > 0 && (t[i] = a[l - 1]), a[l] = i)
    }
  }
  for (l = a.length, h = a[l - 1]; l-- > 0;) a[l] = h, h = t[h];
  return a
}

function a0(e) {
  const t = e.subTree.component;
  if (t) return t.asyncDep && !t.asyncResolved ? t : a0(t)
}

function jp(e) {
  if (e)
    for (let t = 0; t < e.length; t++) e[t].active = !1
}
const Dk = Symbol.for("v-scx"),
  Nk = () => fa(Dk);

function Er(e, t) {
  return kf(e, null, t)
}
const Zl = {};

function Xt(e, t, a) {
  return kf(e, t, a)
}

function kf(e, t, {
  immediate: a,
  deep: i,
  flush: o,
  once: l,
  onTrack: h,
  onTrigger: p
} = ka) {
  if (t && l) {
    const X = t;
    t = (...V) => {
      X(...V), W()
    }
  }
  const m = sr,
    k = X => i === !0 ? X : vi(X, i === !1 ? 1 : void 0);
  let w, S = !1,
    A = !1;
  if (Fa(e) ? (w = () => e.value, S = qs(e)) : Uo(e) ? (w = () => k(e), S = !0) : kt(e) ? (A = !0, S = e.some(X => Uo(X) || qs(X)), w = () => e.map(X => {
      if (Fa(X)) return X.value;
      if (Uo(X)) return k(X);
      if (Pt(X)) return ki(X, m, 2)
    })) : Pt(e) ? t ? w = () => ki(e, m, 2) : w = () => (E && E(), en(e, m, 3, [M])) : w = Jr, t && i) {
    const X = w;
    w = () => vi(X())
  }
  let E, M = X => {
      E = N.onStop = () => {
        ki(X, m, 4), E = N.onStop = void 0
      }
    },
    D;
  if (cu)
    if (M = Jr, t ? a && en(t, m, 3, [w(), A ? [] : void 0, M]) : w(), o === "sync") {
      const X = Nk();
      D = X.__watcherHandles || (X.__watcherHandles = [])
    } else return Jr;
  let B = A ? new Array(e.length).fill(Zl) : Zl;
  const z = () => {
    if (!(!N.active || !N.dirty))
      if (t) {
        const X = N.run();
        (i || S || (A ? X.some((V, ne) => Ci(V, B[ne])) : Ci(X, B))) && (E && E(), en(t, m, 3, [X, B === Zl ? void 0 : A && B[0] === Zl ? [] : B, M]), B = X)
      } else N.run()
  };
  z.allowRecurse = !!t;
  let I;
  o === "sync" ? I = z : o === "post" ? I = () => Dr(z, m && m.suspense) : (z.pre = !0, m && (z.id = m.uid), I = () => gf(z));
  const N = new of(w, Jr, I),
    U = nb(),
    W = () => {
      N.stop(), U && nf(U.effects, N)
    };
  return t ? a ? z() : B = N.run() : o === "post" ? Dr(N.run.bind(N), m && m.suspense) : N.run(), D && D.push(W), W
}

function Fk(e, t, a) {
  const i = this.proxy,
    o = Ca(e) ? e.includes(".") ? r0(i, e) : () => i[e] : e.bind(i, i);
  let l;
  Pt(t) ? l = t : (l = t.handler, a = t);
  const h = El(this),
    p = kf(o, l.bind(i), a);
  return h(), p
}

function r0(e, t) {
  const a = t.split(".");
  return () => {
    let i = e;
    for (let o = 0; o < a.length && i; o++) i = i[a[o]];
    return i
  }
}

function vi(e, t = 1 / 0, a) {
  if (t <= 0 || !pa(e) || e.__v_skip || (a = a || new Set, a.has(e))) return e;
  if (a.add(e), t--, Fa(e)) vi(e.value, t, a);
  else if (kt(e))
    for (let i = 0; i < e.length; i++) vi(e[i], t, a);
  else if (Uv(e) || Xs(e)) e.forEach(i => {
    vi(i, t, a)
  });
  else if (Kv(e)) {
    for (const i in e) vi(e[i], t, a);
    for (const i of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, i) && vi(e[i], t, a)
  }
  return e
}
const $k = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${dn(t)}Modifiers`] || e[`${Oi(t)}Modifiers`];

function Bk(e, t, ...a) {
  if (e.isUnmounted) return;
  const i = e.vnode.props || ka;
  let o = a;
  const l = t.startsWith("update:"),
    h = l && $k(i, t.slice(7));
  h && (h.trim && (o = a.map(w => Ca(w) ? w.trim() : w)), h.number && (o = a.map(Qd)));
  let p, m = i[p = Hu(t)] || i[p = Hu(dn(t))];
  !m && l && (m = i[p = Hu(Oi(t))]), m && en(m, e, 6, o);
  const k = i[p + "Once"];
  if (k) {
    if (!e.emitted) e.emitted = {};
    else if (e.emitted[p]) return;
    e.emitted[p] = !0, en(k, e, 6, o)
  }
}

function n0(e, t, a = !1) {
  const i = t.emitsCache,
    o = i.get(e);
  if (o !== void 0) return o;
  const l = e.emits;
  let h = {},
    p = !1;
  if (!Pt(e)) {
    const m = k => {
      const w = n0(k, t, !0);
      w && (p = !0, ar(h, w))
    };
    !a && t.mixins.length && t.mixins.forEach(m), e.extends && m(e.extends), e.mixins && e.mixins.forEach(m)
  }
  return !l && !p ? (pa(e) && i.set(e, null), null) : (kt(l) ? l.forEach(m => h[m] = null) : ar(h, l), pa(e) && i.set(e, h), h)
}

function lu(e, t) {
  return !e || !Jc(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Gt(e, t[0].toLowerCase() + t.slice(1)) || Gt(e, Oi(t)) || Gt(e, t))
}

function Vu(e) {
  const {
    type: t,
    vnode: a,
    proxy: i,
    withProxy: o,
    propsOptions: [l],
    slots: h,
    attrs: p,
    emit: m,
    render: k,
    renderCache: w,
    props: S,
    data: A,
    setupState: E,
    ctx: M,
    inheritAttrs: D
  } = e, B = Ac(e);
  let z, I;
  try {
    if (a.shapeFlag & 4) {
      const U = o || i,
        W = U;
      z = _n(k.call(W, U, w, S, E, A, M)), I = p
    } else {
      const U = t;
      z = _n(U.length > 1 ? U(S, {
        attrs: p,
        slots: h,
        emit: m
      }) : U(S, null)), I = t.props ? p : Hk(p)
    }
  } catch (U) {
    Zo.length = 0, nu(U, e, 1), z = Ze(Nr)
  }
  let N = z;
  if (I && D !== !1) {
    const U = Object.keys(I),
      {
        shapeFlag: W
      } = N;
    U.length && W & 7 && (l && U.some(rf) && (I = Yk(I, l)), N = Gn(N, I, !1, !0))
  }
  return a.dirs && (N = Gn(N, null, !1, !0), N.dirs = N.dirs ? N.dirs.concat(a.dirs) : a.dirs), a.transition && (N.transition = a.transition), z = N, Ac(B), z
}
const Hk = e => {
    let t;
    for (const a in e)(a === "class" || a === "style" || Jc(a)) && ((t || (t = {}))[a] = e[a]);
    return t
  },
  Yk = (e, t) => {
    const a = {};
    for (const i in e)(!rf(i) || !(i.slice(9) in t)) && (a[i] = e[i]);
    return a
  };

function zk(e, t, a) {
  const {
    props: i,
    children: o,
    component: l
  } = e, {
    props: h,
    children: p,
    patchFlag: m
  } = t, k = l.emitsOptions;
  if (t.dirs || t.transition) return !0;
  if (a && m >= 0) {
    if (m & 1024) return !0;
    if (m & 16) return i ? Up(i, h, k) : !!h;
    if (m & 8) {
      const w = t.dynamicProps;
      for (let S = 0; S < w.length; S++) {
        const A = w[S];
        if (h[A] !== i[A] && !lu(k, A)) return !0
      }
    }
  } else return (o || p) && (!p || !p.$stable) ? !0 : i === h ? !1 : i ? h ? Up(i, h, k) : !0 : !!h;
  return !1
}

function Up(e, t, a) {
  const i = Object.keys(t);
  if (i.length !== Object.keys(e).length) return !0;
  for (let o = 0; o < i.length; o++) {
    const l = i[o];
    if (t[l] !== e[l] && !lu(a, l)) return !0
  }
  return !1
}

function Xk({
  vnode: e,
  parent: t
}, a) {
  for (; t;) {
    const i = t.subTree;
    if (i.suspense && i.suspense.activeBranch === e && (i.el = e.el), i === e)(e = t.vnode).el = a, t = t.parent;
    else break
  }
}
const Wk = e => e.__isSuspense;

function Vk(e, t) {
  t && t.pendingBranch ? kt(e) ? t.effects.push(...e) : t.effects.push(e) : ek(e)
}
const vt = Symbol.for("v-fgt"),
  Cl = Symbol.for("v-txt"),
  Nr = Symbol.for("v-cmt"),
  hc = Symbol.for("v-stc"),
  Zo = [];
let jr = null;

function be(e = !1) {
  Zo.push(jr = e ? null : [])
}

function jk() {
  Zo.pop(), jr = Zo[Zo.length - 1] || null
}
let ul = 1;

function Gp(e) {
  ul += e, e < 0 && jr && (jr.hasOnce = !0)
}

function i0(e) {
  return e.dynamicChildren = ul > 0 ? jr || zs : null, jk(), ul > 0 && jr && jr.push(e), e
}

function Ne(e, t, a, i, o, l) {
  return i0(ce(e, t, a, i, o, l, !0))
}

function yt(e, t, a, i, o) {
  return i0(Ze(e, t, a, i, o, !0))
}

function Ec(e) {
  return e ? e.__v_isVNode === !0 : !1
}

function as(e, t) {
  return e.type === t.type && e.key === t.key
}
const s0 = ({
    key: e
  }) => e ?? null,
  fc = ({
    ref: e,
    ref_key: t,
    ref_for: a
  }) => (typeof e == "number" && (e = "" + e), e != null ? Ca(e) || Fa(e) || Pt(e) ? {
    i: er,
    r: e,
    k: t,
    f: !!a
  } : e : null);

function ce(e, t = null, a = null, i = 0, o = null, l = e === vt ? 0 : 1, h = !1, p = !1) {
  const m = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && s0(t),
    ref: t && fc(t),
    scopeId: iu,
    slotScopeIds: null,
    children: a,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: l,
    patchFlag: i,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: er
  };
  return p ? (_f(m, a), l & 128 && e.normalize(m)) : a && (m.shapeFlag |= Ca(a) ? 8 : 16), ul > 0 && !h && jr && (m.patchFlag > 0 || l & 6) && m.patchFlag !== 32 && jr.push(m), m
}
const Ze = Uk;

function Uk(e, t = null, a = null, i = 0, o = null, l = !1) {
  if ((!e || e === $b) && (e = Nr), Ec(e)) {
    const p = Gn(e, t, !0);
    return a && _f(p, a), ul > 0 && !l && jr && (p.shapeFlag & 6 ? jr[jr.indexOf(e)] = p : jr.push(p)), p.patchFlag = -2, p
  }
  if (t_(e) && (e = e.__vccOpts), t) {
    t = Ar(t);
    let {
      class: p,
      style: m
    } = t;
    p && !Ca(p) && (t.class = ut(p)), pa(m) && (bb(m) && !kt(m) && (m = ar({}, m)), t.style = pr(m))
  }
  const h = Ca(e) ? 1 : Wk(e) ? 128 : Ek(e) ? 64 : pa(e) ? 4 : Pt(e) ? 2 : 0;
  return ce(e, t, a, i, o, h, l, !0)
}

function Ar(e) {
  return e ? bb(e) || jb(e) ? ar({}, e) : e : null
}

function Gn(e, t, a = !1, i = !1) {
  const {
    props: o,
    ref: l,
    patchFlag: h,
    children: p,
    transition: m
  } = e, k = t ? ja(o || {}, t) : o, w = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: k,
    key: k && s0(k),
    ref: t && t.ref ? a && l ? kt(l) ? l.concat(fc(t)) : [l, fc(t)] : fc(t) : l,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: p,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    patchFlag: t && e.type !== vt ? h === -1 ? 16 : h | 16 : h,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: m,
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && Gn(e.ssContent),
    ssFallback: e.ssFallback && Gn(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return m && i && Cc(w, m.clone(w)), w
}

function $t(e = " ", t = 0) {
  return Ze(Cl, null, e, t)
}

function Tl(e, t) {
  const a = Ze(hc, null, e);
  return a.staticCount = t, a
}

function Ke(e = "", t = !1) {
  return t ? (be(), yt(Nr, null, e)) : Ze(Nr, null, e)
}

function _n(e) {
  return e == null || typeof e == "boolean" ? Ze(Nr) : kt(e) ? Ze(vt, null, e.slice()) : typeof e == "object" ? pi(e) : Ze(Cl, null, String(e))
}

function pi(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : Gn(e)
}

function _f(e, t) {
  let a = 0;
  const {
    shapeFlag: i
  } = e;
  if (t == null) t = null;
  else if (kt(t)) a = 16;
  else if (typeof t == "object")
    if (i & 65) {
      const o = t.default;
      o && (o._c && (o._d = !1), _f(e, o()), o._c && (o._d = !0));
      return
    } else {
      a = 32;
      const o = t._;
      !o && !jb(t) ? t._ctx = er : o === 3 && er && (er.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
    }
  else Pt(t) ? (t = {
    default: t,
    _ctx: er
  }, a = 32) : (t = String(t), i & 64 ? (a = 16, t = [$t(t)]) : a = 8);
  e.children = t, e.shapeFlag |= a
}

function ja(...e) {
  const t = {};
  for (let a = 0; a < e.length; a++) {
    const i = e[a];
    for (const o in i)
      if (o === "class") t.class !== i.class && (t.class = ut([t.class, i.class]));
      else if (o === "style") t.style = pr([t.style, i.style]);
    else if (Jc(o)) {
      const l = t[o],
        h = i[o];
      h && l !== h && !(kt(l) && l.includes(h)) && (t[o] = l ? [].concat(l, h) : h)
    } else o !== "" && (t[o] = i[o])
  }
  return t
}

function xn(e, t, a, i = null) {
  en(e, t, 7, [a, i])
}
const Gk = Xb();
let qk = 0;

function Kk(e, t, a) {
  const i = e.type,
    o = (t ? t.appContext : e.appContext) || Gk,
    l = {
      uid: qk++,
      vnode: e,
      type: i,
      parent: t,
      appContext: o,
      root: null,
      next: null,
      subTree: null,
      effect: null,
      update: null,
      scope: new ab(!0),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: t ? t.provides : Object.create(o.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: Gb(i, o),
      emitsOptions: n0(i, o),
      emit: null,
      emitted: null,
      propsDefaults: ka,
      inheritAttrs: i.inheritAttrs,
      ctx: ka,
      data: ka,
      props: ka,
      attrs: ka,
      slots: ka,
      refs: ka,
      setupState: ka,
      setupContext: null,
      suspense: a,
      suspenseId: a ? a.pendingId : 0,
      asyncDep: null,
      asyncResolved: !1,
      isMounted: !1,
      isUnmounted: !1,
      isDeactivated: !1,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
  return l.ctx = {
    _: l
  }, l.root = t ? t.root : l, l.emit = Bk.bind(null, l), e.ce && e.ce(l), l
}
let sr = null;
const hn = () => sr || er;
let Pc, uh; {
  const e = Qv(),
    t = (a, i) => {
      let o;
      return (o = e[a]) || (o = e[a] = []), o.push(i), l => {
        o.length > 1 ? o.forEach(h => h(l)) : o[0](l)
      }
    };
  Pc = t("__VUE_INSTANCE_SETTERS__", a => sr = a), uh = t("__VUE_SSR_SETTERS__", a => cu = a)
}
const El = e => {
    const t = sr;
    return Pc(e), e.scope.on(), () => {
      e.scope.off(), Pc(t)
    }
  },
  qp = () => {
    sr && sr.scope.off(), Pc(null)
  };

function o0(e) {
  return e.vnode.shapeFlag & 4
}
let cu = !1;

function Zk(e, t = !1, a = !1) {
  t && uh(t);
  const {
    props: i,
    children: o
  } = e.vnode, l = o0(e);
  kk(e, i, l, t), Ck(e, o, a);
  const h = l ? Qk(e, t) : void 0;
  return t && uh(!1), h
}

function Qk(e, t) {
  const a = e.type;
  e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, fk);
  const {
    setup: i
  } = a;
  if (i) {
    const o = e.setupContext = i.length > 1 ? c0(e) : null,
      l = El(e);
    Mi();
    const h = ki(i, e, 0, [e.props, o]);
    if (Ii(), l(), Gv(h)) {
      if (h.then(qp, qp), t) return h.then(p => {
        Kp(e, p, t)
      }).catch(p => {
        nu(p, e, 0)
      });
      e.asyncDep = h
    } else Kp(e, h, t)
  } else l0(e, t)
}

function Kp(e, t, a) {
  Pt(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : pa(t) && (e.setupState = _b(t)), l0(e, a)
}
let Zp;

function l0(e, t, a) {
  const i = e.type;
  if (!e.render) {
    if (!t && Zp && !i.render) {
      const o = i.template || bf(e).template;
      if (o) {
        const {
          isCustomElement: l,
          compilerOptions: h
        } = e.appContext.config, {
          delimiters: p,
          compilerOptions: m
        } = i, k = ar(ar({
          isCustomElement: l,
          delimiters: p
        }, h), m);
        i.render = Zp(o, k)
      }
    }
    e.render = i.render || Jr
  } {
    const o = El(e);
    Mi();
    try {
      gk(e)
    } finally {
      Ii(), o()
    }
  }
}
const Jk = {
  get(e, t) {
    return Hr(e, "get", ""), e[t]
  }
};

function c0(e) {
  const t = a => {
    e.exposed = a || {}
  };
  return {
    attrs: new Proxy(e.attrs, Jk),
    slots: e.slots,
    emit: e.emit,
    expose: t
  }
}

function uu(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(_b(yb(e.exposed)), {
    get(t, a) {
      if (a in t) return t[a];
      if (a in qo) return qo[a](e)
    },
    has(t, a) {
      return a in t || a in qo
    }
  })) : e.proxy
}

function e_(e, t = !0) {
  return Pt(e) ? e.displayName || e.name : e.name || t && e.__name
}

function t_(e) {
  return Pt(e) && "__vccOpts" in e
}
const Oe = (e, t) => Vw(e, t, cu);

function oa(e, t, a) {
  const i = arguments.length;
  return i === 2 ? pa(t) && !kt(t) ? Ec(t) ? Ze(e, null, [t]) : Ze(e, t) : Ze(e, null, t) : (i > 3 ? a = Array.prototype.slice.call(arguments, 2) : i === 3 && Ec(a) && (a = [a]), Ze(e, t, a))
}
const a_ = "3.4.37";
/**
 * @vue/runtime-dom v3.4.37
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const r_ = "http://www.w3.org/2000/svg",
  n_ = "http://www.w3.org/1998/Math/MathML",
  zn = typeof document < "u" ? document : null,
  Qp = zn && zn.createElement("template"),
  i_ = {
    insert: (e, t, a) => {
      t.insertBefore(e, a || null)
    },
    remove: e => {
      const t = e.parentNode;
      t && t.removeChild(e)
    },
    createElement: (e, t, a, i) => {
      const o = t === "svg" ? zn.createElementNS(r_, e) : t === "mathml" ? zn.createElementNS(n_, e) : a ? zn.createElement(e, {
        is: a
      }) : zn.createElement(e);
      return e === "select" && i && i.multiple != null && o.setAttribute("multiple", i.multiple), o
    },
    createText: e => zn.createTextNode(e),
    createComment: e => zn.createComment(e),
    setText: (e, t) => {
      e.nodeValue = t
    },
    setElementText: (e, t) => {
      e.textContent = t
    },
    parentNode: e => e.parentNode,
    nextSibling: e => e.nextSibling,
    querySelector: e => zn.querySelector(e),
    setScopeId(e, t) {
      e.setAttribute(t, "")
    },
    insertStaticContent(e, t, a, i, o, l) {
      const h = a ? a.previousSibling : t.lastChild;
      if (o && (o === l || o.nextSibling))
        for (; t.insertBefore(o.cloneNode(!0), a), !(o === l || !(o = o.nextSibling)););
      else {
        Qp.innerHTML = i === "svg" ? `<svg>${e}</svg>` : i === "mathml" ? `<math>${e}</math>` : e;
        const p = Qp.content;
        if (i === "svg" || i === "mathml") {
          const m = p.firstChild;
          for (; m.firstChild;) p.appendChild(m.firstChild);
          p.removeChild(m)
        }
        t.insertBefore(p, a)
      }
      return [h ? h.nextSibling : t.firstChild, a ? a.previousSibling : t.lastChild]
    }
  },
  ii = "transition",
  Po = "animation",
  dl = Symbol("_vtc"),
  In = (e, {
    slots: t
  }) => oa(nk, s_(e), t);
In.displayName = "Transition";
const u0 = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
In.props = ar({}, Ob, u0);
const Ui = (e, t = []) => {
    kt(e) ? e.forEach(a => a(...t)) : e && e(...t)
  },
  Jp = e => e ? kt(e) ? e.some(t => t.length > 1) : e.length > 1 : !1;

function s_(e) {
  const t = {};
  for (const le in e) le in u0 || (t[le] = e[le]);
  if (e.css === !1) return t;
  const {
    name: a = "v",
    type: i,
    duration: o,
    enterFromClass: l = `${a}-enter-from`,
    enterActiveClass: h = `${a}-enter-active`,
    enterToClass: p = `${a}-enter-to`,
    appearFromClass: m = l,
    appearActiveClass: k = h,
    appearToClass: w = p,
    leaveFromClass: S = `${a}-leave-from`,
    leaveActiveClass: A = `${a}-leave-active`,
    leaveToClass: E = `${a}-leave-to`
  } = e, M = o_(o), D = M && M[0], B = M && M[1], {
    onBeforeEnter: z,
    onEnter: I,
    onEnterCancelled: N,
    onLeave: U,
    onLeaveCancelled: W,
    onBeforeAppear: X = z,
    onAppear: V = I,
    onAppearCancelled: ne = N
  } = t, Z = (le, Ee, ye) => {
    Gi(le, Ee ? w : p), Gi(le, Ee ? k : h), ye && ye()
  }, ie = (le, Ee) => {
    le._isLeaving = !1, Gi(le, S), Gi(le, E), Gi(le, A), Ee && Ee()
  }, fe = le => (Ee, ye) => {
    const ve = le ? V : I,
      me = () => Z(Ee, le, ye);
    Ui(ve, [Ee, me]), eg(() => {
      Gi(Ee, le ? m : l), si(Ee, le ? w : p), Jp(ve) || tg(Ee, i, D, me)
    })
  };
  return ar(t, {
    onBeforeEnter(le) {
      Ui(z, [le]), si(le, l), si(le, h)
    },
    onBeforeAppear(le) {
      Ui(X, [le]), si(le, m), si(le, k)
    },
    onEnter: fe(!1),
    onAppear: fe(!0),
    onLeave(le, Ee) {
      le._isLeaving = !0;
      const ye = () => ie(le, Ee);
      si(le, S), si(le, A), u_(), eg(() => {
        le._isLeaving && (Gi(le, S), si(le, E), Jp(U) || tg(le, i, B, ye))
      }), Ui(U, [le, ye])
    },
    onEnterCancelled(le) {
      Z(le, !1), Ui(N, [le])
    },
    onAppearCancelled(le) {
      Z(le, !0), Ui(ne, [le])
    },
    onLeaveCancelled(le) {
      ie(le), Ui(W, [le])
    }
  })
}

function o_(e) {
  if (e == null) return null;
  if (pa(e)) return [ju(e.enter), ju(e.leave)]; {
    const t = ju(e);
    return [t, t]
  }
}

function ju(e) {
  return mw(e)
}

function si(e, t) {
  t.split(/\s+/).forEach(a => a && e.classList.add(a)), (e[dl] || (e[dl] = new Set)).add(t)
}

function Gi(e, t) {
  t.split(/\s+/).forEach(i => i && e.classList.remove(i));
  const a = e[dl];
  a && (a.delete(t), a.size || (e[dl] = void 0))
}

function eg(e) {
  requestAnimationFrame(() => {
    requestAnimationFrame(e)
  })
}
let l_ = 0;

function tg(e, t, a, i) {
  const o = e._endId = ++l_,
    l = () => {
      o === e._endId && i()
    };
  if (a) return setTimeout(l, a);
  const {
    type: h,
    timeout: p,
    propCount: m
  } = c_(e, t);
  if (!h) return i();
  const k = h + "end";
  let w = 0;
  const S = () => {
      e.removeEventListener(k, A), l()
    },
    A = E => {
      E.target === e && ++w >= m && S()
    };
  setTimeout(() => {
    w < m && S()
  }, p + 1), e.addEventListener(k, A)
}

function c_(e, t) {
  const a = window.getComputedStyle(e),
    i = M => (a[M] || "").split(", "),
    o = i(`${ii}Delay`),
    l = i(`${ii}Duration`),
    h = ag(o, l),
    p = i(`${Po}Delay`),
    m = i(`${Po}Duration`),
    k = ag(p, m);
  let w = null,
    S = 0,
    A = 0;
  t === ii ? h > 0 && (w = ii, S = h, A = l.length) : t === Po ? k > 0 && (w = Po, S = k, A = m.length) : (S = Math.max(h, k), w = S > 0 ? h > k ? ii : Po : null, A = w ? w === ii ? l.length : m.length : 0);
  const E = w === ii && /\b(transform|all)(,|$)/.test(i(`${ii}Property`).toString());
  return {
    type: w,
    timeout: S,
    propCount: A,
    hasTransform: E
  }
}

function ag(e, t) {
  for (; e.length < t.length;) e = e.concat(e);
  return Math.max(...t.map((a, i) => rg(a) + rg(e[i])))
}

function rg(e) {
  return e === "auto" ? 0 : Number(e.slice(0, -1).replace(",", ".")) * 1e3
}

function u_() {
  return document.body.offsetHeight
}

function d_(e, t, a) {
  const i = e[dl];
  i && (t = (t ? [t, ...i] : [...i]).join(" ")), t == null ? e.removeAttribute("class") : a ? e.setAttribute("class", t) : e.className = t
}
const Lc = Symbol("_vod"),
  d0 = Symbol("_vsh"),
  pc = {
    beforeMount(e, {
      value: t
    }, {
      transition: a
    }) {
      e[Lc] = e.style.display === "none" ? "" : e.style.display, a && t ? a.beforeEnter(e) : Lo(e, t)
    },
    mounted(e, {
      value: t
    }, {
      transition: a
    }) {
      a && t && a.enter(e)
    },
    updated(e, {
      value: t,
      oldValue: a
    }, {
      transition: i
    }) {
      !t != !a && (i ? t ? (i.beforeEnter(e), Lo(e, !0), i.enter(e)) : i.leave(e, () => {
        Lo(e, !1)
      }) : Lo(e, t))
    },
    beforeUnmount(e, {
      value: t
    }) {
      Lo(e, t)
    }
  };

function Lo(e, t) {
  e.style.display = t ? e[Lc] : "none", e[d0] = !t
}
const h_ = Symbol(""),
  f_ = /(^|;)\s*display\s*:/;

function p_(e, t, a) {
  const i = e.style,
    o = Ca(a);
  let l = !1;
  if (a && !o) {
    if (t)
      if (Ca(t))
        for (const h of t.split(";")) {
          const p = h.slice(0, h.indexOf(":")).trim();
          a[p] == null && gc(i, p, "")
        } else
          for (const h in t) a[h] == null && gc(i, h, "");
    for (const h in a) h === "display" && (l = !0), gc(i, h, a[h])
  } else if (o) {
    if (t !== a) {
      const h = i[h_];
      h && (a += ";" + h), i.cssText = a, l = f_.test(a)
    }
  } else t && e.removeAttribute("style");
  Lc in e && (e[Lc] = l ? i.display : "", e[d0] && (i.display = "none"))
}
const ng = /\s*!important$/;

function gc(e, t, a) {
  if (kt(a)) a.forEach(i => gc(e, t, i));
  else if (a == null && (a = ""), t.startsWith("--")) e.setProperty(t, a);
  else {
    const i = g_(e, t);
    ng.test(a) ? e.setProperty(Oi(i), a.replace(ng, ""), "important") : e[i] = a
  }
}
const ig = ["Webkit", "Moz", "ms"],
  Uu = {};

function g_(e, t) {
  const a = Uu[t];
  if (a) return a;
  let i = dn(t);
  if (i !== "filter" && i in e) return Uu[t] = i;
  i = au(i);
  for (let o = 0; o < ig.length; o++) {
    const l = ig[o] + i;
    if (l in e) return Uu[t] = l
  }
  return t
}
const sg = "http://www.w3.org/1999/xlink";

function og(e, t, a, i, o, l = kw(t)) {
  i && t.startsWith("xlink:") ? a == null ? e.removeAttributeNS(sg, t.slice(6, t.length)) : e.setAttributeNS(sg, t, a) : a == null || l && !Jv(a) ? e.removeAttribute(t) : e.setAttribute(t, l ? "" : Li(a) ? String(a) : a)
}

function m_(e, t, a, i) {
  if (t === "innerHTML" || t === "textContent") {
    if (a == null) return;
    e[t] = a;
    return
  }
  const o = e.tagName;
  if (t === "value" && o !== "PROGRESS" && !o.includes("-")) {
    const h = o === "OPTION" ? e.getAttribute("value") || "" : e.value,
      p = a == null ? "" : String(a);
    (h !== p || !("_value" in e)) && (e.value = p), a == null && e.removeAttribute(t), e._value = a;
    return
  }
  let l = !1;
  if (a === "" || a == null) {
    const h = typeof e[t];
    h === "boolean" ? a = Jv(a) : a == null && h === "string" ? (a = "", l = !0) : h === "number" && (a = 0, l = !0)
  }
  try {
    e[t] = a
  } catch {}
  l && e.removeAttribute(t)
}

function Rs(e, t, a, i) {
  e.addEventListener(t, a, i)
}

function v_(e, t, a, i) {
  e.removeEventListener(t, a, i)
}
const lg = Symbol("_vei");

function b_(e, t, a, i, o = null) {
  const l = e[lg] || (e[lg] = {}),
    h = l[t];
  if (i && h) h.value = i;
  else {
    const [p, m] = y_(t);
    if (i) {
      const k = l[t] = k_(i, o);
      Rs(e, p, k, m)
    } else h && (v_(e, p, h, m), l[t] = void 0)
  }
}
const cg = /(?:Once|Passive|Capture)$/;

function y_(e) {
  let t;
  if (cg.test(e)) {
    t = {};
    let i;
    for (; i = e.match(cg);) e = e.slice(0, e.length - i[0].length), t[i[0].toLowerCase()] = !0
  }
  return [e[2] === ":" ? e.slice(3) : Oi(e.slice(2)), t]
}
let Gu = 0;
const x_ = Promise.resolve(),
  w_ = () => Gu || (x_.then(() => Gu = 0), Gu = Date.now());

function k_(e, t) {
  const a = i => {
    if (!i._vts) i._vts = Date.now();
    else if (i._vts <= a.attached) return;
    en(__(i, a.value), t, 5, [i])
  };
  return a.value = e, a.attached = w_(), a
}

function __(e, t) {
  if (kt(t)) {
    const a = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      a.call(e), e._stopped = !0
    }, t.map(i => o => !o._stopped && i && i(o))
  } else return t
}
const ug = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,
  S_ = (e, t, a, i, o, l) => {
    const h = o === "svg";
    t === "class" ? d_(e, i, h) : t === "style" ? p_(e, a, i) : Jc(t) ? rf(t) || b_(e, t, a, i, l) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : A_(e, t, i, h)) ? (m_(e, t, i), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && og(e, t, i, h, l, t !== "value")) : (t === "true-value" ? e._trueValue = i : t === "false-value" && (e._falseValue = i), og(e, t, i, h))
  };

function A_(e, t, a, i) {
  if (i) return !!(t === "innerHTML" || t === "textContent" || t in e && ug(t) && Pt(a));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1;
  if (t === "width" || t === "height") {
    const o = e.tagName;
    if (o === "IMG" || o === "VIDEO" || o === "CANVAS" || o === "SOURCE") return !1
  }
  return ug(t) && Ca(a) ? !1 : t in e
}
const dg = e => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return kt(t) ? a => uc(t, a) : t
};

function C_(e) {
  e.target.composing = !0
}

function hg(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}
const qu = Symbol("_assign"),
  h0 = {
    created(e, {
      modifiers: {
        lazy: t,
        trim: a,
        number: i
      }
    }, o) {
      e[qu] = dg(o);
      const l = i || o.props && o.props.type === "number";
      Rs(e, t ? "change" : "input", h => {
        if (h.target.composing) return;
        let p = e.value;
        a && (p = p.trim()), l && (p = Qd(p)), e[qu](p)
      }), a && Rs(e, "change", () => {
        e.value = e.value.trim()
      }), t || (Rs(e, "compositionstart", C_), Rs(e, "compositionend", hg), Rs(e, "change", hg))
    },
    mounted(e, {
      value: t
    }) {
      e.value = t ?? ""
    },
    beforeUpdate(e, {
      value: t,
      oldValue: a,
      modifiers: {
        lazy: i,
        trim: o,
        number: l
      }
    }, h) {
      if (e[qu] = dg(h), e.composing) return;
      const p = (l || e.type === "number") && !/^0\d/.test(e.value) ? Qd(e.value) : e.value,
        m = t ?? "";
      p !== m && (document.activeElement === e && e.type !== "range" && (i && t === a || o && e.value.trim() === m) || (e.value = m))
    }
  },
  T_ = ["ctrl", "shift", "alt", "meta"],
  E_ = {
    stop: e => e.stopPropagation(),
    prevent: e => e.preventDefault(),
    self: e => e.target !== e.currentTarget,
    ctrl: e => !e.ctrlKey,
    shift: e => !e.shiftKey,
    alt: e => !e.altKey,
    meta: e => !e.metaKey,
    left: e => "button" in e && e.button !== 0,
    middle: e => "button" in e && e.button !== 1,
    right: e => "button" in e && e.button !== 2,
    exact: (e, t) => T_.some(a => e[`${a}Key`] && !t.includes(a))
  },
  qn = (e, t) => {
    const a = e._withMods || (e._withMods = {}),
      i = t.join(".");
    return a[i] || (a[i] = (o, ...l) => {
      for (let h = 0; h < t.length; h++) {
        const p = E_[t[h]];
        if (p && p(o, t)) return
      }
      return e(o, ...l)
    })
  },
  P_ = {
    esc: "escape",
    space: " ",
    up: "arrow-up",
    left: "arrow-left",
    right: "arrow-right",
    down: "arrow-down",
    delete: "backspace"
  },
  L_ = (e, t) => {
    const a = e._withKeys || (e._withKeys = {}),
      i = t.join(".");
    return a[i] || (a[i] = o => {
      if (!("key" in o)) return;
      const l = Oi(o.key);
      if (t.some(h => h === l || P_[h] === l)) return e(o)
    })
  },
  O_ = ar({
    patchProp: S_
  }, i_);
let fg;

function f0() {
  return fg || (fg = Ok(O_))
}
const pg = (...e) => {
    f0().render(...e)
  },
  M_ = (...e) => {
    const t = f0().createApp(...e),
      {
        mount: a
      } = t;
    return t.mount = i => {
      const o = R_(i);
      if (!o) return;
      const l = t._component;
      !Pt(l) && !l.render && !l.template && (l.template = o.innerHTML), o.innerHTML = "";
      const h = a(o, !1, I_(o));
      return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), h
    }, t
  };

function I_(e) {
  if (e instanceof SVGElement) return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml"
}

function R_(e) {
  return Ca(e) ? document.querySelector(e) : e
}

function D_() {
  return p0().__VUE_DEVTOOLS_GLOBAL_HOOK__
}

function p0() {
  return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {}
}
const N_ = typeof Proxy == "function",
  F_ = "devtools-plugin:setup",
  $_ = "plugin:settings:set";
let As, dh;

function B_() {
  var e;
  return As !== void 0 || (typeof window < "u" && window.performance ? (As = !0, dh = window.performance) : typeof globalThis < "u" && (!((e = globalThis.perf_hooks) === null || e === void 0) && e.performance) ? (As = !0, dh = globalThis.perf_hooks.performance) : As = !1), As
}

function H_() {
  return B_() ? dh.now() : Date.now()
}
class Y_ {
  constructor(t, a) {
    this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = t, this.hook = a;
    const i = {};
    if (t.settings)
      for (const h in t.settings) {
        const p = t.settings[h];
        i[h] = p.defaultValue
      }
    const o = `__vue-devtools-plugin-settings__${t.id}`;
    let l = Object.assign({}, i);
    try {
      const h = localStorage.getItem(o),
        p = JSON.parse(h);
      Object.assign(l, p)
    } catch {}
    this.fallbacks = {
      getSettings() {
        return l
      },
      setSettings(h) {
        try {
          localStorage.setItem(o, JSON.stringify(h))
        } catch {}
        l = h
      },
      now() {
        return H_()
      }
    }, a && a.on($_, (h, p) => {
      h === this.plugin.id && this.fallbacks.setSettings(p)
    }), this.proxiedOn = new Proxy({}, {
      get: (h, p) => this.target ? this.target.on[p] : (...m) => {
        this.onQueue.push({
          method: p,
          args: m
        })
      }
    }), this.proxiedTarget = new Proxy({}, {
      get: (h, p) => this.target ? this.target[p] : p === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(p) ? (...m) => (this.targetQueue.push({
        method: p,
        args: m,
        resolve: () => {}
      }), this.fallbacks[p](...m)) : (...m) => new Promise(k => {
        this.targetQueue.push({
          method: p,
          args: m,
          resolve: k
        })
      })
    })
  }
  async setRealTarget(t) {
    this.target = t;
    for (const a of this.onQueue) this.target.on[a.method](...a.args);
    for (const a of this.targetQueue) a.resolve(await this.target[a.method](...a.args))
  }
}

function z_(e, t) {
  const a = e,
    i = p0(),
    o = D_(),
    l = N_ && a.enableEarlyProxy;
  if (o && (i.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !l)) o.emit(F_, e, t);
  else {
    const h = l ? new Y_(a, o) : null;
    (i.__VUE_DEVTOOLS_PLUGINS__ = i.__VUE_DEVTOOLS_PLUGINS__ || []).push({
      pluginDescriptor: a,
      setupFn: t,
      proxy: h
    }), h && t(h.proxiedTarget)
  }
}
/*!
 * vuex v4.1.0
 * (c) 2022 Evan You
 * @license MIT
 */
var g0 = "store";

function X_(e) {
  return e === void 0 && (e = null), fa(e !== null ? e : g0)
}

function fo(e, t) {
  Object.keys(e).forEach(function (a) {
    return t(e[a], a)
  })
}

function W_(e) {
  return e !== null && typeof e == "object"
}

function V_(e) {
  return e && typeof e.then == "function"
}

function j_(e, t) {
  return function () {
    return e(t)
  }
}

function m0(e, t, a) {
  return t.indexOf(e) < 0 && (a && a.prepend ? t.unshift(e) : t.push(e)),
    function () {
      var i = t.indexOf(e);
      i > -1 && t.splice(i, 1)
    }
}

function v0(e, t) {
  e._actions = Object.create(null), e._mutations = Object.create(null), e._wrappedGetters = Object.create(null), e._modulesNamespaceMap = Object.create(null);
  var a = e.state;
  du(e, a, [], e._modules.root, !0), Sf(e, a, t)
}

function Sf(e, t, a) {
  var i = e._state,
    o = e._scope;
  e.getters = {}, e._makeLocalGettersCache = Object.create(null);
  var l = e._wrappedGetters,
    h = {},
    p = {},
    m = rb(!0);
  m.run(function () {
    fo(l, function (k, w) {
      h[w] = j_(k, e), p[w] = Oe(function () {
        return h[w]()
      }), Object.defineProperty(e.getters, w, {
        get: function () {
          return p[w].value
        },
        enumerable: !0
      })
    })
  }), e._state = qr({
    data: t
  }), e._scope = m, e.strict && Z_(e), i && a && e._withCommit(function () {
    i.data = null
  }), o && o.stop()
}

function du(e, t, a, i, o) {
  var l = !a.length,
    h = e._modules.getNamespace(a);
  if (i.namespaced && (e._modulesNamespaceMap[h], e._modulesNamespaceMap[h] = i), !l && !o) {
    var p = Af(t, a.slice(0, -1)),
      m = a[a.length - 1];
    e._withCommit(function () {
      p[m] = i.state
    })
  }
  var k = i.context = U_(e, h, a);
  i.forEachMutation(function (w, S) {
    var A = h + S;
    G_(e, A, w, k)
  }), i.forEachAction(function (w, S) {
    var A = w.root ? S : h + S,
      E = w.handler || w;
    q_(e, A, E, k)
  }), i.forEachGetter(function (w, S) {
    var A = h + S;
    K_(e, A, w, k)
  }), i.forEachChild(function (w, S) {
    du(e, t, a.concat(S), w, o)
  })
}

function U_(e, t, a) {
  var i = t === "",
    o = {
      dispatch: i ? e.dispatch : function (l, h, p) {
        var m = Oc(l, h, p),
          k = m.payload,
          w = m.options,
          S = m.type;
        return (!w || !w.root) && (S = t + S), e.dispatch(S, k)
      },
      commit: i ? e.commit : function (l, h, p) {
        var m = Oc(l, h, p),
          k = m.payload,
          w = m.options,
          S = m.type;
        (!w || !w.root) && (S = t + S), e.commit(S, k, w)
      }
    };
  return Object.defineProperties(o, {
    getters: {
      get: i ? function () {
        return e.getters
      } : function () {
        return b0(e, t)
      }
    },
    state: {
      get: function () {
        return Af(e.state, a)
      }
    }
  }), o
}

function b0(e, t) {
  if (!e._makeLocalGettersCache[t]) {
    var a = {},
      i = t.length;
    Object.keys(e.getters).forEach(function (o) {
      if (o.slice(0, i) === t) {
        var l = o.slice(i);
        Object.defineProperty(a, l, {
          get: function () {
            return e.getters[o]
          },
          enumerable: !0
        })
      }
    }), e._makeLocalGettersCache[t] = a
  }
  return e._makeLocalGettersCache[t]
}

function G_(e, t, a, i) {
  var o = e._mutations[t] || (e._mutations[t] = []);
  o.push(function (h) {
    a.call(e, i.state, h)
  })
}

function q_(e, t, a, i) {
  var o = e._actions[t] || (e._actions[t] = []);
  o.push(function (h) {
    var p = a.call(e, {
      dispatch: i.dispatch,
      commit: i.commit,
      getters: i.getters,
      state: i.state,
      rootGetters: e.getters,
      rootState: e.state
    }, h);
    return V_(p) || (p = Promise.resolve(p)), e._devtoolHook ? p.catch(function (m) {
      throw e._devtoolHook.emit("vuex:error", m), m
    }) : p
  })
}

function K_(e, t, a, i) {
  e._wrappedGetters[t] || (e._wrappedGetters[t] = function (l) {
    return a(i.state, i.getters, l.state, l.getters)
  })
}

function Z_(e) {
  Xt(function () {
    return e._state.data
  }, function () {}, {
    deep: !0,
    flush: "sync"
  })
}

function Af(e, t) {
  return t.reduce(function (a, i) {
    return a[i]
  }, e)
}

function Oc(e, t, a) {
  return W_(e) && e.type && (a = t, t = e, e = e.type), {
    type: e,
    payload: t,
    options: a
  }
}
var Q_ = "vuex bindings",
  gg = "vuex:mutations",
  Ku = "vuex:actions",
  Cs = "vuex",
  J_ = 0;

function eS(e, t) {
  z_({
    id: "org.vuejs.vuex",
    app: e,
    label: "Vuex",
    homepage: "https://next.vuex.vuejs.org/",
    logo: "https://vuejs.org/images/icons/favicon-96x96.png",
    packageName: "vuex",
    componentStateTypes: [Q_]
  }, function (a) {
    a.addTimelineLayer({
      id: gg,
      label: "Vuex Mutations",
      color: mg
    }), a.addTimelineLayer({
      id: Ku,
      label: "Vuex Actions",
      color: mg
    }), a.addInspector({
      id: Cs,
      label: "Vuex",
      icon: "storage",
      treeFilterPlaceholder: "Filter stores..."
    }), a.on.getInspectorTree(function (i) {
      if (i.app === e && i.inspectorId === Cs)
        if (i.filter) {
          var o = [];
          k0(o, t._modules.root, i.filter, ""), i.rootNodes = o
        } else i.rootNodes = [w0(t._modules.root, "")]
    }), a.on.getInspectorState(function (i) {
      if (i.app === e && i.inspectorId === Cs) {
        var o = i.nodeId;
        b0(t, o), i.state = rS(iS(t._modules, o), o === "root" ? t.getters : t._makeLocalGettersCache, o)
      }
    }), a.on.editInspectorState(function (i) {
      if (i.app === e && i.inspectorId === Cs) {
        var o = i.nodeId,
          l = i.path;
        o !== "root" && (l = o.split("/").filter(Boolean).concat(l)), t._withCommit(function () {
          i.set(t._state.data, l, i.state.value)
        })
      }
    }), t.subscribe(function (i, o) {
      var l = {};
      i.payload && (l.payload = i.payload), l.state = o, a.notifyComponentUpdate(), a.sendInspectorTree(Cs), a.sendInspectorState(Cs), a.addTimelineEvent({
        layerId: gg,
        event: {
          time: Date.now(),
          title: i.type,
          data: l
        }
      })
    }), t.subscribeAction({
      before: function (i, o) {
        var l = {};
        i.payload && (l.payload = i.payload), i._id = J_++, i._time = Date.now(), l.state = o, a.addTimelineEvent({
          layerId: Ku,
          event: {
            time: i._time,
            title: i.type,
            groupId: i._id,
            subtitle: "start",
            data: l
          }
        })
      },
      after: function (i, o) {
        var l = {},
          h = Date.now() - i._time;
        l.duration = {
          _custom: {
            type: "duration",
            display: h + "ms",
            tooltip: "Action duration",
            value: h
          }
        }, i.payload && (l.payload = i.payload), l.state = o, a.addTimelineEvent({
          layerId: Ku,
          event: {
            time: Date.now(),
            title: i.type,
            groupId: i._id,
            subtitle: "end",
            data: l
          }
        })
      }
    })
  })
}
var mg = 8702998,
  tS = 6710886,
  aS = 16777215,
  y0 = {
    label: "namespaced",
    textColor: aS,
    backgroundColor: tS
  };

function x0(e) {
  return e && e !== "root" ? e.split("/").slice(-2, -1)[0] : "Root"
}

function w0(e, t) {
  return {
    id: t || "root",
    label: x0(t),
    tags: e.namespaced ? [y0] : [],
    children: Object.keys(e._children).map(function (a) {
      return w0(e._children[a], t + a + "/")
    })
  }
}

function k0(e, t, a, i) {
  i.includes(a) && e.push({
    id: i || "root",
    label: i.endsWith("/") ? i.slice(0, i.length - 1) : i || "Root",
    tags: t.namespaced ? [y0] : []
  }), Object.keys(t._children).forEach(function (o) {
    k0(e, t._children[o], a, i + o + "/")
  })
}

function rS(e, t, a) {
  t = a === "root" ? t : t[a];
  var i = Object.keys(t),
    o = {
      state: Object.keys(e.state).map(function (h) {
        return {
          key: h,
          editable: !0,
          value: e.state[h]
        }
      })
    };
  if (i.length) {
    var l = nS(t);
    o.getters = Object.keys(l).map(function (h) {
      return {
        key: h.endsWith("/") ? x0(h) : h,
        editable: !1,
        value: hh(function () {
          return l[h]
        })
      }
    })
  }
  return o
}

function nS(e) {
  var t = {};
  return Object.keys(e).forEach(function (a) {
    var i = a.split("/");
    if (i.length > 1) {
      var o = t,
        l = i.pop();
      i.forEach(function (h) {
        o[h] || (o[h] = {
          _custom: {
            value: {},
            display: h,
            tooltip: "Module",
            abstract: !0
          }
        }), o = o[h]._custom.value
      }), o[l] = hh(function () {
        return e[a]
      })
    } else t[a] = hh(function () {
      return e[a]
    })
  }), t
}

function iS(e, t) {
  var a = t.split("/").filter(function (i) {
    return i
  });
  return a.reduce(function (i, o, l) {
    var h = i[o];
    if (!h) throw new Error('Missing module "' + o + '" for path "' + t + '".');
    return l === a.length - 1 ? h : h._children
  }, t === "root" ? e : e.root._children)
}

function hh(e) {
  try {
    return e()
  } catch (t) {
    return t
  }
}
var mn = function (t, a) {
    this.runtime = a, this._children = Object.create(null), this._rawModule = t;
    var i = t.state;
    this.state = (typeof i == "function" ? i() : i) || {}
  },
  _0 = {
    namespaced: {
      configurable: !0
    }
  };
_0.namespaced.get = function () {
  return !!this._rawModule.namespaced
};
mn.prototype.addChild = function (t, a) {
  this._children[t] = a
};
mn.prototype.removeChild = function (t) {
  delete this._children[t]
};
mn.prototype.getChild = function (t) {
  return this._children[t]
};
mn.prototype.hasChild = function (t) {
  return t in this._children
};
mn.prototype.update = function (t) {
  this._rawModule.namespaced = t.namespaced, t.actions && (this._rawModule.actions = t.actions), t.mutations && (this._rawModule.mutations = t.mutations), t.getters && (this._rawModule.getters = t.getters)
};
mn.prototype.forEachChild = function (t) {
  fo(this._children, t)
};
mn.prototype.forEachGetter = function (t) {
  this._rawModule.getters && fo(this._rawModule.getters, t)
};
mn.prototype.forEachAction = function (t) {
  this._rawModule.actions && fo(this._rawModule.actions, t)
};
mn.prototype.forEachMutation = function (t) {
  this._rawModule.mutations && fo(this._rawModule.mutations, t)
};
Object.defineProperties(mn.prototype, _0);
var bs = function (t) {
  this.register([], t, !1)
};
bs.prototype.get = function (t) {
  return t.reduce(function (a, i) {
    return a.getChild(i)
  }, this.root)
};
bs.prototype.getNamespace = function (t) {
  var a = this.root;
  return t.reduce(function (i, o) {
    return a = a.getChild(o), i + (a.namespaced ? o + "/" : "")
  }, "")
};
bs.prototype.update = function (t) {
  S0([], this.root, t)
};
bs.prototype.register = function (t, a, i) {
  var o = this;
  i === void 0 && (i = !0);
  var l = new mn(a, i);
  if (t.length === 0) this.root = l;
  else {
    var h = this.get(t.slice(0, -1));
    h.addChild(t[t.length - 1], l)
  }
  a.modules && fo(a.modules, function (p, m) {
    o.register(t.concat(m), p, i)
  })
};
bs.prototype.unregister = function (t) {
  var a = this.get(t.slice(0, -1)),
    i = t[t.length - 1],
    o = a.getChild(i);
  o && o.runtime && a.removeChild(i)
};
bs.prototype.isRegistered = function (t) {
  var a = this.get(t.slice(0, -1)),
    i = t[t.length - 1];
  return a ? a.hasChild(i) : !1
};

function S0(e, t, a) {
  if (t.update(a), a.modules)
    for (var i in a.modules) {
      if (!t.getChild(i)) return;
      S0(e.concat(i), t.getChild(i), a.modules[i])
    }
}

function sS(e) {
  return new Yr(e)
}
var Yr = function (t) {
    var a = this;
    t === void 0 && (t = {});
    var i = t.plugins;
    i === void 0 && (i = []);
    var o = t.strict;
    o === void 0 && (o = !1);
    var l = t.devtools;
    this._committing = !1, this._actions = Object.create(null), this._actionSubscribers = [], this._mutations = Object.create(null), this._wrappedGetters = Object.create(null), this._modules = new bs(t), this._modulesNamespaceMap = Object.create(null), this._subscribers = [], this._makeLocalGettersCache = Object.create(null), this._scope = null, this._devtools = l;
    var h = this,
      p = this,
      m = p.dispatch,
      k = p.commit;
    this.dispatch = function (A, E) {
      return m.call(h, A, E)
    }, this.commit = function (A, E, M) {
      return k.call(h, A, E, M)
    }, this.strict = o;
    var w = this._modules.root.state;
    du(this, w, [], this._modules.root), Sf(this, w), i.forEach(function (S) {
      return S(a)
    })
  },
  Cf = {
    state: {
      configurable: !0
    }
  };
Yr.prototype.install = function (t, a) {
  t.provide(a || g0, this), t.config.globalProperties.$store = this;
  var i = this._devtools !== void 0 ? this._devtools : !1;
  i && eS(t, this)
};
Cf.state.get = function () {
  return this._state.data
};
Cf.state.set = function (e) {};
Yr.prototype.commit = function (t, a, i) {
  var o = this,
    l = Oc(t, a, i),
    h = l.type,
    p = l.payload,
    m = {
      type: h,
      payload: p
    },
    k = this._mutations[h];
  k && (this._withCommit(function () {
    k.forEach(function (S) {
      S(p)
    })
  }), this._subscribers.slice().forEach(function (w) {
    return w(m, o.state)
  }))
};
Yr.prototype.dispatch = function (t, a) {
  var i = this,
    o = Oc(t, a),
    l = o.type,
    h = o.payload,
    p = {
      type: l,
      payload: h
    },
    m = this._actions[l];
  if (m) {
    try {
      this._actionSubscribers.slice().filter(function (w) {
        return w.before
      }).forEach(function (w) {
        return w.before(p, i.state)
      })
    } catch {}
    var k = m.length > 1 ? Promise.all(m.map(function (w) {
      return w(h)
    })) : m[0](h);
    return new Promise(function (w, S) {
      k.then(function (A) {
        try {
          i._actionSubscribers.filter(function (E) {
            return E.after
          }).forEach(function (E) {
            return E.after(p, i.state)
          })
        } catch {}
        w(A)
      }, function (A) {
        try {
          i._actionSubscribers.filter(function (E) {
            return E.error
          }).forEach(function (E) {
            return E.error(p, i.state, A)
          })
        } catch {}
        S(A)
      })
    })
  }
};
Yr.prototype.subscribe = function (t, a) {
  return m0(t, this._subscribers, a)
};
Yr.prototype.subscribeAction = function (t, a) {
  var i = typeof t == "function" ? {
    before: t
  } : t;
  return m0(i, this._actionSubscribers, a)
};
Yr.prototype.watch = function (t, a, i) {
  var o = this;
  return Xt(function () {
    return t(o.state, o.getters)
  }, a, Object.assign({}, i))
};
Yr.prototype.replaceState = function (t) {
  var a = this;
  this._withCommit(function () {
    a._state.data = t
  })
};
Yr.prototype.registerModule = function (t, a, i) {
  i === void 0 && (i = {}), typeof t == "string" && (t = [t]), this._modules.register(t, a), du(this, this.state, t, this._modules.get(t), i.preserveState), Sf(this, this.state)
};
Yr.prototype.unregisterModule = function (t) {
  var a = this;
  typeof t == "string" && (t = [t]), this._modules.unregister(t), this._withCommit(function () {
    var i = Af(a.state, t.slice(0, -1));
    delete i[t[t.length - 1]]
  }), v0(this)
};
Yr.prototype.hasModule = function (t) {
  return typeof t == "string" && (t = [t]), this._modules.isRegistered(t)
};
Yr.prototype.hotUpdate = function (t) {
  this._modules.update(t), v0(this, !0)
};
Yr.prototype._withCommit = function (t) {
  var a = this._committing;
  this._committing = !0, t(), this._committing = a
};
Object.defineProperties(Yr.prototype, Cf);

function A0(e, t) {
  return function () {
    return e.apply(t, arguments)
  }
}
const {
  toString: oS
} = Object.prototype, {
  getPrototypeOf: Tf
} = Object, hu = (e => t => {
  const a = oS.call(t);
  return e[a] || (e[a] = a.slice(8, -1).toLowerCase())
})(Object.create(null)), vn = e => (e = e.toLowerCase(), t => hu(t) === e), fu = e => t => typeof t === e, {
  isArray: po
} = Array, hl = fu("undefined");

function lS(e) {
  return e !== null && !hl(e) && e.constructor !== null && !hl(e.constructor) && Gr(e.constructor.isBuffer) && e.constructor.isBuffer(e)
}
const C0 = vn("ArrayBuffer");

function cS(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && C0(e.buffer), t
}
const uS = fu("string"),
  Gr = fu("function"),
  T0 = fu("number"),
  pu = e => e !== null && typeof e == "object",
  dS = e => e === !0 || e === !1,
  mc = e => {
    if (hu(e) !== "object") return !1;
    const t = Tf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e)
  },
  hS = vn("Date"),
  fS = vn("File"),
  pS = vn("Blob"),
  gS = vn("FileList"),
  mS = e => pu(e) && Gr(e.pipe),
  vS = e => {
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || Gr(e.append) && ((t = hu(e)) === "formdata" || t === "object" && Gr(e.toString) && e.toString() === "[object FormData]"))
  },
  bS = vn("URLSearchParams"),
  [yS, xS, wS, kS] = ["ReadableStream", "Request", "Response", "Headers"].map(vn),
  _S = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function Pl(e, t, {
  allOwnKeys: a = !1
} = {}) {
  if (e === null || typeof e > "u") return;
  let i, o;
  if (typeof e != "object" && (e = [e]), po(e))
    for (i = 0, o = e.length; i < o; i++) t.call(null, e[i], i, e);
  else {
    const l = a ? Object.getOwnPropertyNames(e) : Object.keys(e),
      h = l.length;
    let p;
    for (i = 0; i < h; i++) p = l[i], t.call(null, e[p], p, e)
  }
}

function E0(e, t) {
  t = t.toLowerCase();
  const a = Object.keys(e);
  let i = a.length,
    o;
  for (; i-- > 0;)
    if (o = a[i], t === o.toLowerCase()) return o;
  return null
}
const is = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global,
  P0 = e => !hl(e) && e !== is;

function fh() {
  const {
    caseless: e
  } = P0(this) && this || {}, t = {}, a = (i, o) => {
    const l = e && E0(t, o) || o;
    mc(t[l]) && mc(i) ? t[l] = fh(t[l], i) : mc(i) ? t[l] = fh({}, i) : po(i) ? t[l] = i.slice() : t[l] = i
  };
  for (let i = 0, o = arguments.length; i < o; i++) arguments[i] && Pl(arguments[i], a);
  return t
}
const SS = (e, t, a, {
    allOwnKeys: i
  } = {}) => (Pl(t, (o, l) => {
    a && Gr(o) ? e[l] = A0(o, a) : e[l] = o
  }, {
    allOwnKeys: i
  }), e),
  AS = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e),
  CS = (e, t, a, i) => {
    e.prototype = Object.create(t.prototype, i), e.prototype.constructor = e, Object.defineProperty(e, "super", {
      value: t.prototype
    }), a && Object.assign(e.prototype, a)
  },
  TS = (e, t, a, i) => {
    let o, l, h;
    const p = {};
    if (t = t || {}, e == null) return t;
    do {
      for (o = Object.getOwnPropertyNames(e), l = o.length; l-- > 0;) h = o[l], (!i || i(h, e, t)) && !p[h] && (t[h] = e[h], p[h] = !0);
      e = a !== !1 && Tf(e)
    } while (e && (!a || a(e, t)) && e !== Object.prototype);
    return t
  },
  ES = (e, t, a) => {
    e = String(e), (a === void 0 || a > e.length) && (a = e.length), a -= t.length;
    const i = e.indexOf(t, a);
    return i !== -1 && i === a
  },
  PS = e => {
    if (!e) return null;
    if (po(e)) return e;
    let t = e.length;
    if (!T0(t)) return null;
    const a = new Array(t);
    for (; t-- > 0;) a[t] = e[t];
    return a
  },
  LS = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && Tf(Uint8Array)),
  OS = (e, t) => {
    const i = (e && e[Symbol.iterator]).call(e);
    let o;
    for (;
      (o = i.next()) && !o.done;) {
      const l = o.value;
      t.call(e, l[0], l[1])
    }
  },
  MS = (e, t) => {
    let a;
    const i = [];
    for (;
      (a = e.exec(t)) !== null;) i.push(a);
    return i
  },
  IS = vn("HTMLFormElement"),
  RS = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (a, i, o) {
    return i.toUpperCase() + o
  }),
  vg = (({
    hasOwnProperty: e
  }) => (t, a) => e.call(t, a))(Object.prototype),
  DS = vn("RegExp"),
  L0 = (e, t) => {
    const a = Object.getOwnPropertyDescriptors(e),
      i = {};
    Pl(a, (o, l) => {
      let h;
      (h = t(o, l, e)) !== !1 && (i[l] = h || o)
    }), Object.defineProperties(e, i)
  },
  NS = e => {
    L0(e, (t, a) => {
      if (Gr(e) && ["arguments", "caller", "callee"].indexOf(a) !== -1) return !1;
      const i = e[a];
      if (Gr(i)) {
        if (t.enumerable = !1, "writable" in t) {
          t.writable = !1;
          return
        }
        t.set || (t.set = () => {
          throw Error("Can not rewrite read-only method '" + a + "'")
        })
      }
    })
  },
  FS = (e, t) => {
    const a = {},
      i = o => {
        o.forEach(l => {
          a[l] = !0
        })
      };
    return po(e) ? i(e) : i(String(e).split(t)), a
  },
  $S = () => {},
  BS = (e, t) => e != null && Number.isFinite(e = +e) ? e : t,
  Zu = "abcdefghijklmnopqrstuvwxyz",
  bg = "0123456789",
  O0 = {
    DIGIT: bg,
    ALPHA: Zu,
    ALPHA_DIGIT: Zu + Zu.toUpperCase() + bg
  },
  HS = (e = 16, t = O0.ALPHA_DIGIT) => {
    let a = "";
    const {
      length: i
    } = t;
    for (; e--;) a += t[Math.random() * i | 0];
    return a
  };

function YS(e) {
  return !!(e && Gr(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator])
}
const zS = e => {
    const t = new Array(10),
      a = (i, o) => {
        if (pu(i)) {
          if (t.indexOf(i) >= 0) return;
          if (!("toJSON" in i)) {
            t[o] = i;
            const l = po(i) ? [] : {};
            return Pl(i, (h, p) => {
              const m = a(h, o + 1);
              !hl(m) && (l[p] = m)
            }), t[o] = void 0, l
          }
        }
        return i
      };
    return a(e, 0)
  },
  XS = vn("AsyncFunction"),
  WS = e => e && (pu(e) || Gr(e)) && Gr(e.then) && Gr(e.catch),
  M0 = ((e, t) => e ? setImmediate : t ? ((a, i) => (is.addEventListener("message", ({
    source: o,
    data: l
  }) => {
    o === is && l === a && i.length && i.shift()()
  }, !1), o => {
    i.push(o), is.postMessage(a, "*")
  }))(`axios@${Math.random()}`, []) : a => setTimeout(a))(typeof setImmediate == "function", Gr(is.postMessage)),
  VS = typeof queueMicrotask < "u" ? queueMicrotask.bind(is) : typeof process < "u" && process.nextTick || M0,
  je = {
    isArray: po,
    isArrayBuffer: C0,
    isBuffer: lS,
    isFormData: vS,
    isArrayBufferView: cS,
    isString: uS,
    isNumber: T0,
    isBoolean: dS,
    isObject: pu,
    isPlainObject: mc,
    isReadableStream: yS,
    isRequest: xS,
    isResponse: wS,
    isHeaders: kS,
    isUndefined: hl,
    isDate: hS,
    isFile: fS,
    isBlob: pS,
    isRegExp: DS,
    isFunction: Gr,
    isStream: mS,
    isURLSearchParams: bS,
    isTypedArray: LS,
    isFileList: gS,
    forEach: Pl,
    merge: fh,
    extend: SS,
    trim: _S,
    stripBOM: AS,
    inherits: CS,
    toFlatObject: TS,
    kindOf: hu,
    kindOfTest: vn,
    endsWith: ES,
    toArray: PS,
    forEachEntry: OS,
    matchAll: MS,
    isHTMLForm: IS,
    hasOwnProperty: vg,
    hasOwnProp: vg,
    reduceDescriptors: L0,
    freezeMethods: NS,
    toObjectSet: FS,
    toCamelCase: RS,
    noop: $S,
    toFiniteNumber: BS,
    findKey: E0,
    global: is,
    isContextDefined: P0,
    ALPHABET: O0,
    generateString: HS,
    isSpecCompliantForm: YS,
    toJSONObject: zS,
    isAsyncFn: XS,
    isThenable: WS,
    setImmediate: M0,
    asap: VS
  };

function Nt(e, t, a, i, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), a && (this.config = a), i && (this.request = i), o && (this.response = o)
}
je.inherits(Nt, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: je.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    }
  }
});
const I0 = Nt.prototype,
  R0 = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => {
  R0[e] = {
    value: e
  }
});
Object.defineProperties(Nt, R0);
Object.defineProperty(I0, "isAxiosError", {
  value: !0
});
Nt.from = (e, t, a, i, o, l) => {
  const h = Object.create(I0);
  return je.toFlatObject(e, h, function (m) {
    return m !== Error.prototype
  }, p => p !== "isAxiosError"), Nt.call(h, e.message, t, a, i, o), h.cause = e, h.name = e.name, l && Object.assign(h, l), h
};
const jS = null;

function ph(e) {
  return je.isPlainObject(e) || je.isArray(e)
}

function D0(e) {
  return je.endsWith(e, "[]") ? e.slice(0, -2) : e
}

function yg(e, t, a) {
  return e ? e.concat(t).map(function (o, l) {
    return o = D0(o), !a && l ? "[" + o + "]" : o
  }).join(a ? "." : "") : t
}

function US(e) {
  return je.isArray(e) && !e.some(ph)
}
const GS = je.toFlatObject(je, {}, null, function (t) {
  return /^is[A-Z]/.test(t)
});

function gu(e, t, a) {
  if (!je.isObject(e)) throw new TypeError("target must be an object");
  t = t || new FormData, a = je.toFlatObject(a, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function (D, B) {
    return !je.isUndefined(B[D])
  });
  const i = a.metaTokens,
    o = a.visitor || w,
    l = a.dots,
    h = a.indexes,
    m = (a.Blob || typeof Blob < "u" && Blob) && je.isSpecCompliantForm(t);
  if (!je.isFunction(o)) throw new TypeError("visitor must be a function");

  function k(M) {
    if (M === null) return "";
    if (je.isDate(M)) return M.toISOString();
    if (!m && je.isBlob(M)) throw new Nt("Blob is not supported. Use a Buffer instead.");
    return je.isArrayBuffer(M) || je.isTypedArray(M) ? m && typeof Blob == "function" ? new Blob([M]) : Buffer.from(M) : M
  }

  function w(M, D, B) {
    let z = M;
    if (M && !B && typeof M == "object") {
      if (je.endsWith(D, "{}")) D = i ? D : D.slice(0, -2), M = JSON.stringify(M);
      else if (je.isArray(M) && US(M) || (je.isFileList(M) || je.endsWith(D, "[]")) && (z = je.toArray(M))) return D = D0(D), z.forEach(function (N, U) {
        !(je.isUndefined(N) || N === null) && t.append(h === !0 ? yg([D], U, l) : h === null ? D : D + "[]", k(N))
      }), !1
    }
    return ph(M) ? !0 : (t.append(yg(B, D, l), k(M)), !1)
  }
  const S = [],
    A = Object.assign(GS, {
      defaultVisitor: w,
      convertValue: k,
      isVisitable: ph
    });

  function E(M, D) {
    if (!je.isUndefined(M)) {
      if (S.indexOf(M) !== -1) throw Error("Circular reference detected in " + D.join("."));
      S.push(M), je.forEach(M, function (z, I) {
        (!(je.isUndefined(z) || z === null) && o.call(t, z, je.isString(I) ? I.trim() : I, D, A)) === !0 && E(z, D ? D.concat(I) : [I])
      }), S.pop()
    }
  }
  if (!je.isObject(e)) throw new TypeError("data must be an object");
  return E(e), t
}

function xg(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (i) {
    return t[i]
  })
}

function Ef(e, t) {
  this._pairs = [], e && gu(e, this, t)
}
const N0 = Ef.prototype;
N0.append = function (t, a) {
  this._pairs.push([t, a])
};
N0.toString = function (t) {
  const a = t ? function (i) {
    return t.call(this, i, xg)
  } : xg;
  return this._pairs.map(function (o) {
    return a(o[0]) + "=" + a(o[1])
  }, "").join("&")
};

function qS(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function F0(e, t, a) {
  if (!t) return e;
  const i = a && a.encode || qS,
    o = a && a.serialize;
  let l;
  if (o ? l = o(t, a) : l = je.isURLSearchParams(t) ? t.toString() : new Ef(t, a).toString(i), l) {
    const h = e.indexOf("#");
    h !== -1 && (e = e.slice(0, h)), e += (e.indexOf("?") === -1 ? "?" : "&") + l
  }
  return e
}
class wg {
  constructor() {
    this.handlers = []
  }
  use(t, a, i) {
    return this.handlers.push({
      fulfilled: t,
      rejected: a,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1
  }
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null)
  }
  clear() {
    this.handlers && (this.handlers = [])
  }
  forEach(t) {
    je.forEach(this.handlers, function (i) {
      i !== null && t(i)
    })
  }
}
const $0 = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  },
  KS = typeof URLSearchParams < "u" ? URLSearchParams : Ef,
  ZS = typeof FormData < "u" ? FormData : null,
  QS = typeof Blob < "u" ? Blob : null,
  JS = {
    isBrowser: !0,
    classes: {
      URLSearchParams: KS,
      FormData: ZS,
      Blob: QS
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  },
  Pf = typeof window < "u" && typeof document < "u",
  e2 = (e => Pf && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product),
  t2 = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function",
  a2 = Pf && window.location.href || "http://localhost",
  r2 = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: Pf,
    hasStandardBrowserEnv: e2,
    hasStandardBrowserWebWorkerEnv: t2,
    origin: a2
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  ln = {
    ...r2,
    ...JS
  };

function n2(e, t) {
  return gu(e, new ln.classes.URLSearchParams, Object.assign({
    visitor: function (a, i, o, l) {
      return ln.isNode && je.isBuffer(a) ? (this.append(i, a.toString("base64")), !1) : l.defaultVisitor.apply(this, arguments)
    }
  }, t))
}

function i2(e) {
  return je.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0])
}

function s2(e) {
  const t = {},
    a = Object.keys(e);
  let i;
  const o = a.length;
  let l;
  for (i = 0; i < o; i++) l = a[i], t[l] = e[l];
  return t
}

function B0(e) {
  function t(a, i, o, l) {
    let h = a[l++];
    if (h === "__proto__") return !0;
    const p = Number.isFinite(+h),
      m = l >= a.length;
    return h = !h && je.isArray(o) ? o.length : h, m ? (je.hasOwnProp(o, h) ? o[h] = [o[h], i] : o[h] = i, !p) : ((!o[h] || !je.isObject(o[h])) && (o[h] = []), t(a, i, o[h], l) && je.isArray(o[h]) && (o[h] = s2(o[h])), !p)
  }
  if (je.isFormData(e) && je.isFunction(e.entries)) {
    const a = {};
    return je.forEachEntry(e, (i, o) => {
      t(i2(i), o, a, 0)
    }), a
  }
  return null
}

function o2(e, t, a) {
  if (je.isString(e)) try {
    return (t || JSON.parse)(e), je.trim(e)
  } catch (i) {
    if (i.name !== "SyntaxError") throw i
  }
  return (a || JSON.stringify)(e)
}
const Ll = {
  transitional: $0,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function (t, a) {
    const i = a.getContentType() || "",
      o = i.indexOf("application/json") > -1,
      l = je.isObject(t);
    if (l && je.isHTMLForm(t) && (t = new FormData(t)), je.isFormData(t)) return o ? JSON.stringify(B0(t)) : t;
    if (je.isArrayBuffer(t) || je.isBuffer(t) || je.isStream(t) || je.isFile(t) || je.isBlob(t) || je.isReadableStream(t)) return t;
    if (je.isArrayBufferView(t)) return t.buffer;
    if (je.isURLSearchParams(t)) return a.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let p;
    if (l) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1) return n2(t, this.formSerializer).toString();
      if ((p = je.isFileList(t)) || i.indexOf("multipart/form-data") > -1) {
        const m = this.env && this.env.FormData;
        return gu(p ? {
          "files[]": t
        } : t, m && new m, this.formSerializer)
      }
    }
    return l || o ? (a.setContentType("application/json", !1), o2(t)) : t
  }],
  transformResponse: [function (t) {
    const a = this.transitional || Ll.transitional,
      i = a && a.forcedJSONParsing,
      o = this.responseType === "json";
    if (je.isResponse(t) || je.isReadableStream(t)) return t;
    if (t && je.isString(t) && (i && !this.responseType || o)) {
      const h = !(a && a.silentJSONParsing) && o;
      try {
        return JSON.parse(t)
      } catch (p) {
        if (h) throw p.name === "SyntaxError" ? Nt.from(p, Nt.ERR_BAD_RESPONSE, this, null, this.response) : p
      }
    }
    return t
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: ln.classes.FormData,
    Blob: ln.classes.Blob
  },
  validateStatus: function (t) {
    return t >= 200 && t < 300
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
je.forEach(["delete", "get", "head", "post", "put", "patch"], e => {
  Ll.headers[e] = {}
});
const l2 = je.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
  c2 = e => {
    const t = {};
    let a, i, o;
    return e && e.split(`
`).forEach(function (h) {
      o = h.indexOf(":"), a = h.substring(0, o).trim().toLowerCase(), i = h.substring(o + 1).trim(), !(!a || t[a] && l2[a]) && (a === "set-cookie" ? t[a] ? t[a].push(i) : t[a] = [i] : t[a] = t[a] ? t[a] + ", " + i : i)
    }), t
  },
  kg = Symbol("internals");

function Oo(e) {
  return e && String(e).trim().toLowerCase()
}

function vc(e) {
  return e === !1 || e == null ? e : je.isArray(e) ? e.map(vc) : String(e)
}

function u2(e) {
  const t = Object.create(null),
    a = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = a.exec(e);) t[i[1]] = i[2];
  return t
}
const d2 = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());

function Qu(e, t, a, i, o) {
  if (je.isFunction(i)) return i.call(this, t, a);
  if (o && (t = a), !!je.isString(t)) {
    if (je.isString(i)) return t.indexOf(i) !== -1;
    if (je.isRegExp(i)) return i.test(t)
  }
}

function h2(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, a, i) => a.toUpperCase() + i)
}

function f2(e, t) {
  const a = je.toCamelCase(" " + t);
  ["get", "set", "has"].forEach(i => {
    Object.defineProperty(e, i + a, {
      value: function (o, l, h) {
        return this[i].call(this, t, o, l, h)
      },
      configurable: !0
    })
  })
}
class Fr {
  constructor(t) {
    t && this.set(t)
  }
  set(t, a, i) {
    const o = this;

    function l(p, m, k) {
      const w = Oo(m);
      if (!w) throw new Error("header name must be a non-empty string");
      const S = je.findKey(o, w);
      (!S || o[S] === void 0 || k === !0 || k === void 0 && o[S] !== !1) && (o[S || m] = vc(p))
    }
    const h = (p, m) => je.forEach(p, (k, w) => l(k, w, m));
    if (je.isPlainObject(t) || t instanceof this.constructor) h(t, a);
    else if (je.isString(t) && (t = t.trim()) && !d2(t)) h(c2(t), a);
    else if (je.isHeaders(t))
      for (const [p, m] of t.entries()) l(m, p, i);
    else t != null && l(a, t, i);
    return this
  }
  get(t, a) {
    if (t = Oo(t), t) {
      const i = je.findKey(this, t);
      if (i) {
        const o = this[i];
        if (!a) return o;
        if (a === !0) return u2(o);
        if (je.isFunction(a)) return a.call(this, o, i);
        if (je.isRegExp(a)) return a.exec(o);
        throw new TypeError("parser must be boolean|regexp|function")
      }
    }
  }
  has(t, a) {
    if (t = Oo(t), t) {
      const i = je.findKey(this, t);
      return !!(i && this[i] !== void 0 && (!a || Qu(this, this[i], i, a)))
    }
    return !1
  }
  delete(t, a) {
    const i = this;
    let o = !1;

    function l(h) {
      if (h = Oo(h), h) {
        const p = je.findKey(i, h);
        p && (!a || Qu(i, i[p], p, a)) && (delete i[p], o = !0)
      }
    }
    return je.isArray(t) ? t.forEach(l) : l(t), o
  }
  clear(t) {
    const a = Object.keys(this);
    let i = a.length,
      o = !1;
    for (; i--;) {
      const l = a[i];
      (!t || Qu(this, this[l], l, t, !0)) && (delete this[l], o = !0)
    }
    return o
  }
  normalize(t) {
    const a = this,
      i = {};
    return je.forEach(this, (o, l) => {
      const h = je.findKey(i, l);
      if (h) {
        a[h] = vc(o), delete a[l];
        return
      }
      const p = t ? h2(l) : String(l).trim();
      p !== l && delete a[l], a[p] = vc(o), i[p] = !0
    }), this
  }
  concat(...t) {
    return this.constructor.concat(this, ...t)
  }
  toJSON(t) {
    const a = Object.create(null);
    return je.forEach(this, (i, o) => {
      i != null && i !== !1 && (a[o] = t && je.isArray(i) ? i.join(", ") : i)
    }), a
  } [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]()
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, a]) => t + ": " + a).join(`
`)
  }
  get[Symbol.toStringTag]() {
    return "AxiosHeaders"
  }
  static from(t) {
    return t instanceof this ? t : new this(t)
  }
  static concat(t, ...a) {
    const i = new this(t);
    return a.forEach(o => i.set(o)), i
  }
  static accessor(t) {
    const i = (this[kg] = this[kg] = {
        accessors: {}
      }).accessors,
      o = this.prototype;

    function l(h) {
      const p = Oo(h);
      i[p] || (f2(o, h), i[p] = !0)
    }
    return je.isArray(t) ? t.forEach(l) : l(t), this
  }
}
Fr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
je.reduceDescriptors(Fr.prototype, ({
  value: e
}, t) => {
  let a = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(i) {
      this[a] = i
    }
  }
});
je.freezeMethods(Fr);

function Ju(e, t) {
  const a = this || Ll,
    i = t || a,
    o = Fr.from(i.headers);
  let l = i.data;
  return je.forEach(e, function (p) {
    l = p.call(a, l, o.normalize(), t ? t.status : void 0)
  }), o.normalize(), l
}

function H0(e) {
  return !!(e && e.__CANCEL__)
}

function go(e, t, a) {
  Nt.call(this, e ?? "canceled", Nt.ERR_CANCELED, t, a), this.name = "CanceledError"
}
je.inherits(go, Nt, {
  __CANCEL__: !0
});

function Y0(e, t, a) {
  const i = a.config.validateStatus;
  !a.status || !i || i(a.status) ? e(a) : t(new Nt("Request failed with status code " + a.status, [Nt.ERR_BAD_REQUEST, Nt.ERR_BAD_RESPONSE][Math.floor(a.status / 100) - 4], a.config, a.request, a))
}

function p2(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || ""
}

function g2(e, t) {
  e = e || 10;
  const a = new Array(e),
    i = new Array(e);
  let o = 0,
    l = 0,
    h;
  return t = t !== void 0 ? t : 1e3,
    function (m) {
      const k = Date.now(),
        w = i[l];
      h || (h = k), a[o] = m, i[o] = k;
      let S = l,
        A = 0;
      for (; S !== o;) A += a[S++], S = S % e;
      if (o = (o + 1) % e, o === l && (l = (l + 1) % e), k - h < t) return;
      const E = w && k - w;
      return E ? Math.round(A * 1e3 / E) : void 0
    }
}

function m2(e, t) {
  let a = 0,
    i = 1e3 / t,
    o, l;
  const h = (k, w = Date.now()) => {
    a = w, o = null, l && (clearTimeout(l), l = null), e.apply(null, k)
  };
  return [(...k) => {
    const w = Date.now(),
      S = w - a;
    S >= i ? h(k, w) : (o = k, l || (l = setTimeout(() => {
      l = null, h(o)
    }, i - S)))
  }, () => o && h(o)]
}
const Mc = (e, t, a = 3) => {
    let i = 0;
    const o = g2(50, 250);
    return m2(l => {
      const h = l.loaded,
        p = l.lengthComputable ? l.total : void 0,
        m = h - i,
        k = o(m),
        w = h <= p;
      i = h;
      const S = {
        loaded: h,
        total: p,
        progress: p ? h / p : void 0,
        bytes: m,
        rate: k || void 0,
        estimated: k && p && w ? (p - h) / k : void 0,
        event: l,
        lengthComputable: p != null,
        [t ? "download" : "upload"]: !0
      };
      e(S)
    }, a)
  },
  _g = (e, t) => {
    const a = e != null;
    return [i => t[0]({
      lengthComputable: a,
      total: e,
      loaded: i
    }), t[1]]
  },
  Sg = e => (...t) => je.asap(() => e(...t)),
  v2 = ln.hasStandardBrowserEnv ? function () {
    const t = /(msie|trident)/i.test(navigator.userAgent),
      a = document.createElement("a");
    let i;

    function o(l) {
      let h = l;
      return t && (a.setAttribute("href", h), h = a.href), a.setAttribute("href", h), {
        href: a.href,
        protocol: a.protocol ? a.protocol.replace(/:$/, "") : "",
        host: a.host,
        search: a.search ? a.search.replace(/^\?/, "") : "",
        hash: a.hash ? a.hash.replace(/^#/, "") : "",
        hostname: a.hostname,
        port: a.port,
        pathname: a.pathname.charAt(0) === "/" ? a.pathname : "/" + a.pathname
      }
    }
    return i = o(window.location.href),
      function (h) {
        const p = je.isString(h) ? o(h) : h;
        return p.protocol === i.protocol && p.host === i.host
      }
  }() : function () {
    return function () {
      return !0
    }
  }(),
  b2 = ln.hasStandardBrowserEnv ? {
    write(e, t, a, i, o, l) {
      const h = [e + "=" + encodeURIComponent(t)];
      je.isNumber(a) && h.push("expires=" + new Date(a).toGMTString()), je.isString(i) && h.push("path=" + i), je.isString(o) && h.push("domain=" + o), l === !0 && h.push("secure"), document.cookie = h.join("; ")
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5)
    }
  } : {
    write() {},
    read() {
      return null
    },
    remove() {}
  };

function y2(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)
}

function x2(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e
}

function z0(e, t) {
  return e && !y2(t) ? x2(e, t) : t
}
const Ag = e => e instanceof Fr ? {
  ...e
} : e;

function ms(e, t) {
  t = t || {};
  const a = {};

  function i(k, w, S) {
    return je.isPlainObject(k) && je.isPlainObject(w) ? je.merge.call({
      caseless: S
    }, k, w) : je.isPlainObject(w) ? je.merge({}, w) : je.isArray(w) ? w.slice() : w
  }

  function o(k, w, S) {
    if (je.isUndefined(w)) {
      if (!je.isUndefined(k)) return i(void 0, k, S)
    } else return i(k, w, S)
  }

  function l(k, w) {
    if (!je.isUndefined(w)) return i(void 0, w)
  }

  function h(k, w) {
    if (je.isUndefined(w)) {
      if (!je.isUndefined(k)) return i(void 0, k)
    } else return i(void 0, w)
  }

  function p(k, w, S) {
    if (S in t) return i(k, w);
    if (S in e) return i(void 0, k)
  }
  const m = {
    url: l,
    method: l,
    data: l,
    baseURL: h,
    transformRequest: h,
    transformResponse: h,
    paramsSerializer: h,
    timeout: h,
    timeoutMessage: h,
    withCredentials: h,
    withXSRFToken: h,
    adapter: h,
    responseType: h,
    xsrfCookieName: h,
    xsrfHeaderName: h,
    onUploadProgress: h,
    onDownloadProgress: h,
    decompress: h,
    maxContentLength: h,
    maxBodyLength: h,
    beforeRedirect: h,
    transport: h,
    httpAgent: h,
    httpsAgent: h,
    cancelToken: h,
    socketPath: h,
    responseEncoding: h,
    validateStatus: p,
    headers: (k, w) => o(Ag(k), Ag(w), !0)
  };
  return je.forEach(Object.keys(Object.assign({}, e, t)), function (w) {
    const S = m[w] || o,
      A = S(e[w], t[w], w);
    je.isUndefined(A) && S !== p || (a[w] = A)
  }), a
}
const X0 = e => {
    const t = ms({}, e);
    let {
      data: a,
      withXSRFToken: i,
      xsrfHeaderName: o,
      xsrfCookieName: l,
      headers: h,
      auth: p
    } = t;
    t.headers = h = Fr.from(h), t.url = F0(z0(t.baseURL, t.url), e.params, e.paramsSerializer), p && h.set("Authorization", "Basic " + btoa((p.username || "") + ":" + (p.password ? unescape(encodeURIComponent(p.password)) : "")));
    let m;
    if (je.isFormData(a)) {
      if (ln.hasStandardBrowserEnv || ln.hasStandardBrowserWebWorkerEnv) h.setContentType(void 0);
      else if ((m = h.getContentType()) !== !1) {
        const [k, ...w] = m ? m.split(";").map(S => S.trim()).filter(Boolean) : [];
        h.setContentType([k || "multipart/form-data", ...w].join("; "))
      }
    }
    if (ln.hasStandardBrowserEnv && (i && je.isFunction(i) && (i = i(t)), i || i !== !1 && v2(t.url))) {
      const k = o && l && b2.read(l);
      k && h.set(o, k)
    }
    return t
  },
  w2 = typeof XMLHttpRequest < "u",
  k2 = w2 && function (e) {
    return new Promise(function (a, i) {
      const o = X0(e);
      let l = o.data;
      const h = Fr.from(o.headers).normalize();
      let {
        responseType: p,
        onUploadProgress: m,
        onDownloadProgress: k
      } = o, w, S, A, E, M;

      function D() {
        E && E(), M && M(), o.cancelToken && o.cancelToken.unsubscribe(w), o.signal && o.signal.removeEventListener("abort", w)
      }
      let B = new XMLHttpRequest;
      B.open(o.method.toUpperCase(), o.url, !0), B.timeout = o.timeout;

      function z() {
        if (!B) return;
        const N = Fr.from("getAllResponseHeaders" in B && B.getAllResponseHeaders()),
          W = {
            data: !p || p === "text" || p === "json" ? B.responseText : B.response,
            status: B.status,
            statusText: B.statusText,
            headers: N,
            config: e,
            request: B
          };
        Y0(function (V) {
          a(V), D()
        }, function (V) {
          i(V), D()
        }, W), B = null
      }
      "onloadend" in B ? B.onloadend = z : B.onreadystatechange = function () {
        !B || B.readyState !== 4 || B.status === 0 && !(B.responseURL && B.responseURL.indexOf("file:") === 0) || setTimeout(z)
      }, B.onabort = function () {
        B && (i(new Nt("Request aborted", Nt.ECONNABORTED, e, B)), B = null)
      }, B.onerror = function () {
        i(new Nt("Network Error", Nt.ERR_NETWORK, e, B)), B = null
      }, B.ontimeout = function () {
        let U = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
        const W = o.transitional || $0;
        o.timeoutErrorMessage && (U = o.timeoutErrorMessage), i(new Nt(U, W.clarifyTimeoutError ? Nt.ETIMEDOUT : Nt.ECONNABORTED, e, B)), B = null
      }, l === void 0 && h.setContentType(null), "setRequestHeader" in B && je.forEach(h.toJSON(), function (U, W) {
        B.setRequestHeader(W, U)
      }), je.isUndefined(o.withCredentials) || (B.withCredentials = !!o.withCredentials), p && p !== "json" && (B.responseType = o.responseType), k && ([A, M] = Mc(k, !0), B.addEventListener("progress", A)), m && B.upload && ([S, E] = Mc(m), B.upload.addEventListener("progress", S), B.upload.addEventListener("loadend", E)), (o.cancelToken || o.signal) && (w = N => {
        B && (i(!N || N.type ? new go(null, e, B) : N), B.abort(), B = null)
      }, o.cancelToken && o.cancelToken.subscribe(w), o.signal && (o.signal.aborted ? w() : o.signal.addEventListener("abort", w)));
      const I = p2(o.url);
      if (I && ln.protocols.indexOf(I) === -1) {
        i(new Nt("Unsupported protocol " + I + ":", Nt.ERR_BAD_REQUEST, e));
        return
      }
      B.send(l || null)
    })
  },
  _2 = (e, t) => {
    let a = new AbortController,
      i;
    const o = function (m) {
      if (!i) {
        i = !0, h();
        const k = m instanceof Error ? m : this.reason;
        a.abort(k instanceof Nt ? k : new go(k instanceof Error ? k.message : k))
      }
    };
    let l = t && setTimeout(() => {
      o(new Nt(`timeout ${t} of ms exceeded`, Nt.ETIMEDOUT))
    }, t);
    const h = () => {
      e && (l && clearTimeout(l), l = null, e.forEach(m => {
        m && (m.removeEventListener ? m.removeEventListener("abort", o) : m.unsubscribe(o))
      }), e = null)
    };
    e.forEach(m => m && m.addEventListener && m.addEventListener("abort", o));
    const {
      signal: p
    } = a;
    return p.unsubscribe = h, [p, () => {
      l && clearTimeout(l), l = null
    }]
  },
  S2 = function* (e, t) {
    let a = e.byteLength;
    if (!t || a < t) {
      yield e;
      return
    }
    let i = 0,
      o;
    for (; i < a;) o = i + t, yield e.slice(i, o), i = o
  },
  A2 = async function* (e, t, a) {
    for await (const i of e) yield* S2(ArrayBuffer.isView(i) ? i : await a(String(i)), t)
  }, Cg = (e, t, a, i, o) => {
    const l = A2(e, t, o);
    let h = 0,
      p, m = k => {
        p || (p = !0, i && i(k))
      };
    return new ReadableStream({
      async pull(k) {
        try {
          const {
            done: w,
            value: S
          } = await l.next();
          if (w) {
            m(), k.close();
            return
          }
          let A = S.byteLength;
          if (a) {
            let E = h += A;
            a(E)
          }
          k.enqueue(new Uint8Array(S))
        } catch (w) {
          throw m(w), w
        }
      },
      cancel(k) {
        return m(k), l.return()
      }
    }, {
      highWaterMark: 2
    })
  }, mu = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", W0 = mu && typeof ReadableStream == "function", gh = mu && (typeof TextEncoder == "function" ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer())), V0 = (e, ...t) => {
    try {
      return !!e(...t)
    } catch {
      return !1
    }
  }, C2 = W0 && V0(() => {
    let e = !1;
    const t = new Request(ln.origin, {
      body: new ReadableStream,
      method: "POST",
      get duplex() {
        return e = !0, "half"
      }
    }).headers.has("Content-Type");
    return e && !t
  }), Tg = 64 * 1024, mh = W0 && V0(() => je.isReadableStream(new Response("").body)), Ic = {
    stream: mh && (e => e.body)
  };
mu && (e => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(t => {
    !Ic[t] && (Ic[t] = je.isFunction(e[t]) ? a => a[t]() : (a, i) => {
      throw new Nt(`Response type '${t}' is not supported`, Nt.ERR_NOT_SUPPORT, i)
    })
  })
})(new Response);
const T2 = async e => {
  if (e == null) return 0;
  if (je.isBlob(e)) return e.size;
  if (je.isSpecCompliantForm(e)) return (await new Request(e).arrayBuffer()).byteLength;
  if (je.isArrayBufferView(e) || je.isArrayBuffer(e)) return e.byteLength;
  if (je.isURLSearchParams(e) && (e = e + ""), je.isString(e)) return (await gh(e)).byteLength
}, E2 = async (e, t) => {
  const a = je.toFiniteNumber(e.getContentLength());
  return a ?? T2(t)
}, P2 = mu && (async e => {
  let {
    url: t,
    method: a,
    data: i,
    signal: o,
    cancelToken: l,
    timeout: h,
    onDownloadProgress: p,
    onUploadProgress: m,
    responseType: k,
    headers: w,
    withCredentials: S = "same-origin",
    fetchOptions: A
  } = X0(e);
  k = k ? (k + "").toLowerCase() : "text";
  let [E, M] = o || l || h ? _2([o, l], h) : [], D, B;
  const z = () => {
    !D && setTimeout(() => {
      E && E.unsubscribe()
    }), D = !0
  };
  let I;
  try {
    if (m && C2 && a !== "get" && a !== "head" && (I = await E2(w, i)) !== 0) {
      let X = new Request(t, {
          method: "POST",
          body: i,
          duplex: "half"
        }),
        V;
      if (je.isFormData(i) && (V = X.headers.get("content-type")) && w.setContentType(V), X.body) {
        const [ne, Z] = _g(I, Mc(Sg(m)));
        i = Cg(X.body, Tg, ne, Z, gh)
      }
    }
    je.isString(S) || (S = S ? "include" : "omit"), B = new Request(t, {
      ...A,
      signal: E,
      method: a.toUpperCase(),
      headers: w.normalize().toJSON(),
      body: i,
      duplex: "half",
      credentials: S
    });
    let N = await fetch(B);
    const U = mh && (k === "stream" || k === "response");
    if (mh && (p || U)) {
      const X = {};
      ["status", "statusText", "headers"].forEach(ie => {
        X[ie] = N[ie]
      });
      const V = je.toFiniteNumber(N.headers.get("content-length")),
        [ne, Z] = p && _g(V, Mc(Sg(p), !0)) || [];
      N = new Response(Cg(N.body, Tg, ne, () => {
        Z && Z(), U && z()
      }, gh), X)
    }
    k = k || "text";
    let W = await Ic[je.findKey(Ic, k) || "text"](N, e);
    return !U && z(), M && M(), await new Promise((X, V) => {
      Y0(X, V, {
        data: W,
        headers: Fr.from(N.headers),
        status: N.status,
        statusText: N.statusText,
        config: e,
        request: B
      })
    })
  } catch (N) {
    throw z(), N && N.name === "TypeError" && /fetch/i.test(N.message) ? Object.assign(new Nt("Network Error", Nt.ERR_NETWORK, e, B), {
      cause: N.cause || N
    }) : Nt.from(N, N && N.code, e, B)
  }
}), vh = {
  http: jS,
  xhr: k2,
  fetch: P2
};
je.forEach(vh, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", {
        value: t
      })
    } catch {}
    Object.defineProperty(e, "adapterName", {
      value: t
    })
  }
});
const Eg = e => `- ${e}`,
  L2 = e => je.isFunction(e) || e === null || e === !1,
  j0 = {
    getAdapter: e => {
      e = je.isArray(e) ? e : [e];
      const {
        length: t
      } = e;
      let a, i;
      const o = {};
      for (let l = 0; l < t; l++) {
        a = e[l];
        let h;
        if (i = a, !L2(a) && (i = vh[(h = String(a)).toLowerCase()], i === void 0)) throw new Nt(`Unknown adapter '${h}'`);
        if (i) break;
        o[h || "#" + l] = i
      }
      if (!i) {
        const l = Object.entries(o).map(([p, m]) => `adapter ${p} ` + (m === !1 ? "is not supported by the environment" : "is not available in the build"));
        let h = t ? l.length > 1 ? `since :
` + l.map(Eg).join(`
`) : " " + Eg(l[0]) : "as no adapter specified";
        throw new Nt("There is no suitable adapter to dispatch the request " + h, "ERR_NOT_SUPPORT")
      }
      return i
    },
    adapters: vh
  };

function ed(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new go(null, e)
}

function Pg(e) {
  return ed(e), e.headers = Fr.from(e.headers), e.data = Ju.call(e, e.transformRequest), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), j0.getAdapter(e.adapter || Ll.adapter)(e).then(function (i) {
    return ed(e), i.data = Ju.call(e, e.transformResponse, i), i.headers = Fr.from(i.headers), i
  }, function (i) {
    return H0(i) || (ed(e), i && i.response && (i.response.data = Ju.call(e, e.transformResponse, i.response), i.response.headers = Fr.from(i.response.headers))), Promise.reject(i)
  })
}
const U0 = "1.7.3",
  Lf = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Lf[e] = function (i) {
    return typeof i === e || "a" + (t < 1 ? "n " : " ") + e
  }
});
const Lg = {};
Lf.transitional = function (t, a, i) {
  function o(l, h) {
    return "[Axios v" + U0 + "] Transitional option '" + l + "'" + h + (i ? ". " + i : "")
  }
  return (l, h, p) => {
    if (t === !1) throw new Nt(o(h, " has been removed" + (a ? " in " + a : "")), Nt.ERR_DEPRECATED);
    return a && !Lg[h] && (Lg[h] = !0, console.warn(o(h, " has been deprecated since v" + a + " and will be removed in the near future"))), t ? t(l, h, p) : !0
  }
};

function O2(e, t, a) {
  if (typeof e != "object") throw new Nt("options must be an object", Nt.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(e);
  let o = i.length;
  for (; o-- > 0;) {
    const l = i[o],
      h = t[l];
    if (h) {
      const p = e[l],
        m = p === void 0 || h(p, l, e);
      if (m !== !0) throw new Nt("option " + l + " must be " + m, Nt.ERR_BAD_OPTION_VALUE);
      continue
    }
    if (a !== !0) throw new Nt("Unknown option " + l, Nt.ERR_BAD_OPTION)
  }
}
const bh = {
    assertOptions: O2,
    validators: Lf
  },
  oi = bh.validators;
class us {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new wg,
      response: new wg
    }
  }
  async request(t, a) {
    try {
      return await this._request(t, a)
    } catch (i) {
      if (i instanceof Error) {
        let o;
        Error.captureStackTrace ? Error.captureStackTrace(o = {}) : o = new Error;
        const l = o.stack ? o.stack.replace(/^.+\n/, "") : "";
        try {
          i.stack ? l && !String(i.stack).endsWith(l.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + l) : i.stack = l
        } catch {}
      }
      throw i
    }
  }
  _request(t, a) {
    typeof t == "string" ? (a = a || {}, a.url = t) : a = t || {}, a = ms(this.defaults, a);
    const {
      transitional: i,
      paramsSerializer: o,
      headers: l
    } = a;
    i !== void 0 && bh.assertOptions(i, {
      silentJSONParsing: oi.transitional(oi.boolean),
      forcedJSONParsing: oi.transitional(oi.boolean),
      clarifyTimeoutError: oi.transitional(oi.boolean)
    }, !1), o != null && (je.isFunction(o) ? a.paramsSerializer = {
      serialize: o
    } : bh.assertOptions(o, {
      encode: oi.function,
      serialize: oi.function
    }, !0)), a.method = (a.method || this.defaults.method || "get").toLowerCase();
    let h = l && je.merge(l.common, l[a.method]);
    l && je.forEach(["delete", "get", "head", "post", "put", "patch", "common"], M => {
      delete l[M]
    }), a.headers = Fr.concat(h, l);
    const p = [];
    let m = !0;
    this.interceptors.request.forEach(function (D) {
      typeof D.runWhen == "function" && D.runWhen(a) === !1 || (m = m && D.synchronous, p.unshift(D.fulfilled, D.rejected))
    });
    const k = [];
    this.interceptors.response.forEach(function (D) {
      k.push(D.fulfilled, D.rejected)
    });
    let w, S = 0,
      A;
    if (!m) {
      const M = [Pg.bind(this), void 0];
      for (M.unshift.apply(M, p), M.push.apply(M, k), A = M.length, w = Promise.resolve(a); S < A;) w = w.then(M[S++], M[S++]);
      return w
    }
    A = p.length;
    let E = a;
    for (S = 0; S < A;) {
      const M = p[S++],
        D = p[S++];
      try {
        E = M(E)
      } catch (B) {
        D.call(this, B);
        break
      }
    }
    try {
      w = Pg.call(this, E)
    } catch (M) {
      return Promise.reject(M)
    }
    for (S = 0, A = k.length; S < A;) w = w.then(k[S++], k[S++]);
    return w
  }
  getUri(t) {
    t = ms(this.defaults, t);
    const a = z0(t.baseURL, t.url);
    return F0(a, t.params, t.paramsSerializer)
  }
}
je.forEach(["delete", "get", "head", "options"], function (t) {
  us.prototype[t] = function (a, i) {
    return this.request(ms(i || {}, {
      method: t,
      url: a,
      data: (i || {}).data
    }))
  }
});
je.forEach(["post", "put", "patch"], function (t) {
  function a(i) {
    return function (l, h, p) {
      return this.request(ms(p || {}, {
        method: t,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: l,
        data: h
      }))
    }
  }
  us.prototype[t] = a(), us.prototype[t + "Form"] = a(!0)
});
class Of {
  constructor(t) {
    if (typeof t != "function") throw new TypeError("executor must be a function.");
    let a;
    this.promise = new Promise(function (l) {
      a = l
    });
    const i = this;
    this.promise.then(o => {
      if (!i._listeners) return;
      let l = i._listeners.length;
      for (; l-- > 0;) i._listeners[l](o);
      i._listeners = null
    }), this.promise.then = o => {
      let l;
      const h = new Promise(p => {
        i.subscribe(p), l = p
      }).then(o);
      return h.cancel = function () {
        i.unsubscribe(l)
      }, h
    }, t(function (l, h, p) {
      i.reason || (i.reason = new go(l, h, p), a(i.reason))
    })
  }
  throwIfRequested() {
    if (this.reason) throw this.reason
  }
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t]
  }
  unsubscribe(t) {
    if (!this._listeners) return;
    const a = this._listeners.indexOf(t);
    a !== -1 && this._listeners.splice(a, 1)
  }
  static source() {
    let t;
    return {
      token: new Of(function (o) {
        t = o
      }),
      cancel: t
    }
  }
}

function M2(e) {
  return function (a) {
    return e.apply(null, a)
  }
}

function I2(e) {
  return je.isObject(e) && e.isAxiosError === !0
}
const yh = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(yh).forEach(([e, t]) => {
  yh[t] = e
});

function G0(e) {
  const t = new us(e),
    a = A0(us.prototype.request, t);
  return je.extend(a, us.prototype, t, {
    allOwnKeys: !0
  }), je.extend(a, t, null, {
    allOwnKeys: !0
  }), a.create = function (o) {
    return G0(ms(e, o))
  }, a
}
const Qt = G0(Ll);
Qt.Axios = us;
Qt.CanceledError = go;
Qt.CancelToken = Of;
Qt.isCancel = H0;
Qt.VERSION = U0;
Qt.toFormData = gu;
Qt.AxiosError = Nt;
Qt.Cancel = Qt.CanceledError;
Qt.all = function (t) {
  return Promise.all(t)
};
Qt.spread = M2;
Qt.isAxiosError = I2;
Qt.mergeConfig = ms;
Qt.AxiosHeaders = Fr;
Qt.formToJSON = e => B0(je.isHTMLForm(e) ? new FormData(e) : e);
Qt.getAdapter = j0.getAdapter;
Qt.HttpStatusCode = yh;
Qt.default = Qt;
const R2 = {
    name: "App"
  },
  D2 = Object.assign(R2, {
    setup(e) {
      const t = X_();
      return Dt(async () => {
        if (!t.getters.getUser) try {
          const a = await Qt.get("/api/current-user");
          t.dispatch("setUser", a.data)
        } catch (a) {
          console.error("Failed to fetch user data:", a)
        }
      }), (a, i) => {
        const o = Mn("router-view");
        return be(), yt(o)
      }
    }
  });
/*!
 * vue-router v4.4.3
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
const Ds = typeof document < "u";

function N2(e) {
  return e.__esModule || e[Symbol.toStringTag] === "Module"
}
const na = Object.assign;

function td(e, t) {
  const a = {};
  for (const i in t) {
    const o = t[i];
    a[i] = fn(o) ? o.map(e) : e(o)
  }
  return a
}
const Qo = () => {},
  fn = Array.isArray,
  q0 = /#/g,
  F2 = /&/g,
  $2 = /\//g,
  B2 = /=/g,
  H2 = /\?/g,
  K0 = /\+/g,
  Y2 = /%5B/g,
  z2 = /%5D/g,
  Z0 = /%5E/g,
  X2 = /%60/g,
  Q0 = /%7B/g,
  W2 = /%7C/g,
  J0 = /%7D/g,
  V2 = /%20/g;

function Mf(e) {
  return encodeURI("" + e).replace(W2, "|").replace(Y2, "[").replace(z2, "]")
}

function j2(e) {
  return Mf(e).replace(Q0, "{").replace(J0, "}").replace(Z0, "^")
}

function xh(e) {
  return Mf(e).replace(K0, "%2B").replace(V2, "+").replace(q0, "%23").replace(F2, "%26").replace(X2, "`").replace(Q0, "{").replace(J0, "}").replace(Z0, "^")
}

function U2(e) {
  return xh(e).replace(B2, "%3D")
}

function G2(e) {
  return Mf(e).replace(q0, "%23").replace(H2, "%3F")
}

function q2(e) {
  return e == null ? "" : G2(e).replace($2, "%2F")
}

function fl(e) {
  try {
    return decodeURIComponent("" + e)
  } catch {}
  return "" + e
}
const K2 = /\/$/,
  Z2 = e => e.replace(K2, "");

function ad(e, t, a = "/") {
  let i, o = {},
    l = "",
    h = "";
  const p = t.indexOf("#");
  let m = t.indexOf("?");
  return p < m && p >= 0 && (m = -1), m > -1 && (i = t.slice(0, m), l = t.slice(m + 1, p > -1 ? p : t.length), o = e(l)), p > -1 && (i = i || t.slice(0, p), h = t.slice(p, t.length)), i = tA(i ?? t, a), {
    fullPath: i + (l && "?") + l + h,
    path: i,
    query: o,
    hash: fl(h)
  }
}

function Q2(e, t) {
  const a = t.query ? e(t.query) : "";
  return t.path + (a && "?") + a + (t.hash || "")
}

function Og(e, t) {
  return !t || !e.toLowerCase().startsWith(t.toLowerCase()) ? e : e.slice(t.length) || "/"
}

function J2(e, t, a) {
  const i = t.matched.length - 1,
    o = a.matched.length - 1;
  return i > -1 && i === o && Ks(t.matched[i], a.matched[o]) && ey(t.params, a.params) && e(t.query) === e(a.query) && t.hash === a.hash
}

function Ks(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t)
}

function ey(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1;
  for (const a in e)
    if (!eA(e[a], t[a])) return !1;
  return !0
}

function eA(e, t) {
  return fn(e) ? Mg(e, t) : fn(t) ? Mg(t, e) : e === t
}

function Mg(e, t) {
  return fn(t) ? e.length === t.length && e.every((a, i) => a === t[i]) : e.length === 1 && e[0] === t
}

function tA(e, t) {
  if (e.startsWith("/")) return e;
  if (!e) return t;
  const a = t.split("/"),
    i = e.split("/"),
    o = i[i.length - 1];
  (o === ".." || o === ".") && i.push("");
  let l = a.length - 1,
    h, p;
  for (h = 0; h < i.length; h++)
    if (p = i[h], p !== ".")
      if (p === "..") l > 1 && l--;
      else break;
  return a.slice(0, l).join("/") + "/" + i.slice(h).join("/")
}
const li = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
var pl;
(function (e) {
  e.pop = "pop", e.push = "push"
})(pl || (pl = {}));
var Jo;
(function (e) {
  e.back = "back", e.forward = "forward", e.unknown = ""
})(Jo || (Jo = {}));

function aA(e) {
  if (!e)
    if (Ds) {
      const t = document.querySelector("base");
      e = t && t.getAttribute("href") || "/", e = e.replace(/^\w+:\/\/[^\/]+/, "")
    } else e = "/";
  return e[0] !== "/" && e[0] !== "#" && (e = "/" + e), Z2(e)
}
const rA = /^[^#]+#/;

function nA(e, t) {
  return e.replace(rA, "#") + t
}

function iA(e, t) {
  const a = document.documentElement.getBoundingClientRect(),
    i = e.getBoundingClientRect();
  return {
    behavior: t.behavior,
    left: i.left - a.left - (t.left || 0),
    top: i.top - a.top - (t.top || 0)
  }
}
const vu = () => ({
  left: window.scrollX,
  top: window.scrollY
});

function sA(e) {
  let t;
  if ("el" in e) {
    const a = e.el,
      i = typeof a == "string" && a.startsWith("#"),
      o = typeof a == "string" ? i ? document.getElementById(a.slice(1)) : document.querySelector(a) : a;
    if (!o) return;
    t = iA(o, e)
  } else t = e;
  "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}

function Ig(e, t) {
  return (history.state ? history.state.position - t : -1) + e
}
const wh = new Map;

function oA(e, t) {
  wh.set(e, t)
}

function lA(e) {
  const t = wh.get(e);
  return wh.delete(e), t
}
let cA = () => location.protocol + "//" + location.host;

function ty(e, t) {
  const {
    pathname: a,
    search: i,
    hash: o
  } = t, l = e.indexOf("#");
  if (l > -1) {
    let p = o.includes(e.slice(l)) ? e.slice(l).length : 1,
      m = o.slice(p);
    return m[0] !== "/" && (m = "/" + m), Og(m, "")
  }
  return Og(a, e) + i + o
}

function uA(e, t, a, i) {
  let o = [],
    l = [],
    h = null;
  const p = ({
    state: A
  }) => {
    const E = ty(e, location),
      M = a.value,
      D = t.value;
    let B = 0;
    if (A) {
      if (a.value = E, t.value = A, h && h === M) {
        h = null;
        return
      }
      B = D ? A.position - D.position : 0
    } else i(E);
    o.forEach(z => {
      z(a.value, M, {
        delta: B,
        type: pl.pop,
        direction: B ? B > 0 ? Jo.forward : Jo.back : Jo.unknown
      })
    })
  };

  function m() {
    h = a.value
  }

  function k(A) {
    o.push(A);
    const E = () => {
      const M = o.indexOf(A);
      M > -1 && o.splice(M, 1)
    };
    return l.push(E), E
  }

  function w() {
    const {
      history: A
    } = window;
    A.state && A.replaceState(na({}, A.state, {
      scroll: vu()
    }), "")
  }

  function S() {
    for (const A of l) A();
    l = [], window.removeEventListener("popstate", p), window.removeEventListener("beforeunload", w)
  }
  return window.addEventListener("popstate", p), window.addEventListener("beforeunload", w, {
    passive: !0
  }), {
    pauseListeners: m,
    listen: k,
    destroy: S
  }
}

function Rg(e, t, a, i = !1, o = !1) {
  return {
    back: e,
    current: t,
    forward: a,
    replaced: i,
    position: window.history.length,
    scroll: o ? vu() : null
  }
}

function dA(e) {
  const {
    history: t,
    location: a
  } = window, i = {
    value: ty(e, a)
  }, o = {
    value: t.state
  };
  o.value || l(i.value, {
    back: null,
    current: i.value,
    forward: null,
    position: t.length - 1,
    replaced: !0,
    scroll: null
  }, !0);

  function l(m, k, w) {
    const S = e.indexOf("#"),
      A = S > -1 ? (a.host && document.querySelector("base") ? e : e.slice(S)) + m : cA() + e + m;
    try {
      t[w ? "replaceState" : "pushState"](k, "", A), o.value = k
    } catch (E) {
      console.error(E), a[w ? "replace" : "assign"](A)
    }
  }

  function h(m, k) {
    const w = na({}, t.state, Rg(o.value.back, m, o.value.forward, !0), k, {
      position: o.value.position
    });
    l(m, w, !0), i.value = m
  }

  function p(m, k) {
    const w = na({}, o.value, t.state, {
      forward: m,
      scroll: vu()
    });
    l(w.current, w, !0);
    const S = na({}, Rg(i.value, m, null), {
      position: w.position + 1
    }, k);
    l(m, S, !1), i.value = m
  }
  return {
    location: i,
    state: o,
    push: p,
    replace: h
  }
}

function hA(e) {
  e = aA(e);
  const t = dA(e),
    a = uA(e, t.state, t.location, t.replace);

  function i(l, h = !0) {
    h || a.pauseListeners(), history.go(l)
  }
  const o = na({
    location: "",
    base: e,
    go: i,
    createHref: nA.bind(null, e)
  }, t, a);
  return Object.defineProperty(o, "location", {
    enumerable: !0,
    get: () => t.location.value
  }), Object.defineProperty(o, "state", {
    enumerable: !0,
    get: () => t.state.value
  }), o
}

function fA(e) {
  return typeof e == "string" || e && typeof e == "object"
}

function ay(e) {
  return typeof e == "string" || typeof e == "symbol"
}
const ry = Symbol("");
var Dg;
(function (e) {
  e[e.aborted = 4] = "aborted", e[e.cancelled = 8] = "cancelled", e[e.duplicated = 16] = "duplicated"
})(Dg || (Dg = {}));

function Zs(e, t) {
  return na(new Error, {
    type: e,
    [ry]: !0
  }, t)
}

function Fn(e, t) {
  return e instanceof Error && ry in e && (t == null || !!(e.type & t))
}
const Ng = "[^/]+?",
  pA = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
  },
  gA = /[.+*?^${}()[\]/\\]/g;

function mA(e, t) {
  const a = na({}, pA, t),
    i = [];
  let o = a.start ? "^" : "";
  const l = [];
  for (const k of e) {
    const w = k.length ? [] : [90];
    a.strict && !k.length && (o += "/");
    for (let S = 0; S < k.length; S++) {
      const A = k[S];
      let E = 40 + (a.sensitive ? .25 : 0);
      if (A.type === 0) S || (o += "/"), o += A.value.replace(gA, "\\$&"), E += 40;
      else if (A.type === 1) {
        const {
          value: M,
          repeatable: D,
          optional: B,
          regexp: z
        } = A;
        l.push({
          name: M,
          repeatable: D,
          optional: B
        });
        const I = z || Ng;
        if (I !== Ng) {
          E += 10;
          try {
            new RegExp(`(${I})`)
          } catch (U) {
            throw new Error(`Invalid custom RegExp for param "${M}" (${I}): ` + U.message)
          }
        }
        let N = D ? `((?:${I})(?:/(?:${I}))*)` : `(${I})`;
        S || (N = B && k.length < 2 ? `(?:/${N})` : "/" + N), B && (N += "?"), o += N, E += 20, B && (E += -8), D && (E += -20), I === ".*" && (E += -50)
      }
      w.push(E)
    }
    i.push(w)
  }
  if (a.strict && a.end) {
    const k = i.length - 1;
    i[k][i[k].length - 1] += .7000000000000001
  }
  a.strict || (o += "/?"), a.end ? o += "$" : a.strict && (o += "(?:/|$)");
  const h = new RegExp(o, a.sensitive ? "" : "i");

  function p(k) {
    const w = k.match(h),
      S = {};
    if (!w) return null;
    for (let A = 1; A < w.length; A++) {
      const E = w[A] || "",
        M = l[A - 1];
      S[M.name] = E && M.repeatable ? E.split("/") : E
    }
    return S
  }

  function m(k) {
    let w = "",
      S = !1;
    for (const A of e) {
      (!S || !w.endsWith("/")) && (w += "/"), S = !1;
      for (const E of A)
        if (E.type === 0) w += E.value;
        else if (E.type === 1) {
        const {
          value: M,
          repeatable: D,
          optional: B
        } = E, z = M in k ? k[M] : "";
        if (fn(z) && !D) throw new Error(`Provided param "${M}" is an array but it is not repeatable (* or + modifiers)`);
        const I = fn(z) ? z.join("/") : z;
        if (!I)
          if (B) A.length < 2 && (w.endsWith("/") ? w = w.slice(0, -1) : S = !0);
          else throw new Error(`Missing required param "${M}"`);
        w += I
      }
    }
    return w || "/"
  }
  return {
    re: h,
    score: i,
    keys: l,
    parse: p,
    stringify: m
  }
}

function vA(e, t) {
  let a = 0;
  for (; a < e.length && a < t.length;) {
    const i = t[a] - e[a];
    if (i) return i;
    a++
  }
  return e.length < t.length ? e.length === 1 && e[0] === 80 ? -1 : 1 : e.length > t.length ? t.length === 1 && t[0] === 80 ? 1 : -1 : 0
}

function ny(e, t) {
  let a = 0;
  const i = e.score,
    o = t.score;
  for (; a < i.length && a < o.length;) {
    const l = vA(i[a], o[a]);
    if (l) return l;
    a++
  }
  if (Math.abs(o.length - i.length) === 1) {
    if (Fg(i)) return 1;
    if (Fg(o)) return -1
  }
  return o.length - i.length
}

function Fg(e) {
  const t = e[e.length - 1];
  return e.length > 0 && t[t.length - 1] < 0
}
const bA = {
    type: 0,
    value: ""
  },
  yA = /[a-zA-Z0-9_]/;

function xA(e) {
  if (!e) return [
    []
  ];
  if (e === "/") return [
    [bA]
  ];
  if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);

  function t(E) {
    throw new Error(`ERR (${a})/"${k}": ${E}`)
  }
  let a = 0,
    i = a;
  const o = [];
  let l;

  function h() {
    l && o.push(l), l = []
  }
  let p = 0,
    m, k = "",
    w = "";

  function S() {
    k && (a === 0 ? l.push({
      type: 0,
      value: k
    }) : a === 1 || a === 2 || a === 3 ? (l.length > 1 && (m === "*" || m === "+") && t(`A repeatable param (${k}) must be alone in its segment. eg: '/:ids+.`), l.push({
      type: 1,
      value: k,
      regexp: w,
      repeatable: m === "*" || m === "+",
      optional: m === "*" || m === "?"
    })) : t("Invalid state to consume buffer"), k = "")
  }

  function A() {
    k += m
  }
  for (; p < e.length;) {
    if (m = e[p++], m === "\\" && a !== 2) {
      i = a, a = 4;
      continue
    }
    switch (a) {
      case 0:
        m === "/" ? (k && S(), h()) : m === ":" ? (S(), a = 1) : A();
        break;
      case 4:
        A(), a = i;
        break;
      case 1:
        m === "(" ? a = 2 : yA.test(m) ? A() : (S(), a = 0, m !== "*" && m !== "?" && m !== "+" && p--);
        break;
      case 2:
        m === ")" ? w[w.length - 1] == "\\" ? w = w.slice(0, -1) + m : a = 3 : w += m;
        break;
      case 3:
        S(), a = 0, m !== "*" && m !== "?" && m !== "+" && p--, w = "";
        break;
      default:
        t("Unknown state");
        break
    }
  }
  return a === 2 && t(`Unfinished custom RegExp for param "${k}"`), S(), h(), o
}

function wA(e, t, a) {
  const i = mA(xA(e.path), a),
    o = na(i, {
      record: e,
      parent: t,
      children: [],
      alias: []
    });
  return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o), o
}

function kA(e, t) {
  const a = [],
    i = new Map;
  t = Hg({
    strict: !1,
    end: !0,
    sensitive: !1
  }, t);

  function o(S) {
    return i.get(S)
  }

  function l(S, A, E) {
    const M = !E,
      D = _A(S);
    D.aliasOf = E && E.record;
    const B = Hg(t, S),
      z = [D];
    if ("alias" in S) {
      const U = typeof S.alias == "string" ? [S.alias] : S.alias;
      for (const W of U) z.push(na({}, D, {
        components: E ? E.record.components : D.components,
        path: W,
        aliasOf: E ? E.record : D
      }))
    }
    let I, N;
    for (const U of z) {
      const {
        path: W
      } = U;
      if (A && W[0] !== "/") {
        const X = A.record.path,
          V = X[X.length - 1] === "/" ? "" : "/";
        U.path = A.record.path + (W && V + W)
      }
      if (I = wA(U, A, B), E ? E.alias.push(I) : (N = N || I, N !== I && N.alias.push(I), M && S.name && !Bg(I) && h(S.name)), iy(I) && m(I), D.children) {
        const X = D.children;
        for (let V = 0; V < X.length; V++) l(X[V], I, E && E.children[V])
      }
      E = E || I
    }
    return N ? () => {
      h(N)
    } : Qo
  }

  function h(S) {
    if (ay(S)) {
      const A = i.get(S);
      A && (i.delete(S), a.splice(a.indexOf(A), 1), A.children.forEach(h), A.alias.forEach(h))
    } else {
      const A = a.indexOf(S);
      A > -1 && (a.splice(A, 1), S.record.name && i.delete(S.record.name), S.children.forEach(h), S.alias.forEach(h))
    }
  }

  function p() {
    return a
  }

  function m(S) {
    const A = CA(S, a);
    a.splice(A, 0, S), S.record.name && !Bg(S) && i.set(S.record.name, S)
  }

  function k(S, A) {
    let E, M = {},
      D, B;
    if ("name" in S && S.name) {
      if (E = i.get(S.name), !E) throw Zs(1, {
        location: S
      });
      B = E.record.name, M = na($g(A.params, E.keys.filter(N => !N.optional).concat(E.parent ? E.parent.keys.filter(N => N.optional) : []).map(N => N.name)), S.params && $g(S.params, E.keys.map(N => N.name))), D = E.stringify(M)
    } else if (S.path != null) D = S.path, E = a.find(N => N.re.test(D)), E && (M = E.parse(D), B = E.record.name);
    else {
      if (E = A.name ? i.get(A.name) : a.find(N => N.re.test(A.path)), !E) throw Zs(1, {
        location: S,
        currentLocation: A
      });
      B = E.record.name, M = na({}, A.params, S.params), D = E.stringify(M)
    }
    const z = [];
    let I = E;
    for (; I;) z.unshift(I.record), I = I.parent;
    return {
      name: B,
      path: D,
      params: M,
      matched: z,
      meta: AA(z)
    }
  }
  e.forEach(S => l(S));

  function w() {
    a.length = 0, i.clear()
  }
  return {
    addRoute: l,
    resolve: k,
    removeRoute: h,
    clearRoutes: w,
    getRoutes: p,
    getRecordMatcher: o
  }
}

function $g(e, t) {
  const a = {};
  for (const i of t) i in e && (a[i] = e[i]);
  return a
}

function _A(e) {
  return {
    path: e.path,
    redirect: e.redirect,
    name: e.name,
    meta: e.meta || {},
    aliasOf: void 0,
    beforeEnter: e.beforeEnter,
    props: SA(e),
    children: e.children || [],
    instances: {},
    leaveGuards: new Set,
    updateGuards: new Set,
    enterCallbacks: {},
    components: "components" in e ? e.components || null : e.component && {
      default: e.component
    }
  }
}

function SA(e) {
  const t = {},
    a = e.props || !1;
  if ("component" in e) t.default = a;
  else
    for (const i in e.components) t[i] = typeof a == "object" ? a[i] : a;
  return t
}

function Bg(e) {
  for (; e;) {
    if (e.record.aliasOf) return !0;
    e = e.parent
  }
  return !1
}

function AA(e) {
  return e.reduce((t, a) => na(t, a.meta), {})
}

function Hg(e, t) {
  const a = {};
  for (const i in e) a[i] = i in t ? t[i] : e[i];
  return a
}

function CA(e, t) {
  let a = 0,
    i = t.length;
  for (; a !== i;) {
    const l = a + i >> 1;
    ny(e, t[l]) < 0 ? i = l : a = l + 1
  }
  const o = TA(e);
  return o && (i = t.lastIndexOf(o, i - 1)), i
}

function TA(e) {
  let t = e;
  for (; t = t.parent;)
    if (iy(t) && ny(e, t) === 0) return t
}

function iy({
  record: e
}) {
  return !!(e.name || e.components && Object.keys(e.components).length || e.redirect)
}

function EA(e) {
  const t = {};
  if (e === "" || e === "?") return t;
  const i = (e[0] === "?" ? e.slice(1) : e).split("&");
  for (let o = 0; o < i.length; ++o) {
    const l = i[o].replace(K0, " "),
      h = l.indexOf("="),
      p = fl(h < 0 ? l : l.slice(0, h)),
      m = h < 0 ? null : fl(l.slice(h + 1));
    if (p in t) {
      let k = t[p];
      fn(k) || (k = t[p] = [k]), k.push(m)
    } else t[p] = m
  }
  return t
}

function Yg(e) {
  let t = "";
  for (let a in e) {
    const i = e[a];
    if (a = U2(a), i == null) {
      i !== void 0 && (t += (t.length ? "&" : "") + a);
      continue
    }(fn(i) ? i.map(l => l && xh(l)) : [i && xh(i)]).forEach(l => {
      l !== void 0 && (t += (t.length ? "&" : "") + a, l != null && (t += "=" + l))
    })
  }
  return t
}

function PA(e) {
  const t = {};
  for (const a in e) {
    const i = e[a];
    i !== void 0 && (t[a] = fn(i) ? i.map(o => o == null ? null : "" + o) : i == null ? i : "" + i)
  }
  return t
}
const LA = Symbol(""),
  zg = Symbol(""),
  bu = Symbol(""),
  sy = Symbol(""),
  kh = Symbol("");

function Mo() {
  let e = [];

  function t(i) {
    return e.push(i), () => {
      const o = e.indexOf(i);
      o > -1 && e.splice(o, 1)
    }
  }

  function a() {
    e = []
  }
  return {
    add: t,
    list: () => e.slice(),
    reset: a
  }
}

function gi(e, t, a, i, o, l = h => h()) {
  const h = i && (i.enterCallbacks[o] = i.enterCallbacks[o] || []);
  return () => new Promise((p, m) => {
    const k = A => {
        A === !1 ? m(Zs(4, {
          from: a,
          to: t
        })) : A instanceof Error ? m(A) : fA(A) ? m(Zs(2, {
          from: t,
          to: A
        })) : (h && i.enterCallbacks[o] === h && typeof A == "function" && h.push(A), p())
      },
      w = l(() => e.call(i && i.instances[o], t, a, k));
    let S = Promise.resolve(w);
    e.length < 3 && (S = S.then(k)), S.catch(A => m(A))
  })
}

function rd(e, t, a, i, o = l => l()) {
  const l = [];
  for (const h of e)
    for (const p in h.components) {
      let m = h.components[p];
      if (!(t !== "beforeRouteEnter" && !h.instances[p]))
        if (OA(m)) {
          const w = (m.__vccOpts || m)[t];
          w && l.push(gi(w, a, i, h, p, o))
        } else {
          let k = m();
          l.push(() => k.then(w => {
            if (!w) return Promise.reject(new Error(`Couldn't resolve component "${p}" at "${h.path}"`));
            const S = N2(w) ? w.default : w;
            h.components[p] = S;
            const E = (S.__vccOpts || S)[t];
            return E && gi(E, a, i, h, p, o)()
          }))
        }
    }
  return l
}

function OA(e) {
  return typeof e == "object" || "displayName" in e || "props" in e || "__vccOpts" in e
}

function Xg(e) {
  const t = fa(bu),
    a = fa(sy),
    i = Oe(() => {
      const m = se(e.to);
      return t.resolve(m)
    }),
    o = Oe(() => {
      const {
        matched: m
      } = i.value, {
        length: k
      } = m, w = m[k - 1], S = a.matched;
      if (!w || !S.length) return -1;
      const A = S.findIndex(Ks.bind(null, w));
      if (A > -1) return A;
      const E = Wg(m[k - 2]);
      return k > 1 && Wg(w) === E && S[S.length - 1].path !== E ? S.findIndex(Ks.bind(null, m[k - 2])) : A
    }),
    l = Oe(() => o.value > -1 && DA(a.params, i.value.params)),
    h = Oe(() => o.value > -1 && o.value === a.matched.length - 1 && ey(a.params, i.value.params));

  function p(m = {}) {
    return RA(m) ? t[se(e.replace) ? "replace" : "push"](se(e.to)).catch(Qo) : Promise.resolve()
  }
  return {
    route: i,
    href: Oe(() => i.value.href),
    isActive: l,
    isExactActive: h,
    navigate: p
  }
}
const MA = Ot({
    name: "RouterLink",
    compatConfig: {
      MODE: 3
    },
    props: {
      to: {
        type: [String, Object],
        required: !0
      },
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String,
      custom: Boolean,
      ariaCurrentValue: {
        type: String,
        default: "page"
      }
    },
    useLink: Xg,
    setup(e, {
      slots: t
    }) {
      const a = qr(Xg(e)),
        {
          options: i
        } = fa(bu),
        o = Oe(() => ({
          [Vg(e.activeClass, i.linkActiveClass, "router-link-active")]: a.isActive,
          [Vg(e.exactActiveClass, i.linkExactActiveClass, "router-link-exact-active")]: a.isExactActive
        }));
      return () => {
        const l = t.default && t.default(a);
        return e.custom ? l : oa("a", {
          "aria-current": a.isExactActive ? e.ariaCurrentValue : null,
          href: a.href,
          onClick: a.navigate,
          class: o.value
        }, l)
      }
    }
  }),
  IA = MA;

function RA(e) {
  if (!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && !e.defaultPrevented && !(e.button !== void 0 && e.button !== 0)) {
    if (e.currentTarget && e.currentTarget.getAttribute) {
      const t = e.currentTarget.getAttribute("target");
      if (/\b_blank\b/i.test(t)) return
    }
    return e.preventDefault && e.preventDefault(), !0
  }
}

function DA(e, t) {
  for (const a in t) {
    const i = t[a],
      o = e[a];
    if (typeof i == "string") {
      if (i !== o) return !1
    } else if (!fn(o) || o.length !== i.length || i.some((l, h) => l !== o[h])) return !1
  }
  return !0
}

function Wg(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}
const Vg = (e, t, a) => e ?? t ?? a,
  NA = Ot({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
      name: {
        type: String,
        default: "default"
      },
      route: Object
    },
    compatConfig: {
      MODE: 3
    },
    setup(e, {
      attrs: t,
      slots: a
    }) {
      const i = fa(kh),
        o = Oe(() => e.route || i.value),
        l = fa(zg, 0),
        h = Oe(() => {
          let k = se(l);
          const {
            matched: w
          } = o.value;
          let S;
          for (;
            (S = w[k]) && !S.components;) k++;
          return k
        }),
        p = Oe(() => o.value.matched[h.value]);
      vr(zg, Oe(() => h.value + 1)), vr(LA, p), vr(kh, o);
      const m = _e();
      return Xt(() => [m.value, p.value, e.name], ([k, w, S], [A, E, M]) => {
        w && (w.instances[S] = k, E && E !== w && k && k === A && (w.leaveGuards.size || (w.leaveGuards = E.leaveGuards), w.updateGuards.size || (w.updateGuards = E.updateGuards))), k && w && (!E || !Ks(w, E) || !A) && (w.enterCallbacks[S] || []).forEach(D => D(k))
      }, {
        flush: "post"
      }), () => {
        const k = o.value,
          w = e.name,
          S = p.value,
          A = S && S.components[w];
        if (!A) return jg(a.default, {
          Component: A,
          route: k
        });
        const E = S.props[w],
          M = E ? E === !0 ? k.params : typeof E == "function" ? E(k) : E : null,
          B = oa(A, na({}, M, t, {
            onVnodeUnmounted: z => {
              z.component.isUnmounted && (S.instances[w] = null)
            },
            ref: m
          }));
        return jg(a.default, {
          Component: B,
          route: k
        }) || B
      }
    }
  });

function jg(e, t) {
  if (!e) return null;
  const a = e(t);
  return a.length === 1 ? a[0] : a
}
const FA = NA;

function $A(e) {
  const t = kA(e.routes, e),
    a = e.parseQuery || EA,
    i = e.stringifyQuery || Yg,
    o = e.history,
    l = Mo(),
    h = Mo(),
    p = Mo(),
    m = Sl(li);
  let k = li;
  Ds && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
  const w = td.bind(null, J => "" + J),
    S = td.bind(null, q2),
    A = td.bind(null, fl);

  function E(J, Re) {
    let Xe, nt;
    return ay(J) ? (Xe = t.getRecordMatcher(J), nt = Re) : nt = J, t.addRoute(nt, Xe)
  }

  function M(J) {
    const Re = t.getRecordMatcher(J);
    Re && t.removeRoute(Re)
  }

  function D() {
    return t.getRoutes().map(J => J.record)
  }

  function B(J) {
    return !!t.getRecordMatcher(J)
  }

  function z(J, Re) {
    if (Re = na({}, Re || m.value), typeof J == "string") {
      const j = ad(a, J, Re.path),
        oe = t.resolve({
          path: j.path
        }, Re),
        de = o.createHref(j.fullPath);
      return na(j, oe, {
        params: A(oe.params),
        hash: fl(j.hash),
        redirectedFrom: void 0,
        href: de
      })
    }
    let Xe;
    if (J.path != null) Xe = na({}, J, {
      path: ad(a, J.path, Re.path).path
    });
    else {
      const j = na({}, J.params);
      for (const oe in j) j[oe] == null && delete j[oe];
      Xe = na({}, J, {
        params: S(j)
      }), Re.params = S(Re.params)
    }
    const nt = t.resolve(Xe, Re),
      Pe = J.hash || "";
    nt.params = w(A(nt.params));
    const We = Q2(i, na({}, J, {
        hash: j2(Pe),
        path: nt.path
      })),
      F = o.createHref(We);
    return na({
      fullPath: We,
      hash: Pe,
      query: i === Yg ? PA(J.query) : J.query || {}
    }, nt, {
      redirectedFrom: void 0,
      href: F
    })
  }

  function I(J) {
    return typeof J == "string" ? ad(a, J, m.value.path) : na({}, J)
  }

  function N(J, Re) {
    if (k !== J) return Zs(8, {
      from: Re,
      to: J
    })
  }

  function U(J) {
    return V(J)
  }

  function W(J) {
    return U(na(I(J), {
      replace: !0
    }))
  }

  function X(J) {
    const Re = J.matched[J.matched.length - 1];
    if (Re && Re.redirect) {
      const {
        redirect: Xe
      } = Re;
      let nt = typeof Xe == "function" ? Xe(J) : Xe;
      return typeof nt == "string" && (nt = nt.includes("?") || nt.includes("#") ? nt = I(nt) : {
        path: nt
      }, nt.params = {}), na({
        query: J.query,
        hash: J.hash,
        params: nt.path != null ? {} : J.params
      }, nt)
    }
  }

  function V(J, Re) {
    const Xe = k = z(J),
      nt = m.value,
      Pe = J.state,
      We = J.force,
      F = J.replace === !0,
      j = X(Xe);
    if (j) return V(na(I(j), {
      state: typeof j == "object" ? na({}, Pe, j.state) : Pe,
      force: We,
      replace: F
    }), Re || Xe);
    const oe = Xe;
    oe.redirectedFrom = Re;
    let de;
    return !We && J2(i, nt, Xe) && (de = Zs(16, {
      to: oe,
      from: nt
    }), Je(nt, nt, !0, !1)), (de ? Promise.resolve(de) : ie(oe, nt)).catch(Ie => Fn(Ie) ? Fn(Ie, 2) ? Ie : Ye(Ie) : He(Ie, oe, nt)).then(Ie => {
      if (Ie) {
        if (Fn(Ie, 2)) return V(na({
          replace: F
        }, I(Ie.to), {
          state: typeof Ie.to == "object" ? na({}, Pe, Ie.to.state) : Pe,
          force: We
        }), Re || oe)
      } else Ie = le(oe, nt, !0, F, Pe);
      return fe(oe, nt, Ie), Ie
    })
  }

  function ne(J, Re) {
    const Xe = N(J, Re);
    return Xe ? Promise.reject(Xe) : Promise.resolve()
  }

  function Z(J) {
    const Re = re.values().next().value;
    return Re && typeof Re.runWithContext == "function" ? Re.runWithContext(J) : J()
  }

  function ie(J, Re) {
    let Xe;
    const [nt, Pe, We] = BA(J, Re);
    Xe = rd(nt.reverse(), "beforeRouteLeave", J, Re);
    for (const j of nt) j.leaveGuards.forEach(oe => {
      Xe.push(gi(oe, J, Re))
    });
    const F = ne.bind(null, J, Re);
    return Xe.push(F), Be(Xe).then(() => {
      Xe = [];
      for (const j of l.list()) Xe.push(gi(j, J, Re));
      return Xe.push(F), Be(Xe)
    }).then(() => {
      Xe = rd(Pe, "beforeRouteUpdate", J, Re);
      for (const j of Pe) j.updateGuards.forEach(oe => {
        Xe.push(gi(oe, J, Re))
      });
      return Xe.push(F), Be(Xe)
    }).then(() => {
      Xe = [];
      for (const j of We)
        if (j.beforeEnter)
          if (fn(j.beforeEnter))
            for (const oe of j.beforeEnter) Xe.push(gi(oe, J, Re));
          else Xe.push(gi(j.beforeEnter, J, Re));
      return Xe.push(F), Be(Xe)
    }).then(() => (J.matched.forEach(j => j.enterCallbacks = {}), Xe = rd(We, "beforeRouteEnter", J, Re, Z), Xe.push(F), Be(Xe))).then(() => {
      Xe = [];
      for (const j of h.list()) Xe.push(gi(j, J, Re));
      return Xe.push(F), Be(Xe)
    }).catch(j => Fn(j, 8) ? j : Promise.reject(j))
  }

  function fe(J, Re, Xe) {
    p.list().forEach(nt => Z(() => nt(J, Re, Xe)))
  }

  function le(J, Re, Xe, nt, Pe) {
    const We = N(J, Re);
    if (We) return We;
    const F = Re === li,
      j = Ds ? history.state : {};
    Xe && (nt || F ? o.replace(J.fullPath, na({
      scroll: F && j && j.scroll
    }, Pe)) : o.push(J.fullPath, Pe)), m.value = J, Je(J, Re, Xe, F), Ye()
  }
  let Ee;

  function ye() {
    Ee || (Ee = o.listen((J, Re, Xe) => {
      if (!Se.listening) return;
      const nt = z(J),
        Pe = X(nt);
      if (Pe) {
        V(na(Pe, {
          replace: !0
        }), nt).catch(Qo);
        return
      }
      k = nt;
      const We = m.value;
      Ds && oA(Ig(We.fullPath, Xe.delta), vu()), ie(nt, We).catch(F => Fn(F, 12) ? F : Fn(F, 2) ? (V(F.to, nt).then(j => {
        Fn(j, 20) && !Xe.delta && Xe.type === pl.pop && o.go(-1, !1)
      }).catch(Qo), Promise.reject()) : (Xe.delta && o.go(-Xe.delta, !1), He(F, nt, We))).then(F => {
        F = F || le(nt, We, !1), F && (Xe.delta && !Fn(F, 8) ? o.go(-Xe.delta, !1) : Xe.type === pl.pop && Fn(F, 20) && o.go(-1, !1)), fe(nt, We, F)
      }).catch(Qo)
    }))
  }
  let ve = Mo(),
    me = Mo(),
    Ae;

  function He(J, Re, Xe) {
    Ye(J);
    const nt = me.list();
    return nt.length ? nt.forEach(Pe => Pe(J, Re, Xe)) : console.error(J), Promise.reject(J)
  }

  function De() {
    return Ae && m.value !== li ? Promise.resolve() : new Promise((J, Re) => {
      ve.add([J, Re])
    })
  }

  function Ye(J) {
    return Ae || (Ae = !J, ye(), ve.list().forEach(([Re, Xe]) => J ? Xe(J) : Re()), ve.reset()), J
  }

  function Je(J, Re, Xe, nt) {
    const {
      scrollBehavior: Pe
    } = e;
    if (!Ds || !Pe) return Promise.resolve();
    const We = !Xe && lA(Ig(J.fullPath, 0)) || (nt || !Xe) && history.state && history.state.scroll || null;
    return Jt().then(() => Pe(J, Re, We)).then(F => F && sA(F)).catch(F => He(F, J, Re))
  }
  const he = J => o.go(J);
  let ke;
  const re = new Set,
    Se = {
      currentRoute: m,
      listening: !0,
      addRoute: E,
      removeRoute: M,
      clearRoutes: t.clearRoutes,
      hasRoute: B,
      getRoutes: D,
      resolve: z,
      options: e,
      push: U,
      replace: W,
      go: he,
      back: () => he(-1),
      forward: () => he(1),
      beforeEach: l.add,
      beforeResolve: h.add,
      afterEach: p.add,
      onError: me.add,
      isReady: De,
      install(J) {
        const Re = this;
        J.component("RouterLink", IA), J.component("RouterView", FA), J.config.globalProperties.$router = Re, Object.defineProperty(J.config.globalProperties, "$route", {
          enumerable: !0,
          get: () => se(m)
        }), Ds && !ke && m.value === li && (ke = !0, U(o.location).catch(Pe => {}));
        const Xe = {};
        for (const Pe in li) Object.defineProperty(Xe, Pe, {
          get: () => m.value[Pe],
          enumerable: !0
        });
        J.provide(bu, Re), J.provide(sy, mb(Xe)), J.provide(kh, m);
        const nt = J.unmount;
        re.add(J), J.unmount = function () {
          re.delete(J), re.size < 1 && (k = li, Ee && Ee(), Ee = null, m.value = li, ke = !1, Ae = !1), nt()
        }
      }
    };

  function Be(J) {
    return J.reduce((Re, Xe) => Re.then(() => Z(Xe)), Promise.resolve())
  }
  return Se
}

function BA(e, t) {
  const a = [],
    i = [],
    o = [],
    l = Math.max(t.matched.length, e.matched.length);
  for (let h = 0; h < l; h++) {
    const p = t.matched[h];
    p && (e.matched.find(k => Ks(k, p)) ? i.push(p) : a.push(p));
    const m = e.matched[h];
    m && (t.matched.find(k => Ks(k, m)) || o.push(m))
  }
  return [a, i, o]
}

function HA() {
  return fa(bu)
}
const YA = ["type", "value", "placeholder", "disabled", "required"],
  zA = {
    key: 0,
    class: "form-error text-[#b91c1c] text-xs"
  },
  Zr = {
    __name: "FormInput",
    props: {
      modelValue: [String, Number],
      label: String,
      name: String,
      placeholder: String,
      type: String,
      className: String,
      labelClass: String,
      required: Boolean,
      error: String,
      disabled: Boolean
    },
    emits: ["update:modelValue"],
    setup(e, {
      emit: t
    }) {
      const a = e,
        i = t,
        o = l => {
          i("update:modelValue", l.target.value)
        };
      return (l, h) => (be(), Ne("div", {
        class: ut(e.className)
      }, [ce("label", {
        for: "name",
        class: ut(["block text-sm leading-6 text-gray-900", e.labelClass])
      }, st(e.label ?? e.name), 3), ce("div", null, [ce("input", {
        class: ut(["block w-full rounded-md border-0 py-1.5 px-4 text-gray-900 shadow-sm outline-none ring-1 ring-inset placeholder:text-gray-400 sm:text-sm sm:leading-6", e.error ? "ring-[#b91c1c]" : "ring-gray-300"]),
        type: e.type,
        value: a.modelValue,
        onInput: o,
        step: "any",
        placeholder: e.placeholder,
        disabled: e.disabled,
        required: e.required
      }, null, 42, YA)]), e.error ? (be(), Ne("div", zA, st(e.error), 1)) : Ke("", !0)], 2))
    }
  },
  XA = {
    class: "flex h-screen justify-center"
  },
  WA = {
    class: "flex justify-center"
  },
  VA = {
    class: "w-[20em] mt-40"
  },
  jA = {
    class: "flex justify-center mb-5"
  },
  UA = ["src", "alt"],
  GA = {
    key: 1,
    class: "text-2xl mb-2"
  },
  qA = ce("h1", {
    class: "text-2xl text-center"
  }, "Login to your account", -1),
  KA = {
    class: "text-center text-sm text-slate-500"
  },
  ZA = {
    class: "mt-5 space-y-4"
  },
  QA = {
    key: 0,
    class: "form-error text-[#b91c1c] text-xs"
  },
  JA = {
    class: "flex items-center justify-between mt-5"
  },
  eC = Tl('<div class="flex items-start"><div class="flex items-center h-5"><input id="remember" type="checkbox" class="w-4 h-4 border border-gray-300 rounded bg-gray-50 focus:ring-3 focus:ring-primary-300 dark:bg-gray-700 dark:border-gray-600 dark:focus:ring-primary-600 dark:ring-offset-gray-800"></div><div class="ml-3 text-sm"><label for="remember" class="text-gray-500 dark:text-gray-300">Remember me</label></div></div>', 1),
  tC = {
    class: "mt-6"
  },
  aC = {
    key: 0,
    type: "submit",
    class: "rounded-md bg-primary px-3 py-3 text-sm text-white shadow-sm w-full"
  },
  rC = {
    key: 1,
    type: "button",
    class: "rounded-md bg-primary px-3 py-3 text-sm text-white shadow-sm w-full flex justify-center"
  },
  nC = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "currentColor",
    d: "M12 2A10 10 0 1 0 22 12A10 10 0 0 0 12 2Zm0 18a8 8 0 1 1 8-8A8 8 0 0 1 12 20Z",
    opacity: ".5"
  }), ce("path", {
    fill: "currentColor",
    d: "M20 12h2A10 10 0 0 0 12 2V4A8 8 0 0 1 20 12Z"
  }, [ce("animateTransform", {
    attributeName: "transform",
    dur: "1s",
    from: "0 12 12",
    repeatCount: "indefinite",
    to: "360 12 12",
    type: "rotate"
  })])], -1),
  iC = [nC],
  sC = {
    key: 0,
    class: "flex justify-center my-6"
  },
  oC = ce("span", {
    class: "text-sm text-gray-500 px-4 text-center"
  }, "Or continue with", -1),
  lC = [oC],
  cC = {
    class: "flex justify-center gap-4"
  },
  uC = {
    key: 0,
    href: "/social-login/facebook",
    class: "border rounded-full p-2 cursor-pointer"
  },
  dC = {
    key: 1,
    href: "/social-login/google",
    class: "border rounded-full p-2 cursor-pointer"
  },
  hC = {
    __name: "Login",
    setup(e) {
      const t = _e({
          logo: "",
          company_name: "DigiLearns.NG",
          allow_facebook_login: !1,
          allow_google_login: !1
        }),
        a = _e({
          email: "",
          password: "",
          recaptcha_response: "",
          errors: {}
        }),
        i = _e(!1);
      HA();
      const o = async () => {
        try {
          const h = await Qt.get("http://localhost:3000/api/settings");
          t.value = h.data
        } catch (h) {
          console.error("Failed to fetch settings:", h)
        }
      }, l = async () => {
        i.value = !0;
        try {
          const p = await Qt.post("http://localhost:3000/api/login", {
            email: a.value.email,
            password: a.value.password
          });
          p.data.user ? (localStorage.setItem("user", JSON.stringify(p.data.user)), localStorage.setItem("khdgisiygkdagdikbkadlnlho3y4973u", "your-auth-token-or-true"), window.location.href = p.data.redirectTo) : a.value.errors = {
            email: "Login failed. Please try again."
          }
        } catch (h) {
          h.response && h.response.data.message && (a.value.errors = {
            email: h.response.data.message
          })
        } finally {
          i.value = !1
        }
      };
      return Dt(() => {
        o()
      }), (h, p) => {
        const m = Mn("router-link");
        return be(), Ne("div", XA, [ce("div", WA, [ce("div", VA, [ce("div", jA, [Ze(m, {
          to: "/"
        }, {
          default: Qe(() => [t.value.logo ? (be(), Ne("img", {
            key: 0,
            class: "max-w-[180px]",
            src: t.value.logo,
            alt: t.value.company_name
          }, null, 8, UA)) : (be(), Ne("h4", GA, st(t.value.company_name), 1))]),
          _: 1
        })]), qA, ce("div", KA, [$t(" Don't have an account? "), Ze(m, {
          to: "/signup",
          class: "text-sm text-primary-600 dark:text-primary-500 border-b hover:border-gray-500"
        }, {
          default: Qe(() => [$t(" Create one here ")]),
          _: 1
        })]), ce("form", {
          onSubmit: qn(l, ["prevent"]),
          class: "mt-5"
        }, [ce("div", ZA, [Ze(Zr, {
          modelValue: a.value.email,
          "onUpdate:modelValue": p[0] || (p[0] = k => a.value.email = k),
          name: "Email",
          error: a.value.errors.email,
          type: "email",
          class: "col-span-3"
        }, null, 8, ["modelValue", "error"]), Ze(Zr, {
          modelValue: a.value.password,
          "onUpdate:modelValue": p[1] || (p[1] = k => a.value.password = k),
          name: "Password",
          error: a.value.errors.password,
          type: "password",
          class: "col-span-3"
        }, null, 8, ["modelValue", "error"]), a.value.errors.recaptcha_response ? (be(), Ne("div", QA, st(a.value.errors.recaptcha_response), 1)) : Ke("", !0)]), ce("div", JA, [eC, Ze(m, {
          to: "/forgot-password",
          class: "text-sm text-primary-600 dark:text-primary-500 border-b hover:border-gray-500"
        }, {
          default: Qe(() => [$t("Forgot password?")]),
          _: 1
        })]), ce("div", tC, [i.value ? (be(), Ne("button", rC, iC)) : (be(), Ne("button", aC, " Login to your account "))])], 32), t.value.allow_facebook_login || t.value.allow_google_login ? (be(), Ne("div", sC, lC)) : Ke("", !0), ce("div", cC, [t.value.allow_facebook_login ? (be(), Ne("a", uC)) : Ke("", !0), t.value.allow_google_login ? (be(), Ne("a", dC)) : Ke("", !0)])])])])
      }
    }
  },
  ys = (e, t) => {
    const a = e.__vccOpts || e;
    for (const [i, o] of t) a[i] = o;
    return a
  },
  fC = {
    name: "Sidebar",
    data() {
      return {
        user: JSON.parse(localStorage.getItem("user")) || {}
      }
    },
    methods: {
      toggleSidebar() {
        this.$emit("toggleSidebar")
      },
      openModal() {}
    }
  },
  oy = e => (Pb("data-v-2e8d35eb"), e = e(), Lb(), e),
  pC = {
    class: "md:flex flex-col h-full w-80 bg-white hidden"
  },
  gC = {
    class: "fixed top-0 z-10 w-full bg-white border-b px-4 py-4 flex items-center justify-between md:hidden"
  },
  mC = oy(() => ce("span", null, [ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "2em",
    height: "2em",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M5 17h8m-8-5h14M5 7h8"
  })])], -1)),
  vC = [mC],
  bC = Tl('<h3 class="text-xl" data-v-2e8d35eb>DigiLearns</h3><div data-v-2e8d35eb><span data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" viewBox="0 0 24 24" data-v-2e8d35eb><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" data-v-2e8d35eb><path d="M12 2C6.477 2 2 6.477 2 12s4.477 10 10 10s10-4.477 10-10S17.523 2 12 2" data-v-2e8d35eb></path><path d="M4.271 18.346S6.5 15.5 12 15.5s7.73 2.846 7.73 2.846M12 12a3 3 0 1 0 0-6a3 3 0 0 0 0 6" data-v-2e8d35eb></path></g></svg></span></div>', 2),
  yC = Tl('<div class="flex items-center justify-between px-5 pt-5 h-20 mb-4" data-v-2e8d35eb><h2 class="ml-2 text-2xl" data-v-2e8d35eb>DigiLearns</h2><div class="relative text-sm text-black" data-v-2e8d35eb><div class="lang-dd flex items-center space-x-2 rounded-xl cursor-pointer" data-v-2e8d35eb><div data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" data-v-2e8d35eb><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" data-v-2e8d35eb><path d="M2 12c0 5.523 4.477 10 10 10s10-4.477 10-10S17.523 2 12 2S2 6.477 2 12" data-v-2e8d35eb></path><path d="M13 2.05S16 6 16 12s-3 9.95-3 9.95m-2 0S8 18 8 12s3-9.95 3-9.95M2.63 15.5h18.74m-18.74-7h18.74" data-v-2e8d35eb></path></g></svg></div><div class="uppercase" data-v-2e8d35eb>en</div><div class="ml-auto" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="currentColor" fill-rule="evenodd" d="M4.47 9.4a.75.75 0 0 1 1.06 0l6.364 6.364a.25.25 0 0 0 .354 0L18.612 9.4a.75.75 0 0 1 1.06 1.06l-6.364 6.364a1.75 1.75 0 0 1-2.475 0L4.47 10.46a.75.75 0 0 1 0-1.06" data-v-2e8d35eb></path></svg></div></div></div></div><div class="flex-grow space-y-3 px-2 overflow-y-scroll" data-v-2e8d35eb><div class="flex-1" data-v-2e8d35eb><ul class="pt-2 space-y-1 text-sm mb-2" data-v-2e8d35eb><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/dashboard" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 11.452V16.8c0 1.12 0 1.68.218 2.109c.192.376.497.682.874.873c.427.218.987.218 2.105.218h9.606c1.118 0 1.677 0 2.104-.218a2 2 0 0 0 .875-.873c.218-.428.218-.987.218-2.105v-5.352c0-.534 0-.801-.065-1.05a1.998 1.998 0 0 0-.28-.617c-.145-.213-.345-.39-.748-.741l-4.8-4.2c-.746-.653-1.12-.98-1.54-1.104c-.37-.11-.764-.11-1.135 0c-.42.124-.792.45-1.538 1.102L5.093 9.044c-.402.352-.603.528-.747.74a2 2 0 0 0-.281.618C4 10.65 4 10.918 4 11.452Z" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Dashboard</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/organizations" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><g fill="none" fill-rule="evenodd" data-v-2e8d35eb><path d="M24 0v24H0V0h24ZM12.593 23.258l-.011.002l-.071.035l-.02.004l-.014-.004l-.071-.035c-.01-.004-.019-.001-.024.005l-.004.01l-.017.428l.005.02l.01.013l.104.074l.015.004l.012-.004l.104-.074l.012-.016l.004-.017l-.017-.427c-.002-.01-.009-.017-.017-.018Zm.265-.113l-.013.002l-.185.093l-.01.01l-.003.011l.018.43l.005.012l.008.007l.201.093c.012.004.023 0 .029-.008l.004-.014l-.034-.614c-.003-.012-.01-.02-.02-.022Zm-.715.002a.023.023 0 0 0-.027.006l-.006.014l-.034.614c0 .012.007.02.017.024l.015-.002l.201-.093l.01-.008l.004-.011l.017-.43l-.003-.012l-.01-.01l-.184-.092Z" data-v-2e8d35eb></path><path fill="currentColor" d="M17 3.722v5.497l2.864.716A1.5 1.5 0 0 1 21 11.39V19a1 1 0 1 1 0 2H3a1 1 0 1 1 0-2v-7.69a1.5 1.5 0 0 1 .83-1.343L7 8.382V6.347a1.5 1.5 0 0 1 .973-1.405l7-2.625A1.5 1.5 0 0 1 17 3.722Zm-2 .721l-6 2.25V19h6V4.443Zm2 6.838V19h2v-7.22l-2-.5Zm-10-.663l-2 1V19h2v-8.382Z" data-v-2e8d35eb></path></g></svg><span data-v-2e8d35eb>Schools</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/students" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20c0-1.657-2.239-3-5-3s-5 1.343-5 3m14-3c0-1.23-1.234-2.287-3-2.75M3 17c0-1.23 1.234-2.287 3-2.75m12-4.014a3 3 0 1 0-4-4.472m-8 4.472a3 3 0 0 1 4-4.472M12 14a3 3 0 1 1 0-6a3 3 0 0 1 0 6Z" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Students</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/users" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20c0-1.657-2.239-3-5-3s-5 1.343-5 3m14-3c0-1.23-1.234-2.287-3-2.75M3 17c0-1.23 1.234-2.287 3-2.75m12-4.014a3 3 0 1 0-4-4.472m-8 4.472a3 3 0 0 1 4-4.472M12 14a3 3 0 1 1 0-6a3 3 0 0 1 0 6Z" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Users</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/payment-logs" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 11v4.8c0 1.12 0 1.68.218 2.108a2 2 0 0 0 .874.874c.427.218.987.218 2.105.218h11.606c1.118 0 1.677 0 2.104-.218c.377-.192.683-.498.875-.874c.218-.428.218-.986.218-2.104V11M3 11V9m0 2h18M3 9v-.8c0-1.12 0-1.68.218-2.108c.192-.377.497-.682.874-.874C4.52 5 5.08 5 6.2 5h11.6c1.12 0 1.68 0 2.107.218c.377.192.683.497.875.874c.218.427.218.987.218 2.105V9M3 9h18M7 15h4m10-4V9" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Billing</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/support" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 8h4a1 1 0 0 1 1 1v11l-3.333-2.769a1.002 1.002 0 0 0-.64-.231H9a1 1 0 0 1-1-1v-3m8-5V5a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v11l3.333-2.77c.18-.148.406-.23.64-.23H8m8-5v4a1 1 0 0 1-1 1H8" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Support Desk</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/team/users" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 20c0-1.742-1.67-3.223-4-3.773M15 20c0-2.21-2.686-4-6-4s-6 1.79-6 4m12-7a4 4 0 0 0 0-8m-6 8a4 4 0 1 1 0-8a4 4 0 0 1 0 8Z" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Team</span></a></li></ul><div class="px-4" data-v-2e8d35eb><hr data-v-2e8d35eb></div><ul class="pb-4 space-y-1 text-sm mt-2" data-v-2e8d35eb><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/team/roles" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 20c0-1.742-1.67-3.223-4-3.773M15 20c0-2.21-2.686-4-6-4s-6 1.79-6 4m12-7a4 4 0 0 0 0-8m-6 8a4 4 0 1 1 0-8a4 4 0 0 1 0 8Z" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Roles</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/plans" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 11v4.8c0 1.12 0 1.68.218 2.108a2 2 0 0 0 .874.874c.427.218.987.218 2.105.218h11.606c1.118 0 1.677 0 2.104-.218c.377-.192.683-.498.875-.874c.218-.428.218-.986.218-2.104V11M3 11V9m0 2h18M3 9v-.8c0-1.12 0-1.68.218-2.108c.192-.377.497-.682.874-.874C4.52 5 5.08 5 6.2 5h11.6c1.12 0 1.68 0 2.107.218c.377.192.683.497.875.874c.218.427.218.987.218 2.105V9M3 9h18M7 15h4m10-4V9" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Subscription Plans</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/faqs" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="currentColor" d="M5.455 15L1 18.5V3a1 1 0 0 1 1-1h15a1 1 0 0 1 1 1v12zm-.692-2H16V4H3v10.385zM8 17h10.237L20 18.385V8h1a1 1 0 0 1 1 1v13.5L17.546 19H9a1 1 0 0 1-1-1z" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>FAQs</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/testimonials" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="currentColor" fill-rule="evenodd" d="M10.486 4.114c.675-1.162 2.353-1.162 3.028 0l2.065 3.56c.19.328.52.551.895.608l3.43.518c1.494.226 2.018 2.114.854 3.078l-2.499 2.07a1.25 1.25 0 0 0-.43 1.197l.7 3.676c.274 1.44-1.238 2.558-2.535 1.876L12.582 18.9a1.25 1.25 0 0 0-1.164 0l-3.412 1.797c-1.297.683-2.809-.436-2.535-1.876l.7-3.676a1.25 1.25 0 0 0-.43-1.197l-2.5-2.07c-1.163-.964-.64-2.852.856-3.078l3.43-.518a1.25 1.25 0 0 0 .894-.609zm1.73.753a.25.25 0 0 0-.432 0l-2.066 3.56a2.75 2.75 0 0 1-1.967 1.338l-3.43.518a.25.25 0 0 0-.122.44l2.499 2.07a2.75 2.75 0 0 1 .947 2.632l-.7 3.676a.25.25 0 0 0 .362.268l3.412-1.796a2.75 2.75 0 0 1 2.562 0l3.412 1.796a.25.25 0 0 0 .362-.268l-.7-3.676a2.75 2.75 0 0 1 .947-2.632l2.5-2.07a.25.25 0 0 0-.123-.44l-3.43-.518a2.75 2.75 0 0 1-1.967-1.339z" clip-rule="evenodd" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Reviews</span></a></li><li class="hover:bg-slate-50 hover:text-black rounded-[5px] px-2 truncate" data-v-2e8d35eb><a rel="noopener noreferrer" class="flex items-center p-2 space-x-3 rounded-md" href="/admin/settings/general" data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 16 16" data-v-2e8d35eb><path fill="currentColor" fill-rule="evenodd" d="M3.5 2h-1v5h1zm6.1 5H6.4L6 6.45v-1L6.4 5h3.2l.4.5v1zm-5 3H1.4L1 9.5v-1l.4-.5h3.2l.4.5v1zm3.9-8h-1v2h1zm-1 6h1v6h-1zm-4 3h-1v3h1zm7.9 0h3.19l.4-.5v-.95l-.4-.5H11.4l-.4.5v.95zm2.1-9h-1v6h1zm-1 10h1v2h-1z" clip-rule="evenodd" data-v-2e8d35eb></path></svg><span data-v-2e8d35eb>Settings</span></a></li></ul></div></div><a class="border-2 border-primary text-sm rounded-[5px] mb-1 m-3 py-2 px-4 flex items-center justify-between cursor-pointer" href="/admin/addons" data-v-2e8d35eb><div class="flex items-center space-x-3" data-v-2e8d35eb><span data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="currentColor" d="M19 6h-2c0-2.8-2.2-5-5-5S7 3.2 7 6H5c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2m-7-3c1.7 0 3 1.3 3 3H9c0-1.7 1.3-3 3-3m7 17H5V8h14zm-7-8c-1.7 0-3-1.3-3-3H7c0 2.8 2.2 5 5 5s5-2.2 5-5h-2c0 1.7-1.3 3-3 3" data-v-2e8d35eb></path></svg></span><span data-v-2e8d35eb>Addons</span></div><span data-v-2e8d35eb><svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24" data-v-2e8d35eb><path fill="currentColor" d="M9 17.898c0 1.074 1.265 1.648 2.073.941l6.31-5.522a1.75 1.75 0 0 0 0-2.634l-6.31-5.522C10.265 4.454 9 5.028 9 6.102z" data-v-2e8d35eb></path></svg></span></a>', 3),
  xC = {
    class: "flex items-center m-3 p-2 rounded-[5px] h-20 py-1 md:py-1 mt-2 space-x-4 justify-between bg-slate-50"
  },
  wC = {
    class: "flex space-x-2"
  },
  kC = {
    class: "rounded-full p-1"
  },
  _C = ["src"],
  SC = {
    class: "text-[18px] capitalize truncate w-[6em]"
  },
  AC = {
    class: "flex items-center space-x-1"
  },
  CC = oy(() => ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "2em",
    height: "2em",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "m12 15l3-3m0 0l-3-3m3 3H4m5-4.751V7.2c0-1.12 0-1.68.218-2.108c.192-.377.497-.682.874-.874C10.52 4 11.08 4 12.2 4h4.6c1.12 0 1.68 0 2.107.218c.377.192.683.497.875.874c.218.427.218.987.218 2.105v9.607c0 1.118 0 1.677-.218 2.104a2.002 2.002 0 0 1-.875.874c-.427.218-.986.218-2.104.218h-4.606c-1.118 0-1.678 0-2.105-.218a2 2 0 0 1-.874-.874C9 18.48 9 17.92 9 16.8v-.05"
  })], -1));

function TC(e, t, a, i, o, l) {
  const h = Mn("Link");
  return be(), Ne("aside", pC, [ce("div", gC, [ce("div", {
    onClick: t[0] || (t[0] = (...p) => l.toggleSidebar && l.toggleSidebar(...p))
  }, vC), bC]), yC, ce("div", xC, [ce("div", wC, [ce("div", kC, [ce("img", {
    class: "rounded-full w-9 h-9",
    src: o.user.avatar || "https://res.cloudinary.com/dzsp4g9vd/image/upload/v1723145284/digilearns/profile/Gideon-Olanrewaju.png"
  }, null, 8, _C)]), ce("div", null, [ce("h2", SC, st(o.user.first_name) + " " + st(o.user.last_name), 1), ce("span", AC, [ce("span", {
    onClick: t[1] || (t[1] = (...p) => l.openModal && l.openModal(...p)),
    class: "text-sm hover:underline dark:text-gray-400 cursor-pointer"
  }, st(e.$t("View profile")), 1)])])]), Ze(h, {
    href: "/logout",
    class: "hover:bg-[#F6F7F9] hover:rounded-full w-[fit-content] p-2"
  }, {
    default: Qe(() => [CC]),
    _: 1
  })])])
}
const EC = ys(fC, [
    ["render", TC],
    ["__scopeId", "data-v-2e8d35eb"]
  ]),
  PC = {
    class: "flex h-screen w-full bg-gray-300/10"
  },
  LC = {
    class: "flex flex-col w-full"
  },
  yu = {
    __name: "App",
    setup(e) {
      return (t, a) => (be(), Ne("div", PC, [Ze(EC), ce("div", LC, [lt(t.$slots, "default")])]))
    }
  },
  OC = {},
  MC = e => (Pb("data-v-e922195a"), e = e(), Lb(), e),
  IC = {
    class: "spinner-container"
  },
  RC = MC(() => ce("div", {
    class: "spinner"
  }, null, -1)),
  DC = [RC];

function NC(e, t) {
  return be(), Ne("div", IC, DC)
}
const FC = ys(OC, [
  ["render", NC],
  ["__scopeId", "data-v-e922195a"]
]);

function $C(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var _h = {
  exports: {}
};
/*!
 * ApexCharts v3.45.2
 * (c) 2018-2024 ApexCharts
 * Released under the MIT License.
 */
(function (e, t) {
  function a(Y, r) {
    var n = Object.keys(Y);
    if (Object.getOwnPropertySymbols) {
      var s = Object.getOwnPropertySymbols(Y);
      r && (s = s.filter(function (c) {
        return Object.getOwnPropertyDescriptor(Y, c).enumerable
      })), n.push.apply(n, s)
    }
    return n
  }

  function i(Y) {
    for (var r = 1; r < arguments.length; r++) {
      var n = arguments[r] != null ? arguments[r] : {};
      r % 2 ? a(Object(n), !0).forEach(function (s) {
        m(Y, s, n[s])
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Y, Object.getOwnPropertyDescriptors(n)) : a(Object(n)).forEach(function (s) {
        Object.defineProperty(Y, s, Object.getOwnPropertyDescriptor(n, s))
      })
    }
    return Y
  }

  function o(Y) {
    return o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (r) {
      return typeof r
    } : function (r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r
    }, o(Y)
  }

  function l(Y, r) {
    if (!(Y instanceof r)) throw new TypeError("Cannot call a class as a function")
  }

  function h(Y, r) {
    for (var n = 0; n < r.length; n++) {
      var s = r[n];
      s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(Y, s.key, s)
    }
  }

  function p(Y, r, n) {
    return r && h(Y.prototype, r), n && h(Y, n), Y
  }

  function m(Y, r, n) {
    return r in Y ? Object.defineProperty(Y, r, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : Y[r] = n, Y
  }

  function k(Y, r) {
    if (typeof r != "function" && r !== null) throw new TypeError("Super expression must either be null or a function");
    Y.prototype = Object.create(r && r.prototype, {
      constructor: {
        value: Y,
        writable: !0,
        configurable: !0
      }
    }), r && S(Y, r)
  }

  function w(Y) {
    return w = Object.setPrototypeOf ? Object.getPrototypeOf : function (r) {
      return r.__proto__ || Object.getPrototypeOf(r)
    }, w(Y)
  }

  function S(Y, r) {
    return S = Object.setPrototypeOf || function (n, s) {
      return n.__proto__ = s, n
    }, S(Y, r)
  }

  function A(Y) {
    if (Y === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return Y
  }

  function E(Y) {
    var r = function () {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
      if (typeof Proxy == "function") return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0
      } catch {
        return !1
      }
    }();
    return function () {
      var n, s = w(Y);
      if (r) {
        var c = w(this).constructor;
        n = Reflect.construct(s, arguments, c)
      } else n = s.apply(this, arguments);
      return function (u, d) {
        if (d && (typeof d == "object" || typeof d == "function")) return d;
        if (d !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
        return A(u)
      }(this, n)
    }
  }

  function M(Y, r) {
    return function (n) {
      if (Array.isArray(n)) return n
    }(Y) || function (n, s) {
      var c = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
      if (c != null) {
        var u, d, f = [],
          g = !0,
          b = !1;
        try {
          for (c = c.call(n); !(g = (u = c.next()).done) && (f.push(u.value), !s || f.length !== s); g = !0);
        } catch (y) {
          b = !0, d = y
        } finally {
          try {
            g || c.return == null || c.return()
          } finally {
            if (b) throw d
          }
        }
        return f
      }
    }(Y, r) || B(Y, r) || function () {
      throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }()
  }

  function D(Y) {
    return function (r) {
      if (Array.isArray(r)) return z(r)
    }(Y) || function (r) {
      if (typeof Symbol < "u" && r[Symbol.iterator] != null || r["@@iterator"] != null) return Array.from(r)
    }(Y) || B(Y) || function () {
      throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
    }()
  }

  function B(Y, r) {
    if (Y) {
      if (typeof Y == "string") return z(Y, r);
      var n = Object.prototype.toString.call(Y).slice(8, -1);
      return n === "Object" && Y.constructor && (n = Y.constructor.name), n === "Map" || n === "Set" ? Array.from(Y) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? z(Y, r) : void 0
    }
  }

  function z(Y, r) {
    (r == null || r > Y.length) && (r = Y.length);
    for (var n = 0, s = new Array(r); n < r; n++) s[n] = Y[n];
    return s
  }
  var I = function () {
      function Y() {
        l(this, Y)
      }
      return p(Y, [{
        key: "shadeRGBColor",
        value: function (r, n) {
          var s = n.split(","),
            c = r < 0 ? 0 : 255,
            u = r < 0 ? -1 * r : r,
            d = parseInt(s[0].slice(4), 10),
            f = parseInt(s[1], 10),
            g = parseInt(s[2], 10);
          return "rgb(" + (Math.round((c - d) * u) + d) + "," + (Math.round((c - f) * u) + f) + "," + (Math.round((c - g) * u) + g) + ")"
        }
      }, {
        key: "shadeHexColor",
        value: function (r, n) {
          var s = parseInt(n.slice(1), 16),
            c = r < 0 ? 0 : 255,
            u = r < 0 ? -1 * r : r,
            d = s >> 16,
            f = s >> 8 & 255,
            g = 255 & s;
          return "#" + (16777216 + 65536 * (Math.round((c - d) * u) + d) + 256 * (Math.round((c - f) * u) + f) + (Math.round((c - g) * u) + g)).toString(16).slice(1)
        }
      }, {
        key: "shadeColor",
        value: function (r, n) {
          return Y.isColorHex(n) ? this.shadeHexColor(r, n) : this.shadeRGBColor(r, n)
        }
      }], [{
        key: "bind",
        value: function (r, n) {
          return function () {
            return r.apply(n, arguments)
          }
        }
      }, {
        key: "isObject",
        value: function (r) {
          return r && o(r) === "object" && !Array.isArray(r) && r != null
        }
      }, {
        key: "is",
        value: function (r, n) {
          return Object.prototype.toString.call(n) === "[object " + r + "]"
        }
      }, {
        key: "listToArray",
        value: function (r) {
          var n, s = [];
          for (n = 0; n < r.length; n++) s[n] = r[n];
          return s
        }
      }, {
        key: "extend",
        value: function (r, n) {
          var s = this;
          typeof Object.assign != "function" && (Object.assign = function (u) {
            if (u == null) throw new TypeError("Cannot convert undefined or null to object");
            for (var d = Object(u), f = 1; f < arguments.length; f++) {
              var g = arguments[f];
              if (g != null)
                for (var b in g) g.hasOwnProperty(b) && (d[b] = g[b])
            }
            return d
          });
          var c = Object.assign({}, r);
          return this.isObject(r) && this.isObject(n) && Object.keys(n).forEach(function (u) {
            s.isObject(n[u]) && u in r ? c[u] = s.extend(r[u], n[u]) : Object.assign(c, m({}, u, n[u]))
          }), c
        }
      }, {
        key: "extendArray",
        value: function (r, n) {
          var s = [];
          return r.map(function (c) {
            s.push(Y.extend(n, c))
          }), r = s
        }
      }, {
        key: "monthMod",
        value: function (r) {
          return r % 12
        }
      }, {
        key: "clone",
        value: function (r) {
          if (Y.is("Array", r)) {
            for (var n = [], s = 0; s < r.length; s++) n[s] = this.clone(r[s]);
            return n
          }
          if (Y.is("Null", r)) return null;
          if (Y.is("Date", r)) return r;
          if (o(r) === "object") {
            var c = {};
            for (var u in r) r.hasOwnProperty(u) && (c[u] = this.clone(r[u]));
            return c
          }
          return r
        }
      }, {
        key: "log10",
        value: function (r) {
          return Math.log(r) / Math.LN10
        }
      }, {
        key: "roundToBase10",
        value: function (r) {
          return Math.pow(10, Math.floor(Math.log10(r)))
        }
      }, {
        key: "roundToBase",
        value: function (r, n) {
          return Math.pow(n, Math.floor(Math.log(r) / Math.log(n)))
        }
      }, {
        key: "parseNumber",
        value: function (r) {
          return r === null ? r : parseFloat(r)
        }
      }, {
        key: "stripNumber",
        value: function (r) {
          var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
          return Number.isInteger(r) ? r : parseFloat(r.toPrecision(n))
        }
      }, {
        key: "randomId",
        value: function () {
          return (Math.random() + 1).toString(36).substring(4)
        }
      }, {
        key: "noExponents",
        value: function (r) {
          var n = String(r).split(/[eE]/);
          if (n.length === 1) return n[0];
          var s = "",
            c = r < 0 ? "-" : "",
            u = n[0].replace(".", ""),
            d = Number(n[1]) + 1;
          if (d < 0) {
            for (s = c + "0."; d++;) s += "0";
            return s + u.replace(/^-/, "")
          }
          for (d -= u.length; d--;) s += "0";
          return u + s
        }
      }, {
        key: "getDimensions",
        value: function (r) {
          var n = getComputedStyle(r, null),
            s = r.clientHeight,
            c = r.clientWidth;
          return s -= parseFloat(n.paddingTop) + parseFloat(n.paddingBottom), [c -= parseFloat(n.paddingLeft) + parseFloat(n.paddingRight), s]
        }
      }, {
        key: "getBoundingClientRect",
        value: function (r) {
          var n = r.getBoundingClientRect();
          return {
            top: n.top,
            right: n.right,
            bottom: n.bottom,
            left: n.left,
            width: r.clientWidth,
            height: r.clientHeight,
            x: n.left,
            y: n.top
          }
        }
      }, {
        key: "getLargestStringFromArr",
        value: function (r) {
          return r.reduce(function (n, s) {
            return Array.isArray(s) && (s = s.reduce(function (c, u) {
              return c.length > u.length ? c : u
            })), n.length > s.length ? n : s
          }, 0)
        }
      }, {
        key: "hexToRgba",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "#999999",
            n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : .6;
          r.substring(0, 1) !== "#" && (r = "#999999");
          var s = r.replace("#", "");
          s = s.match(new RegExp("(.{" + s.length / 3 + "})", "g"));
          for (var c = 0; c < s.length; c++) s[c] = parseInt(s[c].length === 1 ? s[c] + s[c] : s[c], 16);
          return n !== void 0 && s.push(n), "rgba(" + s.join(",") + ")"
        }
      }, {
        key: "getOpacityFromRGBA",
        value: function (r) {
          return parseFloat(r.replace(/^.*,(.+)\)/, "$1"))
        }
      }, {
        key: "rgb2hex",
        value: function (r) {
          return (r = r.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && r.length === 4 ? "#" + ("0" + parseInt(r[1], 10).toString(16)).slice(-2) + ("0" + parseInt(r[2], 10).toString(16)).slice(-2) + ("0" + parseInt(r[3], 10).toString(16)).slice(-2) : ""
        }
      }, {
        key: "isColorHex",
        value: function (r) {
          return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(r)
        }
      }, {
        key: "getPolygonPos",
        value: function (r, n) {
          for (var s = [], c = 2 * Math.PI / n, u = 0; u < n; u++) {
            var d = {};
            d.x = r * Math.sin(u * c), d.y = -r * Math.cos(u * c), s.push(d)
          }
          return s
        }
      }, {
        key: "polarToCartesian",
        value: function (r, n, s, c) {
          var u = (c - 90) * Math.PI / 180;
          return {
            x: r + s * Math.cos(u),
            y: n + s * Math.sin(u)
          }
        }
      }, {
        key: "escapeString",
        value: function (r) {
          var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x",
            s = r.toString().slice();
          return s = s.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, n)
        }
      }, {
        key: "negToZero",
        value: function (r) {
          return r < 0 ? 0 : r
        }
      }, {
        key: "moveIndexInArray",
        value: function (r, n, s) {
          if (s >= r.length)
            for (var c = s - r.length + 1; c--;) r.push(void 0);
          return r.splice(s, 0, r.splice(n, 1)[0]), r
        }
      }, {
        key: "extractNumber",
        value: function (r) {
          return parseFloat(r.replace(/[^\d.]*/g, ""))
        }
      }, {
        key: "findAncestor",
        value: function (r, n) {
          for (;
            (r = r.parentElement) && !r.classList.contains(n););
          return r
        }
      }, {
        key: "setELstyles",
        value: function (r, n) {
          for (var s in n) n.hasOwnProperty(s) && (r.style.key = n[s])
        }
      }, {
        key: "isNumber",
        value: function (r) {
          return !isNaN(r) && parseFloat(Number(r)) === r && !isNaN(parseInt(r, 10))
        }
      }, {
        key: "isFloat",
        value: function (r) {
          return Number(r) === r && r % 1 != 0
        }
      }, {
        key: "isSafari",
        value: function () {
          return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
        }
      }, {
        key: "isFirefox",
        value: function () {
          return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
        }
      }, {
        key: "isIE11",
        value: function () {
          if (window.navigator.userAgent.indexOf("MSIE") !== -1 || window.navigator.appVersion.indexOf("Trident/") > -1) return !0
        }
      }, {
        key: "isIE",
        value: function () {
          var r = window.navigator.userAgent,
            n = r.indexOf("MSIE ");
          if (n > 0) return parseInt(r.substring(n + 5, r.indexOf(".", n)), 10);
          if (r.indexOf("Trident/") > 0) {
            var s = r.indexOf("rv:");
            return parseInt(r.substring(s + 3, r.indexOf(".", s)), 10)
          }
          var c = r.indexOf("Edge/");
          return c > 0 && parseInt(r.substring(c + 5, r.indexOf(".", c)), 10)
        }
      }]), Y
    }(),
    N = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.setEasingFunctions()
      }
      return p(Y, [{
        key: "setEasingFunctions",
        value: function () {
          var r;
          if (!this.w.globals.easing) {
            switch (this.w.config.chart.animations.easing) {
              case "linear":
                r = "-";
                break;
              case "easein":
                r = "<";
                break;
              case "easeout":
                r = ">";
                break;
              case "easeinout":
              default:
                r = "<>";
                break;
              case "swing":
                r = function (n) {
                  var s = 1.70158;
                  return (n -= 1) * n * ((s + 1) * n + s) + 1
                };
                break;
              case "bounce":
                r = function (n) {
                  return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375
                };
                break;
              case "elastic":
                r = function (n) {
                  return n === !!n ? n : Math.pow(2, -10 * n) * Math.sin((n - .075) * (2 * Math.PI) / .3) + 1
                }
            }
            this.w.globals.easing = r
          }
        }
      }, {
        key: "animateLine",
        value: function (r, n, s, c) {
          r.attr(n).animate(c).attr(s)
        }
      }, {
        key: "animateMarker",
        value: function (r, n, s, c, u, d) {
          n || (n = 0), r.attr({
            r: n,
            width: n,
            height: n
          }).animate(c, u).attr({
            r: s,
            width: s.width,
            height: s.height
          }).afterAll(function () {
            d()
          })
        }
      }, {
        key: "animateCircle",
        value: function (r, n, s, c, u) {
          r.attr({
            r: n.r,
            cx: n.cx,
            cy: n.cy
          }).animate(c, u).attr({
            r: s.r,
            cx: s.cx,
            cy: s.cy
          })
        }
      }, {
        key: "animateRect",
        value: function (r, n, s, c, u) {
          r.attr(n).animate(c).attr(s).afterAll(function () {
            return u()
          })
        }
      }, {
        key: "animatePathsGradually",
        value: function (r) {
          var n = r.el,
            s = r.realIndex,
            c = r.j,
            u = r.fill,
            d = r.pathFrom,
            f = r.pathTo,
            g = r.speed,
            b = r.delay,
            y = this.w,
            x = 0;
          y.config.chart.animations.animateGradually.enabled && (x = y.config.chart.animations.animateGradually.delay), y.config.chart.animations.dynamicAnimation.enabled && y.globals.dataChanged && y.config.chart.type !== "bar" && (x = 0), this.morphSVG(n, s, c, y.config.chart.type !== "line" || y.globals.comboCharts ? u : "stroke", d, f, g, b * x)
        }
      }, {
        key: "showDelayedElements",
        value: function () {
          this.w.globals.delayedElements.forEach(function (r) {
            var n = r.el;
            n.classList.remove("apexcharts-element-hidden"), n.classList.add("apexcharts-hidden-element-shown")
          })
        }
      }, {
        key: "animationCompleted",
        value: function (r) {
          var n = this.w;
          n.globals.animationEnded || (n.globals.animationEnded = !0, this.showDelayedElements(), typeof n.config.chart.events.animationEnd == "function" && n.config.chart.events.animationEnd(this.ctx, {
            el: r,
            w: n
          }))
        }
      }, {
        key: "morphSVG",
        value: function (r, n, s, c, u, d, f, g) {
          var b = this,
            y = this.w;
          u || (u = r.attr("pathFrom")), d || (d = r.attr("pathTo"));
          var x = function (_) {
            return y.config.chart.type === "radar" && (f = 1), "M 0 ".concat(y.globals.gridHeight)
          };
          (!u || u.indexOf("undefined") > -1 || u.indexOf("NaN") > -1) && (u = x()), (!d || d.indexOf("undefined") > -1 || d.indexOf("NaN") > -1) && (d = x()), y.globals.shouldAnimate || (f = 1), r.plot(u).animate(1, y.globals.easing, g).plot(u).animate(f, y.globals.easing, g).plot(d).afterAll(function () {
            I.isNumber(s) ? s === y.globals.series[y.globals.maxValsInArrayIndex].length - 2 && y.globals.shouldAnimate && b.animationCompleted(r) : c !== "none" && y.globals.shouldAnimate && (!y.globals.comboCharts && n === y.globals.series.length - 1 || y.globals.comboCharts) && b.animationCompleted(r), b.showDelayedElements()
          })
        }
      }]), Y
    }(),
    U = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "getDefaultFilter",
        value: function (r, n) {
          var s = this.w;
          r.unfilter(!0), new window.SVG.Filter().size("120%", "180%", "-5%", "-40%"), s.config.states.normal.filter !== "none" ? this.applyFilter(r, n, s.config.states.normal.filter.type, s.config.states.normal.filter.value) : s.config.chart.dropShadow.enabled && this.dropShadow(r, s.config.chart.dropShadow, n)
        }
      }, {
        key: "addNormalFilter",
        value: function (r, n) {
          var s = this.w;
          s.config.chart.dropShadow.enabled && !r.node.classList.contains("apexcharts-marker") && this.dropShadow(r, s.config.chart.dropShadow, n)
        }
      }, {
        key: "addLightenFilter",
        value: function (r, n, s) {
          var c = this,
            u = this.w,
            d = s.intensity;
          r.unfilter(!0), new window.SVG.Filter, r.filter(function (f) {
            var g = u.config.chart.dropShadow;
            (g.enabled ? c.addShadow(f, n, g) : f).componentTransfer({
              rgb: {
                type: "linear",
                slope: 1.5,
                intercept: d
              }
            })
          }), r.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(r.filterer.node)
        }
      }, {
        key: "addDarkenFilter",
        value: function (r, n, s) {
          var c = this,
            u = this.w,
            d = s.intensity;
          r.unfilter(!0), new window.SVG.Filter, r.filter(function (f) {
            var g = u.config.chart.dropShadow;
            (g.enabled ? c.addShadow(f, n, g) : f).componentTransfer({
              rgb: {
                type: "linear",
                slope: d
              }
            })
          }), r.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(r.filterer.node)
        }
      }, {
        key: "applyFilter",
        value: function (r, n, s) {
          var c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : .5;
          switch (s) {
            case "none":
              this.addNormalFilter(r, n);
              break;
            case "lighten":
              this.addLightenFilter(r, n, {
                intensity: c
              });
              break;
            case "darken":
              this.addDarkenFilter(r, n, {
                intensity: c
              })
          }
        }
      }, {
        key: "addShadow",
        value: function (r, n, s) {
          var c = s.blur,
            u = s.top,
            d = s.left,
            f = s.color,
            g = s.opacity,
            b = r.flood(Array.isArray(f) ? f[n] : f, g).composite(r.sourceAlpha, "in").offset(d, u).gaussianBlur(c).merge(r.source);
          return r.blend(r.source, b)
        }
      }, {
        key: "dropShadow",
        value: function (r, n) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
            c = n.top,
            u = n.left,
            d = n.blur,
            f = n.color,
            g = n.opacity,
            b = n.noUserSpaceOnUse,
            y = this.w;
          return r.unfilter(!0), I.isIE() && y.config.chart.type === "radialBar" || (f = Array.isArray(f) ? f[s] : f, r.filter(function (x) {
            var _ = null;
            _ = I.isSafari() || I.isFirefox() || I.isIE() ? x.flood(f, g).composite(x.sourceAlpha, "in").offset(u, c).gaussianBlur(d) : x.flood(f, g).composite(x.sourceAlpha, "in").offset(u, c).gaussianBlur(d).merge(x.source), x.blend(x.source, _)
          }), b || r.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(r.filterer.node)), r
        }
      }, {
        key: "setSelectionFilter",
        value: function (r, n, s) {
          var c = this.w;
          if (c.globals.selectedDataPoints[n] !== void 0 && c.globals.selectedDataPoints[n].indexOf(s) > -1) {
            r.node.setAttribute("selected", !0);
            var u = c.config.states.active.filter;
            u !== "none" && this.applyFilter(r, n, u.type, u.value)
          }
        }
      }, {
        key: "_scaleFilterSize",
        value: function (r) {
          (function (n) {
            for (var s in n) n.hasOwnProperty(s) && r.setAttribute(s, n[s])
          })({
            width: "200%",
            height: "200%",
            x: "-50%",
            y: "-50%"
          })
        }
      }]), Y
    }(),
    W = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "roundPathCorners",
        value: function (r, n) {
          function s(ee, ge, pe) {
            var Fe = ge.x - ee.x,
              Ue = ge.y - ee.y,
              Ve = Math.sqrt(Fe * Fe + Ue * Ue);
            return c(ee, ge, Math.min(1, pe / Ve))
          }

          function c(ee, ge, pe) {
            return {
              x: ee.x + (ge.x - ee.x) * pe,
              y: ee.y + (ge.y - ee.y) * pe
            }
          }

          function u(ee, ge) {
            ee.length > 2 && (ee[ee.length - 2] = ge.x, ee[ee.length - 1] = ge.y)
          }

          function d(ee) {
            return {
              x: parseFloat(ee[ee.length - 2]),
              y: parseFloat(ee[ee.length - 1])
            }
          }
          r.indexOf("NaN") > -1 && (r = "");
          var f = r.split(/[,\s]/).reduce(function (ee, ge) {
              var pe = ge.match("([a-zA-Z])(.+)");
              return pe ? (ee.push(pe[1]), ee.push(pe[2])) : ee.push(ge), ee
            }, []).reduce(function (ee, ge) {
              return parseFloat(ge) == ge && ee.length ? ee[ee.length - 1].push(ge) : ee.push([ge]), ee
            }, []),
            g = [];
          if (f.length > 1) {
            var b = d(f[0]),
              y = null;
            f[f.length - 1][0] == "Z" && f[0].length > 2 && (y = ["L", b.x, b.y], f[f.length - 1] = y), g.push(f[0]);
            for (var x = 1; x < f.length; x++) {
              var _ = g[g.length - 1],
                T = f[x],
                P = T == y ? f[1] : f[x + 1];
              if (P && _ && _.length > 2 && T[0] == "L" && P.length > 2 && P[0] == "L") {
                var O, $, G = d(_),
                  Q = d(T),
                  v = d(P);
                O = s(Q, G, n), $ = s(Q, v, n), u(T, O), T.origPoint = Q, g.push(T);
                var C = c(O, Q, .5),
                  L = c(Q, $, .5),
                  H = ["C", C.x, C.y, L.x, L.y, $.x, $.y];
                H.origPoint = Q, g.push(H)
              } else g.push(T)
            }
            if (y) {
              var q = d(g[g.length - 1]);
              g.push(["Z"]), u(g[0], q)
            }
          } else g = f;
          return g.reduce(function (ee, ge) {
            return ee + ge.join(" ") + " "
          }, "")
        }
      }, {
        key: "drawLine",
        value: function (r, n, s, c) {
          var u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#a8a8a8",
            d = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0,
            f = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null,
            g = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : "butt";
          return this.w.globals.dom.Paper.line().attr({
            x1: r,
            y1: n,
            x2: s,
            y2: c,
            stroke: u,
            "stroke-dasharray": d,
            "stroke-width": f,
            "stroke-linecap": g
          })
        }
      }, {
        key: "drawRect",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0,
            n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0,
            s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0,
            c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
            u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0,
            d = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "#fefefe",
            f = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1,
            g = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null,
            b = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : null,
            y = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 0,
            x = this.w.globals.dom.Paper.rect();
          return x.attr({
            x: r,
            y: n,
            width: s > 0 ? s : 0,
            height: c > 0 ? c : 0,
            rx: u,
            ry: u,
            opacity: f,
            "stroke-width": g !== null ? g : 0,
            stroke: b !== null ? b : "none",
            "stroke-dasharray": y
          }), x.node.setAttribute("fill", d), x
        }
      }, {
        key: "drawPolygon",
        value: function (r) {
          var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#e1e1e1",
            s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1,
            c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "none";
          return this.w.globals.dom.Paper.polygon(r).attr({
            fill: c,
            stroke: n,
            "stroke-width": s
          })
        }
      }, {
        key: "drawCircle",
        value: function (r) {
          var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          r < 0 && (r = 0);
          var s = this.w.globals.dom.Paper.circle(2 * r);
          return n !== null && s.attr(n), s
        }
      }, {
        key: "drawPath",
        value: function (r) {
          var n = r.d,
            s = n === void 0 ? "" : n,
            c = r.stroke,
            u = c === void 0 ? "#a8a8a8" : c,
            d = r.strokeWidth,
            f = d === void 0 ? 1 : d,
            g = r.fill,
            b = r.fillOpacity,
            y = b === void 0 ? 1 : b,
            x = r.strokeOpacity,
            _ = x === void 0 ? 1 : x,
            T = r.classes,
            P = r.strokeLinecap,
            O = P === void 0 ? null : P,
            $ = r.strokeDashArray,
            G = $ === void 0 ? 0 : $,
            Q = this.w;
          return O === null && (O = Q.config.stroke.lineCap), (s.indexOf("undefined") > -1 || s.indexOf("NaN") > -1) && (s = "M 0 ".concat(Q.globals.gridHeight)), Q.globals.dom.Paper.path(s).attr({
            fill: g,
            "fill-opacity": y,
            stroke: u,
            "stroke-opacity": _,
            "stroke-linecap": O,
            "stroke-width": f,
            "stroke-dasharray": G,
            class: T
          })
        }
      }, {
        key: "group",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null,
            n = this.w.globals.dom.Paper.group();
          return r !== null && n.attr(r), n
        }
      }, {
        key: "move",
        value: function (r, n) {
          var s = ["M", r, n].join(" ");
          return s
        }
      }, {
        key: "line",
        value: function (r, n) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
            c = null;
          return s === null ? c = [" L", r, n].join(" ") : s === "H" ? c = [" H", r].join(" ") : s === "V" && (c = [" V", n].join(" ")), c
        }
      }, {
        key: "curve",
        value: function (r, n, s, c, u, d) {
          var f = ["C", r, n, s, c, u, d].join(" ");
          return f
        }
      }, {
        key: "quadraticCurve",
        value: function (r, n, s, c) {
          return ["Q", r, n, s, c].join(" ")
        }
      }, {
        key: "arc",
        value: function (r, n, s, c, u, d, f) {
          var g = "A";
          arguments.length > 7 && arguments[7] !== void 0 && arguments[7] && (g = "a");
          var b = [g, r, n, s, c, u, d, f].join(" ");
          return b
        }
      }, {
        key: "renderPaths",
        value: function (r) {
          var n, s = r.j,
            c = r.realIndex,
            u = r.pathFrom,
            d = r.pathTo,
            f = r.stroke,
            g = r.strokeWidth,
            b = r.strokeLinecap,
            y = r.fill,
            x = r.animationDelay,
            _ = r.initialSpeed,
            T = r.dataChangeSpeed,
            P = r.className,
            O = r.shouldClipToGrid,
            $ = O === void 0 || O,
            G = r.bindEventsOnPaths,
            Q = G === void 0 || G,
            v = r.drawShadow,
            C = v === void 0 || v,
            L = this.w,
            H = new U(this.ctx),
            q = new N(this.ctx),
            ee = this.w.config.chart.animations.enabled,
            ge = ee && this.w.config.chart.animations.dynamicAnimation.enabled,
            pe = !!(ee && !L.globals.resized || ge && L.globals.dataChanged && L.globals.shouldAnimate);
          pe ? n = u : (n = d, L.globals.animationEnded = !0);
          var Fe = L.config.stroke.dashArray,
            Ue = 0;
          Ue = Array.isArray(Fe) ? Fe[c] : L.config.stroke.dashArray;
          var Ve = this.drawPath({
            d: n,
            stroke: f,
            strokeWidth: g,
            fill: y,
            fillOpacity: 1,
            classes: P,
            strokeLinecap: b,
            strokeDashArray: Ue
          });
          if (Ve.attr("index", c), $ && Ve.attr({
              "clip-path": "url(#gridRectMask".concat(L.globals.cuid, ")")
            }), L.config.states.normal.filter.type !== "none") H.getDefaultFilter(Ve, c);
          else if (L.config.chart.dropShadow.enabled && C && (!L.config.chart.dropShadow.enabledOnSeries || L.config.chart.dropShadow.enabledOnSeries && L.config.chart.dropShadow.enabledOnSeries.indexOf(c) !== -1)) {
            var it = L.config.chart.dropShadow;
            H.dropShadow(Ve, it, c)
          }
          Q && (Ve.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, Ve)), Ve.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, Ve)), Ve.node.addEventListener("mousedown", this.pathMouseDown.bind(this, Ve))), Ve.attr({
            pathTo: d,
            pathFrom: u
          });
          var dt = {
            el: Ve,
            j: s,
            realIndex: c,
            pathFrom: u,
            pathTo: d,
            fill: y,
            strokeWidth: g,
            delay: x
          };
          return !ee || L.globals.resized || L.globals.dataChanged ? !L.globals.resized && L.globals.dataChanged || q.showDelayedElements() : q.animatePathsGradually(i(i({}, dt), {}, {
            speed: _
          })), L.globals.dataChanged && ge && pe && q.animatePathsGradually(i(i({}, dt), {}, {
            speed: T
          })), Ve
        }
      }, {
        key: "drawPattern",
        value: function (r, n, s) {
          var c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "#a8a8a8",
            u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
          return this.w.globals.dom.Paper.pattern(n, s, function (d) {
            r === "horizontalLines" ? d.line(0, 0, s, 0).stroke({
              color: c,
              width: u + 1
            }) : r === "verticalLines" ? d.line(0, 0, 0, n).stroke({
              color: c,
              width: u + 1
            }) : r === "slantedLines" ? d.line(0, 0, n, s).stroke({
              color: c,
              width: u
            }) : r === "squares" ? d.rect(n, s).fill("none").stroke({
              color: c,
              width: u
            }) : r === "circles" && d.circle(n).fill("none").stroke({
              color: c,
              width: u
            })
          })
        }
      }, {
        key: "drawGradient",
        value: function (r, n, s, c, u) {
          var d, f = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null,
            g = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : null,
            b = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : null,
            y = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 0,
            x = this.w;
          n.length < 9 && n.indexOf("#") === 0 && (n = I.hexToRgba(n, c)), s.length < 9 && s.indexOf("#") === 0 && (s = I.hexToRgba(s, u));
          var _ = 0,
            T = 1,
            P = 1,
            O = null;
          g !== null && (_ = g[0] !== void 0 ? g[0] / 100 : 0, T = g[1] !== void 0 ? g[1] / 100 : 1, P = g[2] !== void 0 ? g[2] / 100 : 1, O = g[3] !== void 0 ? g[3] / 100 : null);
          var $ = !(x.config.chart.type !== "donut" && x.config.chart.type !== "pie" && x.config.chart.type !== "polarArea" && x.config.chart.type !== "bubble");
          if (d = b === null || b.length === 0 ? x.globals.dom.Paper.gradient($ ? "radial" : "linear", function (v) {
              v.at(_, n, c), v.at(T, s, u), v.at(P, s, u), O !== null && v.at(O, n, c)
            }) : x.globals.dom.Paper.gradient($ ? "radial" : "linear", function (v) {
              (Array.isArray(b[y]) ? b[y] : b).forEach(function (C) {
                v.at(C.offset / 100, C.color, C.opacity)
              })
            }), $) {
            var G = x.globals.gridWidth / 2,
              Q = x.globals.gridHeight / 2;
            x.config.chart.type !== "bubble" ? d.attr({
              gradientUnits: "userSpaceOnUse",
              cx: G,
              cy: Q,
              r: f
            }) : d.attr({
              cx: .5,
              cy: .5,
              r: .8,
              fx: .2,
              fy: .2
            })
          } else r === "vertical" ? d.from(0, 0).to(0, 1) : r === "diagonal" ? d.from(0, 0).to(1, 1) : r === "horizontal" ? d.from(0, 1).to(1, 1) : r === "diagonal2" && d.from(1, 0).to(0, 1);
          return d
        }
      }, {
        key: "getTextBasedOnMaxWidth",
        value: function (r) {
          var n = r.text,
            s = r.maxWidth,
            c = r.fontSize,
            u = r.fontFamily,
            d = this.getTextRects(n, c, u),
            f = d.width / n.length,
            g = Math.floor(s / f);
          return s < d.width ? n.slice(0, g - 3) + "..." : n
        }
      }, {
        key: "drawText",
        value: function (r) {
          var n = this,
            s = r.x,
            c = r.y,
            u = r.text,
            d = r.textAnchor,
            f = r.fontSize,
            g = r.fontFamily,
            b = r.fontWeight,
            y = r.foreColor,
            x = r.opacity,
            _ = r.maxWidth,
            T = r.cssClass,
            P = T === void 0 ? "" : T,
            O = r.isPlainText,
            $ = O === void 0 || O,
            G = r.dominantBaseline,
            Q = G === void 0 ? "auto" : G,
            v = this.w;
          u === void 0 && (u = "");
          var C = u;
          d || (d = "start"), y && y.length || (y = v.config.chart.foreColor), g = g || v.config.chart.fontFamily, b = b || "regular";
          var L, H = {
            maxWidth: _,
            fontSize: f = f || "11px",
            fontFamily: g
          };
          return Array.isArray(u) ? L = v.globals.dom.Paper.text(function (q) {
            for (var ee = 0; ee < u.length; ee++) C = u[ee], _ && (C = n.getTextBasedOnMaxWidth(i({
              text: u[ee]
            }, H))), ee === 0 ? q.tspan(C) : q.tspan(C).newLine()
          }) : (_ && (C = this.getTextBasedOnMaxWidth(i({
            text: u
          }, H))), L = $ ? v.globals.dom.Paper.plain(u) : v.globals.dom.Paper.text(function (q) {
            return q.tspan(C)
          })), L.attr({
            x: s,
            y: c,
            "text-anchor": d,
            "dominant-baseline": Q,
            "font-size": f,
            "font-family": g,
            "font-weight": b,
            fill: y,
            class: "apexcharts-text " + P
          }), L.node.style.fontFamily = g, L.node.style.opacity = x, L
        }
      }, {
        key: "drawMarker",
        value: function (r, n, s) {
          r = r || 0;
          var c = s.pSize || 0,
            u = null;
          if (s.shape === "square" || s.shape === "rect") {
            var d = s.pRadius === void 0 ? c / 2 : s.pRadius;
            n !== null && c || (c = 0, d = 0);
            var f = 1.2 * c + d,
              g = this.drawRect(f, f, f, f, d);
            g.attr({
              x: r - f / 2,
              y: n - f / 2,
              cx: r,
              cy: n,
              class: s.class ? s.class : "",
              fill: s.pointFillColor,
              "fill-opacity": s.pointFillOpacity ? s.pointFillOpacity : 1,
              stroke: s.pointStrokeColor,
              "stroke-width": s.pointStrokeWidth ? s.pointStrokeWidth : 0,
              "stroke-opacity": s.pointStrokeOpacity ? s.pointStrokeOpacity : 1
            }), u = g
          } else s.shape !== "circle" && s.shape || (I.isNumber(n) || (c = 0, n = 0), u = this.drawCircle(c, {
            cx: r,
            cy: n,
            class: s.class ? s.class : "",
            stroke: s.pointStrokeColor,
            fill: s.pointFillColor,
            "fill-opacity": s.pointFillOpacity ? s.pointFillOpacity : 1,
            "stroke-width": s.pointStrokeWidth ? s.pointStrokeWidth : 0,
            "stroke-opacity": s.pointStrokeOpacity ? s.pointStrokeOpacity : 1
          }));
          return u
        }
      }, {
        key: "pathMouseEnter",
        value: function (r, n) {
          var s = this.w,
            c = new U(this.ctx),
            u = parseInt(r.node.getAttribute("index"), 10),
            d = parseInt(r.node.getAttribute("j"), 10);
          if (typeof s.config.chart.events.dataPointMouseEnter == "function" && s.config.chart.events.dataPointMouseEnter(n, this.ctx, {
              seriesIndex: u,
              dataPointIndex: d,
              w: s
            }), this.ctx.events.fireEvent("dataPointMouseEnter", [n, this.ctx, {
              seriesIndex: u,
              dataPointIndex: d,
              w: s
            }]), (s.config.states.active.filter.type === "none" || r.node.getAttribute("selected") !== "true") && s.config.states.hover.filter.type !== "none" && !s.globals.isTouchDevice) {
            var f = s.config.states.hover.filter;
            c.applyFilter(r, u, f.type, f.value)
          }
        }
      }, {
        key: "pathMouseLeave",
        value: function (r, n) {
          var s = this.w,
            c = new U(this.ctx),
            u = parseInt(r.node.getAttribute("index"), 10),
            d = parseInt(r.node.getAttribute("j"), 10);
          typeof s.config.chart.events.dataPointMouseLeave == "function" && s.config.chart.events.dataPointMouseLeave(n, this.ctx, {
            seriesIndex: u,
            dataPointIndex: d,
            w: s
          }), this.ctx.events.fireEvent("dataPointMouseLeave", [n, this.ctx, {
            seriesIndex: u,
            dataPointIndex: d,
            w: s
          }]), s.config.states.active.filter.type !== "none" && r.node.getAttribute("selected") === "true" || s.config.states.hover.filter.type !== "none" && c.getDefaultFilter(r, u)
        }
      }, {
        key: "pathMouseDown",
        value: function (r, n) {
          var s = this.w,
            c = new U(this.ctx),
            u = parseInt(r.node.getAttribute("index"), 10),
            d = parseInt(r.node.getAttribute("j"), 10),
            f = "false";
          if (r.node.getAttribute("selected") === "true") {
            if (r.node.setAttribute("selected", "false"), s.globals.selectedDataPoints[u].indexOf(d) > -1) {
              var g = s.globals.selectedDataPoints[u].indexOf(d);
              s.globals.selectedDataPoints[u].splice(g, 1)
            }
          } else {
            if (!s.config.states.active.allowMultipleDataPointsSelection && s.globals.selectedDataPoints.length > 0) {
              s.globals.selectedDataPoints = [];
              var b = s.globals.dom.Paper.select(".apexcharts-series path").members,
                y = s.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,
                x = function (P) {
                  Array.prototype.forEach.call(P, function (O) {
                    O.node.setAttribute("selected", "false"), c.getDefaultFilter(O, u)
                  })
                };
              x(b), x(y)
            }
            r.node.setAttribute("selected", "true"), f = "true", s.globals.selectedDataPoints[u] === void 0 && (s.globals.selectedDataPoints[u] = []), s.globals.selectedDataPoints[u].push(d)
          }
          if (f === "true") {
            var _ = s.config.states.active.filter;
            if (_ !== "none") c.applyFilter(r, u, _.type, _.value);
            else if (s.config.states.hover.filter !== "none" && !s.globals.isTouchDevice) {
              var T = s.config.states.hover.filter;
              c.applyFilter(r, u, T.type, T.value)
            }
          } else s.config.states.active.filter.type !== "none" && (s.config.states.hover.filter.type === "none" || s.globals.isTouchDevice ? c.getDefaultFilter(r, u) : (T = s.config.states.hover.filter, c.applyFilter(r, u, T.type, T.value)));
          typeof s.config.chart.events.dataPointSelection == "function" && s.config.chart.events.dataPointSelection(n, this.ctx, {
            selectedDataPoints: s.globals.selectedDataPoints,
            seriesIndex: u,
            dataPointIndex: d,
            w: s
          }), n && this.ctx.events.fireEvent("dataPointSelection", [n, this.ctx, {
            selectedDataPoints: s.globals.selectedDataPoints,
            seriesIndex: u,
            dataPointIndex: d,
            w: s
          }])
        }
      }, {
        key: "rotateAroundCenter",
        value: function (r) {
          var n = {};
          return r && typeof r.getBBox == "function" && (n = r.getBBox()), {
            x: n.x + n.width / 2,
            y: n.y + n.height / 2
          }
        }
      }, {
        key: "getTextRects",
        value: function (r, n, s, c) {
          var u = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4],
            d = this.w,
            f = this.drawText({
              x: -200,
              y: -200,
              text: r,
              textAnchor: "start",
              fontSize: n,
              fontFamily: s,
              foreColor: "#fff",
              opacity: 0
            });
          c && f.attr("transform", c), d.globals.dom.Paper.add(f);
          var g = f.bbox();
          return u || (g = f.node.getBoundingClientRect()), f.remove(), {
            width: g.width,
            height: g.height
          }
        }
      }, {
        key: "placeTextWithEllipsis",
        value: function (r, n, s) {
          if (typeof r.getComputedTextLength == "function" && (r.textContent = n, n.length > 0 && r.getComputedTextLength() >= s / 1.1)) {
            for (var c = n.length - 3; c > 0; c -= 3)
              if (r.getSubStringLength(0, c) <= s / 1.1) return void(r.textContent = n.substring(0, c) + "...");
            r.textContent = "."
          }
        }
      }], [{
        key: "setAttrs",
        value: function (r, n) {
          for (var s in n) n.hasOwnProperty(s) && r.setAttribute(s, n[s])
        }
      }]), Y
    }(),
    X = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "getStackedSeriesTotals",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
            n = this.w,
            s = [];
          if (n.globals.series.length === 0) return s;
          for (var c = 0; c < n.globals.series[n.globals.maxValsInArrayIndex].length; c++) {
            for (var u = 0, d = 0; d < n.globals.series.length; d++) n.globals.series[d][c] !== void 0 && r.indexOf(d) === -1 && (u += n.globals.series[d][c]);
            s.push(u)
          }
          return s
        }
      }, {
        key: "getSeriesTotalByIndex",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          return r === null ? this.w.config.series.reduce(function (n, s) {
            return n + s
          }, 0) : this.w.globals.series[r].reduce(function (n, s) {
            return n + s
          }, 0)
        }
      }, {
        key: "getStackedSeriesTotalsByGroups",
        value: function () {
          var r = this,
            n = this.w,
            s = [];
          return n.globals.seriesGroups.forEach(function (c) {
            var u = [];
            n.config.series.forEach(function (f, g) {
              c.indexOf(f.name) > -1 && u.push(g)
            });
            var d = n.globals.series.map(function (f, g) {
              return u.indexOf(g) === -1 ? g : -1
            }).filter(function (f) {
              return f !== -1
            });
            s.push(r.getStackedSeriesTotals(d))
          }), s
        }
      }, {
        key: "isSeriesNull",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          return (r === null ? this.w.config.series.filter(function (n) {
            return n !== null
          }) : this.w.config.series[r].data.filter(function (n) {
            return n !== null
          })).length === 0
        }
      }, {
        key: "seriesHaveSameValues",
        value: function (r) {
          return this.w.globals.series[r].every(function (n, s, c) {
            return n === c[0]
          })
        }
      }, {
        key: "getCategoryLabels",
        value: function (r) {
          var n = this.w,
            s = r.slice();
          return n.config.xaxis.convertedCatToNumeric && (s = r.map(function (c, u) {
            return n.config.xaxis.labels.formatter(c - n.globals.minX + 1)
          })), s
        }
      }, {
        key: "getLargestSeries",
        value: function () {
          var r = this.w;
          r.globals.maxValsInArrayIndex = r.globals.series.map(function (n) {
            return n.length
          }).indexOf(Math.max.apply(Math, r.globals.series.map(function (n) {
            return n.length
          })))
        }
      }, {
        key: "getLargestMarkerSize",
        value: function () {
          var r = this.w,
            n = 0;
          return r.globals.markers.size.forEach(function (s) {
            n = Math.max(n, s)
          }), r.config.markers.discrete && r.config.markers.discrete.length && r.config.markers.discrete.forEach(function (s) {
            n = Math.max(n, s.size)
          }), n > 0 && (n += r.config.markers.hover.sizeOffset + 1), r.globals.markers.largestSize = n, n
        }
      }, {
        key: "getSeriesTotals",
        value: function () {
          var r = this.w;
          r.globals.seriesTotals = r.globals.series.map(function (n, s) {
            var c = 0;
            if (Array.isArray(n))
              for (var u = 0; u < n.length; u++) c += n[u];
            else c += n;
            return c
          })
        }
      }, {
        key: "getSeriesTotalsXRange",
        value: function (r, n) {
          var s = this.w;
          return s.globals.series.map(function (c, u) {
            for (var d = 0, f = 0; f < c.length; f++) s.globals.seriesX[u][f] > r && s.globals.seriesX[u][f] < n && (d += c[f]);
            return d
          })
        }
      }, {
        key: "getPercentSeries",
        value: function () {
          var r = this.w;
          r.globals.seriesPercent = r.globals.series.map(function (n, s) {
            var c = [];
            if (Array.isArray(n))
              for (var u = 0; u < n.length; u++) {
                var d = r.globals.stackedSeriesTotals[u],
                  f = 0;
                d && (f = 100 * n[u] / d), c.push(f)
              } else {
                var g = 100 * n / r.globals.seriesTotals.reduce(function (b, y) {
                  return b + y
                }, 0);
                c.push(g)
              }
            return c
          })
        }
      }, {
        key: "getCalculatedRatios",
        value: function () {
          var r, n, s, c = this.w.globals,
            u = [],
            d = 0,
            f = [],
            g = .1,
            b = 0;
          if (c.yRange = [], c.isMultipleYAxis)
            for (var y = 0; y < c.minYArr.length; y++) c.yRange.push(Math.abs(c.minYArr[y] - c.maxYArr[y])), f.push(0);
          else c.yRange.push(Math.abs(c.minY - c.maxY));
          c.xRange = Math.abs(c.maxX - c.minX), c.zRange = Math.abs(c.maxZ - c.minZ);
          for (var x = 0; x < c.yRange.length; x++) u.push(c.yRange[x] / c.gridHeight);
          if (n = c.xRange / c.gridWidth, r = c.yRange / c.gridWidth, s = c.xRange / c.gridHeight, (d = c.zRange / c.gridHeight * 16) || (d = 1), c.minY !== Number.MIN_VALUE && Math.abs(c.minY) !== 0 && (c.hasNegs = !0), c.isMultipleYAxis) {
            f = [];
            for (var _ = 0; _ < u.length; _++) f.push(-c.minYArr[_] / u[_])
          } else f.push(-c.minY / u[0]), c.minY !== Number.MIN_VALUE && Math.abs(c.minY) !== 0 && (g = -c.minY / r, b = c.minX / n);
          return {
            yRatio: u,
            invertedYRatio: r,
            zRatio: d,
            xRatio: n,
            invertedXRatio: s,
            baseLineInvertedY: g,
            baseLineY: f,
            baseLineX: b
          }
        }
      }, {
        key: "getLogSeries",
        value: function (r) {
          var n = this,
            s = this.w;
          return s.globals.seriesLog = r.map(function (c, u) {
            return s.config.yaxis[u] && s.config.yaxis[u].logarithmic ? c.map(function (d) {
              return d === null ? null : n.getLogVal(s.config.yaxis[u].logBase, d, u)
            }) : c
          }), s.globals.invalidLogScale ? r : s.globals.seriesLog
        }
      }, {
        key: "getBaseLog",
        value: function (r, n) {
          return Math.log(n) / Math.log(r)
        }
      }, {
        key: "getLogVal",
        value: function (r, n, s) {
          if (n === 0) return 0;
          var c = this.w,
            u = c.globals.minYArr[s] === 0 ? -1 : this.getBaseLog(r, c.globals.minYArr[s]),
            d = (c.globals.maxYArr[s] === 0 ? 0 : this.getBaseLog(r, c.globals.maxYArr[s])) - u;
          return n < 1 ? n / d : (this.getBaseLog(r, n) - u) / d
        }
      }, {
        key: "getLogYRatios",
        value: function (r) {
          var n = this,
            s = this.w,
            c = this.w.globals;
          return c.yLogRatio = r.slice(), c.logYRange = c.yRange.map(function (u, d) {
            if (s.config.yaxis[d] && n.w.config.yaxis[d].logarithmic) {
              var f, g = -Number.MAX_VALUE,
                b = Number.MIN_VALUE;
              return c.seriesLog.forEach(function (y, x) {
                y.forEach(function (_) {
                  s.config.yaxis[x] && s.config.yaxis[x].logarithmic && (g = Math.max(_, g), b = Math.min(_, b))
                })
              }), f = Math.pow(c.yRange[d], Math.abs(b - g) / c.yRange[d]), c.yLogRatio[d] = f / c.gridHeight, f
            }
          }), c.invalidLogScale ? r.slice() : c.yLogRatio
        }
      }], [{
        key: "checkComboSeries",
        value: function (r) {
          var n = !1,
            s = 0,
            c = 0;
          return r.length && r[0].type !== void 0 && r.forEach(function (u) {
            u.type !== "bar" && u.type !== "column" && u.type !== "candlestick" && u.type !== "boxPlot" || s++, u.type !== void 0 && c++
          }), c > 0 && (n = !0), {
            comboBarCount: s,
            comboCharts: n
          }
        }
      }, {
        key: "extendArrayProps",
        value: function (r, n, s) {
          return n.yaxis && (n = r.extendYAxis(n, s)), n.annotations && (n.annotations.yaxis && (n = r.extendYAxisAnnotations(n)), n.annotations.xaxis && (n = r.extendXAxisAnnotations(n)), n.annotations.points && (n = r.extendPointAnnotations(n))), n
        }
      }]), Y
    }(),
    V = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.annoCtx = r
      }
      return p(Y, [{
        key: "setOrientations",
        value: function (r) {
          var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
            s = this.w;
          if (r.label.orientation === "vertical") {
            var c = n !== null ? n : 0,
              u = s.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(c, "']"));
            if (u !== null) {
              var d = u.getBoundingClientRect();
              u.setAttribute("x", parseFloat(u.getAttribute("x")) - d.height + 4), r.label.position === "top" ? u.setAttribute("y", parseFloat(u.getAttribute("y")) + d.width) : u.setAttribute("y", parseFloat(u.getAttribute("y")) - d.width);
              var f = this.annoCtx.graphics.rotateAroundCenter(u),
                g = f.x,
                b = f.y;
              u.setAttribute("transform", "rotate(-90 ".concat(g, " ").concat(b, ")"))
            }
          }
        }
      }, {
        key: "addBackgroundToAnno",
        value: function (r, n) {
          var s = this.w;
          if (!r || n.label.text === void 0 || n.label.text !== void 0 && !String(n.label.text).trim()) return null;
          var c = s.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),
            u = r.getBoundingClientRect(),
            d = n.label.style.padding.left,
            f = n.label.style.padding.right,
            g = n.label.style.padding.top,
            b = n.label.style.padding.bottom;
          n.label.orientation === "vertical" && (g = n.label.style.padding.left, b = n.label.style.padding.right, d = n.label.style.padding.top, f = n.label.style.padding.bottom);
          var y = u.left - c.left - d,
            x = u.top - c.top - g,
            _ = this.annoCtx.graphics.drawRect(y - s.globals.barPadForNumericAxis, x, u.width + d + f, u.height + g + b, n.label.borderRadius, n.label.style.background, 1, n.label.borderWidth, n.label.borderColor, 0);
          return n.id && _.node.classList.add(n.id), _
        }
      }, {
        key: "annotationsBackground",
        value: function () {
          var r = this,
            n = this.w,
            s = function (c, u, d) {
              var f = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(d, "-annotations .apexcharts-").concat(d, "-annotation-label[rel='").concat(u, "']"));
              if (f) {
                var g = f.parentNode,
                  b = r.addBackgroundToAnno(f, c);
                b && (g.insertBefore(b.node, f), c.label.mouseEnter && b.node.addEventListener("mouseenter", c.label.mouseEnter.bind(r, c)), c.label.mouseLeave && b.node.addEventListener("mouseleave", c.label.mouseLeave.bind(r, c)), c.label.click && b.node.addEventListener("click", c.label.click.bind(r, c)))
              }
            };
          n.config.annotations.xaxis.map(function (c, u) {
            s(c, u, "xaxis")
          }), n.config.annotations.yaxis.map(function (c, u) {
            s(c, u, "yaxis")
          }), n.config.annotations.points.map(function (c, u) {
            s(c, u, "point")
          })
        }
      }, {
        key: "getY1Y2",
        value: function (r, n) {
          var s, c = r === "y1" ? n.y : n.y2,
            u = this.w;
          if (this.annoCtx.invertAxis) {
            var d = u.globals.labels.indexOf(c);
            u.config.xaxis.convertedCatToNumeric && (d = u.globals.categoryLabels.indexOf(c));
            var f = u.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (d + 1) + ")");
            f && (s = parseFloat(f.getAttribute("y"))), n.seriesIndex !== void 0 && u.globals.barHeight && (s = s - u.globals.barHeight / 2 * (u.globals.series.length - 1) + u.globals.barHeight * n.seriesIndex)
          } else {
            var g;
            u.config.yaxis[n.yAxisIndex].logarithmic ? g = (c = new X(this.annoCtx.ctx).getLogVal(c, n.yAxisIndex)) / u.globals.yLogRatio[n.yAxisIndex] : g = (c - u.globals.minYArr[n.yAxisIndex]) / (u.globals.yRange[n.yAxisIndex] / u.globals.gridHeight), s = u.globals.gridHeight - g, !n.marker || n.y !== void 0 && n.y !== null || (s = 0), u.config.yaxis[n.yAxisIndex] && u.config.yaxis[n.yAxisIndex].reversed && (s = g)
          }
          return typeof c == "string" && c.indexOf("px") > -1 && (s = parseFloat(c)), s
        }
      }, {
        key: "getX1X2",
        value: function (r, n) {
          var s = this.w,
            c = this.annoCtx.invertAxis ? s.globals.minY : s.globals.minX,
            u = this.annoCtx.invertAxis ? s.globals.maxY : s.globals.maxX,
            d = this.annoCtx.invertAxis ? s.globals.yRange[0] : s.globals.xRange,
            f = (n.x - c) / (d / s.globals.gridWidth);
          this.annoCtx.inversedReversedAxis && (f = (u - n.x) / (d / s.globals.gridWidth)), s.config.xaxis.type !== "category" && !s.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || s.globals.dataFormatXNumeric || (f = this.getStringX(n.x));
          var g = (n.x2 - c) / (d / s.globals.gridWidth);
          return this.annoCtx.inversedReversedAxis && (g = (u - n.x2) / (d / s.globals.gridWidth)), s.config.xaxis.type !== "category" && !s.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || s.globals.dataFormatXNumeric || (g = this.getStringX(n.x2)), n.x !== void 0 && n.x !== null || !n.marker || (f = s.globals.gridWidth), r === "x1" && typeof n.x == "string" && n.x.indexOf("px") > -1 && (f = parseFloat(n.x)), r === "x2" && typeof n.x2 == "string" && n.x2.indexOf("px") > -1 && (g = parseFloat(n.x2)), n.seriesIndex !== void 0 && s.globals.barWidth && !this.annoCtx.invertAxis && (f = f - s.globals.barWidth / 2 * (s.globals.series.length - 1) + s.globals.barWidth * n.seriesIndex), r === "x1" ? f : g
        }
      }, {
        key: "getStringX",
        value: function (r) {
          var n = this.w,
            s = r;
          n.config.xaxis.convertedCatToNumeric && n.globals.categoryLabels.length && (r = n.globals.categoryLabels.indexOf(r) + 1);
          var c = n.globals.labels.indexOf(r),
            u = n.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (c + 1) + ")");
          return u && (s = parseFloat(u.getAttribute("x"))), s
        }
      }]), Y
    }(),
    ne = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.annoCtx = r, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new V(this.annoCtx)
      }
      return p(Y, [{
        key: "addXaxisAnnotation",
        value: function (r, n, s) {
          var c, u = this.w,
            d = this.helpers.getX1X2("x1", r),
            f = r.label.text,
            g = r.strokeDashArray;
          if (I.isNumber(d)) {
            if (r.x2 === null || r.x2 === void 0) {
              var b = this.annoCtx.graphics.drawLine(d + r.offsetX, 0 + r.offsetY, d + r.offsetX, u.globals.gridHeight + r.offsetY, r.borderColor, g, r.borderWidth);
              n.appendChild(b.node), r.id && b.node.classList.add(r.id)
            } else {
              if ((c = this.helpers.getX1X2("x2", r)) < d) {
                var y = d;
                d = c, c = y
              }
              var x = this.annoCtx.graphics.drawRect(d + r.offsetX, 0 + r.offsetY, c - d, u.globals.gridHeight + r.offsetY, 0, r.fillColor, r.opacity, 1, r.borderColor, g);
              x.node.classList.add("apexcharts-annotation-rect"), x.attr("clip-path", "url(#gridRectMask".concat(u.globals.cuid, ")")), n.appendChild(x.node), r.id && x.node.classList.add(r.id)
            }
            var _ = this.annoCtx.graphics.getTextRects(f, parseFloat(r.label.style.fontSize)),
              T = r.label.position === "top" ? 4 : r.label.position === "center" ? u.globals.gridHeight / 2 + (r.label.orientation === "vertical" ? _.width / 2 : 0) : u.globals.gridHeight,
              P = this.annoCtx.graphics.drawText({
                x: d + r.label.offsetX,
                y: T + r.label.offsetY - (r.label.orientation === "vertical" ? r.label.position === "top" ? _.width / 2 - 12 : -_.width / 2 : 0),
                text: f,
                textAnchor: r.label.textAnchor,
                fontSize: r.label.style.fontSize,
                fontFamily: r.label.style.fontFamily,
                fontWeight: r.label.style.fontWeight,
                foreColor: r.label.style.color,
                cssClass: "apexcharts-xaxis-annotation-label ".concat(r.label.style.cssClass, " ").concat(r.id ? r.id : "")
              });
            P.attr({
              rel: s
            }), n.appendChild(P.node), this.annoCtx.helpers.setOrientations(r, s)
          }
        }
      }, {
        key: "drawXAxisAnnotations",
        value: function () {
          var r = this,
            n = this.w,
            s = this.annoCtx.graphics.group({
              class: "apexcharts-xaxis-annotations"
            });
          return n.config.annotations.xaxis.map(function (c, u) {
            r.addXaxisAnnotation(c, s.node, u)
          }), s
        }
      }]), Y
    }(),
    Z = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.annoCtx = r, this.helpers = new V(this.annoCtx)
      }
      return p(Y, [{
        key: "addYaxisAnnotation",
        value: function (r, n, s) {
          var c, u = this.w,
            d = r.strokeDashArray,
            f = this.helpers.getY1Y2("y1", r),
            g = r.label.text;
          if (r.y2 === null || r.y2 === void 0) {
            var b = this.annoCtx.graphics.drawLine(0 + r.offsetX, f + r.offsetY, this._getYAxisAnnotationWidth(r), f + r.offsetY, r.borderColor, d, r.borderWidth);
            n.appendChild(b.node), r.id && b.node.classList.add(r.id)
          } else {
            if ((c = this.helpers.getY1Y2("y2", r)) > f) {
              var y = f;
              f = c, c = y
            }
            var x = this.annoCtx.graphics.drawRect(0 + r.offsetX, c + r.offsetY, this._getYAxisAnnotationWidth(r), f - c, 0, r.fillColor, r.opacity, 1, r.borderColor, d);
            x.node.classList.add("apexcharts-annotation-rect"), x.attr("clip-path", "url(#gridRectMask".concat(u.globals.cuid, ")")), n.appendChild(x.node), r.id && x.node.classList.add(r.id)
          }
          var _ = r.label.position === "right" ? u.globals.gridWidth : r.label.position === "center" ? u.globals.gridWidth / 2 : 0,
            T = this.annoCtx.graphics.drawText({
              x: _ + r.label.offsetX,
              y: (c ?? f) + r.label.offsetY - 3,
              text: g,
              textAnchor: r.label.textAnchor,
              fontSize: r.label.style.fontSize,
              fontFamily: r.label.style.fontFamily,
              fontWeight: r.label.style.fontWeight,
              foreColor: r.label.style.color,
              cssClass: "apexcharts-yaxis-annotation-label ".concat(r.label.style.cssClass, " ").concat(r.id ? r.id : "")
            });
          T.attr({
            rel: s
          }), n.appendChild(T.node)
        }
      }, {
        key: "_getYAxisAnnotationWidth",
        value: function (r) {
          var n = this.w;
          return n.globals.gridWidth, (r.width.indexOf("%") > -1 ? n.globals.gridWidth * parseInt(r.width, 10) / 100 : parseInt(r.width, 10)) + r.offsetX
        }
      }, {
        key: "drawYAxisAnnotations",
        value: function () {
          var r = this,
            n = this.w,
            s = this.annoCtx.graphics.group({
              class: "apexcharts-yaxis-annotations"
            });
          return n.config.annotations.yaxis.map(function (c, u) {
            r.addYaxisAnnotation(c, s.node, u)
          }), s
        }
      }]), Y
    }(),
    ie = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.annoCtx = r, this.helpers = new V(this.annoCtx)
      }
      return p(Y, [{
        key: "addPointAnnotation",
        value: function (r, n, s) {
          this.w;
          var c = this.helpers.getX1X2("x1", r),
            u = this.helpers.getY1Y2("y1", r);
          if (I.isNumber(c)) {
            var d = {
                pSize: r.marker.size,
                pointStrokeWidth: r.marker.strokeWidth,
                pointFillColor: r.marker.fillColor,
                pointStrokeColor: r.marker.strokeColor,
                shape: r.marker.shape,
                pRadius: r.marker.radius,
                class: "apexcharts-point-annotation-marker ".concat(r.marker.cssClass, " ").concat(r.id ? r.id : "")
              },
              f = this.annoCtx.graphics.drawMarker(c + r.marker.offsetX, u + r.marker.offsetY, d);
            n.appendChild(f.node);
            var g = r.label.text ? r.label.text : "",
              b = this.annoCtx.graphics.drawText({
                x: c + r.label.offsetX,
                y: u + r.label.offsetY - r.marker.size - parseFloat(r.label.style.fontSize) / 1.6,
                text: g,
                textAnchor: r.label.textAnchor,
                fontSize: r.label.style.fontSize,
                fontFamily: r.label.style.fontFamily,
                fontWeight: r.label.style.fontWeight,
                foreColor: r.label.style.color,
                cssClass: "apexcharts-point-annotation-label ".concat(r.label.style.cssClass, " ").concat(r.id ? r.id : "")
              });
            if (b.attr({
                rel: s
              }), n.appendChild(b.node), r.customSVG.SVG) {
              var y = this.annoCtx.graphics.group({
                class: "apexcharts-point-annotations-custom-svg " + r.customSVG.cssClass
              });
              y.attr({
                transform: "translate(".concat(c + r.customSVG.offsetX, ", ").concat(u + r.customSVG.offsetY, ")")
              }), y.node.innerHTML = r.customSVG.SVG, n.appendChild(y.node)
            }
            if (r.image.path) {
              var x = r.image.width ? r.image.width : 20,
                _ = r.image.height ? r.image.height : 20;
              f = this.annoCtx.addImage({
                x: c + r.image.offsetX - x / 2,
                y: u + r.image.offsetY - _ / 2,
                width: x,
                height: _,
                path: r.image.path,
                appendTo: ".apexcharts-point-annotations"
              })
            }
            r.mouseEnter && f.node.addEventListener("mouseenter", r.mouseEnter.bind(this, r)), r.mouseLeave && f.node.addEventListener("mouseleave", r.mouseLeave.bind(this, r)), r.click && f.node.addEventListener("click", r.click.bind(this, r))
          }
        }
      }, {
        key: "drawPointAnnotations",
        value: function () {
          var r = this,
            n = this.w,
            s = this.annoCtx.graphics.group({
              class: "apexcharts-point-annotations"
            });
          return n.config.annotations.points.map(function (c, u) {
            r.addPointAnnotation(c, s.node, u)
          }), s
        }
      }]), Y
    }(),
    fe = {
      name: "en",
      options: {
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        toolbar: {
          exportToSVG: "Download SVG",
          exportToPNG: "Download PNG",
          exportToCSV: "Download CSV",
          menu: "Menu",
          selection: "Selection",
          selectionZoom: "Selection Zoom",
          zoomIn: "Zoom In",
          zoomOut: "Zoom Out",
          pan: "Panning",
          reset: "Reset Zoom"
        }
      }
    },
    le = function () {
      function Y() {
        l(this, Y), this.yAxis = {
          show: !0,
          showAlways: !1,
          showForNullSeries: !0,
          seriesName: void 0,
          opposite: !1,
          reversed: !1,
          logarithmic: !1,
          logBase: 10,
          tickAmount: void 0,
          stepSize: void 0,
          forceNiceScale: !1,
          max: void 0,
          min: void 0,
          floating: !1,
          decimalsInFloat: void 0,
          labels: {
            show: !0,
            minWidth: 0,
            maxWidth: 160,
            offsetX: 0,
            offsetY: 0,
            align: void 0,
            rotate: 0,
            padding: 20,
            style: {
              colors: [],
              fontSize: "11px",
              fontWeight: 400,
              fontFamily: void 0,
              cssClass: ""
            },
            formatter: void 0
          },
          axisBorder: {
            show: !1,
            color: "#e0e0e0",
            width: 1,
            offsetX: 0,
            offsetY: 0
          },
          axisTicks: {
            show: !1,
            color: "#e0e0e0",
            width: 6,
            offsetX: 0,
            offsetY: 0
          },
          title: {
            text: void 0,
            rotate: -90,
            offsetY: 0,
            offsetX: 0,
            style: {
              color: void 0,
              fontSize: "11px",
              fontWeight: 900,
              fontFamily: void 0,
              cssClass: ""
            }
          },
          tooltip: {
            enabled: !1,
            offsetX: 0
          },
          crosshairs: {
            show: !0,
            position: "front",
            stroke: {
              color: "#b6b6b6",
              width: 1,
              dashArray: 0
            }
          }
        }, this.pointAnnotation = {
          id: void 0,
          x: 0,
          y: null,
          yAxisIndex: 0,
          seriesIndex: void 0,
          mouseEnter: void 0,
          mouseLeave: void 0,
          click: void 0,
          marker: {
            size: 4,
            fillColor: "#fff",
            strokeWidth: 2,
            strokeColor: "#333",
            shape: "circle",
            offsetX: 0,
            offsetY: 0,
            radius: 2,
            cssClass: ""
          },
          label: {
            borderColor: "#c2c2c2",
            borderWidth: 1,
            borderRadius: 2,
            text: void 0,
            textAnchor: "middle",
            offsetX: 0,
            offsetY: 0,
            mouseEnter: void 0,
            mouseLeave: void 0,
            click: void 0,
            style: {
              background: "#fff",
              color: void 0,
              fontSize: "11px",
              fontFamily: void 0,
              fontWeight: 400,
              cssClass: "",
              padding: {
                left: 5,
                right: 5,
                top: 2,
                bottom: 2
              }
            }
          },
          customSVG: {
            SVG: void 0,
            cssClass: void 0,
            offsetX: 0,
            offsetY: 0
          },
          image: {
            path: void 0,
            width: 20,
            height: 20,
            offsetX: 0,
            offsetY: 0
          }
        }, this.yAxisAnnotation = {
          id: void 0,
          y: 0,
          y2: null,
          strokeDashArray: 1,
          fillColor: "#c2c2c2",
          borderColor: "#c2c2c2",
          borderWidth: 1,
          opacity: .3,
          offsetX: 0,
          offsetY: 0,
          width: "100%",
          yAxisIndex: 0,
          label: {
            borderColor: "#c2c2c2",
            borderWidth: 1,
            borderRadius: 2,
            text: void 0,
            textAnchor: "end",
            position: "right",
            offsetX: 0,
            offsetY: -3,
            mouseEnter: void 0,
            mouseLeave: void 0,
            click: void 0,
            style: {
              background: "#fff",
              color: void 0,
              fontSize: "11px",
              fontFamily: void 0,
              fontWeight: 400,
              cssClass: "",
              padding: {
                left: 5,
                right: 5,
                top: 2,
                bottom: 2
              }
            }
          }
        }, this.xAxisAnnotation = {
          id: void 0,
          x: 0,
          x2: null,
          strokeDashArray: 1,
          fillColor: "#c2c2c2",
          borderColor: "#c2c2c2",
          borderWidth: 1,
          opacity: .3,
          offsetX: 0,
          offsetY: 0,
          label: {
            borderColor: "#c2c2c2",
            borderWidth: 1,
            borderRadius: 2,
            text: void 0,
            textAnchor: "middle",
            orientation: "vertical",
            position: "top",
            offsetX: 0,
            offsetY: 0,
            mouseEnter: void 0,
            mouseLeave: void 0,
            click: void 0,
            style: {
              background: "#fff",
              color: void 0,
              fontSize: "11px",
              fontFamily: void 0,
              fontWeight: 400,
              cssClass: "",
              padding: {
                left: 5,
                right: 5,
                top: 2,
                bottom: 2
              }
            }
          }
        }, this.text = {
          x: 0,
          y: 0,
          text: "",
          textAnchor: "start",
          foreColor: void 0,
          fontSize: "13px",
          fontFamily: void 0,
          fontWeight: 400,
          appendTo: ".apexcharts-annotations",
          backgroundColor: "transparent",
          borderColor: "#c2c2c2",
          borderRadius: 0,
          borderWidth: 0,
          paddingLeft: 4,
          paddingRight: 4,
          paddingTop: 2,
          paddingBottom: 2
        }
      }
      return p(Y, [{
        key: "init",
        value: function () {
          return {
            annotations: {
              yaxis: [this.yAxisAnnotation],
              xaxis: [this.xAxisAnnotation],
              points: [this.pointAnnotation],
              texts: [],
              images: [],
              shapes: []
            },
            chart: {
              animations: {
                enabled: !0,
                easing: "easeinout",
                speed: 800,
                animateGradually: {
                  delay: 150,
                  enabled: !0
                },
                dynamicAnimation: {
                  enabled: !0,
                  speed: 350
                }
              },
              background: "transparent",
              locales: [fe],
              defaultLocale: "en",
              dropShadow: {
                enabled: !1,
                enabledOnSeries: void 0,
                top: 2,
                left: 2,
                blur: 4,
                color: "#000",
                opacity: .35
              },
              events: {
                animationEnd: void 0,
                beforeMount: void 0,
                mounted: void 0,
                updated: void 0,
                click: void 0,
                mouseMove: void 0,
                mouseLeave: void 0,
                xAxisLabelClick: void 0,
                legendClick: void 0,
                markerClick: void 0,
                selection: void 0,
                dataPointSelection: void 0,
                dataPointMouseEnter: void 0,
                dataPointMouseLeave: void 0,
                beforeZoom: void 0,
                beforeResetZoom: void 0,
                zoomed: void 0,
                scrolled: void 0,
                brushScrolled: void 0
              },
              foreColor: "#373d3f",
              fontFamily: "Helvetica, Arial, sans-serif",
              height: "auto",
              parentHeightOffset: 15,
              redrawOnParentResize: !0,
              redrawOnWindowResize: !0,
              id: void 0,
              group: void 0,
              nonce: void 0,
              offsetX: 0,
              offsetY: 0,
              selection: {
                enabled: !1,
                type: "x",
                fill: {
                  color: "#24292e",
                  opacity: .1
                },
                stroke: {
                  width: 1,
                  color: "#24292e",
                  opacity: .4,
                  dashArray: 3
                },
                xaxis: {
                  min: void 0,
                  max: void 0
                },
                yaxis: {
                  min: void 0,
                  max: void 0
                }
              },
              sparkline: {
                enabled: !1
              },
              brush: {
                enabled: !1,
                autoScaleYaxis: !0,
                target: void 0,
                targets: void 0
              },
              stacked: !1,
              stackOnlyBar: !0,
              stackType: "normal",
              toolbar: {
                show: !0,
                offsetX: 0,
                offsetY: 0,
                tools: {
                  download: !0,
                  selection: !0,
                  zoom: !0,
                  zoomin: !0,
                  zoomout: !0,
                  pan: !0,
                  reset: !0,
                  customIcons: []
                },
                export: {
                  csv: {
                    filename: void 0,
                    columnDelimiter: ",",
                    headerCategory: "category",
                    headerValue: "value",
                    dateFormatter: function (r) {
                      return new Date(r).toDateString()
                    }
                  },
                  png: {
                    filename: void 0
                  },
                  svg: {
                    filename: void 0
                  }
                },
                autoSelected: "zoom"
              },
              type: "line",
              width: "100%",
              zoom: {
                enabled: !0,
                type: "x",
                autoScaleYaxis: !1,
                zoomedArea: {
                  fill: {
                    color: "#90CAF9",
                    opacity: .4
                  },
                  stroke: {
                    color: "#0D47A1",
                    opacity: .4,
                    width: 1
                  }
                }
              }
            },
            plotOptions: {
              area: {
                fillTo: "origin"
              },
              bar: {
                horizontal: !1,
                columnWidth: "70%",
                barHeight: "70%",
                distributed: !1,
                borderRadius: 0,
                borderRadiusApplication: "around",
                borderRadiusWhenStacked: "last",
                rangeBarOverlap: !0,
                rangeBarGroupRows: !1,
                hideZeroBarsWhenGrouped: !1,
                isDumbbell: !1,
                dumbbellColors: void 0,
                isFunnel: !1,
                isFunnel3d: !0,
                colors: {
                  ranges: [],
                  backgroundBarColors: [],
                  backgroundBarOpacity: 1,
                  backgroundBarRadius: 0
                },
                dataLabels: {
                  position: "top",
                  maxItems: 100,
                  hideOverflowingLabels: !0,
                  orientation: "horizontal",
                  total: {
                    enabled: !1,
                    formatter: void 0,
                    offsetX: 0,
                    offsetY: 0,
                    style: {
                      color: "#373d3f",
                      fontSize: "12px",
                      fontFamily: void 0,
                      fontWeight: 600
                    }
                  }
                }
              },
              bubble: {
                zScaling: !0,
                minBubbleRadius: void 0,
                maxBubbleRadius: void 0
              },
              candlestick: {
                colors: {
                  upward: "#00B746",
                  downward: "#EF403C"
                },
                wick: {
                  useFillColor: !0
                }
              },
              boxPlot: {
                colors: {
                  upper: "#00E396",
                  lower: "#008FFB"
                }
              },
              heatmap: {
                radius: 2,
                enableShades: !0,
                shadeIntensity: .5,
                reverseNegativeShade: !1,
                distributed: !1,
                useFillColorAsStroke: !1,
                colorScale: {
                  inverse: !1,
                  ranges: [],
                  min: void 0,
                  max: void 0
                }
              },
              treemap: {
                enableShades: !0,
                shadeIntensity: .5,
                distributed: !1,
                reverseNegativeShade: !1,
                useFillColorAsStroke: !1,
                borderRadius: 4,
                dataLabels: {
                  format: "scale"
                },
                colorScale: {
                  inverse: !1,
                  ranges: [],
                  min: void 0,
                  max: void 0
                }
              },
              radialBar: {
                inverseOrder: !1,
                startAngle: 0,
                endAngle: 360,
                offsetX: 0,
                offsetY: 0,
                hollow: {
                  margin: 5,
                  size: "50%",
                  background: "transparent",
                  image: void 0,
                  imageWidth: 150,
                  imageHeight: 150,
                  imageOffsetX: 0,
                  imageOffsetY: 0,
                  imageClipped: !0,
                  position: "front",
                  dropShadow: {
                    enabled: !1,
                    top: 0,
                    left: 0,
                    blur: 3,
                    color: "#000",
                    opacity: .5
                  }
                },
                track: {
                  show: !0,
                  startAngle: void 0,
                  endAngle: void 0,
                  background: "#f2f2f2",
                  strokeWidth: "97%",
                  opacity: 1,
                  margin: 5,
                  dropShadow: {
                    enabled: !1,
                    top: 0,
                    left: 0,
                    blur: 3,
                    color: "#000",
                    opacity: .5
                  }
                },
                dataLabels: {
                  show: !0,
                  name: {
                    show: !0,
                    fontSize: "16px",
                    fontFamily: void 0,
                    fontWeight: 600,
                    color: void 0,
                    offsetY: 0,
                    formatter: function (r) {
                      return r
                    }
                  },
                  value: {
                    show: !0,
                    fontSize: "14px",
                    fontFamily: void 0,
                    fontWeight: 400,
                    color: void 0,
                    offsetY: 16,
                    formatter: function (r) {
                      return r + "%"
                    }
                  },
                  total: {
                    show: !1,
                    label: "Total",
                    fontSize: "16px",
                    fontWeight: 600,
                    fontFamily: void 0,
                    color: void 0,
                    formatter: function (r) {
                      return r.globals.seriesTotals.reduce(function (n, s) {
                        return n + s
                      }, 0) / r.globals.series.length + "%"
                    }
                  }
                },
                barLabels: {
                  enabled: !1,
                  margin: 5,
                  useSeriesColors: !0,
                  fontFamily: void 0,
                  fontWeight: 600,
                  fontSize: "16px",
                  formatter: function (r) {
                    return r
                  },
                  onClick: void 0
                }
              },
              pie: {
                customScale: 1,
                offsetX: 0,
                offsetY: 0,
                startAngle: 0,
                endAngle: 360,
                expandOnClick: !0,
                dataLabels: {
                  offset: 0,
                  minAngleToShowLabel: 10
                },
                donut: {
                  size: "65%",
                  background: "transparent",
                  labels: {
                    show: !1,
                    name: {
                      show: !0,
                      fontSize: "16px",
                      fontFamily: void 0,
                      fontWeight: 600,
                      color: void 0,
                      offsetY: -10,
                      formatter: function (r) {
                        return r
                      }
                    },
                    value: {
                      show: !0,
                      fontSize: "20px",
                      fontFamily: void 0,
                      fontWeight: 400,
                      color: void 0,
                      offsetY: 10,
                      formatter: function (r) {
                        return r
                      }
                    },
                    total: {
                      show: !1,
                      showAlways: !1,
                      label: "Total",
                      fontSize: "16px",
                      fontWeight: 400,
                      fontFamily: void 0,
                      color: void 0,
                      formatter: function (r) {
                        return r.globals.seriesTotals.reduce(function (n, s) {
                          return n + s
                        }, 0)
                      }
                    }
                  }
                }
              },
              polarArea: {
                rings: {
                  strokeWidth: 1,
                  strokeColor: "#e8e8e8"
                },
                spokes: {
                  strokeWidth: 1,
                  connectorColors: "#e8e8e8"
                }
              },
              radar: {
                size: void 0,
                offsetX: 0,
                offsetY: 0,
                polygons: {
                  strokeWidth: 1,
                  strokeColors: "#e8e8e8",
                  connectorColors: "#e8e8e8",
                  fill: {
                    colors: void 0
                  }
                }
              }
            },
            colors: void 0,
            dataLabels: {
              enabled: !0,
              enabledOnSeries: void 0,
              formatter: function (r) {
                return r !== null ? r : ""
              },
              textAnchor: "middle",
              distributed: !1,
              offsetX: 0,
              offsetY: 0,
              style: {
                fontSize: "12px",
                fontFamily: void 0,
                fontWeight: 600,
                colors: void 0
              },
              background: {
                enabled: !0,
                foreColor: "#fff",
                borderRadius: 2,
                padding: 4,
                opacity: .9,
                borderWidth: 1,
                borderColor: "#fff",
                dropShadow: {
                  enabled: !1,
                  top: 1,
                  left: 1,
                  blur: 1,
                  color: "#000",
                  opacity: .45
                }
              },
              dropShadow: {
                enabled: !1,
                top: 1,
                left: 1,
                blur: 1,
                color: "#000",
                opacity: .45
              }
            },
            fill: {
              type: "solid",
              colors: void 0,
              opacity: .85,
              gradient: {
                shade: "dark",
                type: "horizontal",
                shadeIntensity: .5,
                gradientToColors: void 0,
                inverseColors: !0,
                opacityFrom: 1,
                opacityTo: 1,
                stops: [0, 50, 100],
                colorStops: []
              },
              image: {
                src: [],
                width: void 0,
                height: void 0
              },
              pattern: {
                style: "squares",
                width: 6,
                height: 6,
                strokeWidth: 2
              }
            },
            forecastDataPoints: {
              count: 0,
              fillOpacity: .5,
              strokeWidth: void 0,
              dashArray: 4
            },
            grid: {
              show: !0,
              borderColor: "#e0e0e0",
              strokeDashArray: 0,
              position: "back",
              xaxis: {
                lines: {
                  show: !1
                }
              },
              yaxis: {
                lines: {
                  show: !0
                }
              },
              row: {
                colors: void 0,
                opacity: .5
              },
              column: {
                colors: void 0,
                opacity: .5
              },
              padding: {
                top: 0,
                right: 10,
                bottom: 0,
                left: 12
              }
            },
            labels: [],
            legend: {
              show: !0,
              showForSingleSeries: !1,
              showForNullSeries: !0,
              showForZeroSeries: !0,
              floating: !1,
              position: "bottom",
              horizontalAlign: "center",
              inverseOrder: !1,
              fontSize: "12px",
              fontFamily: void 0,
              fontWeight: 400,
              width: void 0,
              height: void 0,
              formatter: void 0,
              tooltipHoverFormatter: void 0,
              offsetX: -20,
              offsetY: 4,
              customLegendItems: [],
              labels: {
                colors: void 0,
                useSeriesColors: !1
              },
              markers: {
                width: 12,
                height: 12,
                strokeWidth: 0,
                fillColors: void 0,
                strokeColor: "#fff",
                radius: 12,
                customHTML: void 0,
                offsetX: 0,
                offsetY: 0,
                onClick: void 0
              },
              itemMargin: {
                horizontal: 5,
                vertical: 2
              },
              onItemClick: {
                toggleDataSeries: !0
              },
              onItemHover: {
                highlightDataSeries: !0
              }
            },
            markers: {
              discrete: [],
              size: 0,
              colors: void 0,
              strokeColors: "#fff",
              strokeWidth: 2,
              strokeOpacity: .9,
              strokeDashArray: 0,
              fillOpacity: 1,
              shape: "circle",
              width: 8,
              height: 8,
              radius: 2,
              offsetX: 0,
              offsetY: 0,
              onClick: void 0,
              onDblClick: void 0,
              showNullDataPoints: !0,
              hover: {
                size: void 0,
                sizeOffset: 3
              }
            },
            noData: {
              text: void 0,
              align: "center",
              verticalAlign: "middle",
              offsetX: 0,
              offsetY: 0,
              style: {
                color: void 0,
                fontSize: "14px",
                fontFamily: void 0
              }
            },
            responsive: [],
            series: void 0,
            states: {
              normal: {
                filter: {
                  type: "none",
                  value: 0
                }
              },
              hover: {
                filter: {
                  type: "lighten",
                  value: .1
                }
              },
              active: {
                allowMultipleDataPointsSelection: !1,
                filter: {
                  type: "darken",
                  value: .5
                }
              }
            },
            title: {
              text: void 0,
              align: "left",
              margin: 5,
              offsetX: 0,
              offsetY: 0,
              floating: !1,
              style: {
                fontSize: "14px",
                fontWeight: 900,
                fontFamily: void 0,
                color: void 0
              }
            },
            subtitle: {
              text: void 0,
              align: "left",
              margin: 5,
              offsetX: 0,
              offsetY: 30,
              floating: !1,
              style: {
                fontSize: "12px",
                fontWeight: 400,
                fontFamily: void 0,
                color: void 0
              }
            },
            stroke: {
              show: !0,
              curve: "smooth",
              lineCap: "butt",
              width: 2,
              colors: void 0,
              dashArray: 0,
              fill: {
                type: "solid",
                colors: void 0,
                opacity: .85,
                gradient: {
                  shade: "dark",
                  type: "horizontal",
                  shadeIntensity: .5,
                  gradientToColors: void 0,
                  inverseColors: !0,
                  opacityFrom: 1,
                  opacityTo: 1,
                  stops: [0, 50, 100],
                  colorStops: []
                }
              }
            },
            tooltip: {
              enabled: !0,
              enabledOnSeries: void 0,
              shared: !0,
              hideEmptySeries: !1,
              followCursor: !1,
              intersect: !1,
              inverseOrder: !1,
              custom: void 0,
              fillSeriesColor: !1,
              theme: "light",
              cssClass: "",
              style: {
                fontSize: "12px",
                fontFamily: void 0
              },
              onDatasetHover: {
                highlightDataSeries: !1
              },
              x: {
                show: !0,
                format: "dd MMM",
                formatter: void 0
              },
              y: {
                formatter: void 0,
                title: {
                  formatter: function (r) {
                    return r ? r + ": " : ""
                  }
                }
              },
              z: {
                formatter: void 0,
                title: "Size: "
              },
              marker: {
                show: !0,
                fillColors: void 0
              },
              items: {
                display: "flex"
              },
              fixed: {
                enabled: !1,
                position: "topRight",
                offsetX: 0,
                offsetY: 0
              }
            },
            xaxis: {
              type: "category",
              categories: [],
              convertedCatToNumeric: !1,
              offsetX: 0,
              offsetY: 0,
              overwriteCategories: void 0,
              labels: {
                show: !0,
                rotate: -45,
                rotateAlways: !1,
                hideOverlappingLabels: !0,
                trim: !1,
                minHeight: void 0,
                maxHeight: 120,
                showDuplicates: !0,
                style: {
                  colors: [],
                  fontSize: "12px",
                  fontWeight: 400,
                  fontFamily: void 0,
                  cssClass: ""
                },
                offsetX: 0,
                offsetY: 0,
                format: void 0,
                formatter: void 0,
                datetimeUTC: !0,
                datetimeFormatter: {
                  year: "yyyy",
                  month: "MMM 'yy",
                  day: "dd MMM",
                  hour: "HH:mm",
                  minute: "HH:mm:ss",
                  second: "HH:mm:ss"
                }
              },
              group: {
                groups: [],
                style: {
                  colors: [],
                  fontSize: "12px",
                  fontWeight: 400,
                  fontFamily: void 0,
                  cssClass: ""
                }
              },
              axisBorder: {
                show: !0,
                color: "#e0e0e0",
                width: "100%",
                height: 1,
                offsetX: 0,
                offsetY: 0
              },
              axisTicks: {
                show: !0,
                color: "#e0e0e0",
                height: 6,
                offsetX: 0,
                offsetY: 0
              },
              stepSize: void 0,
              tickAmount: void 0,
              tickPlacement: "on",
              min: void 0,
              max: void 0,
              range: void 0,
              floating: !1,
              decimalsInFloat: void 0,
              position: "bottom",
              title: {
                text: void 0,
                offsetX: 0,
                offsetY: 0,
                style: {
                  color: void 0,
                  fontSize: "12px",
                  fontWeight: 900,
                  fontFamily: void 0,
                  cssClass: ""
                }
              },
              crosshairs: {
                show: !0,
                width: 1,
                position: "back",
                opacity: .9,
                stroke: {
                  color: "#b6b6b6",
                  width: 1,
                  dashArray: 3
                },
                fill: {
                  type: "solid",
                  color: "#B1B9C4",
                  gradient: {
                    colorFrom: "#D8E3F0",
                    colorTo: "#BED1E6",
                    stops: [0, 100],
                    opacityFrom: .4,
                    opacityTo: .5
                  }
                },
                dropShadow: {
                  enabled: !1,
                  left: 0,
                  top: 0,
                  blur: 1,
                  opacity: .4
                }
              },
              tooltip: {
                enabled: !0,
                offsetY: 0,
                formatter: void 0,
                style: {
                  fontSize: "12px",
                  fontFamily: void 0
                }
              }
            },
            yaxis: this.yAxis,
            theme: {
              mode: "light",
              palette: "palette1",
              monochrome: {
                enabled: !1,
                color: "#008FFB",
                shadeTo: "light",
                shadeIntensity: .65
              }
            }
          }
        }
      }]), Y
    }(),
    Ee = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.graphics = new W(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new V(this), this.xAxisAnnotations = new ne(this), this.yAxisAnnotations = new Z(this), this.pointsAnnotations = new ie(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
      }
      return p(Y, [{
        key: "drawAxesAnnotations",
        value: function () {
          var r = this.w;
          if (r.globals.axisCharts) {
            for (var n = this.yAxisAnnotations.drawYAxisAnnotations(), s = this.xAxisAnnotations.drawXAxisAnnotations(), c = this.pointsAnnotations.drawPointAnnotations(), u = r.config.chart.animations.enabled, d = [n, s, c], f = [s.node, n.node, c.node], g = 0; g < 3; g++) r.globals.dom.elGraphical.add(d[g]), !u || r.globals.resized || r.globals.dataChanged || r.config.chart.type !== "scatter" && r.config.chart.type !== "bubble" && r.globals.dataPoints > 1 && f[g].classList.add("apexcharts-element-hidden"), r.globals.delayedElements.push({
              el: f[g],
              index: 0
            });
            this.helpers.annotationsBackground()
          }
        }
      }, {
        key: "drawImageAnnos",
        value: function () {
          var r = this;
          this.w.config.annotations.images.map(function (n, s) {
            r.addImage(n, s)
          })
        }
      }, {
        key: "drawTextAnnos",
        value: function () {
          var r = this;
          this.w.config.annotations.texts.map(function (n, s) {
            r.addText(n, s)
          })
        }
      }, {
        key: "addXaxisAnnotation",
        value: function (r, n, s) {
          this.xAxisAnnotations.addXaxisAnnotation(r, n, s)
        }
      }, {
        key: "addYaxisAnnotation",
        value: function (r, n, s) {
          this.yAxisAnnotations.addYaxisAnnotation(r, n, s)
        }
      }, {
        key: "addPointAnnotation",
        value: function (r, n, s) {
          this.pointsAnnotations.addPointAnnotation(r, n, s)
        }
      }, {
        key: "addText",
        value: function (r, n) {
          var s = r.x,
            c = r.y,
            u = r.text,
            d = r.textAnchor,
            f = r.foreColor,
            g = r.fontSize,
            b = r.fontFamily,
            y = r.fontWeight,
            x = r.cssClass,
            _ = r.backgroundColor,
            T = r.borderWidth,
            P = r.strokeDashArray,
            O = r.borderRadius,
            $ = r.borderColor,
            G = r.appendTo,
            Q = G === void 0 ? ".apexcharts-svg" : G,
            v = r.paddingLeft,
            C = v === void 0 ? 4 : v,
            L = r.paddingRight,
            H = L === void 0 ? 4 : L,
            q = r.paddingBottom,
            ee = q === void 0 ? 2 : q,
            ge = r.paddingTop,
            pe = ge === void 0 ? 2 : ge,
            Fe = this.w,
            Ue = this.graphics.drawText({
              x: s,
              y: c,
              text: u,
              textAnchor: d || "start",
              fontSize: g || "12px",
              fontWeight: y || "regular",
              fontFamily: b || Fe.config.chart.fontFamily,
              foreColor: f || Fe.config.chart.foreColor,
              cssClass: x
            }),
            Ve = Fe.globals.dom.baseEl.querySelector(Q);
          Ve && Ve.appendChild(Ue.node);
          var it = Ue.bbox();
          if (u) {
            var dt = this.graphics.drawRect(it.x - C, it.y - pe, it.width + C + H, it.height + ee + pe, O, _ || "transparent", 1, T, $, P);
            Ve.insertBefore(dt.node, Ue.node)
          }
        }
      }, {
        key: "addImage",
        value: function (r, n) {
          var s = this.w,
            c = r.path,
            u = r.x,
            d = u === void 0 ? 0 : u,
            f = r.y,
            g = f === void 0 ? 0 : f,
            b = r.width,
            y = b === void 0 ? 20 : b,
            x = r.height,
            _ = x === void 0 ? 20 : x,
            T = r.appendTo,
            P = T === void 0 ? ".apexcharts-svg" : T,
            O = s.globals.dom.Paper.image(c);
          O.size(y, _).move(d, g);
          var $ = s.globals.dom.baseEl.querySelector(P);
          return $ && $.appendChild(O.node), O
        }
      }, {
        key: "addXaxisAnnotationExternal",
        value: function (r, n, s) {
          return this.addAnnotationExternal({
            params: r,
            pushToMemory: n,
            context: s,
            type: "xaxis",
            contextMethod: s.addXaxisAnnotation
          }), s
        }
      }, {
        key: "addYaxisAnnotationExternal",
        value: function (r, n, s) {
          return this.addAnnotationExternal({
            params: r,
            pushToMemory: n,
            context: s,
            type: "yaxis",
            contextMethod: s.addYaxisAnnotation
          }), s
        }
      }, {
        key: "addPointAnnotationExternal",
        value: function (r, n, s) {
          return this.invertAxis === void 0 && (this.invertAxis = s.w.globals.isBarHorizontal), this.addAnnotationExternal({
            params: r,
            pushToMemory: n,
            context: s,
            type: "point",
            contextMethod: s.addPointAnnotation
          }), s
        }
      }, {
        key: "addAnnotationExternal",
        value: function (r) {
          var n = r.params,
            s = r.pushToMemory,
            c = r.context,
            u = r.type,
            d = r.contextMethod,
            f = c,
            g = f.w,
            b = g.globals.dom.baseEl.querySelector(".apexcharts-".concat(u, "-annotations")),
            y = b.childNodes.length + 1,
            x = new le,
            _ = Object.assign({}, u === "xaxis" ? x.xAxisAnnotation : u === "yaxis" ? x.yAxisAnnotation : x.pointAnnotation),
            T = I.extend(_, n);
          switch (u) {
            case "xaxis":
              this.addXaxisAnnotation(T, b, y);
              break;
            case "yaxis":
              this.addYaxisAnnotation(T, b, y);
              break;
            case "point":
              this.addPointAnnotation(T, b, y)
          }
          var P = g.globals.dom.baseEl.querySelector(".apexcharts-".concat(u, "-annotations .apexcharts-").concat(u, "-annotation-label[rel='").concat(y, "']")),
            O = this.helpers.addBackgroundToAnno(P, T);
          return O && b.insertBefore(O.node, P), s && g.globals.memory.methodsToExec.push({
            context: f,
            id: T.id ? T.id : I.randomId(),
            method: d,
            label: "addAnnotation",
            params: n
          }), c
        }
      }, {
        key: "clearAnnotations",
        value: function (r) {
          var n = r.w,
            s = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
          n.globals.memory.methodsToExec.map(function (c, u) {
            c.label !== "addText" && c.label !== "addAnnotation" || n.globals.memory.methodsToExec.splice(u, 1)
          }), s = I.listToArray(s), Array.prototype.forEach.call(s, function (c) {
            for (; c.firstChild;) c.removeChild(c.firstChild)
          })
        }
      }, {
        key: "removeAnnotation",
        value: function (r, n) {
          var s = r.w,
            c = s.globals.dom.baseEl.querySelectorAll(".".concat(n));
          c && (s.globals.memory.methodsToExec.map(function (u, d) {
            u.id === n && s.globals.memory.methodsToExec.splice(d, 1)
          }), Array.prototype.forEach.call(c, function (u) {
            u.parentElement.removeChild(u)
          }))
        }
      }]), Y
    }(),
    ye = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
      }
      return p(Y, [{
        key: "isValidDate",
        value: function (r) {
          return typeof r != "number" && !isNaN(this.parseDate(r))
        }
      }, {
        key: "getTimeStamp",
        value: function (r) {
          return Date.parse(r) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(r).toISOString().substr(0, 25)).getTime() : new Date(r).getTime() : r
        }
      }, {
        key: "getDate",
        value: function (r) {
          return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(r).toUTCString()) : new Date(r)
        }
      }, {
        key: "parseDate",
        value: function (r) {
          var n = Date.parse(r);
          if (!isNaN(n)) return this.getTimeStamp(r);
          var s = Date.parse(r.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
          return s = this.getTimeStamp(s)
        }
      }, {
        key: "parseDateWithTimezone",
        value: function (r) {
          return Date.parse(r.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
        }
      }, {
        key: "formatDate",
        value: function (r, n) {
          var s = this.w.globals.locale,
            c = this.w.config.xaxis.labels.datetimeUTC,
            u = ["\0"].concat(D(s.months)),
            d = [""].concat(D(s.shortMonths)),
            f = [""].concat(D(s.days)),
            g = [""].concat(D(s.shortDays));

          function b(ee, ge) {
            var pe = ee + "";
            for (ge = ge || 2; pe.length < ge;) pe = "0" + pe;
            return pe
          }
          var y = c ? r.getUTCFullYear() : r.getFullYear();
          n = (n = (n = n.replace(/(^|[^\\])yyyy+/g, "$1" + y)).replace(/(^|[^\\])yy/g, "$1" + y.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + y);
          var x = (c ? r.getUTCMonth() : r.getMonth()) + 1;
          n = (n = (n = (n = n.replace(/(^|[^\\])MMMM+/g, "$1" + u[0])).replace(/(^|[^\\])MMM/g, "$1" + d[0])).replace(/(^|[^\\])MM/g, "$1" + b(x))).replace(/(^|[^\\])M/g, "$1" + x);
          var _ = c ? r.getUTCDate() : r.getDate();
          n = (n = (n = (n = n.replace(/(^|[^\\])dddd+/g, "$1" + f[0])).replace(/(^|[^\\])ddd/g, "$1" + g[0])).replace(/(^|[^\\])dd/g, "$1" + b(_))).replace(/(^|[^\\])d/g, "$1" + _);
          var T = c ? r.getUTCHours() : r.getHours(),
            P = T > 12 ? T - 12 : T === 0 ? 12 : T;
          n = (n = (n = (n = n.replace(/(^|[^\\])HH+/g, "$1" + b(T))).replace(/(^|[^\\])H/g, "$1" + T)).replace(/(^|[^\\])hh+/g, "$1" + b(P))).replace(/(^|[^\\])h/g, "$1" + P);
          var O = c ? r.getUTCMinutes() : r.getMinutes();
          n = (n = n.replace(/(^|[^\\])mm+/g, "$1" + b(O))).replace(/(^|[^\\])m/g, "$1" + O);
          var $ = c ? r.getUTCSeconds() : r.getSeconds();
          n = (n = n.replace(/(^|[^\\])ss+/g, "$1" + b($))).replace(/(^|[^\\])s/g, "$1" + $);
          var G = c ? r.getUTCMilliseconds() : r.getMilliseconds();
          n = n.replace(/(^|[^\\])fff+/g, "$1" + b(G, 3)), G = Math.round(G / 10), n = n.replace(/(^|[^\\])ff/g, "$1" + b(G)), G = Math.round(G / 10);
          var Q = T < 12 ? "AM" : "PM";
          n = (n = (n = n.replace(/(^|[^\\])f/g, "$1" + G)).replace(/(^|[^\\])TT+/g, "$1" + Q)).replace(/(^|[^\\])T/g, "$1" + Q.charAt(0));
          var v = Q.toLowerCase();
          n = (n = n.replace(/(^|[^\\])tt+/g, "$1" + v)).replace(/(^|[^\\])t/g, "$1" + v.charAt(0));
          var C = -r.getTimezoneOffset(),
            L = c || !C ? "Z" : C > 0 ? "+" : "-";
          if (!c) {
            var H = (C = Math.abs(C)) % 60;
            L += b(Math.floor(C / 60)) + ":" + b(H)
          }
          n = n.replace(/(^|[^\\])K/g, "$1" + L);
          var q = (c ? r.getUTCDay() : r.getDay()) + 1;
          return n = (n = (n = (n = (n = n.replace(new RegExp(f[0], "g"), f[q])).replace(new RegExp(g[0], "g"), g[q])).replace(new RegExp(u[0], "g"), u[x])).replace(new RegExp(d[0], "g"), d[x])).replace(/\\(.)/g, "$1")
        }
      }, {
        key: "getTimeUnitsfromTimestamp",
        value: function (r, n, s) {
          var c = this.w;
          c.config.xaxis.min !== void 0 && (r = c.config.xaxis.min), c.config.xaxis.max !== void 0 && (n = c.config.xaxis.max);
          var u = this.getDate(r),
            d = this.getDate(n),
            f = this.formatDate(u, "yyyy MM dd HH mm ss fff").split(" "),
            g = this.formatDate(d, "yyyy MM dd HH mm ss fff").split(" ");
          return {
            minMillisecond: parseInt(f[6], 10),
            maxMillisecond: parseInt(g[6], 10),
            minSecond: parseInt(f[5], 10),
            maxSecond: parseInt(g[5], 10),
            minMinute: parseInt(f[4], 10),
            maxMinute: parseInt(g[4], 10),
            minHour: parseInt(f[3], 10),
            maxHour: parseInt(g[3], 10),
            minDate: parseInt(f[2], 10),
            maxDate: parseInt(g[2], 10),
            minMonth: parseInt(f[1], 10) - 1,
            maxMonth: parseInt(g[1], 10) - 1,
            minYear: parseInt(f[0], 10),
            maxYear: parseInt(g[0], 10)
          }
        }
      }, {
        key: "isLeapYear",
        value: function (r) {
          return r % 4 == 0 && r % 100 != 0 || r % 400 == 0
        }
      }, {
        key: "calculcateLastDaysOfMonth",
        value: function (r, n, s) {
          return this.determineDaysOfMonths(r, n) - s
        }
      }, {
        key: "determineDaysOfYear",
        value: function (r) {
          var n = 365;
          return this.isLeapYear(r) && (n = 366), n
        }
      }, {
        key: "determineRemainingDaysOfYear",
        value: function (r, n, s) {
          var c = this.daysCntOfYear[n] + s;
          return n > 1 && this.isLeapYear() && c++, c
        }
      }, {
        key: "determineDaysOfMonths",
        value: function (r, n) {
          var s = 30;
          switch (r = I.monthMod(r), !0) {
            case this.months30.indexOf(r) > -1:
              r === 2 && (s = this.isLeapYear(n) ? 29 : 28);
              break;
            case this.months31.indexOf(r) > -1:
            default:
              s = 31
          }
          return s
        }
      }]), Y
    }(),
    ve = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.tooltipKeyFormat = "dd MMM"
      }
      return p(Y, [{
        key: "xLabelFormat",
        value: function (r, n, s, c) {
          var u = this.w;
          if (u.config.xaxis.type === "datetime" && u.config.xaxis.labels.formatter === void 0 && u.config.tooltip.x.formatter === void 0) {
            var d = new ye(this.ctx);
            return d.formatDate(d.getDate(n), u.config.tooltip.x.format)
          }
          return r(n, s, c)
        }
      }, {
        key: "defaultGeneralFormatter",
        value: function (r) {
          return Array.isArray(r) ? r.map(function (n) {
            return n
          }) : r
        }
      }, {
        key: "defaultYFormatter",
        value: function (r, n, s) {
          var c = this.w;
          return I.isNumber(r) && (r = c.globals.yValueDecimal !== 0 ? r.toFixed(n.decimalsInFloat !== void 0 ? n.decimalsInFloat : c.globals.yValueDecimal) : c.globals.maxYArr[s] - c.globals.minYArr[s] < 5 ? r.toFixed(1) : r.toFixed(0)), r
        }
      }, {
        key: "setLabelFormatters",
        value: function () {
          var r = this,
            n = this.w;
          return n.globals.xaxisTooltipFormatter = function (s) {
            return r.defaultGeneralFormatter(s)
          }, n.globals.ttKeyFormatter = function (s) {
            return r.defaultGeneralFormatter(s)
          }, n.globals.ttZFormatter = function (s) {
            return s
          }, n.globals.legendFormatter = function (s) {
            return r.defaultGeneralFormatter(s)
          }, n.config.xaxis.labels.formatter !== void 0 ? n.globals.xLabelFormatter = n.config.xaxis.labels.formatter : n.globals.xLabelFormatter = function (s) {
            if (I.isNumber(s)) {
              if (!n.config.xaxis.convertedCatToNumeric && n.config.xaxis.type === "numeric") {
                if (I.isNumber(n.config.xaxis.decimalsInFloat)) return s.toFixed(n.config.xaxis.decimalsInFloat);
                var c = n.globals.maxX - n.globals.minX;
                return c > 0 && c < 100 ? s.toFixed(1) : s.toFixed(0)
              }
              return n.globals.isBarHorizontal && n.globals.maxY - n.globals.minYArr < 4 ? s.toFixed(1) : s.toFixed(0)
            }
            return s
          }, typeof n.config.tooltip.x.formatter == "function" ? n.globals.ttKeyFormatter = n.config.tooltip.x.formatter : n.globals.ttKeyFormatter = n.globals.xLabelFormatter, typeof n.config.xaxis.tooltip.formatter == "function" && (n.globals.xaxisTooltipFormatter = n.config.xaxis.tooltip.formatter), (Array.isArray(n.config.tooltip.y) || n.config.tooltip.y.formatter !== void 0) && (n.globals.ttVal = n.config.tooltip.y), n.config.tooltip.z.formatter !== void 0 && (n.globals.ttZFormatter = n.config.tooltip.z.formatter), n.config.legend.formatter !== void 0 && (n.globals.legendFormatter = n.config.legend.formatter), n.config.yaxis.forEach(function (s, c) {
            s.labels.formatter !== void 0 ? n.globals.yLabelFormatters[c] = s.labels.formatter : n.globals.yLabelFormatters[c] = function (u) {
              return n.globals.xyCharts ? Array.isArray(u) ? u.map(function (d) {
                return r.defaultYFormatter(d, s, c)
              }) : r.defaultYFormatter(u, s, c) : u
            }
          }), n.globals
        }
      }, {
        key: "heatmapLabelFormatters",
        value: function () {
          var r = this.w;
          if (r.config.chart.type === "heatmap") {
            r.globals.yAxisScale[0].result = r.globals.seriesNames.slice();
            var n = r.globals.seriesNames.reduce(function (s, c) {
              return s.length > c.length ? s : c
            }, 0);
            r.globals.yAxisScale[0].niceMax = n, r.globals.yAxisScale[0].niceMin = n
          }
        }
      }]), Y
    }(),
    me = function (Y) {
      var r, n = Y.isTimeline,
        s = Y.ctx,
        c = Y.seriesIndex,
        u = Y.dataPointIndex,
        d = Y.y1,
        f = Y.y2,
        g = Y.w,
        b = g.globals.seriesRangeStart[c][u],
        y = g.globals.seriesRangeEnd[c][u],
        x = g.globals.labels[u],
        _ = g.config.series[c].name ? g.config.series[c].name : "",
        T = g.globals.ttKeyFormatter,
        P = g.config.tooltip.y.title.formatter,
        O = {
          w: g,
          seriesIndex: c,
          dataPointIndex: u,
          start: b,
          end: y
        };
      typeof P == "function" && (_ = P(_, O)), (r = g.config.series[c].data[u]) !== null && r !== void 0 && r.x && (x = g.config.series[c].data[u].x), n || g.config.xaxis.type === "datetime" && (x = new ve(s).xLabelFormat(g.globals.ttKeyFormatter, x, x, {
        i: void 0,
        dateFormatter: new ye(s).formatDate,
        w: g
      })), typeof T == "function" && (x = T(x, O)), Number.isFinite(d) && Number.isFinite(f) && (b = d, y = f);
      var $ = "",
        G = "",
        Q = g.globals.colors[c];
      if (g.config.tooltip.x.formatter === void 0)
        if (g.config.xaxis.type === "datetime") {
          var v = new ye(s);
          $ = v.formatDate(v.getDate(b), g.config.tooltip.x.format), G = v.formatDate(v.getDate(y), g.config.tooltip.x.format)
        } else $ = b, G = y;
      else $ = g.config.tooltip.x.formatter(b), G = g.config.tooltip.x.formatter(y);
      return {
        start: b,
        end: y,
        startVal: $,
        endVal: G,
        ylabel: x,
        color: Q,
        seriesName: _
      }
    },
    Ae = function (Y) {
      var r = Y.color,
        n = Y.seriesName,
        s = Y.ylabel,
        c = Y.start,
        u = Y.end,
        d = Y.seriesIndex,
        f = Y.dataPointIndex,
        g = Y.ctx.tooltip.tooltipLabels.getFormatters(d);
      c = g.yLbFormatter(c), u = g.yLbFormatter(u);
      var b = g.yLbFormatter(Y.w.globals.series[d][f]),
        y = `<span class="value start-value">
  `.concat(c, `
  </span> <span class="separator">-</span> <span class="value end-value">
  `).concat(u, `
  </span>`);
      return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + r + '">' + (n || "") + '</span></div><div> <span class="category">' + s + ": </span> " + (Y.w.globals.comboCharts ? Y.w.config.series[d].type === "rangeArea" || Y.w.config.series[d].type === "rangeBar" ? y : "<span>".concat(b, "</span>") : y) + " </div></div>"
    },
    He = function () {
      function Y(r) {
        l(this, Y), this.opts = r
      }
      return p(Y, [{
        key: "hideYAxis",
        value: function () {
          this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0
        }
      }, {
        key: "line",
        value: function () {
          return {
            chart: {
              animations: {
                easing: "swing"
              }
            },
            dataLabels: {
              enabled: !1
            },
            stroke: {
              width: 5,
              curve: "straight"
            },
            markers: {
              size: 0,
              hover: {
                sizeOffset: 6
              }
            },
            xaxis: {
              crosshairs: {
                width: 1
              }
            }
          }
        }
      }, {
        key: "sparkline",
        value: function (r) {
          return this.hideYAxis(), I.extend(r, {
            grid: {
              show: !1,
              padding: {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
              }
            },
            legend: {
              show: !1
            },
            xaxis: {
              labels: {
                show: !1
              },
              tooltip: {
                enabled: !1
              },
              axisBorder: {
                show: !1
              },
              axisTicks: {
                show: !1
              }
            },
            chart: {
              toolbar: {
                show: !1
              },
              zoom: {
                enabled: !1
              }
            },
            dataLabels: {
              enabled: !1
            }
          })
        }
      }, {
        key: "bar",
        value: function () {
          return {
            chart: {
              stacked: !1,
              animations: {
                easing: "swing"
              }
            },
            plotOptions: {
              bar: {
                dataLabels: {
                  position: "center"
                }
              }
            },
            dataLabels: {
              style: {
                colors: ["#fff"]
              },
              background: {
                enabled: !1
              }
            },
            stroke: {
              width: 0,
              lineCap: "round"
            },
            fill: {
              opacity: .85
            },
            legend: {
              markers: {
                shape: "square",
                radius: 2,
                size: 8
              }
            },
            tooltip: {
              shared: !1,
              intersect: !0
            },
            xaxis: {
              tooltip: {
                enabled: !1
              },
              tickPlacement: "between",
              crosshairs: {
                width: "barWidth",
                position: "back",
                fill: {
                  type: "gradient"
                },
                dropShadow: {
                  enabled: !1
                },
                stroke: {
                  width: 0
                }
              }
            }
          }
        }
      }, {
        key: "funnel",
        value: function () {
          return this.hideYAxis(), i(i({}, this.bar()), {}, {
            chart: {
              animations: {
                easing: "linear",
                speed: 800,
                animateGradually: {
                  enabled: !1
                }
              }
            },
            plotOptions: {
              bar: {
                horizontal: !0,
                borderRadiusApplication: "around",
                borderRadius: 0,
                dataLabels: {
                  position: "center"
                }
              }
            },
            grid: {
              show: !1,
              padding: {
                left: 0,
                right: 0
              }
            },
            xaxis: {
              labels: {
                show: !1
              },
              tooltip: {
                enabled: !1
              },
              axisBorder: {
                show: !1
              },
              axisTicks: {
                show: !1
              }
            }
          })
        }
      }, {
        key: "candlestick",
        value: function () {
          var r = this;
          return {
            stroke: {
              width: 1,
              colors: ["#333"]
            },
            fill: {
              opacity: 1
            },
            dataLabels: {
              enabled: !1
            },
            tooltip: {
              shared: !0,
              custom: function (n) {
                var s = n.seriesIndex,
                  c = n.dataPointIndex,
                  u = n.w;
                return r._getBoxTooltip(u, s, c, ["Open", "High", "", "Low", "Close"], "candlestick")
              }
            },
            states: {
              active: {
                filter: {
                  type: "none"
                }
              }
            },
            xaxis: {
              crosshairs: {
                width: 1
              }
            }
          }
        }
      }, {
        key: "boxPlot",
        value: function () {
          var r = this;
          return {
            chart: {
              animations: {
                dynamicAnimation: {
                  enabled: !1
                }
              }
            },
            stroke: {
              width: 1,
              colors: ["#24292e"]
            },
            dataLabels: {
              enabled: !1
            },
            tooltip: {
              shared: !0,
              custom: function (n) {
                var s = n.seriesIndex,
                  c = n.dataPointIndex,
                  u = n.w;
                return r._getBoxTooltip(u, s, c, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot")
              }
            },
            markers: {
              size: 5,
              strokeWidth: 1,
              strokeColors: "#111"
            },
            xaxis: {
              crosshairs: {
                width: 1
              }
            }
          }
        }
      }, {
        key: "rangeBar",
        value: function () {
          return {
            chart: {
              animations: {
                animateGradually: !1
              }
            },
            stroke: {
              width: 0,
              lineCap: "square"
            },
            plotOptions: {
              bar: {
                borderRadius: 0,
                dataLabels: {
                  position: "center"
                }
              }
            },
            dataLabels: {
              enabled: !1,
              formatter: function (r, n) {
                n.ctx;
                var s = n.seriesIndex,
                  c = n.dataPointIndex,
                  u = n.w,
                  d = function () {
                    var f = u.globals.seriesRangeStart[s][c];
                    return u.globals.seriesRangeEnd[s][c] - f
                  };
                return u.globals.comboCharts ? u.config.series[s].type === "rangeBar" || u.config.series[s].type === "rangeArea" ? d() : r : d()
              },
              background: {
                enabled: !1
              },
              style: {
                colors: ["#fff"]
              }
            },
            markers: {
              size: 10
            },
            tooltip: {
              shared: !1,
              followCursor: !0,
              custom: function (r) {
                return r.w.config.plotOptions && r.w.config.plotOptions.bar && r.w.config.plotOptions.bar.horizontal ? function (n) {
                  var s = me(i(i({}, n), {}, {
                      isTimeline: !0
                    })),
                    c = s.color,
                    u = s.seriesName,
                    d = s.ylabel,
                    f = s.startVal,
                    g = s.endVal;
                  return Ae(i(i({}, n), {}, {
                    color: c,
                    seriesName: u,
                    ylabel: d,
                    start: f,
                    end: g
                  }))
                }(r) : function (n) {
                  var s = me(n),
                    c = s.color,
                    u = s.seriesName,
                    d = s.ylabel,
                    f = s.start,
                    g = s.end;
                  return Ae(i(i({}, n), {}, {
                    color: c,
                    seriesName: u,
                    ylabel: d,
                    start: f,
                    end: g
                  }))
                }(r)
              }
            },
            xaxis: {
              tickPlacement: "between",
              tooltip: {
                enabled: !1
              },
              crosshairs: {
                stroke: {
                  width: 0
                }
              }
            }
          }
        }
      }, {
        key: "dumbbell",
        value: function (r) {
          var n, s;
          return (n = r.plotOptions.bar) !== null && n !== void 0 && n.barHeight || (r.plotOptions.bar.barHeight = 2), (s = r.plotOptions.bar) !== null && s !== void 0 && s.columnWidth || (r.plotOptions.bar.columnWidth = 2), r
        }
      }, {
        key: "area",
        value: function () {
          return {
            stroke: {
              width: 4,
              fill: {
                type: "solid",
                gradient: {
                  inverseColors: !1,
                  shade: "light",
                  type: "vertical",
                  opacityFrom: .65,
                  opacityTo: .5,
                  stops: [0, 100, 100]
                }
              }
            },
            fill: {
              type: "gradient",
              gradient: {
                inverseColors: !1,
                shade: "light",
                type: "vertical",
                opacityFrom: .65,
                opacityTo: .5,
                stops: [0, 100, 100]
              }
            },
            markers: {
              size: 0,
              hover: {
                sizeOffset: 6
              }
            },
            tooltip: {
              followCursor: !1
            }
          }
        }
      }, {
        key: "rangeArea",
        value: function () {
          return {
            stroke: {
              curve: "straight",
              width: 0
            },
            fill: {
              type: "solid",
              opacity: .6
            },
            markers: {
              size: 0
            },
            states: {
              hover: {
                filter: {
                  type: "none"
                }
              },
              active: {
                filter: {
                  type: "none"
                }
              }
            },
            tooltip: {
              intersect: !1,
              shared: !0,
              followCursor: !0,
              custom: function (r) {
                return function (n) {
                  var s = me(n),
                    c = s.color,
                    u = s.seriesName,
                    d = s.ylabel,
                    f = s.start,
                    g = s.end;
                  return Ae(i(i({}, n), {}, {
                    color: c,
                    seriesName: u,
                    ylabel: d,
                    start: f,
                    end: g
                  }))
                }(r)
              }
            }
          }
        }
      }, {
        key: "brush",
        value: function (r) {
          return I.extend(r, {
            chart: {
              toolbar: {
                autoSelected: "selection",
                show: !1
              },
              zoom: {
                enabled: !1
              }
            },
            dataLabels: {
              enabled: !1
            },
            stroke: {
              width: 1
            },
            tooltip: {
              enabled: !1
            },
            xaxis: {
              tooltip: {
                enabled: !1
              }
            }
          })
        }
      }, {
        key: "stacked100",
        value: function (r) {
          r.dataLabels = r.dataLabels || {}, r.dataLabels.formatter = r.dataLabels.formatter || void 0;
          var n = r.dataLabels.formatter;
          return r.yaxis.forEach(function (s, c) {
            r.yaxis[c].min = 0, r.yaxis[c].max = 100
          }), r.chart.type === "bar" && (r.dataLabels.formatter = n || function (s) {
            return typeof s == "number" && s ? s.toFixed(0) + "%" : s
          }), r
        }
      }, {
        key: "stackedBars",
        value: function () {
          var r = this.bar();
          return i(i({}, r), {}, {
            plotOptions: i(i({}, r.plotOptions), {}, {
              bar: i(i({}, r.plotOptions.bar), {}, {
                borderRadiusApplication: "end",
                borderRadiusWhenStacked: "last"
              })
            })
          })
        }
      }, {
        key: "convertCatToNumeric",
        value: function (r) {
          return r.xaxis.convertedCatToNumeric = !0, r
        }
      }, {
        key: "convertCatToNumericXaxis",
        value: function (r, n, s) {
          r.xaxis.type = "numeric", r.xaxis.labels = r.xaxis.labels || {}, r.xaxis.labels.formatter = r.xaxis.labels.formatter || function (d) {
            return I.isNumber(d) ? Math.floor(d) : d
          };
          var c = r.xaxis.labels.formatter,
            u = r.xaxis.categories && r.xaxis.categories.length ? r.xaxis.categories : r.labels;
          return s && s.length && (u = s.map(function (d) {
            return Array.isArray(d) ? d : String(d)
          })), u && u.length && (r.xaxis.labels.formatter = function (d) {
            return I.isNumber(d) ? c(u[Math.floor(d) - 1]) : c(d)
          }), r.xaxis.categories = [], r.labels = [], r.xaxis.tickAmount = r.xaxis.tickAmount || "dataPoints", r
        }
      }, {
        key: "bubble",
        value: function () {
          return {
            dataLabels: {
              style: {
                colors: ["#fff"]
              }
            },
            tooltip: {
              shared: !1,
              intersect: !0
            },
            xaxis: {
              crosshairs: {
                width: 0
              }
            },
            fill: {
              type: "solid",
              gradient: {
                shade: "light",
                inverse: !0,
                shadeIntensity: .55,
                opacityFrom: .4,
                opacityTo: .8
              }
            }
          }
        }
      }, {
        key: "scatter",
        value: function () {
          return {
            dataLabels: {
              enabled: !1
            },
            tooltip: {
              shared: !1,
              intersect: !0
            },
            markers: {
              size: 6,
              strokeWidth: 1,
              hover: {
                sizeOffset: 2
              }
            }
          }
        }
      }, {
        key: "heatmap",
        value: function () {
          return {
            chart: {
              stacked: !1
            },
            fill: {
              opacity: 1
            },
            dataLabels: {
              style: {
                colors: ["#fff"]
              }
            },
            stroke: {
              colors: ["#fff"]
            },
            tooltip: {
              followCursor: !0,
              marker: {
                show: !1
              },
              x: {
                show: !1
              }
            },
            legend: {
              position: "top",
              markers: {
                shape: "square",
                size: 10,
                offsetY: 2
              }
            },
            grid: {
              padding: {
                right: 20
              }
            }
          }
        }
      }, {
        key: "treemap",
        value: function () {
          return {
            chart: {
              zoom: {
                enabled: !1
              }
            },
            dataLabels: {
              style: {
                fontSize: 14,
                fontWeight: 600,
                colors: ["#fff"]
              }
            },
            stroke: {
              show: !0,
              width: 2,
              colors: ["#fff"]
            },
            legend: {
              show: !1
            },
            fill: {
              gradient: {
                stops: [0, 100]
              }
            },
            tooltip: {
              followCursor: !0,
              x: {
                show: !1
              }
            },
            grid: {
              padding: {
                left: 0,
                right: 0
              }
            },
            xaxis: {
              crosshairs: {
                show: !1
              },
              tooltip: {
                enabled: !1
              }
            }
          }
        }
      }, {
        key: "pie",
        value: function () {
          return {
            chart: {
              toolbar: {
                show: !1
              }
            },
            plotOptions: {
              pie: {
                donut: {
                  labels: {
                    show: !1
                  }
                }
              }
            },
            dataLabels: {
              formatter: function (r) {
                return r.toFixed(1) + "%"
              },
              style: {
                colors: ["#fff"]
              },
              background: {
                enabled: !1
              },
              dropShadow: {
                enabled: !0
              }
            },
            stroke: {
              colors: ["#fff"]
            },
            fill: {
              opacity: 1,
              gradient: {
                shade: "light",
                stops: [0, 100]
              }
            },
            tooltip: {
              theme: "dark",
              fillSeriesColor: !0
            },
            legend: {
              position: "right"
            }
          }
        }
      }, {
        key: "donut",
        value: function () {
          return {
            chart: {
              toolbar: {
                show: !1
              }
            },
            dataLabels: {
              formatter: function (r) {
                return r.toFixed(1) + "%"
              },
              style: {
                colors: ["#fff"]
              },
              background: {
                enabled: !1
              },
              dropShadow: {
                enabled: !0
              }
            },
            stroke: {
              colors: ["#fff"]
            },
            fill: {
              opacity: 1,
              gradient: {
                shade: "light",
                shadeIntensity: .35,
                stops: [80, 100],
                opacityFrom: 1,
                opacityTo: 1
              }
            },
            tooltip: {
              theme: "dark",
              fillSeriesColor: !0
            },
            legend: {
              position: "right"
            }
          }
        }
      }, {
        key: "polarArea",
        value: function () {
          return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, {
            chart: {
              toolbar: {
                show: !1
              }
            },
            dataLabels: {
              formatter: function (r) {
                return r.toFixed(1) + "%"
              },
              enabled: !1
            },
            stroke: {
              show: !0,
              width: 2
            },
            fill: {
              opacity: .7
            },
            tooltip: {
              theme: "dark",
              fillSeriesColor: !0
            },
            legend: {
              position: "right"
            }
          }
        }
      }, {
        key: "radar",
        value: function () {
          return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
            dataLabels: {
              enabled: !1,
              style: {
                fontSize: "11px"
              }
            },
            stroke: {
              width: 2
            },
            markers: {
              size: 3,
              strokeWidth: 1,
              strokeOpacity: 1
            },
            fill: {
              opacity: .2
            },
            tooltip: {
              shared: !1,
              intersect: !0,
              followCursor: !0
            },
            grid: {
              show: !1
            },
            xaxis: {
              labels: {
                formatter: function (r) {
                  return r
                },
                style: {
                  colors: ["#a8a8a8"],
                  fontSize: "11px"
                }
              },
              tooltip: {
                enabled: !1
              },
              crosshairs: {
                show: !1
              }
            }
          }
        }
      }, {
        key: "radialBar",
        value: function () {
          return {
            chart: {
              animations: {
                dynamicAnimation: {
                  enabled: !0,
                  speed: 800
                }
              },
              toolbar: {
                show: !1
              }
            },
            fill: {
              gradient: {
                shade: "dark",
                shadeIntensity: .4,
                inverseColors: !1,
                type: "diagonal2",
                opacityFrom: 1,
                opacityTo: 1,
                stops: [70, 98, 100]
              }
            },
            legend: {
              show: !1,
              position: "right"
            },
            tooltip: {
              enabled: !1,
              fillSeriesColor: !0
            }
          }
        }
      }, {
        key: "_getBoxTooltip",
        value: function (r, n, s, c, u) {
          var d = r.globals.seriesCandleO[n][s],
            f = r.globals.seriesCandleH[n][s],
            g = r.globals.seriesCandleM[n][s],
            b = r.globals.seriesCandleL[n][s],
            y = r.globals.seriesCandleC[n][s];
          return r.config.series[n].type && r.config.series[n].type !== u ? `<div class="apexcharts-custom-tooltip">
          `.concat(r.config.series[n].name ? r.config.series[n].name : "series-" + (n + 1), ": <strong>").concat(r.globals.series[n][s], `</strong>
        </div>`) : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(r.config.chart.type, '">') + "<div>".concat(c[0], ': <span class="value">') + d + "</span></div>" + "<div>".concat(c[1], ': <span class="value">') + f + "</span></div>" + (g ? "<div>".concat(c[2], ': <span class="value">') + g + "</span></div>" : "") + "<div>".concat(c[3], ': <span class="value">') + b + "</span></div>" + "<div>".concat(c[4], ': <span class="value">') + y + "</span></div></div>"
        }
      }]), Y
    }(),
    De = function () {
      function Y(r) {
        l(this, Y), this.opts = r
      }
      return p(Y, [{
        key: "init",
        value: function (r) {
          var n = r.responsiveOverride,
            s = this.opts,
            c = new le,
            u = new He(s);
          this.chartType = s.chart.type, s = this.extendYAxis(s), s = this.extendAnnotations(s);
          var d = c.init(),
            f = {};
          if (s && o(s) === "object") {
            var g, b, y, x, _, T, P, O, $ = {};
            $ = ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(s.chart.type) !== -1 ? u[s.chart.type]() : u.line(), (g = s.plotOptions) !== null && g !== void 0 && (b = g.bar) !== null && b !== void 0 && b.isFunnel && ($ = u.funnel()), s.chart.stacked && s.chart.type === "bar" && ($ = u.stackedBars()), (y = s.chart.brush) !== null && y !== void 0 && y.enabled && ($ = u.brush($)), s.chart.stacked && s.chart.stackType === "100%" && (s = u.stacked100(s)), (x = s.plotOptions) !== null && x !== void 0 && (_ = x.bar) !== null && _ !== void 0 && _.isDumbbell && (s = u.dumbbell(s)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(s), s.xaxis = s.xaxis || window.Apex.xaxis || {}, n || (s.xaxis.convertedCatToNumeric = !1), ((T = (s = this.checkForCatToNumericXAxis(this.chartType, $, s)).chart.sparkline) !== null && T !== void 0 && T.enabled || (P = window.Apex.chart) !== null && P !== void 0 && (O = P.sparkline) !== null && O !== void 0 && O.enabled) && ($ = u.sparkline($)), f = I.extend(d, $)
          }
          var G = I.extend(f, window.Apex);
          return d = I.extend(G, s), d = this.handleUserInputErrors(d)
        }
      }, {
        key: "checkForCatToNumericXAxis",
        value: function (r, n, s) {
          var c, u, d = new He(s),
            f = (r === "bar" || r === "boxPlot") && ((c = s.plotOptions) === null || c === void 0 || (u = c.bar) === null || u === void 0 ? void 0 : u.horizontal),
            g = r === "pie" || r === "polarArea" || r === "donut" || r === "radar" || r === "radialBar" || r === "heatmap",
            b = s.xaxis.type !== "datetime" && s.xaxis.type !== "numeric",
            y = s.xaxis.tickPlacement ? s.xaxis.tickPlacement : n.xaxis && n.xaxis.tickPlacement;
          return f || g || !b || y === "between" || (s = d.convertCatToNumeric(s)), s
        }
      }, {
        key: "extendYAxis",
        value: function (r, n) {
          var s = new le;
          (r.yaxis === void 0 || !r.yaxis || Array.isArray(r.yaxis) && r.yaxis.length === 0) && (r.yaxis = {}), r.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (r.yaxis = I.extend(r.yaxis, window.Apex.yaxis)), r.yaxis.constructor !== Array ? r.yaxis = [I.extend(s.yAxis, r.yaxis)] : r.yaxis = I.extendArray(r.yaxis, s.yAxis);
          var c = !1;
          r.yaxis.forEach(function (d) {
            d.logarithmic && (c = !0)
          });
          var u = r.series;
          return n && !u && (u = n.config.series), c && u.length !== r.yaxis.length && u.length && (r.yaxis = u.map(function (d, f) {
            if (d.name || (u[f].name = "series-".concat(f + 1)), r.yaxis[f]) return r.yaxis[f].seriesName = u[f].name, r.yaxis[f];
            var g = I.extend(s.yAxis, r.yaxis[0]);
            return g.show = !1, g
          })), c && u.length > 1 && u.length !== r.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), r
        }
      }, {
        key: "extendAnnotations",
        value: function (r) {
          return r.annotations === void 0 && (r.annotations = {}, r.annotations.yaxis = [], r.annotations.xaxis = [], r.annotations.points = []), r = this.extendYAxisAnnotations(r), r = this.extendXAxisAnnotations(r), r = this.extendPointAnnotations(r)
        }
      }, {
        key: "extendYAxisAnnotations",
        value: function (r) {
          var n = new le;
          return r.annotations.yaxis = I.extendArray(r.annotations.yaxis !== void 0 ? r.annotations.yaxis : [], n.yAxisAnnotation), r
        }
      }, {
        key: "extendXAxisAnnotations",
        value: function (r) {
          var n = new le;
          return r.annotations.xaxis = I.extendArray(r.annotations.xaxis !== void 0 ? r.annotations.xaxis : [], n.xAxisAnnotation), r
        }
      }, {
        key: "extendPointAnnotations",
        value: function (r) {
          var n = new le;
          return r.annotations.points = I.extendArray(r.annotations.points !== void 0 ? r.annotations.points : [], n.pointAnnotation), r
        }
      }, {
        key: "checkForDarkTheme",
        value: function (r) {
          r.theme && r.theme.mode === "dark" && (r.tooltip || (r.tooltip = {}), r.tooltip.theme !== "light" && (r.tooltip.theme = "dark"), r.chart.foreColor || (r.chart.foreColor = "#f6f7f8"), r.chart.background || (r.chart.background = "#424242"), r.theme.palette || (r.theme.palette = "palette4"))
        }
      }, {
        key: "handleUserInputErrors",
        value: function (r) {
          var n = r;
          if (n.tooltip.shared && n.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
          if (n.chart.type === "bar" && n.plotOptions.bar.horizontal) {
            if (n.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
            n.yaxis[0].reversed && (n.yaxis[0].opposite = !0), n.xaxis.tooltip.enabled = !1, n.yaxis[0].tooltip.enabled = !1, n.chart.zoom.enabled = !1
          }
          return n.chart.type !== "bar" && n.chart.type !== "rangeBar" || n.tooltip.shared && n.xaxis.crosshairs.width === "barWidth" && n.series.length > 1 && (n.xaxis.crosshairs.width = "tickWidth"), n.chart.type !== "candlestick" && n.chart.type !== "boxPlot" || n.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(n.chart.type, " chart is not supported.")), n.yaxis[0].reversed = !1), n
        }
      }]), Y
    }(),
    Ye = function () {
      function Y() {
        l(this, Y)
      }
      return p(Y, [{
        key: "initGlobalVars",
        value: function (r) {
          r.series = [], r.seriesCandleO = [], r.seriesCandleH = [], r.seriesCandleM = [], r.seriesCandleL = [], r.seriesCandleC = [], r.seriesRangeStart = [], r.seriesRangeEnd = [], r.seriesRange = [], r.seriesPercent = [], r.seriesGoals = [], r.seriesX = [], r.seriesZ = [], r.seriesNames = [], r.seriesTotals = [], r.seriesLog = [], r.seriesColors = [], r.stackedSeriesTotals = [], r.seriesXvalues = [], r.seriesYvalues = [], r.labels = [], r.hasXaxisGroups = !1, r.groups = [], r.hasSeriesGroups = !1, r.seriesGroups = [], r.categoryLabels = [], r.timescaleLabels = [], r.noLabelsProvided = !1, r.resizeTimer = null, r.selectionResizeTimer = null, r.delayedElements = [], r.pointsArray = [], r.dataLabelsRects = [], r.isXNumeric = !1, r.skipLastTimelinelabel = !1, r.skipFirstTimelinelabel = !1, r.isDataXYZ = !1, r.isMultiLineX = !1, r.isMultipleYAxis = !1, r.maxY = -Number.MAX_VALUE, r.minY = Number.MIN_VALUE, r.minYArr = [], r.maxYArr = [], r.maxX = -Number.MAX_VALUE, r.minX = Number.MAX_VALUE, r.initialMaxX = -Number.MAX_VALUE, r.initialMinX = Number.MAX_VALUE, r.maxDate = 0, r.minDate = Number.MAX_VALUE, r.minZ = Number.MAX_VALUE, r.maxZ = -Number.MAX_VALUE, r.minXDiff = Number.MAX_VALUE, r.yAxisScale = [], r.xAxisScale = null, r.xAxisTicksPositions = [], r.yLabelsCoords = [], r.yTitleCoords = [], r.barPadForNumericAxis = 0, r.padHorizontal = 0, r.xRange = 0, r.yRange = [], r.zRange = 0, r.dataPoints = 0, r.xTickAmount = 0
        }
      }, {
        key: "globalVars",
        value: function (r) {
          return {
            chartID: null,
            cuid: null,
            events: {
              beforeMount: [],
              mounted: [],
              updated: [],
              clicked: [],
              selection: [],
              dataPointSelection: [],
              zoomed: [],
              scrolled: []
            },
            colors: [],
            clientX: null,
            clientY: null,
            fill: {
              colors: []
            },
            stroke: {
              colors: []
            },
            dataLabels: {
              style: {
                colors: []
              }
            },
            radarPolygons: {
              fill: {
                colors: []
              }
            },
            markers: {
              colors: [],
              size: r.markers.size,
              largestSize: 0
            },
            animationEnded: !1,
            isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
            isDirty: !1,
            isExecCalled: !1,
            initialConfig: null,
            initialSeries: [],
            lastXAxis: [],
            lastYAxis: [],
            columnSeries: null,
            labels: [],
            timescaleLabels: [],
            noLabelsProvided: !1,
            allSeriesCollapsed: !1,
            collapsedSeries: [],
            collapsedSeriesIndices: [],
            ancillaryCollapsedSeries: [],
            ancillaryCollapsedSeriesIndices: [],
            risingSeries: [],
            dataFormatXNumeric: !1,
            capturedSeriesIndex: -1,
            capturedDataPointIndex: -1,
            selectedDataPoints: [],
            goldenPadding: 35,
            invalidLogScale: !1,
            ignoreYAxisIndexes: [],
            yAxisSameScaleIndices: [],
            maxValsInArrayIndex: 0,
            radialSize: 0,
            selection: void 0,
            zoomEnabled: r.chart.toolbar.autoSelected === "zoom" && r.chart.toolbar.tools.zoom && r.chart.zoom.enabled,
            panEnabled: r.chart.toolbar.autoSelected === "pan" && r.chart.toolbar.tools.pan,
            selectionEnabled: r.chart.toolbar.autoSelected === "selection" && r.chart.toolbar.tools.selection,
            yaxis: null,
            mousedown: !1,
            lastClientPosition: {},
            visibleXRange: void 0,
            yValueDecimal: 0,
            total: 0,
            SVGNS: "http://www.w3.org/2000/svg",
            svgWidth: 0,
            svgHeight: 0,
            noData: !1,
            locale: {},
            dom: {},
            memory: {
              methodsToExec: []
            },
            shouldAnimate: !0,
            skipLastTimelinelabel: !1,
            skipFirstTimelinelabel: !1,
            delayedElements: [],
            axisCharts: !0,
            isDataXYZ: !1,
            resized: !1,
            resizeTimer: null,
            comboCharts: !1,
            dataChanged: !1,
            previousPaths: [],
            allSeriesHasEqualX: !0,
            pointsArray: [],
            dataLabelsRects: [],
            lastDrawnDataLabelsIndexes: [],
            hasNullValues: !1,
            easing: null,
            zoomed: !1,
            gridWidth: 0,
            gridHeight: 0,
            rotateXLabels: !1,
            defaultLabels: !1,
            xLabelFormatter: void 0,
            yLabelFormatters: [],
            xaxisTooltipFormatter: void 0,
            ttKeyFormatter: void 0,
            ttVal: void 0,
            ttZFormatter: void 0,
            LINE_HEIGHT_RATIO: 1.618,
            xAxisLabelsHeight: 0,
            xAxisGroupLabelsHeight: 0,
            xAxisLabelsWidth: 0,
            yAxisLabelsWidth: 0,
            scaleX: 1,
            scaleY: 1,
            translateX: 0,
            translateY: 0,
            translateYAxisX: [],
            yAxisWidths: [],
            translateXAxisY: 0,
            translateXAxisX: 0,
            tooltip: null
          }
        }
      }, {
        key: "init",
        value: function (r) {
          var n = this.globalVars(r);
          return this.initGlobalVars(n), n.initialConfig = I.extend({}, r), n.initialSeries = I.clone(r.series), n.lastXAxis = I.clone(n.initialConfig.xaxis), n.lastYAxis = I.clone(n.initialConfig.yaxis), n
        }
      }]), Y
    }(),
    Je = function () {
      function Y(r) {
        l(this, Y), this.opts = r
      }
      return p(Y, [{
        key: "init",
        value: function () {
          var r = new De(this.opts).init({
            responsiveOverride: !1
          });
          return {
            config: r,
            globals: new Ye().init(r)
          }
        }
      }]), Y
    }(),
    he = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.opts = null, this.seriesIndex = 0
      }
      return p(Y, [{
        key: "clippedImgArea",
        value: function (r) {
          var n = this.w,
            s = n.config,
            c = parseInt(n.globals.gridWidth, 10),
            u = parseInt(n.globals.gridHeight, 10),
            d = c > u ? c : u,
            f = r.image,
            g = 0,
            b = 0;
          r.width === void 0 && r.height === void 0 ? s.fill.image.width !== void 0 && s.fill.image.height !== void 0 ? (g = s.fill.image.width + 1, b = s.fill.image.height) : (g = d + 1, b = d) : (g = r.width, b = r.height);
          var y = document.createElementNS(n.globals.SVGNS, "pattern");
          W.setAttrs(y, {
            id: r.patternID,
            patternUnits: r.patternUnits ? r.patternUnits : "userSpaceOnUse",
            width: g + "px",
            height: b + "px"
          });
          var x = document.createElementNS(n.globals.SVGNS, "image");
          y.appendChild(x), x.setAttributeNS(window.SVG.xlink, "href", f), W.setAttrs(x, {
            x: 0,
            y: 0,
            preserveAspectRatio: "none",
            width: g + "px",
            height: b + "px"
          }), x.style.opacity = r.opacity, n.globals.dom.elDefs.node.appendChild(y)
        }
      }, {
        key: "getSeriesIndex",
        value: function (r) {
          var n = this.w,
            s = n.config.chart.type;
          return (s === "bar" || s === "rangeBar") && n.config.plotOptions.bar.distributed || s === "heatmap" || s === "treemap" ? this.seriesIndex = r.seriesNumber : this.seriesIndex = r.seriesNumber % n.globals.series.length, this.seriesIndex
        }
      }, {
        key: "fillPath",
        value: function (r) {
          var n = this.w;
          this.opts = r;
          var s, c, u, d = this.w.config;
          this.seriesIndex = this.getSeriesIndex(r);
          var f = this.getFillColors()[this.seriesIndex];
          n.globals.seriesColors[this.seriesIndex] !== void 0 && (f = n.globals.seriesColors[this.seriesIndex]), typeof f == "function" && (f = f({
            seriesIndex: this.seriesIndex,
            dataPointIndex: r.dataPointIndex,
            value: r.value,
            w: n
          }));
          var g = r.fillType ? r.fillType : this.getFillType(this.seriesIndex),
            b = Array.isArray(d.fill.opacity) ? d.fill.opacity[this.seriesIndex] : d.fill.opacity;
          r.color && (f = r.color), f || (f = "#fff", console.warn("undefined color - ApexCharts"));
          var y = f;
          if (f.indexOf("rgb") === -1 ? f.length < 9 && (y = I.hexToRgba(f, b)) : f.indexOf("rgba") > -1 && (b = I.getOpacityFromRGBA(f)), r.opacity && (b = r.opacity), g === "pattern" && (c = this.handlePatternFill({
              fillConfig: r.fillConfig,
              patternFill: c,
              fillColor: f,
              fillOpacity: b,
              defaultColor: y
            })), g === "gradient" && (u = this.handleGradientFill({
              fillConfig: r.fillConfig,
              fillColor: f,
              fillOpacity: b,
              i: this.seriesIndex
            })), g === "image") {
            var x = d.fill.image.src,
              _ = r.patternID ? r.patternID : "";
            this.clippedImgArea({
              opacity: b,
              image: Array.isArray(x) ? r.seriesNumber < x.length ? x[r.seriesNumber] : x[0] : x,
              width: r.width ? r.width : void 0,
              height: r.height ? r.height : void 0,
              patternUnits: r.patternUnits,
              patternID: "pattern".concat(n.globals.cuid).concat(r.seriesNumber + 1).concat(_)
            }), s = "url(#pattern".concat(n.globals.cuid).concat(r.seriesNumber + 1).concat(_, ")")
          } else s = g === "gradient" ? u : g === "pattern" ? c : y;
          return r.solid && (s = y), s
        }
      }, {
        key: "getFillType",
        value: function (r) {
          var n = this.w;
          return Array.isArray(n.config.fill.type) ? n.config.fill.type[r] : n.config.fill.type
        }
      }, {
        key: "getFillColors",
        value: function () {
          var r = this.w,
            n = r.config,
            s = this.opts,
            c = [];
          return r.globals.comboCharts ? r.config.series[this.seriesIndex].type === "line" ? Array.isArray(r.globals.stroke.colors) ? c = r.globals.stroke.colors : c.push(r.globals.stroke.colors) : Array.isArray(r.globals.fill.colors) ? c = r.globals.fill.colors : c.push(r.globals.fill.colors) : n.chart.type === "line" ? Array.isArray(r.globals.stroke.colors) ? c = r.globals.stroke.colors : c.push(r.globals.stroke.colors) : Array.isArray(r.globals.fill.colors) ? c = r.globals.fill.colors : c.push(r.globals.fill.colors), s.fillColors !== void 0 && (c = [], Array.isArray(s.fillColors) ? c = s.fillColors.slice() : c.push(s.fillColors)), c
        }
      }, {
        key: "handlePatternFill",
        value: function (r) {
          var n = r.fillConfig,
            s = r.patternFill,
            c = r.fillColor,
            u = r.fillOpacity,
            d = r.defaultColor,
            f = this.w.config.fill;
          n && (f = n);
          var g = this.opts,
            b = new W(this.ctx),
            y = Array.isArray(f.pattern.strokeWidth) ? f.pattern.strokeWidth[this.seriesIndex] : f.pattern.strokeWidth,
            x = c;
          return Array.isArray(f.pattern.style) ? s = f.pattern.style[g.seriesNumber] !== void 0 ? b.drawPattern(f.pattern.style[g.seriesNumber], f.pattern.width, f.pattern.height, x, y, u) : d : s = b.drawPattern(f.pattern.style, f.pattern.width, f.pattern.height, x, y, u), s
        }
      }, {
        key: "handleGradientFill",
        value: function (r) {
          var n = r.fillColor,
            s = r.fillOpacity,
            c = r.fillConfig,
            u = r.i,
            d = this.w.config.fill;
          c && (d = i(i({}, d), c));
          var f, g = this.opts,
            b = new W(this.ctx),
            y = new I,
            x = d.gradient.type,
            _ = n,
            T = d.gradient.opacityFrom === void 0 ? s : Array.isArray(d.gradient.opacityFrom) ? d.gradient.opacityFrom[u] : d.gradient.opacityFrom;
          _.indexOf("rgba") > -1 && (T = I.getOpacityFromRGBA(_));
          var P = d.gradient.opacityTo === void 0 ? s : Array.isArray(d.gradient.opacityTo) ? d.gradient.opacityTo[u] : d.gradient.opacityTo;
          if (d.gradient.gradientToColors === void 0 || d.gradient.gradientToColors.length === 0) f = d.gradient.shade === "dark" ? y.shadeColor(-1 * parseFloat(d.gradient.shadeIntensity), n.indexOf("rgb") > -1 ? I.rgb2hex(n) : n) : y.shadeColor(parseFloat(d.gradient.shadeIntensity), n.indexOf("rgb") > -1 ? I.rgb2hex(n) : n);
          else if (d.gradient.gradientToColors[g.seriesNumber]) {
            var O = d.gradient.gradientToColors[g.seriesNumber];
            f = O, O.indexOf("rgba") > -1 && (P = I.getOpacityFromRGBA(O))
          } else f = n;
          if (d.gradient.gradientFrom && (_ = d.gradient.gradientFrom), d.gradient.gradientTo && (f = d.gradient.gradientTo), d.gradient.inverseColors) {
            var $ = _;
            _ = f, f = $
          }
          return _.indexOf("rgb") > -1 && (_ = I.rgb2hex(_)), f.indexOf("rgb") > -1 && (f = I.rgb2hex(f)), b.drawGradient(x, _, f, T, P, g.size, d.gradient.stops, d.gradient.colorStops, u)
        }
      }]), Y
    }(),
    ke = function () {
      function Y(r, n) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "setGlobalMarkerSize",
        value: function () {
          var r = this.w;
          if (r.globals.markers.size = Array.isArray(r.config.markers.size) ? r.config.markers.size : [r.config.markers.size], r.globals.markers.size.length > 0) {
            if (r.globals.markers.size.length < r.globals.series.length + 1)
              for (var n = 0; n <= r.globals.series.length; n++) r.globals.markers.size[n] === void 0 && r.globals.markers.size.push(r.globals.markers.size[0])
          } else r.globals.markers.size = r.config.series.map(function (s) {
            return r.config.markers.size
          })
        }
      }, {
        key: "plotChartMarkers",
        value: function (r, n, s, c) {
          var u, d = arguments.length > 4 && arguments[4] !== void 0 && arguments[4],
            f = this.w,
            g = n,
            b = r,
            y = null,
            x = new W(this.ctx),
            _ = f.config.markers.discrete && f.config.markers.discrete.length;
          if ((f.globals.markers.size[n] > 0 || d || _) && (y = x.group({
              class: d || _ ? "" : "apexcharts-series-markers"
            })).attr("clip-path", "url(#gridRectMarkerMask".concat(f.globals.cuid, ")")), Array.isArray(b.x))
            for (var T = 0; T < b.x.length; T++) {
              var P = s;
              s === 1 && T === 0 && (P = 0), s === 1 && T === 1 && (P = 1);
              var O = "apexcharts-marker";
              if (f.config.chart.type !== "line" && f.config.chart.type !== "area" || f.globals.comboCharts || f.config.tooltip.intersect || (O += " no-pointer-events"), (Array.isArray(f.config.markers.size) ? f.globals.markers.size[n] > 0 : f.config.markers.size > 0) || d || _) {
                I.isNumber(b.y[T]) ? O += " w".concat(I.randomId()) : O = "apexcharts-nullpoint";
                var $ = this.getMarkerConfig({
                  cssClass: O,
                  seriesIndex: n,
                  dataPointIndex: P
                });
                f.config.series[g].data[P] && (f.config.series[g].data[P].fillColor && ($.pointFillColor = f.config.series[g].data[P].fillColor), f.config.series[g].data[P].strokeColor && ($.pointStrokeColor = f.config.series[g].data[P].strokeColor)), c && ($.pSize = c), (b.x[T] < 0 || b.x[T] > f.globals.gridWidth || b.y[T] < -f.globals.markers.largestSize || b.y[T] > f.globals.gridHeight + f.globals.markers.largestSize) && ($.pSize = 0), (u = x.drawMarker(b.x[T], b.y[T], $)).attr("rel", P), u.attr("j", P), u.attr("index", n), u.node.setAttribute("default-marker-size", $.pSize), new U(this.ctx).setSelectionFilter(u, n, P), this.addEvents(u), y && y.add(u)
              } else f.globals.pointsArray[n] === void 0 && (f.globals.pointsArray[n] = []), f.globals.pointsArray[n].push([b.x[T], b.y[T]])
            }
          return y
        }
      }, {
        key: "getMarkerConfig",
        value: function (r) {
          var n = r.cssClass,
            s = r.seriesIndex,
            c = r.dataPointIndex,
            u = c === void 0 ? null : c,
            d = r.finishRadius,
            f = d === void 0 ? null : d,
            g = this.w,
            b = this.getMarkerStyle(s),
            y = g.globals.markers.size[s],
            x = g.config.markers;
          return u !== null && x.discrete.length && x.discrete.map(function (_) {
            _.seriesIndex === s && _.dataPointIndex === u && (b.pointStrokeColor = _.strokeColor, b.pointFillColor = _.fillColor, y = _.size, b.pointShape = _.shape)
          }), {
            pSize: f === null ? y : f,
            pRadius: x.radius,
            width: Array.isArray(x.width) ? x.width[s] : x.width,
            height: Array.isArray(x.height) ? x.height[s] : x.height,
            pointStrokeWidth: Array.isArray(x.strokeWidth) ? x.strokeWidth[s] : x.strokeWidth,
            pointStrokeColor: b.pointStrokeColor,
            pointFillColor: b.pointFillColor,
            shape: b.pointShape || (Array.isArray(x.shape) ? x.shape[s] : x.shape),
            class: n,
            pointStrokeOpacity: Array.isArray(x.strokeOpacity) ? x.strokeOpacity[s] : x.strokeOpacity,
            pointStrokeDashArray: Array.isArray(x.strokeDashArray) ? x.strokeDashArray[s] : x.strokeDashArray,
            pointFillOpacity: Array.isArray(x.fillOpacity) ? x.fillOpacity[s] : x.fillOpacity,
            seriesIndex: s
          }
        }
      }, {
        key: "addEvents",
        value: function (r) {
          var n = this.w,
            s = new W(this.ctx);
          r.node.addEventListener("mouseenter", s.pathMouseEnter.bind(this.ctx, r)), r.node.addEventListener("mouseleave", s.pathMouseLeave.bind(this.ctx, r)), r.node.addEventListener("mousedown", s.pathMouseDown.bind(this.ctx, r)), r.node.addEventListener("click", n.config.markers.onClick), r.node.addEventListener("dblclick", n.config.markers.onDblClick), r.node.addEventListener("touchstart", s.pathMouseDown.bind(this.ctx, r), {
            passive: !0
          })
        }
      }, {
        key: "getMarkerStyle",
        value: function (r) {
          var n = this.w,
            s = n.globals.markers.colors,
            c = n.config.markers.strokeColor || n.config.markers.strokeColors;
          return {
            pointStrokeColor: Array.isArray(c) ? c[r] : c,
            pointFillColor: Array.isArray(s) ? s[r] : s
          }
        }
      }]), Y
    }(),
    re = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled
      }
      return p(Y, [{
        key: "draw",
        value: function (r, n, s) {
          var c = this.w,
            u = new W(this.ctx),
            d = s.realIndex,
            f = s.pointsPos,
            g = s.zRatio,
            b = s.elParent,
            y = u.group({
              class: "apexcharts-series-markers apexcharts-series-".concat(c.config.chart.type)
            });
          if (y.attr("clip-path", "url(#gridRectMarkerMask".concat(c.globals.cuid, ")")), Array.isArray(f.x))
            for (var x = 0; x < f.x.length; x++) {
              var _ = n + 1,
                T = !0;
              n === 0 && x === 0 && (_ = 0), n === 0 && x === 1 && (_ = 1);
              var P = 0,
                O = c.globals.markers.size[d];
              if (g !== 1 / 0) {
                var $ = c.config.plotOptions.bubble;
                O = c.globals.seriesZ[d][_], $.zScaling && (O /= g), $.minBubbleRadius && O < $.minBubbleRadius && (O = $.minBubbleRadius), $.maxBubbleRadius && O > $.maxBubbleRadius && (O = $.maxBubbleRadius)
              }
              c.config.chart.animations.enabled || (P = O);
              var G = f.x[x],
                Q = f.y[x];
              if (P = P || 0, Q !== null && c.globals.series[d][_] !== void 0 || (T = !1), T) {
                var v = this.drawPoint(G, Q, P, O, d, _, n);
                y.add(v)
              }
              b.add(y)
            }
        }
      }, {
        key: "drawPoint",
        value: function (r, n, s, c, u, d, f) {
          var g = this.w,
            b = u,
            y = new N(this.ctx),
            x = new U(this.ctx),
            _ = new he(this.ctx),
            T = new ke(this.ctx),
            P = new W(this.ctx),
            O = T.getMarkerConfig({
              cssClass: "apexcharts-marker",
              seriesIndex: b,
              dataPointIndex: d,
              finishRadius: g.config.chart.type === "bubble" || g.globals.comboCharts && g.config.series[u] && g.config.series[u].type === "bubble" ? c : null
            });
          c = O.pSize;
          var $, G = _.fillPath({
            seriesNumber: u,
            dataPointIndex: d,
            color: O.pointFillColor,
            patternUnits: "objectBoundingBox",
            value: g.globals.series[u][f]
          });
          if (O.shape === "circle" ? $ = P.drawCircle(s) : O.shape !== "square" && O.shape !== "rect" || ($ = P.drawRect(0, 0, O.width - O.pointStrokeWidth / 2, O.height - O.pointStrokeWidth / 2, O.pRadius)), g.config.series[b].data[d] && g.config.series[b].data[d].fillColor && (G = g.config.series[b].data[d].fillColor), $.attr({
              x: r - O.width / 2 - O.pointStrokeWidth / 2,
              y: n - O.height / 2 - O.pointStrokeWidth / 2,
              cx: r,
              cy: n,
              fill: G,
              "fill-opacity": O.pointFillOpacity,
              stroke: O.pointStrokeColor,
              r: c,
              "stroke-width": O.pointStrokeWidth,
              "stroke-dasharray": O.pointStrokeDashArray,
              "stroke-opacity": O.pointStrokeOpacity
            }), g.config.chart.dropShadow.enabled) {
            var Q = g.config.chart.dropShadow;
            x.dropShadow($, Q, u)
          }
          if (!this.initialAnim || g.globals.dataChanged || g.globals.resized) g.globals.animationEnded = !0;
          else {
            var v = g.config.chart.animations.speed;
            y.animateMarker($, 0, O.shape === "circle" ? c : {
              width: O.width,
              height: O.height
            }, v, g.globals.easing, function () {
              window.setTimeout(function () {
                y.animationCompleted($)
              }, 100)
            })
          }
          if (g.globals.dataChanged && O.shape === "circle")
            if (this.dynamicAnim) {
              var C, L, H, q, ee = g.config.chart.animations.dynamicAnimation.speed;
              (q = g.globals.previousPaths[u] && g.globals.previousPaths[u][f]) != null && (C = q.x, L = q.y, H = q.r !== void 0 ? q.r : c);
              for (var ge = 0; ge < g.globals.collapsedSeries.length; ge++) g.globals.collapsedSeries[ge].index === u && (ee = 1, c = 0);
              r === 0 && n === 0 && (c = 0), y.animateCircle($, {
                cx: C,
                cy: L,
                r: H
              }, {
                cx: r,
                cy: n,
                r: c
              }, ee, g.globals.easing)
            } else $.attr({
              r: c
            });
          return $.attr({
            rel: d,
            j: d,
            index: u,
            "default-marker-size": c
          }), x.setSelectionFilter($, u, d), T.addEvents($), $.node.classList.add("apexcharts-marker"), $
        }
      }, {
        key: "centerTextInBubble",
        value: function (r) {
          var n = this.w;
          return {
            y: r += parseInt(n.config.dataLabels.style.fontSize, 10) / 4
          }
        }
      }]), Y
    }(),
    Se = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "dataLabelsCorrection",
        value: function (r, n, s, c, u, d, f) {
          var g = this.w,
            b = !1,
            y = new W(this.ctx).getTextRects(s, f),
            x = y.width,
            _ = y.height;
          n < 0 && (n = 0), n > g.globals.gridHeight + _ && (n = g.globals.gridHeight + _ / 2), g.globals.dataLabelsRects[c] === void 0 && (g.globals.dataLabelsRects[c] = []), g.globals.dataLabelsRects[c].push({
            x: r,
            y: n,
            width: x,
            height: _
          });
          var T = g.globals.dataLabelsRects[c].length - 2,
            P = g.globals.lastDrawnDataLabelsIndexes[c] !== void 0 ? g.globals.lastDrawnDataLabelsIndexes[c][g.globals.lastDrawnDataLabelsIndexes[c].length - 1] : 0;
          if (g.globals.dataLabelsRects[c][T] !== void 0) {
            var O = g.globals.dataLabelsRects[c][P];
            (r > O.x + O.width || n > O.y + O.height || n + _ < O.y || r + x < O.x) && (b = !0)
          }
          return (u === 0 || d) && (b = !0), {
            x: r,
            y: n,
            textRects: y,
            drawnextLabel: b
          }
        }
      }, {
        key: "drawDataLabel",
        value: function (r) {
          var n = this,
            s = r.type,
            c = r.pos,
            u = r.i,
            d = r.j,
            f = r.isRangeStart,
            g = r.strokeWidth,
            b = g === void 0 ? 2 : g,
            y = this.w,
            x = new W(this.ctx),
            _ = y.config.dataLabels,
            T = 0,
            P = 0,
            O = d,
            $ = null;
          if (!_.enabled || !Array.isArray(c.x)) return $;
          $ = x.group({
            class: "apexcharts-data-labels"
          });
          for (var G = 0; G < c.x.length; G++)
            if (T = c.x[G] + _.offsetX, P = c.y[G] + _.offsetY + b, !isNaN(T)) {
              d === 1 && G === 0 && (O = 0), d === 1 && G === 1 && (O = 1);
              var Q = y.globals.series[u][O];
              s === "rangeArea" && (Q = f ? y.globals.seriesRangeStart[u][O] : y.globals.seriesRangeEnd[u][O]);
              var v = "",
                C = function (L) {
                  return y.config.dataLabels.formatter(L, {
                    ctx: n.ctx,
                    seriesIndex: u,
                    dataPointIndex: O,
                    w: y
                  })
                };
              y.config.chart.type === "bubble" ? (v = C(Q = y.globals.seriesZ[u][O]), P = c.y[G], P = new re(this.ctx).centerTextInBubble(P, u, O).y) : Q !== void 0 && (v = C(Q)), this.plotDataLabelsText({
                x: T,
                y: P,
                text: v,
                i: u,
                j: O,
                parent: $,
                offsetCorrection: !0,
                dataLabelsConfig: y.config.dataLabels
              })
            } return $
        }
      }, {
        key: "plotDataLabelsText",
        value: function (r) {
          var n = this.w,
            s = new W(this.ctx),
            c = r.x,
            u = r.y,
            d = r.i,
            f = r.j,
            g = r.text,
            b = r.textAnchor,
            y = r.fontSize,
            x = r.parent,
            _ = r.dataLabelsConfig,
            T = r.color,
            P = r.alwaysDrawDataLabel,
            O = r.offsetCorrection;
          if (!(Array.isArray(n.config.dataLabels.enabledOnSeries) && n.config.dataLabels.enabledOnSeries.indexOf(d) < 0)) {
            var $ = {
              x: c,
              y: u,
              drawnextLabel: !0,
              textRects: null
            };
            O && ($ = this.dataLabelsCorrection(c, u, g, d, f, P, parseInt(_.style.fontSize, 10))), n.globals.zoomed || (c = $.x, u = $.y), $.textRects && (c < -20 - $.textRects.width || c > n.globals.gridWidth + $.textRects.width + 30) && (g = "");
            var G = n.globals.dataLabels.style.colors[d];
            ((n.config.chart.type === "bar" || n.config.chart.type === "rangeBar") && n.config.plotOptions.bar.distributed || n.config.dataLabels.distributed) && (G = n.globals.dataLabels.style.colors[f]), typeof G == "function" && (G = G({
              series: n.globals.series,
              seriesIndex: d,
              dataPointIndex: f,
              w: n
            })), T && (G = T);
            var Q = _.offsetX,
              v = _.offsetY;
            if (n.config.chart.type !== "bar" && n.config.chart.type !== "rangeBar" || (Q = 0, v = 0), $.drawnextLabel) {
              var C = s.drawText({
                width: 100,
                height: parseInt(_.style.fontSize, 10),
                x: c + Q,
                y: u + v,
                foreColor: G,
                textAnchor: b || _.textAnchor,
                text: g,
                fontSize: y || _.style.fontSize,
                fontFamily: _.style.fontFamily,
                fontWeight: _.style.fontWeight || "normal"
              });
              if (C.attr({
                  class: "apexcharts-datalabel",
                  cx: c,
                  cy: u
                }), _.dropShadow.enabled) {
                var L = _.dropShadow;
                new U(this.ctx).dropShadow(C, L)
              }
              x.add(C), n.globals.lastDrawnDataLabelsIndexes[d] === void 0 && (n.globals.lastDrawnDataLabelsIndexes[d] = []), n.globals.lastDrawnDataLabelsIndexes[d].push(f)
            }
          }
        }
      }, {
        key: "addBackgroundToDataLabel",
        value: function (r, n) {
          var s = this.w,
            c = s.config.dataLabels.background,
            u = c.padding,
            d = c.padding / 2,
            f = n.width,
            g = n.height,
            b = new W(this.ctx).drawRect(n.x - u, n.y - d / 2, f + 2 * u, g + d, c.borderRadius, s.config.chart.background === "transparent" ? "#fff" : s.config.chart.background, c.opacity, c.borderWidth, c.borderColor);
          return c.dropShadow.enabled && new U(this.ctx).dropShadow(b, c.dropShadow), b
        }
      }, {
        key: "dataLabelsBackground",
        value: function () {
          var r = this.w;
          if (r.config.chart.type !== "bubble")
            for (var n = r.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), s = 0; s < n.length; s++) {
              var c = n[s],
                u = c.getBBox(),
                d = null;
              if (u.width && u.height && (d = this.addBackgroundToDataLabel(c, u)), d) {
                c.parentNode.insertBefore(d.node, c);
                var f = c.getAttribute("fill");
                r.config.chart.animations.enabled && !r.globals.resized && !r.globals.dataChanged ? d.animate().attr({
                  fill: f
                }) : d.attr({
                  fill: f
                }), c.setAttribute("fill", r.config.dataLabels.background.foreColor)
              }
            }
        }
      }, {
        key: "bringForward",
        value: function () {
          for (var r = this.w, n = r.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), s = r.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), c = 0; c < n.length; c++) s && s.insertBefore(n[c], s.nextSibling)
        }
      }]), Y
    }(),
    Be = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.legendInactiveClass = "legend-mouseover-inactive"
      }
      return p(Y, [{
        key: "getAllSeriesEls",
        value: function () {
          return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
        }
      }, {
        key: "getSeriesByName",
        value: function (r) {
          return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(I.escapeString(r), "']"))
        }
      }, {
        key: "isSeriesHidden",
        value: function (r) {
          var n = this.getSeriesByName(r),
            s = parseInt(n.getAttribute("data:realIndex"), 10);
          return {
            isHidden: n.classList.contains("apexcharts-series-collapsed"),
            realIndex: s
          }
        }
      }, {
        key: "addCollapsedClassToSeries",
        value: function (r, n) {
          var s = this.w;

          function c(u) {
            for (var d = 0; d < u.length; d++) u[d].index === n && r.node.classList.add("apexcharts-series-collapsed")
          }
          c(s.globals.collapsedSeries), c(s.globals.ancillaryCollapsedSeries)
        }
      }, {
        key: "toggleSeries",
        value: function (r) {
          var n = this.isSeriesHidden(r);
          return this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, n.isHidden), n.isHidden
        }
      }, {
        key: "showSeries",
        value: function (r) {
          var n = this.isSeriesHidden(r);
          n.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, !0)
        }
      }, {
        key: "hideSeries",
        value: function (r) {
          var n = this.isSeriesHidden(r);
          n.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(n.realIndex, !1)
        }
      }, {
        key: "resetSeries",
        value: function () {
          var r = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0],
            n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
            s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2],
            c = this.w,
            u = I.clone(c.globals.initialSeries);
          c.globals.previousPaths = [], s ? (c.globals.collapsedSeries = [], c.globals.ancillaryCollapsedSeries = [], c.globals.collapsedSeriesIndices = [], c.globals.ancillaryCollapsedSeriesIndices = []) : u = this.emptyCollapsedSeries(u), c.config.series = u, r && (n && (c.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(u, c.config.chart.animations.dynamicAnimation.enabled))
        }
      }, {
        key: "emptyCollapsedSeries",
        value: function (r) {
          for (var n = this.w, s = 0; s < r.length; s++) n.globals.collapsedSeriesIndices.indexOf(s) > -1 && (r[s].data = []);
          return r
        }
      }, {
        key: "toggleSeriesOnHover",
        value: function (r, n) {
          var s = this.w;
          n || (n = r.target);
          var c = s.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
          if (r.type === "mousemove") {
            var u = parseInt(n.getAttribute("rel"), 10) - 1,
              d = null,
              f = null;
            s.globals.axisCharts || s.config.chart.type === "radialBar" ? s.globals.axisCharts ? (d = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(u, "']")), f = s.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(u, "']"))) : d = s.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(u + 1, "']")) : d = s.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(u + 1, "'] path"));
            for (var g = 0; g < c.length; g++) c[g].classList.add(this.legendInactiveClass);
            d !== null && (s.globals.axisCharts || d.parentNode.classList.remove(this.legendInactiveClass), d.classList.remove(this.legendInactiveClass), f !== null && f.classList.remove(this.legendInactiveClass))
          } else if (r.type === "mouseout")
            for (var b = 0; b < c.length; b++) c[b].classList.remove(this.legendInactiveClass)
        }
      }, {
        key: "highlightRangeInSeries",
        value: function (r, n) {
          var s = this,
            c = this.w,
            u = c.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),
            d = function (g) {
              for (var b = 0; b < u.length; b++) u[b].classList[g](s.legendInactiveClass)
            };
          if (r.type === "mousemove") {
            var f = parseInt(n.getAttribute("rel"), 10) - 1;
            d("add"),
              function (g) {
                for (var b = 0; b < u.length; b++) {
                  var y = parseInt(u[b].getAttribute("val"), 10);
                  y >= g.from && y <= g.to && u[b].classList.remove(s.legendInactiveClass)
                }
              }(c.config.plotOptions.heatmap.colorScale.ranges[f])
          } else r.type === "mouseout" && d("remove")
        }
      }, {
        key: "getActiveConfigSeriesIndex",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "asc",
            n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [],
            s = this.w,
            c = 0;
          if (s.config.series.length > 1) {
            for (var u = s.config.series.map(function (f, g) {
                return f.data && f.data.length > 0 && s.globals.collapsedSeriesIndices.indexOf(g) === -1 && (!s.globals.comboCharts || n.length === 0 || n.length && n.indexOf(s.config.series[g].type) > -1) ? g : -1
              }), d = r === "asc" ? 0 : u.length - 1; r === "asc" ? d < u.length : d >= 0; r === "asc" ? d++ : d--)
              if (u[d] !== -1) {
                c = u[d];
                break
              }
          }
          return c
        }
      }, {
        key: "getBarSeriesIndices",
        value: function () {
          return this.w.globals.comboCharts ? this.w.config.series.map(function (r, n) {
            return r.type === "bar" || r.type === "column" ? n : -1
          }).filter(function (r) {
            return r !== -1
          }) : this.w.config.series.map(function (r, n) {
            return n
          })
        }
      }, {
        key: "getPreviousPaths",
        value: function () {
          var r = this.w;

          function n(d, f, g) {
            for (var b = d[f].childNodes, y = {
                type: g,
                paths: [],
                realIndex: d[f].getAttribute("data:realIndex")
              }, x = 0; x < b.length; x++)
              if (b[x].hasAttribute("pathTo")) {
                var _ = b[x].getAttribute("pathTo");
                y.paths.push({
                  d: _
                })
              } r.globals.previousPaths.push(y)
          }
          r.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function (d) {
            for (var f, g = (f = d, r.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(f, "-series .apexcharts-series"))), b = 0; b < g.length; b++) n(g, b, d)
          }), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
          var s = r.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(r.config.chart.type, " .apexcharts-series"));
          if (s.length > 0)
            for (var c = function (d) {
                for (var f = r.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(r.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(d, "'] rect")), g = [], b = function (x) {
                    var _ = function (P) {
                        return f[x].getAttribute(P)
                      },
                      T = {
                        x: parseFloat(_("x")),
                        y: parseFloat(_("y")),
                        width: parseFloat(_("width")),
                        height: parseFloat(_("height"))
                      };
                    g.push({
                      rect: T,
                      color: f[x].getAttribute("color")
                    })
                  }, y = 0; y < f.length; y++) b(y);
                r.globals.previousPaths.push(g)
              }, u = 0; u < s.length; u++) c(u);
          r.globals.axisCharts || (r.globals.previousPaths = r.globals.series)
        }
      }, {
        key: "handlePrevBubbleScatterPaths",
        value: function (r) {
          var n = this.w,
            s = n.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(r, "-series .apexcharts-series"));
          if (s.length > 0)
            for (var c = 0; c < s.length; c++) {
              for (var u = n.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(r, "-series .apexcharts-series[data\\:realIndex='").concat(c, "'] circle")), d = [], f = 0; f < u.length; f++) d.push({
                x: u[f].getAttribute("cx"),
                y: u[f].getAttribute("cy"),
                r: u[f].getAttribute("r")
              });
              n.globals.previousPaths.push(d)
            }
        }
      }, {
        key: "clearPreviousPaths",
        value: function () {
          var r = this.w;
          r.globals.previousPaths = [], r.globals.allSeriesCollapsed = !1
        }
      }, {
        key: "handleNoData",
        value: function () {
          var r = this.w,
            n = r.config.noData,
            s = new W(this.ctx),
            c = r.globals.svgWidth / 2,
            u = r.globals.svgHeight / 2,
            d = "middle";
          if (r.globals.noData = !0, r.globals.animationEnded = !0, n.align === "left" ? (c = 10, d = "start") : n.align === "right" && (c = r.globals.svgWidth - 10, d = "end"), n.verticalAlign === "top" ? u = 50 : n.verticalAlign === "bottom" && (u = r.globals.svgHeight - 50), c += n.offsetX, u = u + parseInt(n.style.fontSize, 10) + 2 + n.offsetY, n.text !== void 0 && n.text !== "") {
            var f = s.drawText({
              x: c,
              y: u,
              text: n.text,
              textAnchor: d,
              fontSize: n.style.fontSize,
              fontFamily: n.style.fontFamily,
              foreColor: n.style.color,
              opacity: 1,
              class: "apexcharts-text-nodata"
            });
            r.globals.dom.Paper.add(f)
          }
        }
      }, {
        key: "setNullSeriesToZeroValues",
        value: function (r) {
          for (var n = this.w, s = 0; s < r.length; s++)
            if (r[s].length === 0)
              for (var c = 0; c < r[n.globals.maxValsInArrayIndex].length; c++) r[s].push(0);
          return r
        }
      }, {
        key: "hasAllSeriesEqualX",
        value: function () {
          for (var r = !0, n = this.w, s = this.filteredSeriesX(), c = 0; c < s.length - 1; c++)
            if (s[c][0] !== s[c + 1][0]) {
              r = !1;
              break
            } return n.globals.allSeriesHasEqualX = r, r
        }
      }, {
        key: "filteredSeriesX",
        value: function () {
          var r = this.w.globals.seriesX.map(function (n) {
            return n.length > 0 ? n : []
          });
          return r
        }
      }]), Y
    }(),
    J = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new X(this.ctx)
      }
      return p(Y, [{
        key: "isMultiFormat",
        value: function () {
          return this.isFormatXY() || this.isFormat2DArray()
        }
      }, {
        key: "isFormatXY",
        value: function () {
          var r = this.w.config.series.slice(),
            n = new Be(this.ctx);
          if (this.activeSeriesIndex = n.getActiveConfigSeriesIndex(), r[this.activeSeriesIndex].data !== void 0 && r[this.activeSeriesIndex].data.length > 0 && r[this.activeSeriesIndex].data[0] !== null && r[this.activeSeriesIndex].data[0].x !== void 0 && r[this.activeSeriesIndex].data[0] !== null) return !0
        }
      }, {
        key: "isFormat2DArray",
        value: function () {
          var r = this.w.config.series.slice(),
            n = new Be(this.ctx);
          if (this.activeSeriesIndex = n.getActiveConfigSeriesIndex(), r[this.activeSeriesIndex].data !== void 0 && r[this.activeSeriesIndex].data.length > 0 && r[this.activeSeriesIndex].data[0] !== void 0 && r[this.activeSeriesIndex].data[0] !== null && r[this.activeSeriesIndex].data[0].constructor === Array) return !0
        }
      }, {
        key: "handleFormat2DArray",
        value: function (r, n) {
          for (var s = this.w.config, c = this.w.globals, u = s.chart.type === "boxPlot" || s.series[n].type === "boxPlot", d = 0; d < r[n].data.length; d++)
            if (r[n].data[d][1] !== void 0 && (Array.isArray(r[n].data[d][1]) && r[n].data[d][1].length === 4 && !u ? this.twoDSeries.push(I.parseNumber(r[n].data[d][1][3])) : r[n].data[d].length >= 5 ? this.twoDSeries.push(I.parseNumber(r[n].data[d][4])) : this.twoDSeries.push(I.parseNumber(r[n].data[d][1])), c.dataFormatXNumeric = !0), s.xaxis.type === "datetime") {
              var f = new Date(r[n].data[d][0]);
              f = new Date(f).getTime(), this.twoDSeriesX.push(f)
            } else this.twoDSeriesX.push(r[n].data[d][0]);
          for (var g = 0; g < r[n].data.length; g++) r[n].data[g][2] !== void 0 && (this.threeDSeries.push(r[n].data[g][2]), c.isDataXYZ = !0)
        }
      }, {
        key: "handleFormatXY",
        value: function (r, n) {
          var s = this.w.config,
            c = this.w.globals,
            u = new ye(this.ctx),
            d = n;
          c.collapsedSeriesIndices.indexOf(n) > -1 && (d = this.activeSeriesIndex);
          for (var f = 0; f < r[n].data.length; f++) r[n].data[f].y !== void 0 && (Array.isArray(r[n].data[f].y) ? this.twoDSeries.push(I.parseNumber(r[n].data[f].y[r[n].data[f].y.length - 1])) : this.twoDSeries.push(I.parseNumber(r[n].data[f].y))), r[n].data[f].goals !== void 0 && Array.isArray(r[n].data[f].goals) ? (this.seriesGoals[n] === void 0 && (this.seriesGoals[n] = []), this.seriesGoals[n].push(r[n].data[f].goals)) : (this.seriesGoals[n] === void 0 && (this.seriesGoals[n] = []), this.seriesGoals[n].push(null));
          for (var g = 0; g < r[d].data.length; g++) {
            var b = typeof r[d].data[g].x == "string",
              y = Array.isArray(r[d].data[g].x),
              x = !y && !!u.isValidDate(r[d].data[g].x);
            if (b || x)
              if (b || s.xaxis.convertedCatToNumeric) {
                var _ = c.isBarHorizontal && c.isRangeData;
                s.xaxis.type !== "datetime" || _ ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(r[d].data[g].x), isNaN(r[d].data[g].x) || this.w.config.xaxis.type === "category" || typeof r[d].data[g].x == "string" || (c.isXNumeric = !0)) : this.twoDSeriesX.push(u.parseDate(r[d].data[g].x))
              } else s.xaxis.type === "datetime" ? this.twoDSeriesX.push(u.parseDate(r[d].data[g].x.toString())) : (c.dataFormatXNumeric = !0, c.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(r[d].data[g].x)));
            else y ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(r[d].data[g].x)) : (c.isXNumeric = !0, c.dataFormatXNumeric = !0, this.twoDSeriesX.push(r[d].data[g].x))
          }
          if (r[n].data[0] && r[n].data[0].z !== void 0) {
            for (var T = 0; T < r[n].data.length; T++) this.threeDSeries.push(r[n].data[T].z);
            c.isDataXYZ = !0
          }
        }
      }, {
        key: "handleRangeData",
        value: function (r, n) {
          var s = this.w.globals,
            c = {};
          return this.isFormat2DArray() ? c = this.handleRangeDataFormat("array", r, n) : this.isFormatXY() && (c = this.handleRangeDataFormat("xy", r, n)), s.seriesRangeStart.push(c.start), s.seriesRangeEnd.push(c.end), s.seriesRange.push(c.rangeUniques), s.seriesRange.forEach(function (u, d) {
            u && u.forEach(function (f, g) {
              f.y.forEach(function (b, y) {
                for (var x = 0; x < f.y.length; x++)
                  if (y !== x) {
                    var _ = b.y1,
                      T = b.y2,
                      P = f.y[x].y1;
                    _ <= f.y[x].y2 && P <= T && (f.overlaps.indexOf(b.rangeName) < 0 && f.overlaps.push(b.rangeName), f.overlaps.indexOf(f.y[x].rangeName) < 0 && f.overlaps.push(f.y[x].rangeName))
                  }
              })
            })
          }), c
        }
      }, {
        key: "handleCandleStickBoxData",
        value: function (r, n) {
          var s = this.w.globals,
            c = {};
          return this.isFormat2DArray() ? c = this.handleCandleStickBoxDataFormat("array", r, n) : this.isFormatXY() && (c = this.handleCandleStickBoxDataFormat("xy", r, n)), s.seriesCandleO[n] = c.o, s.seriesCandleH[n] = c.h, s.seriesCandleM[n] = c.m, s.seriesCandleL[n] = c.l, s.seriesCandleC[n] = c.c, c
        }
      }, {
        key: "handleRangeDataFormat",
        value: function (r, n, s) {
          var c = [],
            u = [],
            d = n[s].data.filter(function (y, x, _) {
              return x === _.findIndex(function (T) {
                return T.x === y.x
              })
            }).map(function (y, x) {
              return {
                x: y.x,
                overlaps: [],
                y: []
              }
            });
          if (r === "array")
            for (var f = 0; f < n[s].data.length; f++) Array.isArray(n[s].data[f]) ? (c.push(n[s].data[f][1][0]), u.push(n[s].data[f][1][1])) : (c.push(n[s].data[f]), u.push(n[s].data[f]));
          else if (r === "xy")
            for (var g = function (y) {
                var x = Array.isArray(n[s].data[y].y),
                  _ = I.randomId(),
                  T = n[s].data[y].x,
                  P = {
                    y1: x ? n[s].data[y].y[0] : n[s].data[y].y,
                    y2: x ? n[s].data[y].y[1] : n[s].data[y].y,
                    rangeName: _
                  };
                n[s].data[y].rangeName = _;
                var O = d.findIndex(function ($) {
                  return $.x === T
                });
                d[O].y.push(P), c.push(P.y1), u.push(P.y2)
              }, b = 0; b < n[s].data.length; b++) g(b);
          return {
            start: c,
            end: u,
            rangeUniques: d
          }
        }
      }, {
        key: "handleCandleStickBoxDataFormat",
        value: function (r, n, s) {
          var c = this.w,
            u = c.config.chart.type === "boxPlot" || c.config.series[s].type === "boxPlot",
            d = [],
            f = [],
            g = [],
            b = [],
            y = [];
          if (r === "array")
            if (u && n[s].data[0].length === 6 || !u && n[s].data[0].length === 5)
              for (var x = 0; x < n[s].data.length; x++) d.push(n[s].data[x][1]), f.push(n[s].data[x][2]), u ? (g.push(n[s].data[x][3]), b.push(n[s].data[x][4]), y.push(n[s].data[x][5])) : (b.push(n[s].data[x][3]), y.push(n[s].data[x][4]));
            else
              for (var _ = 0; _ < n[s].data.length; _++) Array.isArray(n[s].data[_][1]) && (d.push(n[s].data[_][1][0]), f.push(n[s].data[_][1][1]), u ? (g.push(n[s].data[_][1][2]), b.push(n[s].data[_][1][3]), y.push(n[s].data[_][1][4])) : (b.push(n[s].data[_][1][2]), y.push(n[s].data[_][1][3])));
          else if (r === "xy")
            for (var T = 0; T < n[s].data.length; T++) Array.isArray(n[s].data[T].y) && (d.push(n[s].data[T].y[0]), f.push(n[s].data[T].y[1]), u ? (g.push(n[s].data[T].y[2]), b.push(n[s].data[T].y[3]), y.push(n[s].data[T].y[4])) : (b.push(n[s].data[T].y[2]), y.push(n[s].data[T].y[3])));
          return {
            o: d,
            h: f,
            m: g,
            l: b,
            c: y
          }
        }
      }, {
        key: "parseDataAxisCharts",
        value: function (r) {
          var n, s = this,
            c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.ctx,
            u = this.w.config,
            d = this.w.globals,
            f = new ye(c),
            g = u.labels.length > 0 ? u.labels.slice() : u.xaxis.categories.slice();
          if (d.isRangeBar = u.chart.type === "rangeBar" && d.isBarHorizontal, d.hasXaxisGroups = u.xaxis.type === "category" && u.xaxis.group.groups.length > 0, d.hasXaxisGroups && (d.groups = u.xaxis.group.groups), d.hasSeriesGroups = (n = r[0]) === null || n === void 0 ? void 0 : n.group, d.hasSeriesGroups) {
            var b = [],
              y = D(new Set(r.map(function (P) {
                return P.group
              })));
            r.forEach(function (P, O) {
              var $ = y.indexOf(P.group);
              b[$] || (b[$] = []), b[$].push(P.name)
            }), d.seriesGroups = b
          }
          for (var x = function () {
              for (var P = 0; P < g.length; P++)
                if (typeof g[P] == "string") {
                  if (!f.isValidDate(g[P])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                  s.twoDSeriesX.push(f.parseDate(g[P]))
                } else s.twoDSeriesX.push(g[P])
            }, _ = 0; _ < r.length; _++) {
            if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], r[_].data === void 0) return void console.error("It is a possibility that you may have not included 'data' property in series.");
            if (u.chart.type !== "rangeBar" && u.chart.type !== "rangeArea" && r[_].type !== "rangeBar" && r[_].type !== "rangeArea" || (d.isRangeData = !0, u.chart.type !== "rangeBar" && u.chart.type !== "rangeArea" || this.handleRangeData(r, _)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(r, _) : this.isFormatXY() && this.handleFormatXY(r, _), u.chart.type !== "candlestick" && r[_].type !== "candlestick" && u.chart.type !== "boxPlot" && r[_].type !== "boxPlot" || this.handleCandleStickBoxData(r, _), d.series.push(this.twoDSeries), d.labels.push(this.twoDSeriesX), d.seriesX.push(this.twoDSeriesX), d.seriesGoals = this.seriesGoals, _ !== this.activeSeriesIndex || this.fallbackToCategory || (d.isXNumeric = !0);
            else {
              u.xaxis.type === "datetime" ? (d.isXNumeric = !0, x(), d.seriesX.push(this.twoDSeriesX)) : u.xaxis.type === "numeric" && (d.isXNumeric = !0, g.length > 0 && (this.twoDSeriesX = g, d.seriesX.push(this.twoDSeriesX))), d.labels.push(this.twoDSeriesX);
              var T = r[_].data.map(function (P) {
                return I.parseNumber(P)
              });
              d.series.push(T)
            }
            d.seriesZ.push(this.threeDSeries), r[_].name !== void 0 ? d.seriesNames.push(r[_].name) : d.seriesNames.push("series-" + parseInt(_ + 1, 10)), r[_].color !== void 0 ? d.seriesColors.push(r[_].color) : d.seriesColors.push(void 0)
          }
          return this.w
        }
      }, {
        key: "parseDataNonAxisCharts",
        value: function (r) {
          var n = this.w.globals,
            s = this.w.config;
          n.series = r.slice(), n.seriesNames = s.labels.slice();
          for (var c = 0; c < n.series.length; c++) n.seriesNames[c] === void 0 && n.seriesNames.push("series-" + (c + 1));
          return this.w
        }
      }, {
        key: "handleExternalLabelsData",
        value: function (r) {
          var n = this.w.config,
            s = this.w.globals;
          n.xaxis.categories.length > 0 ? s.labels = n.xaxis.categories : n.labels.length > 0 ? s.labels = n.labels.slice() : this.fallbackToCategory ? (s.labels = s.labels[0], s.seriesRange.length && (s.seriesRange.map(function (c) {
            c.forEach(function (u) {
              s.labels.indexOf(u.x) < 0 && u.x && s.labels.push(u.x)
            })
          }), s.labels = Array.from(new Set(s.labels.map(JSON.stringify)), JSON.parse)), n.xaxis.convertedCatToNumeric && (new He(n).convertCatToNumericXaxis(n, this.ctx, s.seriesX[0]), this._generateExternalLabels(r))) : this._generateExternalLabels(r)
        }
      }, {
        key: "_generateExternalLabels",
        value: function (r) {
          var n = this.w.globals,
            s = this.w.config,
            c = [];
          if (n.axisCharts) {
            if (n.series.length > 0)
              if (this.isFormatXY())
                for (var u = s.series.map(function (x, _) {
                    return x.data.filter(function (T, P, O) {
                      return O.findIndex(function ($) {
                        return $.x === T.x
                      }) === P
                    })
                  }), d = u.reduce(function (x, _, T, P) {
                    return P[x].length > _.length ? x : T
                  }, 0), f = 0; f < u[d].length; f++) c.push(f + 1);
              else
                for (var g = 0; g < n.series[n.maxValsInArrayIndex].length; g++) c.push(g + 1);
            n.seriesX = [];
            for (var b = 0; b < r.length; b++) n.seriesX.push(c);
            this.w.globals.isBarHorizontal || (n.isXNumeric = !0)
          }
          if (c.length === 0) {
            c = n.axisCharts ? [] : n.series.map(function (x, _) {
              return _ + 1
            });
            for (var y = 0; y < r.length; y++) n.seriesX.push(c)
          }
          n.labels = c, s.xaxis.convertedCatToNumeric && (n.categoryLabels = c.map(function (x) {
            return s.xaxis.labels.formatter(x)
          })), n.noLabelsProvided = !0
        }
      }, {
        key: "parseData",
        value: function (r) {
          var n = this.w,
            s = n.config,
            c = n.globals;
          if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), c.axisCharts ? (this.parseDataAxisCharts(r), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(r), s.chart.stacked) {
            var u = new Be(this.ctx);
            c.series = u.setNullSeriesToZeroValues(c.series)
          }
          this.coreUtils.getSeriesTotals(), c.axisCharts && (c.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), c.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), c.dataFormatXNumeric || c.isXNumeric && (s.xaxis.type !== "numeric" || s.labels.length !== 0 || s.xaxis.categories.length !== 0) || this.handleExternalLabelsData(r);
          for (var d = this.coreUtils.getCategoryLabels(c.labels), f = 0; f < d.length; f++)
            if (Array.isArray(d[f])) {
              c.isMultiLineX = !0;
              break
            }
        }
      }, {
        key: "excludeCollapsedSeriesInYAxis",
        value: function () {
          var r = this,
            n = this.w;
          n.globals.ignoreYAxisIndexes = n.globals.collapsedSeries.map(function (s, c) {
            if (r.w.globals.isMultipleYAxis && !n.config.chart.stacked) return s.index
          })
        }
      }]), Y
    }(),
    Re = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "getLabel",
        value: function (r, n, s, c) {
          var u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [],
            d = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "12px",
            f = !(arguments.length > 6 && arguments[6] !== void 0) || arguments[6],
            g = this.w,
            b = r[c] === void 0 ? "" : r[c],
            y = b,
            x = g.globals.xLabelFormatter,
            _ = g.config.xaxis.labels.formatter,
            T = !1,
            P = new ve(this.ctx),
            O = b;
          f && (y = P.xLabelFormat(x, b, O, {
            i: c,
            dateFormatter: new ye(this.ctx).formatDate,
            w: g
          }), _ !== void 0 && (y = _(b, r[c], {
            i: c,
            dateFormatter: new ye(this.ctx).formatDate,
            w: g
          })));
          var $, G;
          n.length > 0 ? ($ = n[c].unit, G = null, n.forEach(function (L) {
            L.unit === "month" ? G = "year" : L.unit === "day" ? G = "month" : L.unit === "hour" ? G = "day" : L.unit === "minute" && (G = "hour")
          }), T = G === $, s = n[c].position, y = n[c].value) : g.config.xaxis.type === "datetime" && _ === void 0 && (y = ""), y === void 0 && (y = ""), y = Array.isArray(y) ? y : y.toString();
          var Q = new W(this.ctx),
            v = {};
          v = g.globals.rotateXLabels && f ? Q.getTextRects(y, parseInt(d, 10), null, "rotate(".concat(g.config.xaxis.labels.rotate, " 0 0)"), !1) : Q.getTextRects(y, parseInt(d, 10));
          var C = !g.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
          return !Array.isArray(y) && (y.indexOf("NaN") === 0 || y.toLowerCase().indexOf("invalid") === 0 || y.toLowerCase().indexOf("infinity") >= 0 || u.indexOf(y) >= 0 && C) && (y = ""), {
            x: s,
            text: y,
            textRect: v,
            isBold: T
          }
        }
      }, {
        key: "checkLabelBasedOnTickamount",
        value: function (r, n, s) {
          var c = this.w,
            u = c.config.xaxis.tickAmount;
          return u === "dataPoints" && (u = Math.round(c.globals.gridWidth / 120)), u > s || r % Math.round(s / (u + 1)) == 0 || (n.text = ""), n
        }
      }, {
        key: "checkForOverflowingLabels",
        value: function (r, n, s, c, u) {
          var d = this.w;
          if (r === 0 && d.globals.skipFirstTimelinelabel && (n.text = ""), r === s - 1 && d.globals.skipLastTimelinelabel && (n.text = ""), d.config.xaxis.labels.hideOverlappingLabels && c.length > 0) {
            var f = u[u.length - 1];
            n.x < f.textRect.width / (d.globals.rotateXLabels ? Math.abs(d.config.xaxis.labels.rotate) / 12 : 1.01) + f.x && (n.text = "")
          }
          return n
        }
      }, {
        key: "checkForReversedLabels",
        value: function (r, n) {
          var s = this.w;
          return s.config.yaxis[r] && s.config.yaxis[r].reversed && n.reverse(), n
        }
      }, {
        key: "isYAxisHidden",
        value: function (r) {
          var n = this.w,
            s = new X(this.ctx);
          return !n.config.yaxis[r].show || !n.config.yaxis[r].showForNullSeries && s.isSeriesNull(r) && n.globals.collapsedSeriesIndices.indexOf(r) === -1
        }
      }, {
        key: "getYAxisForeColor",
        value: function (r, n) {
          var s = this.w;
          return Array.isArray(r) && s.globals.yAxisScale[n] && this.ctx.theme.pushExtraColors(r, s.globals.yAxisScale[n].result.length, !1), r
        }
      }, {
        key: "drawYAxisTicks",
        value: function (r, n, s, c, u, d, f) {
          var g = this.w,
            b = new W(this.ctx),
            y = g.globals.translateY;
          if (c.show && n > 0) {
            g.config.yaxis[u].opposite === !0 && (r += c.width);
            for (var x = n; x >= 0; x--) {
              var _ = y + n / 10 + g.config.yaxis[u].labels.offsetY - 1;
              g.globals.isBarHorizontal && (_ = d * x), g.config.chart.type === "heatmap" && (_ += d / 2);
              var T = b.drawLine(r + s.offsetX - c.width + c.offsetX, _ + c.offsetY, r + s.offsetX + c.offsetX, _ + c.offsetY, c.color);
              f.add(T), y += d
            }
          }
        }
      }]), Y
    }(),
    Xe = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "scaleSvgNode",
        value: function (r, n) {
          var s = parseFloat(r.getAttributeNS(null, "width")),
            c = parseFloat(r.getAttributeNS(null, "height"));
          r.setAttributeNS(null, "width", s * n), r.setAttributeNS(null, "height", c * n), r.setAttributeNS(null, "viewBox", "0 0 " + s + " " + c)
        }
      }, {
        key: "fixSvgStringForIe11",
        value: function (r) {
          if (!I.isIE11()) return r.replace(/&nbsp;/g, "&#160;");
          var n = 0,
            s = r.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, function (c) {
              return ++n === 2 ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : c
            });
          return s = (s = s.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1")
        }
      }, {
        key: "getSvgString",
        value: function (r) {
          r == null && (r = 1);
          var n = this.w.globals.dom.Paper.svg();
          if (r !== 1) {
            var s = this.w.globals.dom.Paper.node.cloneNode(!0);
            this.scaleSvgNode(s, r), n = new XMLSerializer().serializeToString(s)
          }
          return this.fixSvgStringForIe11(n)
        }
      }, {
        key: "cleanup",
        value: function () {
          var r = this.w,
            n = r.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
            s = r.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
            c = r.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
          Array.prototype.forEach.call(c, function (u) {
            u.setAttribute("width", 0)
          }), n && n[0] && (n[0].setAttribute("x", -500), n[0].setAttribute("x1", -500), n[0].setAttribute("x2", -500)), s && s[0] && (s[0].setAttribute("y", -100), s[0].setAttribute("y1", -100), s[0].setAttribute("y2", -100))
        }
      }, {
        key: "svgUrl",
        value: function () {
          this.cleanup();
          var r = this.getSvgString(),
            n = new Blob([r], {
              type: "image/svg+xml;charset=utf-8"
            });
          return URL.createObjectURL(n)
        }
      }, {
        key: "dataURI",
        value: function (r) {
          var n = this;
          return new Promise(function (s) {
            var c = n.w,
              u = r ? r.scale || r.width / c.globals.svgWidth : 1;
            n.cleanup();
            var d = document.createElement("canvas");
            d.width = c.globals.svgWidth * u, d.height = parseInt(c.globals.dom.elWrap.style.height, 10) * u;
            var f = c.config.chart.background === "transparent" ? "#fff" : c.config.chart.background,
              g = d.getContext("2d");
            g.fillStyle = f, g.fillRect(0, 0, d.width * u, d.height * u);
            var b = n.getSvgString(u);
            if (window.canvg && I.isIE11()) {
              var y = window.canvg.Canvg.fromString(g, b, {
                ignoreClear: !0,
                ignoreDimensions: !0
              });
              y.start();
              var x = d.msToBlob();
              y.stop(), s({
                blob: x
              })
            } else {
              var _ = "data:image/svg+xml," + encodeURIComponent(b),
                T = new Image;
              T.crossOrigin = "anonymous", T.onload = function () {
                if (g.drawImage(T, 0, 0), d.msToBlob) {
                  var P = d.msToBlob();
                  s({
                    blob: P
                  })
                } else {
                  var O = d.toDataURL("image/png");
                  s({
                    imgURI: O
                  })
                }
              }, T.src = _
            }
          })
        }
      }, {
        key: "exportToSVG",
        value: function () {
          this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg")
        }
      }, {
        key: "exportToPng",
        value: function () {
          var r = this;
          this.dataURI().then(function (n) {
            var s = n.imgURI,
              c = n.blob;
            c ? navigator.msSaveOrOpenBlob(c, r.w.globals.chartID + ".png") : r.triggerDownload(s, r.w.config.chart.toolbar.export.png.filename, ".png")
          })
        }
      }, {
        key: "exportToCSV",
        value: function (r) {
          var n = this,
            s = r.series,
            c = r.fileName,
            u = r.columnDelimiter,
            d = u === void 0 ? "," : u,
            f = r.lineDelimiter,
            g = f === void 0 ? `
` : f,
            b = this.w;
          s || (s = b.config.series);
          var y, x, _ = [],
            T = [],
            P = "",
            O = b.globals.series.map(function (H, q) {
              return b.globals.collapsedSeriesIndices.indexOf(q) === -1 ? H : []
            }),
            $ = function (H) {
              return b.config.xaxis.type === "datetime" && String(H).length >= 10
            },
            G = Math.max.apply(Math, D(s.map(function (H) {
              return H.data ? H.data.length : 0
            }))),
            Q = new J(this.ctx),
            v = new Re(this.ctx),
            C = function (H) {
              var q = "";
              if (b.globals.axisCharts) {
                if (b.config.xaxis.type === "category" || b.config.xaxis.convertedCatToNumeric)
                  if (b.globals.isBarHorizontal) {
                    var ee = b.globals.yLabelFormatters[0],
                      ge = new Be(n.ctx).getActiveConfigSeriesIndex();
                    q = ee(b.globals.labels[H], {
                      seriesIndex: ge,
                      dataPointIndex: H,
                      w: b
                    })
                  } else q = v.getLabel(b.globals.labels, b.globals.timescaleLabels, 0, H).text;
                b.config.xaxis.type === "datetime" && (b.config.xaxis.categories.length ? q = b.config.xaxis.categories[H] : b.config.labels.length && (q = b.config.labels[H]))
              } else q = b.config.labels[H];
              return Array.isArray(q) && (q = q.join(" ")), I.isNumber(q) ? q : q.split(d).join("")
            },
            L = function (H, q) {
              if (_.length && q === 0 && T.push(_.join(d)), H.data) {
                H.data = H.data.length && H.data || D(Array(G)).map(function () {
                  return ""
                });
                for (var ee = 0; ee < H.data.length; ee++) {
                  _ = [];
                  var ge = C(ee);
                  if (ge || (Q.isFormatXY() ? ge = s[q].data[ee].x : Q.isFormat2DArray() && (ge = s[q].data[ee] ? s[q].data[ee][0] : "")), q === 0) {
                    _.push($(ge) ? b.config.chart.toolbar.export.csv.dateFormatter(ge) : I.isNumber(ge) ? ge : ge.split(d).join(""));
                    for (var pe = 0; pe < b.globals.series.length; pe++) {
                      var Fe;
                      Q.isFormatXY() ? _.push((Fe = s[pe].data[ee]) === null || Fe === void 0 ? void 0 : Fe.y) : _.push(O[pe][ee])
                    }
                  }(b.config.chart.type === "candlestick" || H.type && H.type === "candlestick") && (_.pop(), _.push(b.globals.seriesCandleO[q][ee]), _.push(b.globals.seriesCandleH[q][ee]), _.push(b.globals.seriesCandleL[q][ee]), _.push(b.globals.seriesCandleC[q][ee])), (b.config.chart.type === "boxPlot" || H.type && H.type === "boxPlot") && (_.pop(), _.push(b.globals.seriesCandleO[q][ee]), _.push(b.globals.seriesCandleH[q][ee]), _.push(b.globals.seriesCandleM[q][ee]), _.push(b.globals.seriesCandleL[q][ee]), _.push(b.globals.seriesCandleC[q][ee])), b.config.chart.type === "rangeBar" && (_.pop(), _.push(b.globals.seriesRangeStart[q][ee]), _.push(b.globals.seriesRangeEnd[q][ee])), _.length && T.push(_.join(d))
                }
              }
            };
          _.push(b.config.chart.toolbar.export.csv.headerCategory), b.config.chart.type === "boxPlot" ? (_.push("minimum"), _.push("q1"), _.push("median"), _.push("q3"), _.push("maximum")) : b.config.chart.type === "candlestick" ? (_.push("open"), _.push("high"), _.push("low"), _.push("close")) : b.config.chart.type === "rangeBar" ? (_.push("minimum"), _.push("maximum")) : s.map(function (H, q) {
            var ee = (H.name ? H.name : "series-".concat(q)) + "";
            b.globals.axisCharts && _.push(ee.split(d).join("") ? ee.split(d).join("") : "series-".concat(q))
          }), b.globals.axisCharts || (_.push(b.config.chart.toolbar.export.csv.headerValue), T.push(_.join(d))), b.globals.allSeriesHasEqualX || !b.globals.axisCharts || b.config.xaxis.categories.length || b.config.labels.length ? s.map(function (H, q) {
            b.globals.axisCharts ? L(H, q) : ((_ = []).push(b.globals.labels[q].split(d).join("")), _.push(O[q]), T.push(_.join(d)))
          }) : (y = new Set, x = {}, s.forEach(function (H, q) {
            H == null || H.data.forEach(function (ee) {
              var ge, pe;
              if (Q.isFormatXY()) ge = ee.x, pe = ee.y;
              else {
                if (!Q.isFormat2DArray()) return;
                ge = ee[0], pe = ee[1]
              }
              x[ge] || (x[ge] = Array(s.length).fill("")), x[ge][q] = pe, y.add(ge)
            })
          }), _.length && T.push(_.join(d)), Array.from(y).sort().forEach(function (H) {
            T.push([$(H) && b.config.xaxis.type === "datetime" ? b.config.chart.toolbar.export.csv.dateFormatter(H) : I.isNumber(H) ? H : H.split(d).join(""), x[H].join(d)])
          })), P += T.join(g), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + P), c || b.config.chart.toolbar.export.csv.filename, ".csv")
        }
      }, {
        key: "triggerDownload",
        value: function (r, n, s) {
          var c = document.createElement("a");
          c.href = r, c.download = (n || this.w.globals.chartID) + s, document.body.appendChild(c), c.click(), document.body.removeChild(c)
        }
      }]), Y
    }(),
    nt = function () {
      function Y(r, n) {
        l(this, Y), this.ctx = r, this.elgrid = n, this.w = r.w;
        var s = this.w;
        this.axesUtils = new Re(r), this.xaxisLabels = s.globals.labels.slice(), s.globals.timescaleLabels.length > 0 && !s.globals.isBarHorizontal && (this.xaxisLabels = s.globals.timescaleLabels.slice()), s.config.xaxis.overwriteCategories && (this.xaxisLabels = s.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], s.config.xaxis.position === "top" ? this.offY = 0 : this.offY = s.globals.gridHeight + 1, this.offY = this.offY + s.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = s.config.chart.type === "bar" && s.config.plotOptions.bar.horizontal, this.xaxisFontSize = s.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s.config.xaxis.axisBorder.height, this.yaxis = s.config.yaxis[0]
      }
      return p(Y, [{
        key: "drawXaxis",
        value: function () {
          var r = this.w,
            n = new W(this.ctx),
            s = n.group({
              class: "apexcharts-xaxis",
              transform: "translate(".concat(r.config.xaxis.offsetX, ", ").concat(r.config.xaxis.offsetY, ")")
            }),
            c = n.group({
              class: "apexcharts-xaxis-texts-g",
              transform: "translate(".concat(r.globals.translateXAxisX, ", ").concat(r.globals.translateXAxisY, ")")
            });
          s.add(c);
          for (var u = [], d = 0; d < this.xaxisLabels.length; d++) u.push(this.xaxisLabels[d]);
          if (this.drawXAxisLabelAndGroup(!0, n, c, u, r.globals.isXNumeric, function (P, O) {
              return O
            }), r.globals.hasXaxisGroups) {
            var f = r.globals.groups;
            u = [];
            for (var g = 0; g < f.length; g++) u.push(f[g].title);
            var b = {};
            r.config.xaxis.group.style && (b.xaxisFontSize = r.config.xaxis.group.style.fontSize, b.xaxisFontFamily = r.config.xaxis.group.style.fontFamily, b.xaxisForeColors = r.config.xaxis.group.style.colors, b.fontWeight = r.config.xaxis.group.style.fontWeight, b.cssClass = r.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, n, c, u, !1, function (P, O) {
              return f[P].cols * O
            }, b)
          }
          if (r.config.xaxis.title.text !== void 0) {
            var y = n.group({
                class: "apexcharts-xaxis-title"
              }),
              x = n.drawText({
                x: r.globals.gridWidth / 2 + r.config.xaxis.title.offsetX,
                y: this.offY + parseFloat(this.xaxisFontSize) + (r.config.xaxis.position === "bottom" ? r.globals.xAxisLabelsHeight : -r.globals.xAxisLabelsHeight - 10) + r.config.xaxis.title.offsetY,
                text: r.config.xaxis.title.text,
                textAnchor: "middle",
                fontSize: r.config.xaxis.title.style.fontSize,
                fontFamily: r.config.xaxis.title.style.fontFamily,
                fontWeight: r.config.xaxis.title.style.fontWeight,
                foreColor: r.config.xaxis.title.style.color,
                cssClass: "apexcharts-xaxis-title-text " + r.config.xaxis.title.style.cssClass
              });
            y.add(x), s.add(y)
          }
          if (r.config.xaxis.axisBorder.show) {
            var _ = r.globals.barPadForNumericAxis,
              T = n.drawLine(r.globals.padHorizontal + r.config.xaxis.axisBorder.offsetX - _, this.offY, this.xaxisBorderWidth + _, this.offY, r.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
            this.elgrid && this.elgrid.elGridBorders && r.config.grid.show ? this.elgrid.elGridBorders.add(T) : s.add(T)
          }
          return s
        }
      }, {
        key: "drawXAxisLabelAndGroup",
        value: function (r, n, s, c, u, d) {
          var f, g = this,
            b = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : {},
            y = [],
            x = [],
            _ = this.w,
            T = b.xaxisFontSize || this.xaxisFontSize,
            P = b.xaxisFontFamily || this.xaxisFontFamily,
            O = b.xaxisForeColors || this.xaxisForeColors,
            $ = b.fontWeight || _.config.xaxis.labels.style.fontWeight,
            G = b.cssClass || _.config.xaxis.labels.style.cssClass,
            Q = _.globals.padHorizontal,
            v = c.length,
            C = _.config.xaxis.type === "category" ? _.globals.dataPoints : v;
          if (C === 0 && v > C && (C = v), u) {
            var L = C > 1 ? C - 1 : C;
            f = _.globals.gridWidth / Math.min(L, v - 1), Q = Q + d(0, f) / 2 + _.config.xaxis.labels.offsetX
          } else f = _.globals.gridWidth / C, Q = Q + d(0, f) + _.config.xaxis.labels.offsetX;
          for (var H = function (ee) {
              var ge = Q - d(ee, f) / 2 + _.config.xaxis.labels.offsetX;
              ee === 0 && v === 1 && f / 2 === Q && C === 1 && (ge = _.globals.gridWidth / 2);
              var pe = g.axesUtils.getLabel(c, _.globals.timescaleLabels, ge, ee, y, T, r),
                Fe = 28;
              if (_.globals.rotateXLabels && r && (Fe = 22), _.config.xaxis.title.text && _.config.xaxis.position === "top" && (Fe += parseFloat(_.config.xaxis.title.style.fontSize) + 2), r || (Fe = Fe + parseFloat(T) + (_.globals.xAxisLabelsHeight - _.globals.xAxisGroupLabelsHeight) + (_.globals.rotateXLabels ? 10 : 0)), pe = _.config.xaxis.tickAmount !== void 0 && _.config.xaxis.tickAmount !== "dataPoints" && _.config.xaxis.type !== "datetime" ? g.axesUtils.checkLabelBasedOnTickamount(ee, pe, v) : g.axesUtils.checkForOverflowingLabels(ee, pe, v, y, x), _.config.xaxis.labels.show) {
                var Ue = n.drawText({
                  x: pe.x,
                  y: g.offY + _.config.xaxis.labels.offsetY + Fe - (_.config.xaxis.position === "top" ? _.globals.xAxisHeight + _.config.xaxis.axisTicks.height - 2 : 0),
                  text: pe.text,
                  textAnchor: "middle",
                  fontWeight: pe.isBold ? 600 : $,
                  fontSize: T,
                  fontFamily: P,
                  foreColor: Array.isArray(O) ? r && _.config.xaxis.convertedCatToNumeric ? O[_.globals.minX + ee - 1] : O[ee] : O,
                  isPlainText: !1,
                  cssClass: (r ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + G
                });
                if (s.add(Ue), Ue.on("click", function (it) {
                    if (typeof _.config.chart.events.xAxisLabelClick == "function") {
                      var dt = Object.assign({}, _, {
                        labelIndex: ee
                      });
                      _.config.chart.events.xAxisLabelClick(it, g.ctx, dt)
                    }
                  }), r) {
                  var Ve = document.createElementNS(_.globals.SVGNS, "title");
                  Ve.textContent = Array.isArray(pe.text) ? pe.text.join(" ") : pe.text, Ue.node.appendChild(Ve), pe.text !== "" && (y.push(pe.text), x.push(pe))
                }
              }
              ee < v - 1 && (Q += d(ee + 1, f))
            }, q = 0; q <= v - 1; q++) H(q)
        }
      }, {
        key: "drawXaxisInversed",
        value: function (r) {
          var n, s, c = this,
            u = this.w,
            d = new W(this.ctx),
            f = u.config.yaxis[0].opposite ? u.globals.translateYAxisX[r] : 0,
            g = d.group({
              class: "apexcharts-yaxis apexcharts-xaxis-inversed",
              rel: r
            }),
            b = d.group({
              class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
              transform: "translate(" + f + ", 0)"
            });
          g.add(b);
          var y = [];
          if (u.config.yaxis[r].show)
            for (var x = 0; x < this.xaxisLabels.length; x++) y.push(this.xaxisLabels[x]);
          n = u.globals.gridHeight / y.length, s = -n / 2.2;
          var _ = u.globals.yLabelFormatters[0],
            T = u.config.yaxis[0].labels;
          if (T.show)
            for (var P = function (L) {
                var H = y[L] === void 0 ? "" : y[L];
                H = _(H, {
                  seriesIndex: r,
                  dataPointIndex: L,
                  w: u
                });
                var q = c.axesUtils.getYAxisForeColor(T.style.colors, r),
                  ee = 0;
                Array.isArray(H) && (ee = H.length / 2 * parseInt(T.style.fontSize, 10));
                var ge = T.offsetX - 15,
                  pe = "end";
                c.yaxis.opposite && (pe = "start"), u.config.yaxis[0].labels.align === "left" ? (ge = T.offsetX, pe = "start") : u.config.yaxis[0].labels.align === "center" ? (ge = T.offsetX, pe = "middle") : u.config.yaxis[0].labels.align === "right" && (pe = "end");
                var Fe = d.drawText({
                  x: ge,
                  y: s + n + T.offsetY - ee,
                  text: H,
                  textAnchor: pe,
                  foreColor: Array.isArray(q) ? q[L] : q,
                  fontSize: T.style.fontSize,
                  fontFamily: T.style.fontFamily,
                  fontWeight: T.style.fontWeight,
                  isPlainText: !1,
                  cssClass: "apexcharts-yaxis-label " + T.style.cssClass,
                  maxWidth: T.maxWidth
                });
                b.add(Fe), Fe.on("click", function (it) {
                  if (typeof u.config.chart.events.xAxisLabelClick == "function") {
                    var dt = Object.assign({}, u, {
                      labelIndex: L
                    });
                    u.config.chart.events.xAxisLabelClick(it, c.ctx, dt)
                  }
                });
                var Ue = document.createElementNS(u.globals.SVGNS, "title");
                if (Ue.textContent = Array.isArray(H) ? H.join(" ") : H, Fe.node.appendChild(Ue), u.config.yaxis[r].labels.rotate !== 0) {
                  var Ve = d.rotateAroundCenter(Fe.node);
                  Fe.node.setAttribute("transform", "rotate(".concat(u.config.yaxis[r].labels.rotate, " 0 ").concat(Ve.y, ")"))
                }
                s += n
              }, O = 0; O <= y.length - 1; O++) P(O);
          if (u.config.yaxis[0].title.text !== void 0) {
            var $ = d.group({
                class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                transform: "translate(" + f + ", 0)"
              }),
              G = d.drawText({
                x: u.config.yaxis[0].title.offsetX,
                y: u.globals.gridHeight / 2 + u.config.yaxis[0].title.offsetY,
                text: u.config.yaxis[0].title.text,
                textAnchor: "middle",
                foreColor: u.config.yaxis[0].title.style.color,
                fontSize: u.config.yaxis[0].title.style.fontSize,
                fontWeight: u.config.yaxis[0].title.style.fontWeight,
                fontFamily: u.config.yaxis[0].title.style.fontFamily,
                cssClass: "apexcharts-yaxis-title-text " + u.config.yaxis[0].title.style.cssClass
              });
            $.add(G), g.add($)
          }
          var Q = 0;
          this.isCategoryBarHorizontal && u.config.yaxis[0].opposite && (Q = u.globals.gridWidth);
          var v = u.config.xaxis.axisBorder;
          if (v.show) {
            var C = d.drawLine(u.globals.padHorizontal + v.offsetX + Q, 1 + v.offsetY, u.globals.padHorizontal + v.offsetX + Q, u.globals.gridHeight + v.offsetY, v.color, 0);
            this.elgrid && this.elgrid.elGridBorders && u.config.grid.show ? this.elgrid.elGridBorders.add(C) : g.add(C)
          }
          return u.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(Q, y.length, u.config.yaxis[0].axisBorder, u.config.yaxis[0].axisTicks, 0, n, g), g
        }
      }, {
        key: "drawXaxisTicks",
        value: function (r, n, s) {
          var c = this.w,
            u = r;
          if (!(r < 0 || r - 2 > c.globals.gridWidth)) {
            var d = this.offY + c.config.xaxis.axisTicks.offsetY;
            if (n = n + d + c.config.xaxis.axisTicks.height, c.config.xaxis.position === "top" && (n = d - c.config.xaxis.axisTicks.height), c.config.xaxis.axisTicks.show) {
              var f = new W(this.ctx).drawLine(r + c.config.xaxis.axisTicks.offsetX, d + c.config.xaxis.offsetY, u + c.config.xaxis.axisTicks.offsetX, n + c.config.xaxis.offsetY, c.config.xaxis.axisTicks.color);
              s.add(f), f.node.classList.add("apexcharts-xaxis-tick")
            }
          }
        }
      }, {
        key: "getXAxisTicksPositions",
        value: function () {
          var r = this.w,
            n = [],
            s = this.xaxisLabels.length,
            c = r.globals.padHorizontal;
          if (r.globals.timescaleLabels.length > 0)
            for (var u = 0; u < s; u++) c = this.xaxisLabels[u].position, n.push(c);
          else
            for (var d = s, f = 0; f < d; f++) {
              var g = d;
              r.globals.isXNumeric && r.config.chart.type !== "bar" && (g -= 1), c += r.globals.gridWidth / g, n.push(c)
            }
          return n
        }
      }, {
        key: "xAxisLabelCorrections",
        value: function () {
          var r = this.w,
            n = new W(this.ctx),
            s = r.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
            c = r.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"),
            u = r.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
            d = r.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
          if (r.globals.rotateXLabels || r.config.xaxis.labels.rotateAlways)
            for (var f = 0; f < c.length; f++) {
              var g = n.rotateAroundCenter(c[f]);
              g.y = g.y - 1, g.x = g.x + 1, c[f].setAttribute("transform", "rotate(".concat(r.config.xaxis.labels.rotate, " ").concat(g.x, " ").concat(g.y, ")")), c[f].setAttribute("text-anchor", "end"), s.setAttribute("transform", "translate(0, ".concat(-10, ")"));
              var b = c[f].childNodes;
              r.config.xaxis.labels.trim && Array.prototype.forEach.call(b, function (T) {
                n.placeTextWithEllipsis(T, T.textContent, r.globals.xAxisLabelsHeight - (r.config.legend.position === "bottom" ? 20 : 10))
              })
            } else(function () {
              for (var T = r.globals.gridWidth / (r.globals.labels.length + 1), P = 0; P < c.length; P++) {
                var O = c[P].childNodes;
                r.config.xaxis.labels.trim && r.config.xaxis.type !== "datetime" && Array.prototype.forEach.call(O, function ($) {
                  n.placeTextWithEllipsis($, $.textContent, T)
                })
              }
            })();
          if (u.length > 0) {
            var y = u[u.length - 1].getBBox(),
              x = u[0].getBBox();
            y.x < -20 && u[u.length - 1].parentNode.removeChild(u[u.length - 1]), x.x + x.width > r.globals.gridWidth && !r.globals.isBarHorizontal && u[0].parentNode.removeChild(u[0]);
            for (var _ = 0; _ < d.length; _++) n.placeTextWithEllipsis(d[_], d[_].textContent, r.config.yaxis[0].labels.maxWidth - (r.config.yaxis[0].title.text ? 2 * parseFloat(r.config.yaxis[0].title.style.fontSize) : 0) - 15)
          }
        }
      }]), Y
    }(),
    Pe = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w;
        var n = this.w;
        this.xaxisLabels = n.globals.labels.slice(), this.axesUtils = new Re(r), this.isRangeBar = n.globals.seriesRange.length && n.globals.isBarHorizontal, n.globals.timescaleLabels.length > 0 && (this.xaxisLabels = n.globals.timescaleLabels.slice())
      }
      return p(Y, [{
        key: "drawGridArea",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null,
            n = this.w,
            s = new W(this.ctx);
          r === null && (r = s.group({
            class: "apexcharts-grid"
          }));
          var c = s.drawLine(n.globals.padHorizontal, 1, n.globals.padHorizontal, n.globals.gridHeight, "transparent"),
            u = s.drawLine(n.globals.padHorizontal, n.globals.gridHeight, n.globals.gridWidth, n.globals.gridHeight, "transparent");
          return r.add(u), r.add(c), r
        }
      }, {
        key: "drawGrid",
        value: function () {
          var r = null;
          return this.w.globals.axisCharts && (r = this.renderGrid(), this.drawGridArea(r.el)), r
        }
      }, {
        key: "createGridMask",
        value: function () {
          var r = this.w,
            n = r.globals,
            s = new W(this.ctx),
            c = Array.isArray(r.config.stroke.width) ? 0 : r.config.stroke.width;
          if (Array.isArray(r.config.stroke.width)) {
            var u = 0;
            r.config.stroke.width.forEach(function (x) {
              u = Math.max(u, x)
            }), c = u
          }
          n.dom.elGridRectMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(n.cuid)), n.dom.elGridRectMarkerMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(n.cuid)), n.dom.elForecastMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elForecastMask.setAttribute("id", "forecastMask".concat(n.cuid)), n.dom.elNonForecastMask = document.createElementNS(n.SVGNS, "clipPath"), n.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(n.cuid));
          var d = r.config.chart.type,
            f = 0,
            g = 0;
          (d === "bar" || d === "rangeBar" || d === "candlestick" || d === "boxPlot" || r.globals.comboBarCount > 0) && r.globals.isXNumeric && !r.globals.isBarHorizontal && (f = r.config.grid.padding.left, g = r.config.grid.padding.right, n.barPadForNumericAxis > f && (f = n.barPadForNumericAxis, g = n.barPadForNumericAxis)), n.dom.elGridRect = s.drawRect(-c - f - 2, 2 * -c - 2, n.gridWidth + c + g + f + 4, n.gridHeight + 4 * c + 4, 0, "#fff");
          var b = r.globals.markers.largestSize + 1;
          n.dom.elGridRectMarker = s.drawRect(2 * -b, 2 * -b, n.gridWidth + 4 * b, n.gridHeight + 4 * b, 0, "#fff"), n.dom.elGridRectMask.appendChild(n.dom.elGridRect.node), n.dom.elGridRectMarkerMask.appendChild(n.dom.elGridRectMarker.node);
          var y = n.dom.baseEl.querySelector("defs");
          y.appendChild(n.dom.elGridRectMask), y.appendChild(n.dom.elForecastMask), y.appendChild(n.dom.elNonForecastMask), y.appendChild(n.dom.elGridRectMarkerMask)
        }
      }, {
        key: "_drawGridLines",
        value: function (r) {
          var n = r.i,
            s = r.x1,
            c = r.y1,
            u = r.x2,
            d = r.y2,
            f = r.xCount,
            g = r.parent,
            b = this.w;
          if (!(n === 0 && b.globals.skipFirstTimelinelabel || n === f - 1 && b.globals.skipLastTimelinelabel && !b.config.xaxis.labels.formatter || b.config.chart.type === "radar")) {
            b.config.grid.xaxis.lines.show && this._drawGridLine({
              i: n,
              x1: s,
              y1: c,
              x2: u,
              y2: d,
              xCount: f,
              parent: g
            });
            var y = 0;
            if (b.globals.hasXaxisGroups && b.config.xaxis.tickPlacement === "between") {
              var x = b.globals.groups;
              if (x) {
                for (var _ = 0, T = 0; _ < n && T < x.length; T++) _ += x[T].cols;
                _ === n && (y = .6 * b.globals.xAxisLabelsHeight)
              }
            }
            new nt(this.ctx).drawXaxisTicks(s, y, b.globals.dom.elGraphical)
          }
        }
      }, {
        key: "_drawGridLine",
        value: function (r) {
          var n = r.i,
            s = r.x1,
            c = r.y1,
            u = r.x2,
            d = r.y2,
            f = r.xCount,
            g = r.parent,
            b = this.w,
            y = !1,
            x = g.node.classList.contains("apexcharts-gridlines-horizontal"),
            _ = b.config.grid.strokeDashArray,
            T = b.globals.barPadForNumericAxis;
          (c === 0 && d === 0 || s === 0 && u === 0) && (y = !0), c === b.globals.gridHeight && d === b.globals.gridHeight && (y = !0), !b.globals.isBarHorizontal || n !== 0 && n !== f - 1 || (y = !0);
          var P = new W(this).drawLine(s - (x ? T : 0), c, u + (x ? T : 0), d, b.config.grid.borderColor, _);
          P.node.classList.add("apexcharts-gridline"), y && b.config.grid.show ? this.elGridBorders.add(P) : g.add(P)
        }
      }, {
        key: "_drawGridBandRect",
        value: function (r) {
          var n = r.c,
            s = r.x1,
            c = r.y1,
            u = r.x2,
            d = r.y2,
            f = r.type,
            g = this.w,
            b = new W(this.ctx),
            y = g.globals.barPadForNumericAxis;
          if (f !== "column" || g.config.xaxis.type !== "datetime") {
            var x = g.config.grid[f].colors[n],
              _ = b.drawRect(s - (f === "row" ? y : 0), c, u + (f === "row" ? 2 * y : 0), d, 0, x, g.config.grid[f].opacity);
            this.elg.add(_), _.attr("clip-path", "url(#gridRectMask".concat(g.globals.cuid, ")")), _.node.classList.add("apexcharts-grid-".concat(f))
          }
        }
      }, {
        key: "_drawXYLines",
        value: function (r) {
          var n = this,
            s = r.xCount,
            c = r.tickAmount,
            u = this.w;
          if (u.config.grid.xaxis.lines.show || u.config.xaxis.axisTicks.show) {
            var d, f = u.globals.padHorizontal,
              g = u.globals.gridHeight;
            u.globals.timescaleLabels.length ? function (P) {
              for (var O = P.xC, $ = P.x1, G = P.y1, Q = P.x2, v = P.y2, C = 0; C < O; C++) $ = n.xaxisLabels[C].position, Q = n.xaxisLabels[C].position, n._drawGridLines({
                i: C,
                x1: $,
                y1: G,
                x2: Q,
                y2: v,
                xCount: s,
                parent: n.elgridLinesV
              })
            }({
              xC: s,
              x1: f,
              y1: 0,
              x2: d,
              y2: g
            }) : (u.globals.isXNumeric && (s = u.globals.xAxisScale.result.length), function (P) {
              for (var O = P.xC, $ = P.x1, G = P.y1, Q = P.x2, v = P.y2, C = 0; C < O + (u.globals.isXNumeric ? 0 : 1); C++) C === 0 && O === 1 && u.globals.dataPoints === 1 && (Q = $ = u.globals.gridWidth / 2), n._drawGridLines({
                i: C,
                x1: $,
                y1: G,
                x2: Q,
                y2: v,
                xCount: s,
                parent: n.elgridLinesV
              }), Q = $ += u.globals.gridWidth / (u.globals.isXNumeric ? O - 1 : O)
            }({
              xC: s,
              x1: f,
              y1: 0,
              x2: d,
              y2: g
            }))
          }
          if (u.config.grid.yaxis.lines.show) {
            var b = 0,
              y = 0,
              x = u.globals.gridWidth,
              _ = c + 1;
            this.isRangeBar && (_ = u.globals.labels.length);
            for (var T = 0; T < _ + (this.isRangeBar ? 1 : 0); T++) this._drawGridLine({
              i: T,
              xCount: _ + (this.isRangeBar ? 1 : 0),
              x1: 0,
              y1: b,
              x2: x,
              y2: y,
              parent: this.elgridLinesH
            }), y = b += u.globals.gridHeight / (this.isRangeBar ? _ : c)
          }
        }
      }, {
        key: "_drawInvertedXYLines",
        value: function (r) {
          var n = r.xCount,
            s = this.w;
          if (s.config.grid.xaxis.lines.show || s.config.xaxis.axisTicks.show)
            for (var c, u = s.globals.padHorizontal, d = s.globals.gridHeight, f = 0; f < n + 1; f++) s.config.grid.xaxis.lines.show && this._drawGridLine({
              i: f,
              xCount: n + 1,
              x1: u,
              y1: 0,
              x2: c,
              y2: d,
              parent: this.elgridLinesV
            }), new nt(this.ctx).drawXaxisTicks(u, 0, s.globals.dom.elGraphical), c = u = u + s.globals.gridWidth / n + .3;
          if (s.config.grid.yaxis.lines.show)
            for (var g = 0, b = 0, y = s.globals.gridWidth, x = 0; x < s.globals.dataPoints + 1; x++) this._drawGridLine({
              i: x,
              xCount: s.globals.dataPoints + 1,
              x1: 0,
              y1: g,
              x2: y,
              y2: b,
              parent: this.elgridLinesH
            }), b = g += s.globals.gridHeight / s.globals.dataPoints
        }
      }, {
        key: "renderGrid",
        value: function () {
          var r = this.w,
            n = new W(this.ctx);
          this.elg = n.group({
            class: "apexcharts-grid"
          }), this.elgridLinesH = n.group({
            class: "apexcharts-gridlines-horizontal"
          }), this.elgridLinesV = n.group({
            class: "apexcharts-gridlines-vertical"
          }), this.elGridBorders = n.group({
            class: "apexcharts-grid-borders"
          }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), r.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
          for (var s, c = r.globals.yAxisScale.length ? r.globals.yAxisScale[0].result.length - 1 : 5, u = 0; u < r.globals.series.length && (r.globals.yAxisScale[u] !== void 0 && (c = r.globals.yAxisScale[u].result.length - 1), !(c > 2)); u++);
          if (!r.globals.isBarHorizontal || this.isRangeBar) {
            var d, f, g;
            s = this.xaxisLabels.length, this.isRangeBar && (s--, c = r.globals.labels.length, r.config.xaxis.tickAmount && r.config.xaxis.labels.formatter && (s = r.config.xaxis.tickAmount), ((d = r.globals.yAxisScale) === null || d === void 0 || (f = d[0]) === null || f === void 0 || (g = f.result) === null || g === void 0 ? void 0 : g.length) > 0 && r.config.xaxis.type !== "datetime" && (s = r.globals.yAxisScale[0].result.length - 1)), this._drawXYLines({
              xCount: s,
              tickAmount: c
            })
          } else s = c, c = r.globals.xTickAmount, this._drawInvertedXYLines({
            xCount: s,
            tickAmount: c
          });
          return this.drawGridBands(s, c), {
            el: this.elg,
            elGridBorders: this.elGridBorders,
            xAxisTickWidth: r.globals.gridWidth / s
          }
        }
      }, {
        key: "drawGridBands",
        value: function (r, n) {
          var s = this.w;
          if (s.config.grid.row.colors !== void 0 && s.config.grid.row.colors.length > 0)
            for (var c = 0, u = s.globals.gridHeight / n, d = s.globals.gridWidth, f = 0, g = 0; f < n; f++, g++) g >= s.config.grid.row.colors.length && (g = 0), this._drawGridBandRect({
              c: g,
              x1: 0,
              y1: c,
              x2: d,
              y2: u,
              type: "row"
            }), c += s.globals.gridHeight / n;
          if (s.config.grid.column.colors !== void 0 && s.config.grid.column.colors.length > 0)
            for (var b = s.globals.isBarHorizontal || s.config.xaxis.tickPlacement !== "on" || s.config.xaxis.type !== "category" && !s.config.xaxis.convertedCatToNumeric ? r : r - 1, y = s.globals.padHorizontal, x = s.globals.padHorizontal + s.globals.gridWidth / b, _ = s.globals.gridHeight, T = 0, P = 0; T < r; T++, P++) P >= s.config.grid.column.colors.length && (P = 0), this._drawGridBandRect({
              c: P,
              x1: y,
              y1: 0,
              x2: x,
              y2: _,
              type: "column"
            }), y += s.globals.gridWidth / b
        }
      }]), Y
    }(),
    We = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "niceScale",
        value: function (r, n) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5,
            c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
            u = arguments.length > 4 ? arguments[4] : void 0,
            d = this.w,
            f = Math.abs(n - r);
          if ((s = this._adjustTicksForSmallRange(s, c, f)) === "dataPoints" && (s = d.globals.dataPoints - 1), r === Number.MIN_VALUE && n === 0 || !I.isNumber(r) && !I.isNumber(n) || r === Number.MIN_VALUE && n === -Number.MAX_VALUE) return r = 0, n = s, this.linearScale(r, n, s, c, d.config.yaxis[c].stepSize);
          r > n ? (console.warn("axis.min cannot be greater than axis.max"), n = r + .1) : r === n && (r = r === 0 ? 0 : r - .5, n = n === 0 ? 2 : n + .5);
          var g = [];
          f < 1 && u && (d.config.chart.type === "candlestick" || d.config.series[c].type === "candlestick" || d.config.chart.type === "boxPlot" || d.config.series[c].type === "boxPlot" || d.globals.isRangeData) && (n *= 1.01);
          var b = s + 1;
          b < 2 ? b = 2 : b > 2 && (b -= 2);
          var y = f / b,
            x = Math.floor(I.log10(y)),
            _ = Math.pow(10, x),
            T = Math.round(y / _);
          T < 1 && (T = 1);
          var P = T * _;
          d.config.yaxis[c].stepSize && (P = d.config.yaxis[c].stepSize), d.globals.isBarHorizontal && d.config.xaxis.stepSize && d.config.xaxis.type !== "datetime" && (P = d.config.xaxis.stepSize);
          var O = P * Math.floor(r / P),
            $ = P * Math.ceil(n / P),
            G = O;
          if (u && f > 2) {
            for (; g.push(I.stripNumber(G, 7)), !((G += P) > $););
            return {
              result: g,
              niceMin: g[0],
              niceMax: g[g.length - 1]
            }
          }
          var Q = r;
          (g = []).push(I.stripNumber(Q, 7));
          for (var v = Math.abs(n - r) / s, C = 0; C <= s; C++) Q += v, g.push(Q);
          return g[g.length - 2] >= n && g.pop(), {
            result: g,
            niceMin: g[0],
            niceMax: g[g.length - 1]
          }
        }
      }, {
        key: "linearScale",
        value: function (r, n) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5,
            c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
            u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0,
            d = Math.abs(n - r);
          (s = this._adjustTicksForSmallRange(s, c, d)) === "dataPoints" && (s = this.w.globals.dataPoints - 1), u || (u = d / s), s === Number.MAX_VALUE && (s = 5, u = 1);
          for (var f = [], g = r; s >= 0;) f.push(g), g += u, s -= 1;
          return {
            result: f,
            niceMin: f[0],
            niceMax: f[f.length - 1]
          }
        }
      }, {
        key: "logarithmicScaleNice",
        value: function (r, n, s) {
          n <= 0 && (n = Math.max(r, s)), r <= 0 && (r = Math.min(n, s));
          for (var c = [], u = Math.ceil(Math.log(n) / Math.log(s) + 1), d = Math.floor(Math.log(r) / Math.log(s)); d < u; d++) c.push(Math.pow(s, d));
          return {
            result: c,
            niceMin: c[0],
            niceMax: c[c.length - 1]
          }
        }
      }, {
        key: "logarithmicScale",
        value: function (r, n, s) {
          n <= 0 && (n = Math.max(r, s)), r <= 0 && (r = Math.min(n, s));
          for (var c = [], u = Math.log(n) / Math.log(s), d = Math.log(r) / Math.log(s), f = u - d, g = Math.round(f), b = f / g, y = 0, x = d; y < g; y++, x += b) c.push(Math.pow(s, x));
          return c.push(Math.pow(s, u)), {
            result: c,
            niceMin: r,
            niceMax: n
          }
        }
      }, {
        key: "_adjustTicksForSmallRange",
        value: function (r, n, s) {
          var c = r;
          if (n !== void 0 && this.w.config.yaxis[n].labels.formatter && this.w.config.yaxis[n].tickAmount === void 0) {
            var u = Number(this.w.config.yaxis[n].labels.formatter(1));
            I.isNumber(u) && this.w.globals.yValueDecimal === 0 && (c = Math.ceil(s))
          }
          return c < r ? c : r
        }
      }, {
        key: "setYScaleForIndex",
        value: function (r, n, s) {
          var c = this.w.globals,
            u = this.w.config,
            d = c.isBarHorizontal ? u.xaxis : u.yaxis[r];
          c.yAxisScale[r] === void 0 && (c.yAxisScale[r] = []);
          var f = Math.abs(s - n);
          if (d.logarithmic && f <= 5 && (c.invalidLogScale = !0), d.logarithmic && f > 5) c.allSeriesCollapsed = !1, c.yAxisScale[r] = this.logarithmicScale(n, s, d.logBase), c.yAxisScale[r] = d.forceNiceScale ? this.logarithmicScaleNice(n, s, d.logBase) : this.logarithmicScale(n, s, d.logBase);
          else if (s !== -Number.MAX_VALUE && I.isNumber(s))
            if (c.allSeriesCollapsed = !1, d.min === void 0 && d.max === void 0 || d.forceNiceScale) {
              var g = u.yaxis[r].max === void 0 && u.yaxis[r].min === void 0 || u.yaxis[r].forceNiceScale;
              c.yAxisScale[r] = this.niceScale(n, s, d.tickAmount ? d.tickAmount : f < 5 && f > 1 ? f + 1 : 5, r, g)
            } else c.yAxisScale[r] = this.linearScale(n, s, d.tickAmount, r, u.yaxis[r].stepSize);
          else c.yAxisScale[r] = this.linearScale(0, 5, 5, r, u.yaxis[r].stepSize)
        }
      }, {
        key: "setXScale",
        value: function (r, n) {
          var s = this.w,
            c = s.globals,
            u = Math.abs(n - r);
          return n !== -Number.MAX_VALUE && I.isNumber(n) ? c.xAxisScale = this.linearScale(r, n, s.config.xaxis.tickAmount ? s.config.xaxis.tickAmount : u < 5 && u > 1 ? u + 1 : 5, 0, s.config.xaxis.stepSize) : c.xAxisScale = this.linearScale(0, 5, 5), c.xAxisScale
        }
      }, {
        key: "setMultipleYScales",
        value: function () {
          var r = this,
            n = this.w.globals,
            s = this.w.config,
            c = n.minYArr.concat([]),
            u = n.maxYArr.concat([]),
            d = [];
          s.yaxis.forEach(function (f, g) {
            var b = g;
            s.series.forEach(function (_, T) {
              _.name === f.seriesName && (b = T, g !== T ? d.push({
                index: T,
                similarIndex: g,
                alreadyExists: !0
              }) : d.push({
                index: T
              }))
            });
            var y = c[b],
              x = u[b];
            r.setYScaleForIndex(g, y, x)
          }), this.sameScaleInMultipleAxes(c, u, d)
        }
      }, {
        key: "sameScaleInMultipleAxes",
        value: function (r, n, s) {
          var c = this,
            u = this.w.config,
            d = this.w.globals,
            f = [];
          s.forEach(function (O) {
            O.alreadyExists && (f[O.index] === void 0 && (f[O.index] = []), f[O.index].push(O.index), f[O.index].push(O.similarIndex))
          }), d.yAxisSameScaleIndices = f, f.forEach(function (O, $) {
            f.forEach(function (G, Q) {
              var v, C;
              $ !== Q && (v = O, C = G, v.filter(function (L) {
                return C.indexOf(L) !== -1
              })).length > 0 && (f[$] = f[$].concat(f[Q]))
            })
          });
          var g = f.map(function (O) {
            return O.filter(function ($, G) {
              return O.indexOf($) === G
            })
          }).map(function (O) {
            return O.sort()
          });
          f = f.filter(function (O) {
            return !!O
          });
          var b = g.slice(),
            y = b.map(function (O) {
              return JSON.stringify(O)
            });
          b = b.filter(function (O, $) {
            return y.indexOf(JSON.stringify(O)) === $
          });
          var x = [],
            _ = [];
          r.forEach(function (O, $) {
            b.forEach(function (G, Q) {
              G.indexOf($) > -1 && (x[Q] === void 0 && (x[Q] = [], _[Q] = []), x[Q].push({
                key: $,
                value: O
              }), _[Q].push({
                key: $,
                value: n[$]
              }))
            })
          });
          var T = Array.apply(null, Array(b.length)).map(Number.prototype.valueOf, Number.MIN_VALUE),
            P = Array.apply(null, Array(b.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
          x.forEach(function (O, $) {
            O.forEach(function (G, Q) {
              T[$] = Math.min(G.value, T[$])
            })
          }), _.forEach(function (O, $) {
            O.forEach(function (G, Q) {
              P[$] = Math.max(G.value, P[$])
            })
          }), r.forEach(function (O, $) {
            _.forEach(function (G, Q) {
              var v = T[Q],
                C = P[Q];
              u.chart.stacked && (C = 0, G.forEach(function (L, H) {
                L.value !== -Number.MAX_VALUE && (C += L.value), v !== Number.MIN_VALUE && (v += x[Q][H].value)
              })), G.forEach(function (L, H) {
                G[H].key === $ && (u.yaxis[$].min !== void 0 && (v = typeof u.yaxis[$].min == "function" ? u.yaxis[$].min(d.minY) : u.yaxis[$].min), u.yaxis[$].max !== void 0 && (C = typeof u.yaxis[$].max == "function" ? u.yaxis[$].max(d.maxY) : u.yaxis[$].max), c.setYScaleForIndex($, v, C))
              })
            })
          })
        }
      }, {
        key: "autoScaleY",
        value: function (r, n, s) {
          r || (r = this);
          var c = r.w;
          if (c.globals.isMultipleYAxis || c.globals.collapsedSeries.length) return console.warn("autoScaleYaxis not supported in a multi-yaxis chart."), n;
          var u = c.globals.seriesX[0],
            d = c.config.chart.stacked;
          return n.forEach(function (f, g) {
            for (var b = 0, y = 0; y < u.length; y++)
              if (u[y] >= s.xaxis.min) {
                b = y;
                break
              } var x, _, T = c.globals.minYArr[g],
              P = c.globals.maxYArr[g],
              O = c.globals.stackedSeriesTotals;
            c.globals.series.forEach(function ($, G) {
              var Q = $[b];
              d ? (Q = O[b], x = _ = Q, O.forEach(function (v, C) {
                u[C] <= s.xaxis.max && u[C] >= s.xaxis.min && (v > _ && v !== null && (_ = v), $[C] < x && $[C] !== null && (x = $[C]))
              })) : (x = _ = Q, $.forEach(function (v, C) {
                if (u[C] <= s.xaxis.max && u[C] >= s.xaxis.min) {
                  var L = v,
                    H = v;
                  c.globals.series.forEach(function (q, ee) {
                    v !== null && (L = Math.min(q[C], L), H = Math.max(q[C], H))
                  }), H > _ && H !== null && (_ = H), L < x && L !== null && (x = L)
                }
              })), x === void 0 && _ === void 0 && (x = T, _ = P), _ *= _ < 0 ? .9 : 1.1, (x *= x < 0 ? 1.1 : .9) === 0 && _ === 0 && (x = -1, _ = 1), _ < 0 && _ < P && (_ = P), x < 0 && x > T && (x = T), n.length > 1 ? (n[G].min = f.min === void 0 ? x : f.min, n[G].max = f.max === void 0 ? _ : f.max) : (n[0].min = f.min === void 0 ? x : f.min, n[0].max = f.max === void 0 ? _ : f.max)
            })
          }), n
        }
      }]), Y
    }(),
    F = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.scales = new We(r)
      }
      return p(Y, [{
        key: "init",
        value: function () {
          this.setYRange(), this.setXRange(), this.setZRange()
        }
      }, {
        key: "getMinYMaxY",
        value: function (r) {
          var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE,
            s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -Number.MAX_VALUE,
            c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null,
            u = this.w.config,
            d = this.w.globals,
            f = -Number.MAX_VALUE,
            g = Number.MIN_VALUE;
          c === null && (c = r + 1);
          var b = d.series,
            y = b,
            x = b;
          u.chart.type === "candlestick" ? (y = d.seriesCandleL, x = d.seriesCandleH) : u.chart.type === "boxPlot" ? (y = d.seriesCandleO, x = d.seriesCandleC) : d.isRangeData && (y = d.seriesRangeStart, x = d.seriesRangeEnd);
          for (var _ = r; _ < c; _++) {
            d.dataPoints = Math.max(d.dataPoints, b[_].length), d.categoryLabels.length && (d.dataPoints = d.categoryLabels.filter(function (O) {
              return O !== void 0
            }).length), d.labels.length && u.xaxis.type !== "datetime" && d.series.reduce(function (O, $) {
              return O + $.length
            }, 0) !== 0 && (d.dataPoints = Math.max(d.dataPoints, d.labels.length));
            for (var T = 0; T < d.series[_].length; T++) {
              var P = b[_][T];
              P !== null && I.isNumber(P) ? (x[_][T] !== void 0 && (f = Math.max(f, x[_][T]), n = Math.min(n, x[_][T])), y[_][T] !== void 0 && (n = Math.min(n, y[_][T]), s = Math.max(s, y[_][T])), this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" && this.w.config.chart.type === "rangeArea" && this.w.config.chart.type === "rangeBar" || (this.w.config.chart.type !== "candlestick" && this.w.config.chart.type !== "boxPlot" || d.seriesCandleC[_][T] !== void 0 && (f = Math.max(f, d.seriesCandleO[_][T]), f = Math.max(f, d.seriesCandleH[_][T]), f = Math.max(f, d.seriesCandleL[_][T]), f = Math.max(f, d.seriesCandleC[_][T]), this.w.config.chart.type === "boxPlot" && (f = Math.max(f, d.seriesCandleM[_][T]))), !u.series[_].type || u.series[_].type === "candlestick" && u.series[_].type === "boxPlot" && u.series[_].type === "rangeArea" && u.series[_].type === "rangeBar" || (f = Math.max(f, d.series[_][T]), n = Math.min(n, d.series[_][T])), s = f), d.seriesGoals[_] && d.seriesGoals[_][T] && Array.isArray(d.seriesGoals[_][T]) && d.seriesGoals[_][T].forEach(function (O) {
                g !== Number.MIN_VALUE && (g = Math.min(g, O.value), n = g), f = Math.max(f, O.value), s = f
              }), I.isFloat(P) && (P = I.noExponents(P), d.yValueDecimal = Math.max(d.yValueDecimal, P.toString().split(".")[1].length)), g > y[_][T] && y[_][T] < 0 && (g = y[_][T])) : d.hasNullValues = !0
            }
          }
          return u.chart.type === "rangeBar" && d.seriesRangeStart.length && d.isBarHorizontal && (g = n), u.chart.type === "bar" && (g < 0 && f < 0 && (f = 0), g === Number.MIN_VALUE && (g = 0)), {
            minY: g,
            maxY: f,
            lowestY: n,
            highestY: s
          }
        }
      }, {
        key: "setYRange",
        value: function () {
          var r = this.w.globals,
            n = this.w.config;
          r.maxY = -Number.MAX_VALUE, r.minY = Number.MIN_VALUE;
          var s = Number.MAX_VALUE;
          if (r.isMultipleYAxis)
            for (var c = 0; c < r.series.length; c++) {
              var u = this.getMinYMaxY(c, s, null, c + 1);
              r.minYArr.push(u.minY), r.maxYArr.push(u.maxY), s = u.lowestY
            }
          var d = this.getMinYMaxY(0, s, null, r.series.length);
          if (r.minY = d.minY, r.maxY = d.maxY, s = d.lowestY, n.chart.stacked && this._setStackedMinMax(), (n.chart.type === "line" || n.chart.type === "area" || n.chart.type === "candlestick" || n.chart.type === "boxPlot" || n.chart.type === "rangeBar" && !r.isBarHorizontal) && r.minY === Number.MIN_VALUE && s !== -Number.MAX_VALUE && s !== r.maxY) {
            var f = r.maxY - s;
            (s >= 0 && s <= 10 || n.yaxis[0].min !== void 0 || n.yaxis[0].max !== void 0) && (f = 0), r.minY = s - 5 * f / 100, s > 0 && r.minY < 0 && (r.minY = 0), r.maxY = r.maxY + 5 * f / 100
          }
          return n.yaxis.forEach(function (g, b) {
            g.max !== void 0 && (typeof g.max == "number" ? r.maxYArr[b] = g.max : typeof g.max == "function" && (r.maxYArr[b] = g.max(r.isMultipleYAxis ? r.maxYArr[b] : r.maxY)), r.maxY = r.maxYArr[b]), g.min !== void 0 && (typeof g.min == "number" ? r.minYArr[b] = g.min : typeof g.min == "function" && (r.minYArr[b] = g.min(r.isMultipleYAxis ? r.minYArr[b] === Number.MIN_VALUE ? 0 : r.minYArr[b] : r.minY)), r.minY = r.minYArr[b])
          }), r.isBarHorizontal && ["min", "max"].forEach(function (g) {
            n.xaxis[g] !== void 0 && typeof n.xaxis[g] == "number" && (g === "min" ? r.minY = n.xaxis[g] : r.maxY = n.xaxis[g])
          }), r.isMultipleYAxis ? (this.scales.setMultipleYScales(), r.minY = s, r.yAxisScale.forEach(function (g, b) {
            r.minYArr[b] = g.niceMin, r.maxYArr[b] = g.niceMax
          })) : (this.scales.setYScaleForIndex(0, r.minY, r.maxY), r.minY = r.yAxisScale[0].niceMin, r.maxY = r.yAxisScale[0].niceMax, r.minYArr[0] = r.yAxisScale[0].niceMin, r.maxYArr[0] = r.yAxisScale[0].niceMax), {
            minY: r.minY,
            maxY: r.maxY,
            minYArr: r.minYArr,
            maxYArr: r.maxYArr,
            yAxisScale: r.yAxisScale
          }
        }
      }, {
        key: "setXRange",
        value: function () {
          var r = this.w.globals,
            n = this.w.config,
            s = n.xaxis.type === "numeric" || n.xaxis.type === "datetime" || n.xaxis.type === "category" && !r.noLabelsProvided || r.noLabelsProvided || r.isXNumeric;
          if (r.isXNumeric && function () {
              for (var f = 0; f < r.series.length; f++)
                if (r.labels[f])
                  for (var g = 0; g < r.labels[f].length; g++) r.labels[f][g] !== null && I.isNumber(r.labels[f][g]) && (r.maxX = Math.max(r.maxX, r.labels[f][g]), r.initialMaxX = Math.max(r.maxX, r.labels[f][g]), r.minX = Math.min(r.minX, r.labels[f][g]), r.initialMinX = Math.min(r.minX, r.labels[f][g]))
            }(), r.noLabelsProvided && n.xaxis.categories.length === 0 && (r.maxX = r.labels[r.labels.length - 1], r.initialMaxX = r.labels[r.labels.length - 1], r.minX = 1, r.initialMinX = 1), r.isXNumeric || r.noLabelsProvided || r.dataFormatXNumeric) {
            var c;
            if (n.xaxis.tickAmount === void 0 ? (c = Math.round(r.svgWidth / 150), n.xaxis.type === "numeric" && r.dataPoints < 30 && (c = r.dataPoints - 1), c > r.dataPoints && r.dataPoints !== 0 && (c = r.dataPoints - 1)) : n.xaxis.tickAmount === "dataPoints" ? (r.series.length > 1 && (c = r.series[r.maxValsInArrayIndex].length - 1), r.isXNumeric && (c = r.maxX - r.minX - 1)) : c = n.xaxis.tickAmount, r.xTickAmount = c, n.xaxis.max !== void 0 && typeof n.xaxis.max == "number" && (r.maxX = n.xaxis.max), n.xaxis.min !== void 0 && typeof n.xaxis.min == "number" && (r.minX = n.xaxis.min), n.xaxis.range !== void 0 && (r.minX = r.maxX - n.xaxis.range), r.minX !== Number.MAX_VALUE && r.maxX !== -Number.MAX_VALUE)
              if (n.xaxis.convertedCatToNumeric && !r.dataFormatXNumeric) {
                for (var u = [], d = r.minX - 1; d < r.maxX; d++) u.push(d + 1);
                r.xAxisScale = {
                  result: u,
                  niceMin: u[0],
                  niceMax: u[u.length - 1]
                }
              } else r.xAxisScale = this.scales.setXScale(r.minX, r.maxX);
            else r.xAxisScale = this.scales.linearScale(0, c, c, 0, n.xaxis.stepSize), r.noLabelsProvided && r.labels.length > 0 && (r.xAxisScale = this.scales.linearScale(1, r.labels.length, c - 1, 0, n.xaxis.stepSize), r.seriesX = r.labels.slice());
            s && (r.labels = r.xAxisScale.result.slice())
          }
          return r.isBarHorizontal && r.labels.length && (r.xTickAmount = r.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
            minX: r.minX,
            maxX: r.maxX
          }
        }
      }, {
        key: "setZRange",
        value: function () {
          var r = this.w.globals;
          if (r.isDataXYZ) {
            for (var n = 0; n < r.series.length; n++)
              if (r.seriesZ[n] !== void 0)
                for (var s = 0; s < r.seriesZ[n].length; s++) r.seriesZ[n][s] !== null && I.isNumber(r.seriesZ[n][s]) && (r.maxZ = Math.max(r.maxZ, r.seriesZ[n][s]), r.minZ = Math.min(r.minZ, r.seriesZ[n][s]))
          }
        }
      }, {
        key: "_handleSingleDataPoint",
        value: function () {
          var r = this.w.globals,
            n = this.w.config;
          if (r.minX === r.maxX) {
            var s = new ye(this.ctx);
            if (n.xaxis.type === "datetime") {
              var c = s.getDate(r.minX);
              n.xaxis.labels.datetimeUTC ? c.setUTCDate(c.getUTCDate() - 2) : c.setDate(c.getDate() - 2), r.minX = new Date(c).getTime();
              var u = s.getDate(r.maxX);
              n.xaxis.labels.datetimeUTC ? u.setUTCDate(u.getUTCDate() + 2) : u.setDate(u.getDate() + 2), r.maxX = new Date(u).getTime()
            } else(n.xaxis.type === "numeric" || n.xaxis.type === "category" && !r.noLabelsProvided) && (r.minX = r.minX - 2, r.initialMinX = r.minX, r.maxX = r.maxX + 2, r.initialMaxX = r.maxX)
          }
        }
      }, {
        key: "_getMinXDiff",
        value: function () {
          var r = this.w.globals;
          r.isXNumeric && r.seriesX.forEach(function (n, s) {
            n.length === 1 && n.push(r.seriesX[r.maxValsInArrayIndex][r.seriesX[r.maxValsInArrayIndex].length - 1]);
            var c = n.slice();
            c.sort(function (u, d) {
              return u - d
            }), c.forEach(function (u, d) {
              if (d > 0) {
                var f = u - c[d - 1];
                f > 0 && (r.minXDiff = Math.min(f, r.minXDiff))
              }
            }), r.dataPoints !== 1 && r.minXDiff !== Number.MAX_VALUE || (r.minXDiff = .5)
          })
        }
      }, {
        key: "_setStackedMinMax",
        value: function () {
          var r = this,
            n = this.w.globals;
          if (n.series.length) {
            var s = n.seriesGroups;
            s.length || (s = [this.w.config.series.map(function (d) {
              return d.name
            })]);
            var c = {},
              u = {};
            s.forEach(function (d) {
              c[d] = [], u[d] = [], r.w.config.series.map(function (f, g) {
                return d.indexOf(f.name) > -1 ? g : null
              }).filter(function (f) {
                return f !== null
              }).forEach(function (f) {
                for (var g = 0; g < n.series[n.maxValsInArrayIndex].length; g++) {
                  var b, y;
                  c[d][g] === void 0 && (c[d][g] = 0, u[d][g] = 0), (r.w.config.chart.stacked && !n.comboCharts || r.w.config.chart.stacked && n.comboCharts && (!r.w.config.chart.stackOnlyBar || ((b = r.w.config.series) === null || b === void 0 || (y = b[f]) === null || y === void 0 ? void 0 : y.type) === "bar")) && n.series[f][g] !== null && I.isNumber(n.series[f][g]) && (n.series[f][g] > 0 ? c[d][g] += parseFloat(n.series[f][g]) + 1e-4 : u[d][g] += parseFloat(n.series[f][g]))
                }
              })
            }), Object.entries(c).forEach(function (d) {
              var f = M(d, 1)[0];
              c[f].forEach(function (g, b) {
                n.maxY = Math.max(n.maxY, c[f][b]), n.minY = Math.min(n.minY, u[f][b])
              })
            })
          }
        }
      }]), Y
    }(),
    j = function () {
      function Y(r, n) {
        l(this, Y), this.ctx = r, this.elgrid = n, this.w = r.w;
        var s = this.w;
        this.xaxisFontSize = s.config.xaxis.labels.style.fontSize, this.axisFontFamily = s.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = s.config.chart.type === "bar" && s.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, s.config.xaxis.position === "bottom" && (this.xAxisoffX = s.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new Re(r)
      }
      return p(Y, [{
        key: "drawYaxis",
        value: function (r) {
          var n = this,
            s = this.w,
            c = new W(this.ctx),
            u = s.config.yaxis[r].labels.style,
            d = u.fontSize,
            f = u.fontFamily,
            g = u.fontWeight,
            b = c.group({
              class: "apexcharts-yaxis",
              rel: r,
              transform: "translate(" + s.globals.translateYAxisX[r] + ", 0)"
            });
          if (this.axesUtils.isYAxisHidden(r)) return b;
          var y = c.group({
            class: "apexcharts-yaxis-texts-g"
          });
          b.add(y);
          var x = s.globals.yAxisScale[r].result.length - 1,
            _ = s.globals.gridHeight / x,
            T = s.globals.translateY,
            P = s.globals.yLabelFormatters[r],
            O = s.globals.yAxisScale[r].result.slice();
          O = this.axesUtils.checkForReversedLabels(r, O);
          var $ = "";
          if (s.config.yaxis[r].labels.show)
            for (var G = function (ge) {
                var pe = O[ge];
                pe = P(pe, ge, s);
                var Fe = s.config.yaxis[r].labels.padding;
                s.config.yaxis[r].opposite && s.config.yaxis.length !== 0 && (Fe *= -1);
                var Ue = "end";
                s.config.yaxis[r].opposite && (Ue = "start"), s.config.yaxis[r].labels.align === "left" ? Ue = "start" : s.config.yaxis[r].labels.align === "center" ? Ue = "middle" : s.config.yaxis[r].labels.align === "right" && (Ue = "end");
                var Ve = n.axesUtils.getYAxisForeColor(u.colors, r),
                  it = s.config.yaxis[r].labels.offsetY;
                s.config.chart.type === "heatmap" && (it -= (s.globals.gridHeight / s.globals.series.length - 1) / 2);
                var dt = c.drawText({
                  x: Fe,
                  y: T + x / 10 + it + 1,
                  text: pe,
                  textAnchor: Ue,
                  fontSize: d,
                  fontFamily: f,
                  fontWeight: g,
                  maxWidth: s.config.yaxis[r].labels.maxWidth,
                  foreColor: Array.isArray(Ve) ? Ve[ge] : Ve,
                  isPlainText: !1,
                  cssClass: "apexcharts-yaxis-label " + u.cssClass
                });
                ge === x && ($ = dt), y.add(dt);
                var mt = document.createElementNS(s.globals.SVGNS, "title");
                if (mt.textContent = Array.isArray(pe) ? pe.join(" ") : pe, dt.node.appendChild(mt), s.config.yaxis[r].labels.rotate !== 0) {
                  var At = c.rotateAroundCenter($.node),
                    _t = c.rotateAroundCenter(dt.node);
                  dt.node.setAttribute("transform", "rotate(".concat(s.config.yaxis[r].labels.rotate, " ").concat(At.x, " ").concat(_t.y, ")"))
                }
                T += _
              }, Q = x; Q >= 0; Q--) G(Q);
          if (s.config.yaxis[r].title.text !== void 0) {
            var v = c.group({
                class: "apexcharts-yaxis-title"
              }),
              C = 0;
            s.config.yaxis[r].opposite && (C = s.globals.translateYAxisX[r]);
            var L = c.drawText({
              x: C,
              y: s.globals.gridHeight / 2 + s.globals.translateY + s.config.yaxis[r].title.offsetY,
              text: s.config.yaxis[r].title.text,
              textAnchor: "end",
              foreColor: s.config.yaxis[r].title.style.color,
              fontSize: s.config.yaxis[r].title.style.fontSize,
              fontWeight: s.config.yaxis[r].title.style.fontWeight,
              fontFamily: s.config.yaxis[r].title.style.fontFamily,
              cssClass: "apexcharts-yaxis-title-text " + s.config.yaxis[r].title.style.cssClass
            });
            v.add(L), b.add(v)
          }
          var H = s.config.yaxis[r].axisBorder,
            q = 31 + H.offsetX;
          if (s.config.yaxis[r].opposite && (q = -31 - H.offsetX), H.show) {
            var ee = c.drawLine(q, s.globals.translateY + H.offsetY - 2, q, s.globals.gridHeight + s.globals.translateY + H.offsetY + 2, H.color, 0, H.width);
            b.add(ee)
          }
          return s.config.yaxis[r].axisTicks.show && this.axesUtils.drawYAxisTicks(q, x, H, s.config.yaxis[r].axisTicks, r, _, b), b
        }
      }, {
        key: "drawYaxisInversed",
        value: function (r) {
          var n = this.w,
            s = new W(this.ctx),
            c = s.group({
              class: "apexcharts-xaxis apexcharts-yaxis-inversed"
            }),
            u = s.group({
              class: "apexcharts-xaxis-texts-g",
              transform: "translate(".concat(n.globals.translateXAxisX, ", ").concat(n.globals.translateXAxisY, ")")
            });
          c.add(u);
          var d = n.globals.yAxisScale[r].result.length - 1,
            f = n.globals.gridWidth / d + .1,
            g = f + n.config.xaxis.labels.offsetX,
            b = n.globals.xLabelFormatter,
            y = n.globals.yAxisScale[r].result.slice(),
            x = n.globals.timescaleLabels;
          x.length > 0 && (this.xaxisLabels = x.slice(), d = (y = x.slice()).length), y = this.axesUtils.checkForReversedLabels(r, y);
          var _ = x.length;
          if (n.config.xaxis.labels.show)
            for (var T = _ ? 0 : d; _ ? T < _ : T >= 0; _ ? T++ : T--) {
              var P = y[T];
              P = b(P, T, n);
              var O = n.globals.gridWidth + n.globals.padHorizontal - (g - f + n.config.xaxis.labels.offsetX);
              if (x.length) {
                var $ = this.axesUtils.getLabel(y, x, O, T, this.drawnLabels, this.xaxisFontSize);
                O = $.x, P = $.text, this.drawnLabels.push($.text), T === 0 && n.globals.skipFirstTimelinelabel && (P = ""), T === y.length - 1 && n.globals.skipLastTimelinelabel && (P = "")
              }
              var G = s.drawText({
                x: O,
                y: this.xAxisoffX + n.config.xaxis.labels.offsetY + 30 - (n.config.xaxis.position === "top" ? n.globals.xAxisHeight + n.config.xaxis.axisTicks.height - 2 : 0),
                text: P,
                textAnchor: "middle",
                foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[r] : this.xaxisForeColors,
                fontSize: this.xaxisFontSize,
                fontFamily: this.xaxisFontFamily,
                fontWeight: n.config.xaxis.labels.style.fontWeight,
                isPlainText: !1,
                cssClass: "apexcharts-xaxis-label " + n.config.xaxis.labels.style.cssClass
              });
              u.add(G), G.tspan(P);
              var Q = document.createElementNS(n.globals.SVGNS, "title");
              Q.textContent = P, G.node.appendChild(Q), g += f
            }
          return this.inversedYAxisTitleText(c), this.inversedYAxisBorder(c), c
        }
      }, {
        key: "inversedYAxisBorder",
        value: function (r) {
          var n = this.w,
            s = new W(this.ctx),
            c = n.config.xaxis.axisBorder;
          if (c.show) {
            var u = 0;
            n.config.chart.type === "bar" && n.globals.isXNumeric && (u -= 15);
            var d = s.drawLine(n.globals.padHorizontal + u + c.offsetX, this.xAxisoffX, n.globals.gridWidth, this.xAxisoffX, c.color, 0, c.height);
            this.elgrid && this.elgrid.elGridBorders && n.config.grid.show ? this.elgrid.elGridBorders.add(d) : r.add(d)
          }
        }
      }, {
        key: "inversedYAxisTitleText",
        value: function (r) {
          var n = this.w,
            s = new W(this.ctx);
          if (n.config.xaxis.title.text !== void 0) {
            var c = s.group({
                class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
              }),
              u = s.drawText({
                x: n.globals.gridWidth / 2 + n.config.xaxis.title.offsetX,
                y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(n.config.xaxis.title.style.fontSize) + n.config.xaxis.title.offsetY + 20,
                text: n.config.xaxis.title.text,
                textAnchor: "middle",
                fontSize: n.config.xaxis.title.style.fontSize,
                fontFamily: n.config.xaxis.title.style.fontFamily,
                fontWeight: n.config.xaxis.title.style.fontWeight,
                foreColor: n.config.xaxis.title.style.color,
                cssClass: "apexcharts-xaxis-title-text " + n.config.xaxis.title.style.cssClass
              });
            c.add(u), r.add(c)
          }
        }
      }, {
        key: "yAxisTitleRotate",
        value: function (r, n) {
          var s = this.w,
            c = new W(this.ctx),
            u = {
              width: 0,
              height: 0
            },
            d = {
              width: 0,
              height: 0
            },
            f = s.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(r, "'] .apexcharts-yaxis-texts-g"));
          f !== null && (u = f.getBoundingClientRect());
          var g = s.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(r, "'] .apexcharts-yaxis-title text"));
          if (g !== null && (d = g.getBoundingClientRect()), g !== null) {
            var b = this.xPaddingForYAxisTitle(r, u, d, n);
            g.setAttribute("x", b.xPos - (n ? 10 : 0))
          }
          if (g !== null) {
            var y = c.rotateAroundCenter(g);
            g.setAttribute("transform", "rotate(".concat(n ? -1 * s.config.yaxis[r].title.rotate : s.config.yaxis[r].title.rotate, " ").concat(y.x, " ").concat(y.y, ")"))
          }
        }
      }, {
        key: "xPaddingForYAxisTitle",
        value: function (r, n, s, c) {
          var u = this.w,
            d = 0,
            f = 0,
            g = 10;
          return u.config.yaxis[r].title.text === void 0 || r < 0 ? {
            xPos: f,
            padd: 0
          } : (c ? (f = n.width + u.config.yaxis[r].title.offsetX + s.width / 2 + g / 2, (d += 1) === 0 && (f -= g / 2)) : (f = -1 * n.width + u.config.yaxis[r].title.offsetX + g / 2 + s.width / 2, u.globals.isBarHorizontal && (g = 25, f = -1 * n.width - u.config.yaxis[r].title.offsetX - g)), {
            xPos: f,
            padd: g
          })
        }
      }, {
        key: "setYAxisXPosition",
        value: function (r, n) {
          var s = this.w,
            c = 0,
            u = 0,
            d = 18,
            f = 1;
          s.config.yaxis.length > 1 && (this.multipleYs = !0), s.config.yaxis.map(function (g, b) {
            var y = s.globals.ignoreYAxisIndexes.indexOf(b) > -1 || !g.show || g.floating || r[b].width === 0,
              x = r[b].width + n[b].width;
            g.opposite ? s.globals.isBarHorizontal ? (u = s.globals.gridWidth + s.globals.translateX - 1, s.globals.translateYAxisX[b] = u - g.labels.offsetX) : (u = s.globals.gridWidth + s.globals.translateX + f, y || (f = f + x + 20), s.globals.translateYAxisX[b] = u - g.labels.offsetX + 20) : (c = s.globals.translateX - d, y || (d = d + x + 20), s.globals.translateYAxisX[b] = c + g.labels.offsetX)
          })
        }
      }, {
        key: "setYAxisTextAlignments",
        value: function () {
          var r = this.w,
            n = r.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
          (n = I.listToArray(n)).forEach(function (s, c) {
            var u = r.config.yaxis[c];
            if (u && !u.floating && u.labels.align !== void 0) {
              var d = r.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(c, "'] .apexcharts-yaxis-texts-g")),
                f = r.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(c, "'] .apexcharts-yaxis-label"));
              f = I.listToArray(f);
              var g = d.getBoundingClientRect();
              u.labels.align === "left" ? (f.forEach(function (b, y) {
                b.setAttribute("text-anchor", "start")
              }), u.opposite || d.setAttribute("transform", "translate(-".concat(g.width, ", 0)"))) : u.labels.align === "center" ? (f.forEach(function (b, y) {
                b.setAttribute("text-anchor", "middle")
              }), d.setAttribute("transform", "translate(".concat(g.width / 2 * (u.opposite ? 1 : -1), ", 0)"))) : u.labels.align === "right" && (f.forEach(function (b, y) {
                b.setAttribute("text-anchor", "end")
              }), u.opposite && d.setAttribute("transform", "translate(".concat(g.width, ", 0)")))
            }
          })
        }
      }]), Y
    }(),
    oe = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.documentEvent = I.bind(this.documentEvent, this)
      }
      return p(Y, [{
        key: "addEventListener",
        value: function (r, n) {
          var s = this.w;
          s.globals.events.hasOwnProperty(r) ? s.globals.events[r].push(n) : s.globals.events[r] = [n]
        }
      }, {
        key: "removeEventListener",
        value: function (r, n) {
          var s = this.w;
          if (s.globals.events.hasOwnProperty(r)) {
            var c = s.globals.events[r].indexOf(n);
            c !== -1 && s.globals.events[r].splice(c, 1)
          }
        }
      }, {
        key: "fireEvent",
        value: function (r, n) {
          var s = this.w;
          if (s.globals.events.hasOwnProperty(r)) {
            n && n.length || (n = []);
            for (var c = s.globals.events[r], u = c.length, d = 0; d < u; d++) c[d].apply(null, n)
          }
        }
      }, {
        key: "setupEventHandlers",
        value: function () {
          var r = this,
            n = this.w,
            s = this.ctx,
            c = n.globals.dom.baseEl.querySelector(n.globals.chartClass);
          this.ctx.eventList.forEach(function (u) {
            c.addEventListener(u, function (d) {
              var f = Object.assign({}, n, {
                seriesIndex: n.globals.capturedSeriesIndex,
                dataPointIndex: n.globals.capturedDataPointIndex
              });
              d.type === "mousemove" || d.type === "touchmove" ? typeof n.config.chart.events.mouseMove == "function" && n.config.chart.events.mouseMove(d, s, f) : d.type === "mouseleave" || d.type === "touchleave" ? typeof n.config.chart.events.mouseLeave == "function" && n.config.chart.events.mouseLeave(d, s, f) : (d.type === "mouseup" && d.which === 1 || d.type === "touchend") && (typeof n.config.chart.events.click == "function" && n.config.chart.events.click(d, s, f), s.ctx.events.fireEvent("click", [d, s, f]))
            }, {
              capture: !1,
              passive: !0
            })
          }), this.ctx.eventList.forEach(function (u) {
            n.globals.dom.baseEl.addEventListener(u, r.documentEvent, {
              passive: !0
            })
          }), this.ctx.core.setupBrushHandler()
        }
      }, {
        key: "documentEvent",
        value: function (r) {
          var n = this.w,
            s = r.target.className;
          if (r.type === "click") {
            var c = n.globals.dom.baseEl.querySelector(".apexcharts-menu");
            c && c.classList.contains("apexcharts-menu-open") && s !== "apexcharts-menu-icon" && c.classList.remove("apexcharts-menu-open")
          }
          n.globals.clientX = r.type === "touchmove" ? r.touches[0].clientX : r.clientX, n.globals.clientY = r.type === "touchmove" ? r.touches[0].clientY : r.clientY
        }
      }]), Y
    }(),
    de = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "setCurrentLocaleValues",
        value: function (r) {
          var n = this.w.config.chart.locales;
          window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (n = this.w.config.chart.locales.concat(window.Apex.chart.locales));
          var s = n.filter(function (u) {
            return u.name === r
          })[0];
          if (!s) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
          var c = I.extend(fe, s);
          this.w.globals.locale = c.options
        }
      }]), Y
    }(),
    Ie = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "drawAxis",
        value: function (r, n) {
          var s, c, u = this,
            d = this.w.globals,
            f = this.w.config,
            g = new nt(this.ctx, n),
            b = new j(this.ctx, n);
          d.axisCharts && r !== "radar" && (d.isBarHorizontal ? (c = b.drawYaxisInversed(0), s = g.drawXaxisInversed(0), d.dom.elGraphical.add(s), d.dom.elGraphical.add(c)) : (s = g.drawXaxis(), d.dom.elGraphical.add(s), f.yaxis.map(function (y, x) {
            if (d.ignoreYAxisIndexes.indexOf(x) === -1 && (c = b.drawYaxis(x), d.dom.Paper.add(c), u.w.config.grid.position === "back")) {
              var _ = d.dom.Paper.children()[1];
              _.remove(), d.dom.Paper.add(_)
            }
          })))
        }
      }]), Y
    }(),
    ue = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "drawXCrosshairs",
        value: function () {
          var r = this.w,
            n = new W(this.ctx),
            s = new U(this.ctx),
            c = r.config.xaxis.crosshairs.fill.gradient,
            u = r.config.xaxis.crosshairs.dropShadow,
            d = r.config.xaxis.crosshairs.fill.type,
            f = c.colorFrom,
            g = c.colorTo,
            b = c.opacityFrom,
            y = c.opacityTo,
            x = c.stops,
            _ = u.enabled,
            T = u.left,
            P = u.top,
            O = u.blur,
            $ = u.color,
            G = u.opacity,
            Q = r.config.xaxis.crosshairs.fill.color;
          if (r.config.xaxis.crosshairs.show) {
            d === "gradient" && (Q = n.drawGradient("vertical", f, g, b, y, null, x, null));
            var v = n.drawRect();
            r.config.xaxis.crosshairs.width === 1 && (v = n.drawLine());
            var C = r.globals.gridHeight;
            (!I.isNumber(C) || C < 0) && (C = 0);
            var L = r.config.xaxis.crosshairs.width;
            (!I.isNumber(L) || L < 0) && (L = 0), v.attr({
              class: "apexcharts-xcrosshairs",
              x: 0,
              y: 0,
              y2: C,
              width: L,
              height: C,
              fill: Q,
              filter: "none",
              "fill-opacity": r.config.xaxis.crosshairs.opacity,
              stroke: r.config.xaxis.crosshairs.stroke.color,
              "stroke-width": r.config.xaxis.crosshairs.stroke.width,
              "stroke-dasharray": r.config.xaxis.crosshairs.stroke.dashArray
            }), _ && (v = s.dropShadow(v, {
              left: T,
              top: P,
              blur: O,
              color: $,
              opacity: G
            })), r.globals.dom.elGraphical.add(v)
          }
        }
      }, {
        key: "drawYCrosshairs",
        value: function () {
          var r = this.w,
            n = new W(this.ctx),
            s = r.config.yaxis[0].crosshairs,
            c = r.globals.barPadForNumericAxis;
          if (r.config.yaxis[0].crosshairs.show) {
            var u = n.drawLine(-c, 0, r.globals.gridWidth + c, 0, s.stroke.color, s.stroke.dashArray, s.stroke.width);
            u.attr({
              class: "apexcharts-ycrosshairs"
            }), r.globals.dom.elGraphical.add(u)
          }
          var d = n.drawLine(-c, 0, r.globals.gridWidth + c, 0, s.stroke.color, 0, 0);
          d.attr({
            class: "apexcharts-ycrosshairs-hidden"
          }), r.globals.dom.elGraphical.add(d)
        }
      }]), Y
    }(),
    Le = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "checkResponsiveConfig",
        value: function (r) {
          var n = this,
            s = this.w,
            c = s.config;
          if (c.responsive.length !== 0) {
            var u = c.responsive.slice();
            u.sort(function (b, y) {
              return b.breakpoint > y.breakpoint ? 1 : y.breakpoint > b.breakpoint ? -1 : 0
            }).reverse();
            var d = new De({}),
              f = function () {
                var b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
                  y = u[0].breakpoint,
                  x = window.innerWidth > 0 ? window.innerWidth : screen.width;
                if (x > y) {
                  var _ = X.extendArrayProps(d, s.globals.initialConfig, s);
                  b = I.extend(_, b), b = I.extend(s.config, b), n.overrideResponsiveOptions(b)
                } else
                  for (var T = 0; T < u.length; T++) x < u[T].breakpoint && (b = X.extendArrayProps(d, u[T].options, s), b = I.extend(s.config, b), n.overrideResponsiveOptions(b))
              };
            if (r) {
              var g = X.extendArrayProps(d, r, s);
              g = I.extend(s.config, g), f(g = I.extend(g, r))
            } else f({})
          }
        }
      }, {
        key: "overrideResponsiveOptions",
        value: function (r) {
          var n = new De(r).init({
            responsiveOverride: !0
          });
          this.w.config = n
        }
      }]), Y
    }(),
    K = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.colors = [], this.w = r.w;
        var n = this.w;
        this.isColorFn = !1, this.isHeatmapDistributed = n.config.chart.type === "treemap" && n.config.plotOptions.treemap.distributed || n.config.chart.type === "heatmap" && n.config.plotOptions.heatmap.distributed, this.isBarDistributed = n.config.plotOptions.bar.distributed && (n.config.chart.type === "bar" || n.config.chart.type === "rangeBar")
      }
      return p(Y, [{
        key: "init",
        value: function () {
          this.setDefaultColors()
        }
      }, {
        key: "setDefaultColors",
        value: function () {
          var r, n = this,
            s = this.w,
            c = new I;
          if (s.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(s.config.theme.mode)), s.config.colors === void 0 || ((r = s.config.colors) === null || r === void 0 ? void 0 : r.length) === 0 ? s.globals.colors = this.predefined() : (s.globals.colors = s.config.colors, Array.isArray(s.config.colors) && s.config.colors.length > 0 && typeof s.config.colors[0] == "function" && (s.globals.colors = s.config.series.map(function (P, O) {
              var $ = s.config.colors[O];
              return $ || ($ = s.config.colors[0]), typeof $ == "function" ? (n.isColorFn = !0, $({
                value: s.globals.axisCharts ? s.globals.series[O][0] ? s.globals.series[O][0] : 0 : s.globals.series[O],
                seriesIndex: O,
                dataPointIndex: O,
                w: s
              })) : $
            }))), s.globals.seriesColors.map(function (P, O) {
              P && (s.globals.colors[O] = P)
            }), s.config.theme.monochrome.enabled) {
            var u = [],
              d = s.globals.series.length;
            (this.isBarDistributed || this.isHeatmapDistributed) && (d = s.globals.series[0].length * s.globals.series.length);
            for (var f = s.config.theme.monochrome.color, g = 1 / (d / s.config.theme.monochrome.shadeIntensity), b = s.config.theme.monochrome.shadeTo, y = 0, x = 0; x < d; x++) {
              var _ = void 0;
              b === "dark" ? (_ = c.shadeColor(-1 * y, f), y += g) : (_ = c.shadeColor(y, f), y += g), u.push(_)
            }
            s.globals.colors = u.slice()
          }
          var T = s.globals.colors.slice();
          this.pushExtraColors(s.globals.colors), ["fill", "stroke"].forEach(function (P) {
            s.config[P].colors === void 0 ? s.globals[P].colors = n.isColorFn ? s.config.colors : T : s.globals[P].colors = s.config[P].colors.slice(), n.pushExtraColors(s.globals[P].colors)
          }), s.config.dataLabels.style.colors === void 0 ? s.globals.dataLabels.style.colors = T : s.globals.dataLabels.style.colors = s.config.dataLabels.style.colors.slice(), this.pushExtraColors(s.globals.dataLabels.style.colors, 50), s.config.plotOptions.radar.polygons.fill.colors === void 0 ? s.globals.radarPolygons.fill.colors = [s.config.theme.mode === "dark" ? "#424242" : "none"] : s.globals.radarPolygons.fill.colors = s.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(s.globals.radarPolygons.fill.colors, 20), s.config.markers.colors === void 0 ? s.globals.markers.colors = T : s.globals.markers.colors = s.config.markers.colors.slice(), this.pushExtraColors(s.globals.markers.colors)
        }
      }, {
        key: "pushExtraColors",
        value: function (r, n) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
            c = this.w,
            u = n || c.globals.series.length;
          if (s === null && (s = this.isBarDistributed || this.isHeatmapDistributed || c.config.chart.type === "heatmap" && c.config.plotOptions.heatmap.colorScale.inverse), s && c.globals.series.length && (u = c.globals.series[c.globals.maxValsInArrayIndex].length * c.globals.series.length), r.length < u)
            for (var d = u - r.length, f = 0; f < d; f++) r.push(r[f])
        }
      }, {
        key: "updateThemeOptions",
        value: function (r) {
          r.chart = r.chart || {}, r.tooltip = r.tooltip || {};
          var n = r.theme.mode || "light",
            s = r.theme.palette ? r.theme.palette : n === "dark" ? "palette4" : "palette1",
            c = r.chart.foreColor ? r.chart.foreColor : n === "dark" ? "#f6f7f8" : "#373d3f";
          return r.tooltip.theme = n, r.chart.foreColor = c, r.theme.palette = s, r
        }
      }, {
        key: "predefined",
        value: function () {
          switch (this.w.config.theme.palette) {
            case "palette1":
            default:
              this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
              break;
            case "palette2":
              this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
              break;
            case "palette3":
              this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
              break;
            case "palette4":
              this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
              break;
            case "palette5":
              this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
              break;
            case "palette6":
              this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
              break;
            case "palette7":
              this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
              break;
            case "palette8":
              this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
              break;
            case "palette9":
              this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
              break;
            case "palette10":
              this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"]
          }
          return this.colors
        }
      }]), Y
    }(),
    ae = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "draw",
        value: function () {
          this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle")
        }
      }, {
        key: "drawTitleSubtitle",
        value: function (r) {
          var n = this.w,
            s = r === "title" ? n.config.title : n.config.subtitle,
            c = n.globals.svgWidth / 2,
            u = s.offsetY,
            d = "middle";
          if (s.align === "left" ? (c = 10, d = "start") : s.align === "right" && (c = n.globals.svgWidth - 10, d = "end"), c += s.offsetX, u = u + parseInt(s.style.fontSize, 10) + s.margin / 2, s.text !== void 0) {
            var f = new W(this.ctx).drawText({
              x: c,
              y: u,
              text: s.text,
              textAnchor: d,
              fontSize: s.style.fontSize,
              fontFamily: s.style.fontFamily,
              fontWeight: s.style.fontWeight,
              foreColor: s.style.color,
              opacity: 1
            });
            f.node.setAttribute("class", "apexcharts-".concat(r, "-text")), n.globals.dom.Paper.add(f)
          }
        }
      }]), Y
    }(),
    xe = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.dCtx = r
      }
      return p(Y, [{
        key: "getTitleSubtitleCoords",
        value: function (r) {
          var n = this.w,
            s = 0,
            c = 0,
            u = r === "title" ? n.config.title.floating : n.config.subtitle.floating,
            d = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(r, "-text"));
          if (d !== null && !u) {
            var f = d.getBoundingClientRect();
            s = f.width, c = n.globals.axisCharts ? f.height + 5 : f.height
          }
          return {
            width: s,
            height: c
          }
        }
      }, {
        key: "getLegendsRect",
        value: function () {
          var r = this.w,
            n = r.globals.dom.elLegendWrap;
          r.config.legend.height || r.config.legend.position !== "top" && r.config.legend.position !== "bottom" || (n.style.maxHeight = r.globals.svgHeight / 2 + "px");
          var s = Object.assign({}, I.getBoundingClientRect(n));
          return n !== null && !r.config.legend.floating && r.config.legend.show ? this.dCtx.lgRect = {
            x: s.x,
            y: s.y,
            height: s.height,
            width: s.height === 0 ? 0 : s.width
          } : this.dCtx.lgRect = {
            x: 0,
            y: 0,
            height: 0,
            width: 0
          }, r.config.legend.position !== "left" && r.config.legend.position !== "right" || 1.5 * this.dCtx.lgRect.width > r.globals.svgWidth && (this.dCtx.lgRect.width = r.globals.svgWidth / 1.5), this.dCtx.lgRect
        }
      }, {
        key: "getLargestStringFromMultiArr",
        value: function (r, n) {
          var s = r;
          if (this.w.globals.isMultiLineX) {
            var c = n.map(function (d, f) {
                return Array.isArray(d) ? d.length : 1
              }),
              u = Math.max.apply(Math, D(c));
            s = n[c.indexOf(u)]
          }
          return s
        }
      }]), Y
    }(),
    Ce = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.dCtx = r
      }
      return p(Y, [{
        key: "getxAxisLabelsCoords",
        value: function () {
          var r, n = this.w,
            s = n.globals.labels.slice();
          if (n.config.xaxis.convertedCatToNumeric && s.length === 0 && (s = n.globals.categoryLabels), n.globals.timescaleLabels.length > 0) {
            var c = this.getxAxisTimeScaleLabelsCoords();
            r = {
              width: c.width,
              height: c.height
            }, n.globals.rotateXLabels = !1
          } else {
            this.dCtx.lgWidthForSideLegends = n.config.legend.position !== "left" && n.config.legend.position !== "right" || n.config.legend.floating ? 0 : this.dCtx.lgRect.width;
            var u = n.globals.xLabelFormatter,
              d = I.getLargestStringFromArr(s),
              f = this.dCtx.dimHelpers.getLargestStringFromMultiArr(d, s);
            n.globals.isBarHorizontal && (f = d = n.globals.yAxisScale[0].result.reduce(function (P, O) {
              return P.length > O.length ? P : O
            }, 0));
            var g = new ve(this.dCtx.ctx),
              b = d;
            d = g.xLabelFormat(u, d, b, {
              i: void 0,
              dateFormatter: new ye(this.dCtx.ctx).formatDate,
              w: n
            }), f = g.xLabelFormat(u, f, b, {
              i: void 0,
              dateFormatter: new ye(this.dCtx.ctx).formatDate,
              w: n
            }), (n.config.xaxis.convertedCatToNumeric && d === void 0 || String(d).trim() === "") && (f = d = "1");
            var y = new W(this.dCtx.ctx),
              x = y.getTextRects(d, n.config.xaxis.labels.style.fontSize),
              _ = x;
            if (d !== f && (_ = y.getTextRects(f, n.config.xaxis.labels.style.fontSize)), (r = {
                width: x.width >= _.width ? x.width : _.width,
                height: x.height >= _.height ? x.height : _.height
              }).width * s.length > n.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && n.config.xaxis.labels.rotate !== 0 || n.config.xaxis.labels.rotateAlways) {
              if (!n.globals.isBarHorizontal) {
                n.globals.rotateXLabels = !0;
                var T = function (P) {
                  return y.getTextRects(P, n.config.xaxis.labels.style.fontSize, n.config.xaxis.labels.style.fontFamily, "rotate(".concat(n.config.xaxis.labels.rotate, " 0 0)"), !1)
                };
                x = T(d), d !== f && (_ = T(f)), r.height = (x.height > _.height ? x.height : _.height) / 1.5, r.width = x.width > _.width ? x.width : _.width
              }
            } else n.globals.rotateXLabels = !1
          }
          return n.config.xaxis.labels.show || (r = {
            width: 0,
            height: 0
          }), {
            width: r.width,
            height: r.height
          }
        }
      }, {
        key: "getxAxisGroupLabelsCoords",
        value: function () {
          var r, n = this.w;
          if (!n.globals.hasXaxisGroups) return {
            width: 0,
            height: 0
          };
          var s, c = ((r = n.config.xaxis.group.style) === null || r === void 0 ? void 0 : r.fontSize) || n.config.xaxis.labels.style.fontSize,
            u = n.globals.groups.map(function (x) {
              return x.title
            }),
            d = I.getLargestStringFromArr(u),
            f = this.dCtx.dimHelpers.getLargestStringFromMultiArr(d, u),
            g = new W(this.dCtx.ctx),
            b = g.getTextRects(d, c),
            y = b;
          return d !== f && (y = g.getTextRects(f, c)), s = {
            width: b.width >= y.width ? b.width : y.width,
            height: b.height >= y.height ? b.height : y.height
          }, n.config.xaxis.labels.show || (s = {
            width: 0,
            height: 0
          }), {
            width: s.width,
            height: s.height
          }
        }
      }, {
        key: "getxAxisTitleCoords",
        value: function () {
          var r = this.w,
            n = 0,
            s = 0;
          if (r.config.xaxis.title.text !== void 0) {
            var c = new W(this.dCtx.ctx).getTextRects(r.config.xaxis.title.text, r.config.xaxis.title.style.fontSize);
            n = c.width, s = c.height
          }
          return {
            width: n,
            height: s
          }
        }
      }, {
        key: "getxAxisTimeScaleLabelsCoords",
        value: function () {
          var r, n = this.w;
          this.dCtx.timescaleLabels = n.globals.timescaleLabels.slice();
          var s = this.dCtx.timescaleLabels.map(function (u) {
              return u.value
            }),
            c = s.reduce(function (u, d) {
              return u === void 0 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : u.length > d.length ? u : d
            }, 0);
          return 1.05 * (r = new W(this.dCtx.ctx).getTextRects(c, n.config.xaxis.labels.style.fontSize)).width * s.length > n.globals.gridWidth && n.config.xaxis.labels.rotate !== 0 && (n.globals.overlappingXLabels = !0), r
        }
      }, {
        key: "additionalPaddingXLabels",
        value: function (r) {
          var n = this,
            s = this.w,
            c = s.globals,
            u = s.config,
            d = u.xaxis.type,
            f = r.width;
          c.skipLastTimelinelabel = !1, c.skipFirstTimelinelabel = !1;
          var g = s.config.yaxis[0].opposite && s.globals.isBarHorizontal,
            b = function (y, x) {
              u.yaxis.length > 1 && function (_) {
                return c.collapsedSeriesIndices.indexOf(_) !== -1
              }(x) || function (_) {
                if (n.dCtx.timescaleLabels && n.dCtx.timescaleLabels.length) {
                  var T = n.dCtx.timescaleLabels[0],
                    P = n.dCtx.timescaleLabels[n.dCtx.timescaleLabels.length - 1].position + f / 1.75 - n.dCtx.yAxisWidthRight,
                    O = T.position - f / 1.75 + n.dCtx.yAxisWidthLeft,
                    $ = s.config.legend.position === "right" && n.dCtx.lgRect.width > 0 ? n.dCtx.lgRect.width : 0;
                  P > c.svgWidth - c.translateX - $ && (c.skipLastTimelinelabel = !0), O < -(_.show && !_.floating || u.chart.type !== "bar" && u.chart.type !== "candlestick" && u.chart.type !== "rangeBar" && u.chart.type !== "boxPlot" ? 10 : f / 1.75) && (c.skipFirstTimelinelabel = !0)
                } else d === "datetime" ? n.dCtx.gridPad.right < f && !c.rotateXLabels && (c.skipLastTimelinelabel = !0) : d !== "datetime" && n.dCtx.gridPad.right < f / 2 - n.dCtx.yAxisWidthRight && !c.rotateXLabels && !s.config.xaxis.labels.trim && (s.config.xaxis.tickPlacement !== "between" || s.globals.isBarHorizontal) && (n.dCtx.xPadRight = f / 2 + 1)
              }(y)
            };
          u.yaxis.forEach(function (y, x) {
            g ? (n.dCtx.gridPad.left < f && (n.dCtx.xPadLeft = f / 2 + 1), n.dCtx.xPadRight = f / 2 + 1) : b(y, x)
          })
        }
      }]), Y
    }(),
    tt = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.dCtx = r
      }
      return p(Y, [{
        key: "getyAxisLabelsCoords",
        value: function () {
          var r = this,
            n = this.w,
            s = [],
            c = 10,
            u = new Re(this.dCtx.ctx);
          return n.config.yaxis.map(function (d, f) {
            var g = {
                seriesIndex: f,
                dataPointIndex: -1,
                w: n
              },
              b = n.globals.yAxisScale[f],
              y = 0;
            if (!u.isYAxisHidden(f) && d.labels.show && d.labels.minWidth !== void 0 && (y = d.labels.minWidth), !u.isYAxisHidden(f) && d.labels.show && b.result.length) {
              var x = n.globals.yLabelFormatters[f],
                _ = b.niceMin === Number.MIN_VALUE ? 0 : b.niceMin,
                T = b.result.reduce(function (C, L) {
                  var H, q;
                  return ((H = String(x(C, g))) === null || H === void 0 ? void 0 : H.length) > ((q = String(x(L, g))) === null || q === void 0 ? void 0 : q.length) ? C : L
                }, _),
                P = T = x(T, g);
              if (T !== void 0 && T.length !== 0 || (T = b.niceMax), n.globals.isBarHorizontal) {
                c = 0;
                var O = n.globals.labels.slice();
                T = I.getLargestStringFromArr(O), T = x(T, {
                  seriesIndex: f,
                  dataPointIndex: -1,
                  w: n
                }), P = r.dCtx.dimHelpers.getLargestStringFromMultiArr(T, O)
              }
              var $ = new W(r.dCtx.ctx),
                G = "rotate(".concat(d.labels.rotate, " 0 0)"),
                Q = $.getTextRects(T, d.labels.style.fontSize, d.labels.style.fontFamily, G, !1),
                v = Q;
              T !== P && (v = $.getTextRects(P, d.labels.style.fontSize, d.labels.style.fontFamily, G, !1)), s.push({
                width: (y > v.width || y > Q.width ? y : v.width > Q.width ? v.width : Q.width) + c,
                height: v.height > Q.height ? v.height : Q.height
              })
            } else s.push({
              width: 0,
              height: 0
            })
          }), s
        }
      }, {
        key: "getyAxisTitleCoords",
        value: function () {
          var r = this,
            n = this.w,
            s = [];
          return n.config.yaxis.map(function (c, u) {
            if (c.show && c.title.text !== void 0) {
              var d = new W(r.dCtx.ctx),
                f = "rotate(".concat(c.title.rotate, " 0 0)"),
                g = d.getTextRects(c.title.text, c.title.style.fontSize, c.title.style.fontFamily, f, !1);
              s.push({
                width: g.width,
                height: g.height
              })
            } else s.push({
              width: 0,
              height: 0
            })
          }), s
        }
      }, {
        key: "getTotalYAxisWidth",
        value: function () {
          var r = this.w,
            n = 0,
            s = 0,
            c = 0,
            u = r.globals.yAxisScale.length > 1 ? 10 : 0,
            d = new Re(this.dCtx.ctx),
            f = function (g, b) {
              var y = r.config.yaxis[b].floating,
                x = 0;
              g.width > 0 && !y ? (x = g.width + u, function (_) {
                return r.globals.ignoreYAxisIndexes.indexOf(_) > -1
              }(b) && (x = x - g.width - u)) : x = y || d.isYAxisHidden(b) ? 0 : 5, r.config.yaxis[b].opposite ? c += x : s += x, n += x
            };
          return r.globals.yLabelsCoords.map(function (g, b) {
            f(g, b)
          }), r.globals.yTitleCoords.map(function (g, b) {
            f(g, b)
          }), r.globals.isBarHorizontal && !r.config.yaxis[0].floating && (n = r.globals.yLabelsCoords[0].width + r.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = s, this.dCtx.yAxisWidthRight = c, n
        }
      }]), Y
    }(),
    qe = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.dCtx = r
      }
      return p(Y, [{
        key: "gridPadForColumnsInNumericAxis",
        value: function (r) {
          var n = this.w;
          if (n.globals.noData || n.globals.allSeriesCollapsed) return 0;
          var s = function (y) {
              return y === "bar" || y === "rangeBar" || y === "candlestick" || y === "boxPlot"
            },
            c = n.config.chart.type,
            u = 0,
            d = s(c) ? n.config.series.length : 1;
          if (n.globals.comboBarCount > 0 && (d = n.globals.comboBarCount), n.globals.collapsedSeries.forEach(function (y) {
              s(y.type) && (d -= 1)
            }), n.config.chart.stacked && (d = 1), (s(c) || n.globals.comboBarCount > 0) && n.globals.isXNumeric && !n.globals.isBarHorizontal && d > 0) {
            var f, g, b = Math.abs(n.globals.initialMaxX - n.globals.initialMinX);
            b <= 3 && (b = n.globals.dataPoints), f = b / r, n.globals.minXDiff && n.globals.minXDiff / f > 0 && (g = n.globals.minXDiff / f), g > r / 2 && (g /= 2), (u = g / d * parseInt(n.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (u = 1), u = u / (d > 1 ? 1 : 1.5) + 5, n.globals.barPadForNumericAxis = u
          }
          return u
        }
      }, {
        key: "gridPadFortitleSubtitle",
        value: function () {
          var r = this,
            n = this.w,
            s = n.globals,
            c = this.dCtx.isSparkline || !n.globals.axisCharts ? 0 : 10;
          ["title", "subtitle"].forEach(function (f) {
            n.config[f].text !== void 0 ? c += n.config[f].margin : c += r.dCtx.isSparkline || !n.globals.axisCharts ? 0 : 5
          }), !n.config.legend.show || n.config.legend.position !== "bottom" || n.config.legend.floating || n.globals.axisCharts || (c += 10);
          var u = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),
            d = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
          s.gridHeight = s.gridHeight - u.height - d.height - c, s.translateY = s.translateY + u.height + d.height + c
        }
      }, {
        key: "setGridXPosForDualYAxis",
        value: function (r, n) {
          var s = this.w,
            c = new Re(this.dCtx.ctx);
          s.config.yaxis.map(function (u, d) {
            s.globals.ignoreYAxisIndexes.indexOf(d) !== -1 || u.floating || c.isYAxisHidden(d) || (u.opposite && (s.globals.translateX = s.globals.translateX - (n[d].width + r[d].width) - parseInt(s.config.yaxis[d].labels.style.fontSize, 10) / 1.2 - 12), s.globals.translateX < 2 && (s.globals.translateX = 2))
          })
        }
      }]), Y
    }(),
    Te = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new xe(this), this.dimYAxis = new tt(this), this.dimXAxis = new Ce(this), this.dimGrid = new qe(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0
      }
      return p(Y, [{
        key: "plotCoords",
        value: function () {
          var r = this,
            n = this.w,
            s = n.globals;
          this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && ((n.config.markers.discrete.length > 0 || n.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function (u) {
            var d = M(u, 2),
              f = d[0],
              g = d[1];
            r.gridPad[f] = Math.max(g, r.w.globals.markers.largestSize / 1.5)
          }), this.gridPad.top = Math.max(n.config.stroke.width / 2, this.gridPad.top), this.gridPad.bottom = Math.max(n.config.stroke.width / 2, this.gridPad.bottom)), s.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), s.gridHeight = s.gridHeight - this.gridPad.top - this.gridPad.bottom, s.gridWidth = s.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
          var c = this.dimGrid.gridPadForColumnsInNumericAxis(s.gridWidth);
          s.gridWidth = s.gridWidth - 2 * c, s.translateX = s.translateX + this.gridPad.left + this.xPadLeft + (c > 0 ? c + 4 : 0), s.translateY = s.translateY + this.gridPad.top
        }
      }, {
        key: "setDimensionsForAxisCharts",
        value: function () {
          var r = this,
            n = this.w,
            s = n.globals,
            c = this.dimYAxis.getyAxisLabelsCoords(),
            u = this.dimYAxis.getyAxisTitleCoords();
          n.globals.yLabelsCoords = [], n.globals.yTitleCoords = [], n.config.yaxis.map(function (T, P) {
            n.globals.yLabelsCoords.push({
              width: c[P].width,
              index: P
            }), n.globals.yTitleCoords.push({
              width: u[P].width,
              index: P
            })
          }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
          var d = this.dimXAxis.getxAxisLabelsCoords(),
            f = this.dimXAxis.getxAxisGroupLabelsCoords(),
            g = this.dimXAxis.getxAxisTitleCoords();
          this.conditionalChecksForAxisCoords(d, g, f), s.translateXAxisY = n.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, s.translateXAxisX = n.globals.rotateXLabels && n.globals.isXNumeric && n.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, n.globals.isBarHorizontal && (s.rotateXLabels = !1, s.translateXAxisY = parseInt(n.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), s.translateXAxisY = s.translateXAxisY + n.config.xaxis.labels.offsetY, s.translateXAxisX = s.translateXAxisX + n.config.xaxis.labels.offsetX;
          var b = this.yAxisWidth,
            y = this.xAxisHeight;
          s.xAxisLabelsHeight = this.xAxisHeight - g.height, s.xAxisGroupLabelsHeight = s.xAxisLabelsHeight - d.height, s.xAxisLabelsWidth = this.xAxisWidth, s.xAxisHeight = this.xAxisHeight;
          var x = 10;
          (n.config.chart.type === "radar" || this.isSparkline) && (b = 0, y = s.goldenPadding), this.isSparkline && (this.lgRect = {
            height: 0,
            width: 0
          }), (this.isSparkline || n.config.chart.type === "treemap") && (b = 0, y = 0, x = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(d);
          var _ = function () {
            s.translateX = b, s.gridHeight = s.svgHeight - r.lgRect.height - y - (r.isSparkline || n.config.chart.type === "treemap" ? 0 : n.globals.rotateXLabels ? 10 : 15), s.gridWidth = s.svgWidth - b
          };
          switch (n.config.xaxis.position === "top" && (x = s.xAxisHeight - n.config.xaxis.axisTicks.height - 5), n.config.legend.position) {
            case "bottom":
              s.translateY = x, _();
              break;
            case "top":
              s.translateY = this.lgRect.height + x, _();
              break;
            case "left":
              s.translateY = x, s.translateX = this.lgRect.width + b, s.gridHeight = s.svgHeight - y - 12, s.gridWidth = s.svgWidth - this.lgRect.width - b;
              break;
            case "right":
              s.translateY = x, s.translateX = b, s.gridHeight = s.svgHeight - y - 12, s.gridWidth = s.svgWidth - this.lgRect.width - b - 5;
              break;
            default:
              throw new Error("Legend position not supported")
          }
          this.dimGrid.setGridXPosForDualYAxis(u, c), new j(this.ctx).setYAxisXPosition(c, u)
        }
      }, {
        key: "setDimensionsForNonAxisCharts",
        value: function () {
          var r = this.w,
            n = r.globals,
            s = r.config,
            c = 0;
          r.config.legend.show && !r.config.legend.floating && (c = 20);
          var u = s.chart.type === "pie" || s.chart.type === "polarArea" || s.chart.type === "donut" ? "pie" : "radialBar",
            d = s.plotOptions[u].offsetY,
            f = s.plotOptions[u].offsetX;
          if (!s.legend.show || s.legend.floating) return n.gridHeight = n.svgHeight - s.grid.padding.left + s.grid.padding.right, n.gridWidth = n.gridHeight, n.translateY = d, void(n.translateX = f + (n.svgWidth - n.gridWidth) / 2);
          switch (s.legend.position) {
            case "bottom":
              n.gridHeight = n.svgHeight - this.lgRect.height - n.goldenPadding, n.gridWidth = n.svgWidth, n.translateY = d - 10, n.translateX = f + (n.svgWidth - n.gridWidth) / 2;
              break;
            case "top":
              n.gridHeight = n.svgHeight - this.lgRect.height - n.goldenPadding, n.gridWidth = n.svgWidth, n.translateY = this.lgRect.height + d + 10, n.translateX = f + (n.svgWidth - n.gridWidth) / 2;
              break;
            case "left":
              n.gridWidth = n.svgWidth - this.lgRect.width - c, n.gridHeight = s.chart.height !== "auto" ? n.svgHeight : n.gridWidth, n.translateY = d, n.translateX = f + this.lgRect.width + c;
              break;
            case "right":
              n.gridWidth = n.svgWidth - this.lgRect.width - c - 5, n.gridHeight = s.chart.height !== "auto" ? n.svgHeight : n.gridWidth, n.translateY = d, n.translateX = f + 10;
              break;
            default:
              throw new Error("Legend position not supported")
          }
        }
      }, {
        key: "conditionalChecksForAxisCoords",
        value: function (r, n, s) {
          var c = this.w,
            u = c.globals.hasXaxisGroups ? 2 : 1,
            d = s.height + r.height + n.height,
            f = c.globals.isMultiLineX ? 1.2 : c.globals.LINE_HEIGHT_RATIO,
            g = c.globals.rotateXLabels ? 22 : 10,
            b = c.globals.rotateXLabels && c.config.legend.position === "bottom" ? 10 : 0;
          this.xAxisHeight = d * f + u * g + b, this.xAxisWidth = r.width, this.xAxisHeight - n.height > c.config.xaxis.labels.maxHeight && (this.xAxisHeight = c.config.xaxis.labels.maxHeight), c.config.xaxis.labels.minHeight && this.xAxisHeight < c.config.xaxis.labels.minHeight && (this.xAxisHeight = c.config.xaxis.labels.minHeight), c.config.xaxis.floating && (this.xAxisHeight = 0);
          var y = 0,
            x = 0;
          c.config.yaxis.forEach(function (_) {
            y += _.labels.minWidth, x += _.labels.maxWidth
          }), this.yAxisWidth < y && (this.yAxisWidth = y), this.yAxisWidth > x && (this.yAxisWidth = x)
        }
      }]), Y
    }(),
    $e = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.lgCtx = r
      }
      return p(Y, [{
        key: "getLegendStyles",
        value: function () {
          var r, n, s, c = document.createElement("style");
          c.setAttribute("type", "text/css");
          var u = ((r = this.lgCtx.ctx) === null || r === void 0 || (n = r.opts) === null || n === void 0 || (s = n.chart) === null || s === void 0 ? void 0 : s.nonce) || this.w.config.chart.nonce;
          u && c.setAttribute("nonce", u);
          var d = document.createTextNode(`
      .apexcharts-legend {
        display: flex;
        overflow: auto;
        padding: 0 10px;
      }
      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {
        flex-wrap: wrap
      }
      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        flex-direction: column;
        bottom: 0;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {
        justify-content: flex-start;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {
        justify-content: center;
      }
      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {
        justify-content: flex-end;
      }
      .apexcharts-legend-series {
        cursor: pointer;
        line-height: normal;
      }
      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{
        display: flex;
        align-items: center;
      }
      .apexcharts-legend-text {
        position: relative;
        font-size: 14px;
      }
      .apexcharts-legend-text *, .apexcharts-legend-marker * {
        pointer-events: none;
      }
      .apexcharts-legend-marker {
        position: relative;
        display: inline-block;
        cursor: pointer;
        margin-right: 3px;
        border-style: solid;
      }

      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{
        display: inline-block;
      }
      .apexcharts-legend-series.apexcharts-no-click {
        cursor: auto;
      }
      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {
        display: none !important;
      }
      .apexcharts-inactive-legend {
        opacity: 0.45;
      }`);
          return c.appendChild(d), c
        }
      }, {
        key: "getLegendBBox",
        value: function () {
          var r = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),
            n = r.width;
          return {
            clwh: r.height,
            clww: n
          }
        }
      }, {
        key: "appendToForeignObject",
        value: function () {
          this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles())
        }
      }, {
        key: "toggleDataSeries",
        value: function (r, n) {
          var s = this,
            c = this.w;
          if (c.globals.axisCharts || c.config.chart.type === "radialBar") {
            c.globals.resized = !0;
            var u = null,
              d = null;
            c.globals.risingSeries = [], c.globals.axisCharts ? (u = c.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(r, "']")), d = parseInt(u.getAttribute("data:realIndex"), 10)) : (u = c.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(r + 1, "']")), d = parseInt(u.getAttribute("rel"), 10) - 1), n ? [{
              cs: c.globals.collapsedSeries,
              csi: c.globals.collapsedSeriesIndices
            }, {
              cs: c.globals.ancillaryCollapsedSeries,
              csi: c.globals.ancillaryCollapsedSeriesIndices
            }].forEach(function (y) {
              s.riseCollapsedSeries(y.cs, y.csi, d)
            }) : this.hideSeries({
              seriesEl: u,
              realIndex: d
            })
          } else {
            var f = c.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(r + 1, "'] path")),
              g = c.config.chart.type;
            if (g === "pie" || g === "polarArea" || g === "donut") {
              var b = c.config.plotOptions.pie.donut.labels;
              new W(this.lgCtx.ctx).pathMouseDown(f.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(f.members[0].node, b)
            }
            f.fire("click")
          }
        }
      }, {
        key: "hideSeries",
        value: function (r) {
          var n = r.seriesEl,
            s = r.realIndex,
            c = this.w,
            u = I.clone(c.config.series);
          if (c.globals.axisCharts) {
            var d = !1;
            if (c.config.yaxis[s] && c.config.yaxis[s].show && c.config.yaxis[s].showAlways && (d = !0, c.globals.ancillaryCollapsedSeriesIndices.indexOf(s) < 0 && (c.globals.ancillaryCollapsedSeries.push({
                index: s,
                data: u[s].data.slice(),
                type: n.parentNode.className.baseVal.split("-")[1]
              }), c.globals.ancillaryCollapsedSeriesIndices.push(s))), !d) {
              c.globals.collapsedSeries.push({
                index: s,
                data: u[s].data.slice(),
                type: n.parentNode.className.baseVal.split("-")[1]
              }), c.globals.collapsedSeriesIndices.push(s);
              var f = c.globals.risingSeries.indexOf(s);
              c.globals.risingSeries.splice(f, 1)
            }
          } else c.globals.collapsedSeries.push({
            index: s,
            data: u[s]
          }), c.globals.collapsedSeriesIndices.push(s);
          for (var g = n.childNodes, b = 0; b < g.length; b++) g[b].classList.contains("apexcharts-series-markers-wrap") && (g[b].classList.contains("apexcharts-hide") ? g[b].classList.remove("apexcharts-hide") : g[b].classList.add("apexcharts-hide"));
          c.globals.allSeriesCollapsed = c.globals.collapsedSeries.length === c.config.series.length, u = this._getSeriesBasedOnCollapsedState(u), this.lgCtx.ctx.updateHelpers._updateSeries(u, c.config.chart.animations.dynamicAnimation.enabled)
        }
      }, {
        key: "riseCollapsedSeries",
        value: function (r, n, s) {
          var c = this.w,
            u = I.clone(c.config.series);
          if (r.length > 0) {
            for (var d = 0; d < r.length; d++) r[d].index === s && (c.globals.axisCharts ? (u[s].data = r[d].data.slice(), r.splice(d, 1), n.splice(d, 1), c.globals.risingSeries.push(s)) : (u[s] = r[d].data, r.splice(d, 1), n.splice(d, 1), c.globals.risingSeries.push(s)));
            u = this._getSeriesBasedOnCollapsedState(u), this.lgCtx.ctx.updateHelpers._updateSeries(u, c.config.chart.animations.dynamicAnimation.enabled)
          }
        }
      }, {
        key: "_getSeriesBasedOnCollapsedState",
        value: function (r) {
          var n = this.w;
          return n.globals.axisCharts ? r.forEach(function (s, c) {
            n.globals.collapsedSeriesIndices.indexOf(c) > -1 && (r[c].data = [])
          }) : r.forEach(function (s, c) {
            n.globals.collapsedSeriesIndices.indexOf(c) > -1 && (r[c] = 0)
          }), r
        }
      }]), Y
    }(),
    ft = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = this.w.config.chart.type === "bar" && this.w.config.plotOptions.bar.distributed && this.w.config.series.length === 1, this.legendHelpers = new $e(this)
      }
      return p(Y, [{
        key: "init",
        value: function () {
          var r = this.w,
            n = r.globals,
            s = r.config;
          if ((s.legend.showForSingleSeries && n.series.length === 1 || this.isBarsDistributed || n.series.length > 1 || !n.axisCharts) && s.legend.show) {
            for (; n.dom.elLegendWrap.firstChild;) n.dom.elLegendWrap.removeChild(n.dom.elLegendWrap.firstChild);
            this.drawLegends(), I.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), s.legend.position === "bottom" || s.legend.position === "top" ? this.legendAlignHorizontal() : s.legend.position !== "right" && s.legend.position !== "left" || this.legendAlignVertical()
          }
        }
      }, {
        key: "drawLegends",
        value: function () {
          var r = this,
            n = this.w,
            s = n.config.legend.fontFamily,
            c = n.globals.seriesNames,
            u = n.globals.colors.slice();
          if (n.config.chart.type === "heatmap") {
            var d = n.config.plotOptions.heatmap.colorScale.ranges;
            c = d.map(function (Ve) {
              return Ve.name ? Ve.name : Ve.from + " - " + Ve.to
            }), u = d.map(function (Ve) {
              return Ve.color
            })
          } else this.isBarsDistributed && (c = n.globals.labels.slice());
          n.config.legend.customLegendItems.length && (c = n.config.legend.customLegendItems);
          for (var f = n.globals.legendFormatter, g = n.config.legend.inverseOrder, b = g ? c.length - 1 : 0; g ? b >= 0 : b <= c.length - 1; g ? b-- : b++) {
            var y, x = f(c[b], {
                seriesIndex: b,
                w: n
              }),
              _ = !1,
              T = !1;
            if (n.globals.collapsedSeries.length > 0)
              for (var P = 0; P < n.globals.collapsedSeries.length; P++) n.globals.collapsedSeries[P].index === b && (_ = !0);
            if (n.globals.ancillaryCollapsedSeriesIndices.length > 0)
              for (var O = 0; O < n.globals.ancillaryCollapsedSeriesIndices.length; O++) n.globals.ancillaryCollapsedSeriesIndices[O] === b && (T = !0);
            var $ = document.createElement("span");
            $.classList.add("apexcharts-legend-marker");
            var G = n.config.legend.markers.offsetX,
              Q = n.config.legend.markers.offsetY,
              v = n.config.legend.markers.height,
              C = n.config.legend.markers.width,
              L = n.config.legend.markers.strokeWidth,
              H = n.config.legend.markers.strokeColor,
              q = n.config.legend.markers.radius,
              ee = $.style;
            ee.background = u[b], ee.color = u[b], ee.setProperty("background", u[b], "important"), n.config.legend.markers.fillColors && n.config.legend.markers.fillColors[b] && (ee.background = n.config.legend.markers.fillColors[b]), n.globals.seriesColors[b] !== void 0 && (ee.background = n.globals.seriesColors[b], ee.color = n.globals.seriesColors[b]), ee.height = Array.isArray(v) ? parseFloat(v[b]) + "px" : parseFloat(v) + "px", ee.width = Array.isArray(C) ? parseFloat(C[b]) + "px" : parseFloat(C) + "px", ee.left = (Array.isArray(G) ? parseFloat(G[b]) : parseFloat(G)) + "px", ee.top = (Array.isArray(Q) ? parseFloat(Q[b]) : parseFloat(Q)) + "px", ee.borderWidth = Array.isArray(L) ? L[b] : L, ee.borderColor = Array.isArray(H) ? H[b] : H, ee.borderRadius = Array.isArray(q) ? parseFloat(q[b]) + "px" : parseFloat(q) + "px", n.config.legend.markers.customHTML && (Array.isArray(n.config.legend.markers.customHTML) ? n.config.legend.markers.customHTML[b] && ($.innerHTML = n.config.legend.markers.customHTML[b]()) : $.innerHTML = n.config.legend.markers.customHTML()), W.setAttrs($, {
              rel: b + 1,
              "data:collapsed": _ || T
            }), (_ || T) && $.classList.add("apexcharts-inactive-legend");
            var ge = document.createElement("div"),
              pe = document.createElement("span");
            pe.classList.add("apexcharts-legend-text"), pe.innerHTML = Array.isArray(x) ? x.join(" ") : x;
            var Fe = n.config.legend.labels.useSeriesColors ? n.globals.colors[b] : Array.isArray(n.config.legend.labels.colors) ? (y = n.config.legend.labels.colors) === null || y === void 0 ? void 0 : y[b] : n.config.legend.labels.colors;
            Fe || (Fe = n.config.chart.foreColor), pe.style.color = Fe, pe.style.fontSize = parseFloat(n.config.legend.fontSize) + "px", pe.style.fontWeight = n.config.legend.fontWeight, pe.style.fontFamily = s || n.config.chart.fontFamily, W.setAttrs(pe, {
              rel: b + 1,
              i: b,
              "data:default-text": encodeURIComponent(x),
              "data:collapsed": _ || T
            }), ge.appendChild($), ge.appendChild(pe);
            var Ue = new X(this.ctx);
            n.config.legend.showForZeroSeries || Ue.getSeriesTotalByIndex(b) === 0 && Ue.seriesHaveSameValues(b) && !Ue.isSeriesNull(b) && n.globals.collapsedSeriesIndices.indexOf(b) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(b) === -1 && ge.classList.add("apexcharts-hidden-zero-series"), n.config.legend.showForNullSeries || Ue.isSeriesNull(b) && n.globals.collapsedSeriesIndices.indexOf(b) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(b) === -1 && ge.classList.add("apexcharts-hidden-null-series"), n.globals.dom.elLegendWrap.appendChild(ge), n.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(n.config.legend.horizontalAlign)), n.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + n.config.legend.position), ge.classList.add("apexcharts-legend-series"), ge.style.margin = "".concat(n.config.legend.itemMargin.vertical, "px ").concat(n.config.legend.itemMargin.horizontal, "px"), n.globals.dom.elLegendWrap.style.width = n.config.legend.width ? n.config.legend.width + "px" : "", n.globals.dom.elLegendWrap.style.height = n.config.legend.height ? n.config.legend.height + "px" : "", W.setAttrs(ge, {
              rel: b + 1,
              seriesName: I.escapeString(c[b]),
              "data:collapsed": _ || T
            }), (_ || T) && ge.classList.add("apexcharts-inactive-legend"), n.config.legend.onItemClick.toggleDataSeries || ge.classList.add("apexcharts-no-click")
          }
          n.globals.dom.elWrap.addEventListener("click", r.onLegendClick, !0), n.config.legend.onItemHover.highlightDataSeries && n.config.legend.customLegendItems.length === 0 && (n.globals.dom.elWrap.addEventListener("mousemove", r.onLegendHovered, !0), n.globals.dom.elWrap.addEventListener("mouseout", r.onLegendHovered, !0))
        }
      }, {
        key: "setLegendWrapXY",
        value: function (r, n) {
          var s = this.w,
            c = s.globals.dom.elLegendWrap,
            u = c.getBoundingClientRect(),
            d = 0,
            f = 0;
          if (s.config.legend.position === "bottom") f += s.globals.svgHeight - u.height / 2;
          else if (s.config.legend.position === "top") {
            var g = new Te(this.ctx),
              b = g.dimHelpers.getTitleSubtitleCoords("title").height,
              y = g.dimHelpers.getTitleSubtitleCoords("subtitle").height;
            f = f + (b > 0 ? b - 10 : 0) + (y > 0 ? y - 10 : 0)
          }
          c.style.position = "absolute", d = d + r + s.config.legend.offsetX, f = f + n + s.config.legend.offsetY, c.style.left = d + "px", c.style.top = f + "px", s.config.legend.position === "bottom" ? (c.style.top = "auto", c.style.bottom = 5 - s.config.legend.offsetY + "px") : s.config.legend.position === "right" && (c.style.left = "auto", c.style.right = 25 + s.config.legend.offsetX + "px"), ["width", "height"].forEach(function (x) {
            c.style[x] && (c.style[x] = parseInt(s.config.legend[x], 10) + "px")
          })
        }
      }, {
        key: "legendAlignHorizontal",
        value: function () {
          var r = this.w;
          r.globals.dom.elLegendWrap.style.right = 0;
          var n = this.legendHelpers.getLegendBBox(),
            s = new Te(this.ctx),
            c = s.dimHelpers.getTitleSubtitleCoords("title"),
            u = s.dimHelpers.getTitleSubtitleCoords("subtitle"),
            d = 0;
          r.config.legend.position === "bottom" ? d = -n.clwh / 1.8 : r.config.legend.position === "top" && (d = c.height + u.height + r.config.title.margin + r.config.subtitle.margin - 10), this.setLegendWrapXY(20, d)
        }
      }, {
        key: "legendAlignVertical",
        value: function () {
          var r = this.w,
            n = this.legendHelpers.getLegendBBox(),
            s = 0;
          r.config.legend.position === "left" && (s = 20), r.config.legend.position === "right" && (s = r.globals.svgWidth - n.clww - 10), this.setLegendWrapXY(s, 20)
        }
      }, {
        key: "onLegendHovered",
        value: function (r) {
          var n = this.w,
            s = r.target.classList.contains("apexcharts-legend-series") || r.target.classList.contains("apexcharts-legend-text") || r.target.classList.contains("apexcharts-legend-marker");
          if (n.config.chart.type === "heatmap" || this.isBarsDistributed) {
            if (s) {
              var c = parseInt(r.target.getAttribute("rel"), 10) - 1;
              this.ctx.events.fireEvent("legendHover", [this.ctx, c, this.w]), new Be(this.ctx).highlightRangeInSeries(r, r.target)
            }
          } else !r.target.classList.contains("apexcharts-inactive-legend") && s && new Be(this.ctx).toggleSeriesOnHover(r, r.target)
        }
      }, {
        key: "onLegendClick",
        value: function (r) {
          var n = this.w;
          if (!n.config.legend.customLegendItems.length && (r.target.classList.contains("apexcharts-legend-series") || r.target.classList.contains("apexcharts-legend-text") || r.target.classList.contains("apexcharts-legend-marker"))) {
            var s = parseInt(r.target.getAttribute("rel"), 10) - 1,
              c = r.target.getAttribute("data:collapsed") === "true",
              u = this.w.config.chart.events.legendClick;
            typeof u == "function" && u(this.ctx, s, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, s, this.w]);
            var d = this.w.config.legend.markers.onClick;
            typeof d == "function" && r.target.classList.contains("apexcharts-legend-marker") && (d(this.ctx, s, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, s, this.w])), n.config.chart.type !== "treemap" && n.config.chart.type !== "heatmap" && !this.isBarsDistributed && n.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(s, c)
          }
        }
      }]), Y
    }(),
    gt = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w;
        var n = this.w;
        this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = n.globals.minX, this.maxX = n.globals.maxX
      }
      return p(Y, [{
        key: "createToolbar",
        value: function () {
          var r = this,
            n = this.w,
            s = function () {
              return document.createElement("div")
            },
            c = s();
          if (c.setAttribute("class", "apexcharts-toolbar"), c.style.top = n.config.chart.toolbar.offsetY + "px", c.style.right = 3 - n.config.chart.toolbar.offsetX + "px", n.globals.dom.elWrap.appendChild(c), this.elZoom = s(), this.elZoomIn = s(), this.elZoomOut = s(), this.elPan = s(), this.elSelection = s(), this.elZoomReset = s(), this.elMenuIcon = s(), this.elMenu = s(), this.elCustomIcons = [], this.t = n.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
            for (var u = 0; u < this.t.customIcons.length; u++) this.elCustomIcons.push(s());
          var d = [],
            f = function (x, _, T) {
              var P = x.toLowerCase();
              r.t[P] && n.config.chart.zoom.enabled && d.push({
                el: _,
                icon: typeof r.t[P] == "string" ? r.t[P] : T,
                title: r.localeValues[x],
                class: "apexcharts-".concat(P, "-icon")
              })
            };
          f("zoomIn", this.elZoomIn, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`), f("zoomOut", this.elZoomOut, `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>
</svg>
`);
          var g = function (x) {
            r.t[x] && n.config.chart[x].enabled && d.push({
              el: x === "zoom" ? r.elZoom : r.elSelection,
              icon: typeof r.t[x] == "string" ? r.t[x] : x === "zoom" ? `<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
    <path d="M0 0h24v24H0V0z" fill="none"/>
    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>
</svg>` : `<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M0 0h24v24H0z" fill="none"/>
    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>
</svg>`,
              title: r.localeValues[x === "zoom" ? "selectionZoom" : "selection"],
              class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(x, "-icon")
            })
          };
          g("zoom"), g("selection"), this.t.pan && n.config.chart.zoom.enabled && d.push({
            el: this.elPan,
            icon: typeof this.t.pan == "string" ? this.t.pan : `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">
    <defs>
        <path d="M0 0h24v24H0z" id="a"/>
    </defs>
    <clipPath id="b">
        <use overflow="visible" xlink:href="#a"/>
    </clipPath>
    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>
</svg>`,
            title: this.localeValues.pan,
            class: n.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
          }), f("reset", this.elZoomReset, `<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">
    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
    <path d="M0 0h24v24H0z" fill="none"/>
</svg>`), this.t.download && d.push({
            el: this.elMenuIcon,
            icon: typeof this.t.download == "string" ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
            title: this.localeValues.menu,
            class: "apexcharts-menu-icon"
          });
          for (var b = 0; b < this.elCustomIcons.length; b++) d.push({
            el: this.elCustomIcons[b],
            icon: this.t.customIcons[b].icon,
            title: this.t.customIcons[b].title,
            index: this.t.customIcons[b].index,
            class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[b].class
          });
          d.forEach(function (x, _) {
            x.index && I.moveIndexInArray(d, _, x.index)
          });
          for (var y = 0; y < d.length; y++) W.setAttrs(d[y].el, {
            class: d[y].class,
            title: d[y].title
          }), d[y].el.innerHTML = d[y].icon, c.appendChild(d[y].el);
          this._createHamburgerMenu(c), n.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : n.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : n.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners()
        }
      }, {
        key: "_createHamburgerMenu",
        value: function (r) {
          this.elMenuItems = [], r.appendChild(this.elMenu), W.setAttrs(this.elMenu, {
            class: "apexcharts-menu"
          });
          for (var n = [{
              name: "exportSVG",
              title: this.localeValues.exportToSVG
            }, {
              name: "exportPNG",
              title: this.localeValues.exportToPNG
            }, {
              name: "exportCSV",
              title: this.localeValues.exportToCSV
            }], s = 0; s < n.length; s++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[s].innerHTML = n[s].title, W.setAttrs(this.elMenuItems[s], {
            class: "apexcharts-menu-item ".concat(n[s].name),
            title: n[s].title
          }), this.elMenu.appendChild(this.elMenuItems[s])
        }
      }, {
        key: "addToolbarEventListeners",
        value: function () {
          var r = this;
          this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function (s) {
            s.classList.contains("exportSVG") ? s.addEventListener("click", r.handleDownload.bind(r, "svg")) : s.classList.contains("exportPNG") ? s.addEventListener("click", r.handleDownload.bind(r, "png")) : s.classList.contains("exportCSV") && s.addEventListener("click", r.handleDownload.bind(r, "csv"))
          });
          for (var n = 0; n < this.t.customIcons.length; n++) this.elCustomIcons[n].addEventListener("click", this.t.customIcons[n].click.bind(this, this.ctx, this.ctx.w))
        }
      }, {
        key: "toggleZoomSelection",
        value: function (r) {
          this.ctx.getSyncedCharts().forEach(function (n) {
            n.ctx.toolbar.toggleOtherControls();
            var s = r === "selection" ? n.ctx.toolbar.elSelection : n.ctx.toolbar.elZoom,
              c = r === "selection" ? "selectionEnabled" : "zoomEnabled";
            n.w.globals[c] = !n.w.globals[c], s.classList.contains(n.ctx.toolbar.selectedClass) ? s.classList.remove(n.ctx.toolbar.selectedClass) : s.classList.add(n.ctx.toolbar.selectedClass)
          })
        }
      }, {
        key: "getToolbarIconsReference",
        value: function () {
          var r = this.w;
          this.elZoom || (this.elZoom = r.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = r.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = r.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
        }
      }, {
        key: "enableZoomPanFromToolbar",
        value: function (r) {
          this.toggleOtherControls(), r === "pan" ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
          var n = r === "pan" ? this.elPan : this.elZoom,
            s = r === "pan" ? this.elZoom : this.elPan;
          n && n.classList.add(this.selectedClass), s && s.classList.remove(this.selectedClass)
        }
      }, {
        key: "togglePanning",
        value: function () {
          this.ctx.getSyncedCharts().forEach(function (r) {
            r.ctx.toolbar.toggleOtherControls(), r.w.globals.panEnabled = !r.w.globals.panEnabled, r.ctx.toolbar.elPan.classList.contains(r.ctx.toolbar.selectedClass) ? r.ctx.toolbar.elPan.classList.remove(r.ctx.toolbar.selectedClass) : r.ctx.toolbar.elPan.classList.add(r.ctx.toolbar.selectedClass)
          })
        }
      }, {
        key: "toggleOtherControls",
        value: function () {
          var r = this,
            n = this.w;
          n.globals.panEnabled = !1, n.globals.zoomEnabled = !1, n.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function (s) {
            s && s.classList.remove(r.selectedClass)
          })
        }
      }, {
        key: "handleZoomIn",
        value: function () {
          var r = this.w;
          r.globals.isRangeBar && (this.minX = r.globals.minY, this.maxX = r.globals.maxY);
          var n = (this.minX + this.maxX) / 2,
            s = (this.minX + n) / 2,
            c = (this.maxX + n) / 2,
            u = this._getNewMinXMaxX(s, c);
          r.globals.disableZoomIn || this.zoomUpdateOptions(u.minX, u.maxX)
        }
      }, {
        key: "handleZoomOut",
        value: function () {
          var r = this.w;
          if (r.globals.isRangeBar && (this.minX = r.globals.minY, this.maxX = r.globals.maxY), !(r.config.xaxis.type === "datetime" && new Date(this.minX).getUTCFullYear() < 1e3)) {
            var n = (this.minX + this.maxX) / 2,
              s = this.minX - (n - this.minX),
              c = this.maxX - (n - this.maxX),
              u = this._getNewMinXMaxX(s, c);
            r.globals.disableZoomOut || this.zoomUpdateOptions(u.minX, u.maxX)
          }
        }
      }, {
        key: "_getNewMinXMaxX",
        value: function (r, n) {
          var s = this.w.config.xaxis.convertedCatToNumeric;
          return {
            minX: s ? Math.floor(r) : r,
            maxX: s ? Math.floor(n) : n
          }
        }
      }, {
        key: "zoomUpdateOptions",
        value: function (r, n) {
          var s = this.w;
          if (r !== void 0 || n !== void 0) {
            if (!(s.config.xaxis.convertedCatToNumeric && (r < 1 && (r = 1, n = s.globals.dataPoints), n - r < 2))) {
              var c = {
                  min: r,
                  max: n
                },
                u = this.getBeforeZoomRange(c);
              u && (c = u.xaxis);
              var d = {
                  xaxis: c
                },
                f = I.clone(s.globals.initialConfig.yaxis);
              s.config.chart.zoom.autoScaleYaxis && (f = new We(this.ctx).autoScaleY(this.ctx, f, {
                xaxis: c
              })), s.config.chart.group || (d.yaxis = f), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(d, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(c, f)
            }
          } else this.handleZoomReset()
        }
      }, {
        key: "zoomCallback",
        value: function (r, n) {
          typeof this.ev.zoomed == "function" && this.ev.zoomed(this.ctx, {
            xaxis: r,
            yaxis: n
          })
        }
      }, {
        key: "getBeforeZoomRange",
        value: function (r, n) {
          var s = null;
          return typeof this.ev.beforeZoom == "function" && (s = this.ev.beforeZoom(this, {
            xaxis: r,
            yaxis: n
          })), s
        }
      }, {
        key: "toggleMenu",
        value: function () {
          var r = this;
          window.setTimeout(function () {
            r.elMenu.classList.contains("apexcharts-menu-open") ? r.elMenu.classList.remove("apexcharts-menu-open") : r.elMenu.classList.add("apexcharts-menu-open")
          }, 0)
        }
      }, {
        key: "handleDownload",
        value: function (r) {
          var n = this.w,
            s = new Xe(this.ctx);
          switch (r) {
            case "svg":
              s.exportToSVG(this.ctx);
              break;
            case "png":
              s.exportToPng(this.ctx);
              break;
            case "csv":
              s.exportToCSV({
                series: n.config.series,
                columnDelimiter: n.config.chart.toolbar.export.csv.columnDelimiter
              })
          }
        }
      }, {
        key: "handleZoomReset",
        value: function (r) {
          this.ctx.getSyncedCharts().forEach(function (n) {
            var s = n.w;
            if (s.globals.lastXAxis.min = s.globals.initialConfig.xaxis.min, s.globals.lastXAxis.max = s.globals.initialConfig.xaxis.max, n.updateHelpers.revertDefaultAxisMinMax(), typeof s.config.chart.events.beforeResetZoom == "function") {
              var c = s.config.chart.events.beforeResetZoom(n, s);
              c && n.updateHelpers.revertDefaultAxisMinMax(c)
            }
            typeof s.config.chart.events.zoomed == "function" && n.ctx.toolbar.zoomCallback({
              min: s.config.xaxis.min,
              max: s.config.xaxis.max
            }), s.globals.zoomed = !1;
            var u = n.ctx.series.emptyCollapsedSeries(I.clone(s.globals.initialSeries));
            n.updateHelpers._updateSeries(u, s.config.chart.animations.dynamicAnimation.enabled)
          })
        }
      }, {
        key: "destroy",
        value: function () {
          this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null
        }
      }]), Y
    }(),
    Ct = function (Y) {
      k(n, gt);
      var r = E(n);

      function n(s) {
        var c;
        return l(this, n), (c = r.call(this, s)).ctx = s, c.w = s.w, c.dragged = !1, c.graphics = new W(c.ctx), c.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], c.clientX = 0, c.clientY = 0, c.startX = 0, c.endX = 0, c.dragX = 0, c.startY = 0, c.endY = 0, c.dragY = 0, c.moveDirection = "none", c
      }
      return p(n, [{
        key: "init",
        value: function (s) {
          var c = this,
            u = s.xyRatios,
            d = this.w,
            f = this;
          this.xyRatios = u, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = d.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), d.globals.dom.elGraphical.add(this.zoomRect), d.globals.dom.elGraphical.add(this.selectionRect), d.config.chart.selection.type === "x" ? this.slDraggableRect = this.selectionRect.draggable({
            minX: 0,
            minY: 0,
            maxX: d.globals.gridWidth,
            maxY: d.globals.gridHeight
          }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : d.config.chart.selection.type === "y" ? this.slDraggableRect = this.selectionRect.draggable({
            minX: 0,
            maxX: d.globals.gridWidth
          }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = d.globals.dom.baseEl.querySelector("".concat(d.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function (g) {
            c.hoverArea.addEventListener(g, f.svgMouseEvents.bind(f, u), {
              capture: !1,
              passive: !0
            })
          })
        }
      }, {
        key: "destroy",
        value: function () {
          this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null
        }
      }, {
        key: "svgMouseEvents",
        value: function (s, c) {
          var u = this.w,
            d = this,
            f = this.ctx.toolbar,
            g = u.globals.zoomEnabled ? u.config.chart.zoom.type : u.config.chart.selection.type,
            b = u.config.chart.toolbar.autoSelected;
          if (c.shiftKey ? (this.shiftWasPressed = !0, f.enableZoomPanFromToolbar(b === "pan" ? "zoom" : "pan")) : this.shiftWasPressed && (f.enableZoomPanFromToolbar(b), this.shiftWasPressed = !1), c.target) {
            var y, x = c.target.classList;
            if (c.target.parentNode && c.target.parentNode !== null && (y = c.target.parentNode.classList), !(x.contains("apexcharts-selection-rect") || x.contains("apexcharts-legend-marker") || x.contains("apexcharts-legend-text") || y && y.contains("apexcharts-toolbar"))) {
              if (d.clientX = c.type === "touchmove" || c.type === "touchstart" ? c.touches[0].clientX : c.type === "touchend" ? c.changedTouches[0].clientX : c.clientX, d.clientY = c.type === "touchmove" || c.type === "touchstart" ? c.touches[0].clientY : c.type === "touchend" ? c.changedTouches[0].clientY : c.clientY, c.type === "mousedown" && c.which === 1) {
                var _ = d.gridRect.getBoundingClientRect();
                d.startX = d.clientX - _.left, d.startY = d.clientY - _.top, d.dragged = !1, d.w.globals.mousedown = !0
              }
              if ((c.type === "mousemove" && c.which === 1 || c.type === "touchmove") && (d.dragged = !0, u.globals.panEnabled ? (u.globals.selection = null, d.w.globals.mousedown && d.panDragging({
                  context: d,
                  zoomtype: g,
                  xyRatios: s
                })) : (d.w.globals.mousedown && u.globals.zoomEnabled || d.w.globals.mousedown && u.globals.selectionEnabled) && (d.selection = d.selectionDrawing({
                  context: d,
                  zoomtype: g
                }))), c.type === "mouseup" || c.type === "touchend" || c.type === "mouseleave") {
                var T = d.gridRect.getBoundingClientRect();
                d.w.globals.mousedown && (d.endX = d.clientX - T.left, d.endY = d.clientY - T.top, d.dragX = Math.abs(d.endX - d.startX), d.dragY = Math.abs(d.endY - d.startY), (u.globals.zoomEnabled || u.globals.selectionEnabled) && d.selectionDrawn({
                  context: d,
                  zoomtype: g
                }), u.globals.panEnabled && u.config.xaxis.convertedCatToNumeric && d.delayedPanScrolled()), u.globals.zoomEnabled && d.hideSelectionRect(this.selectionRect), d.dragged = !1, d.w.globals.mousedown = !1
              }
              this.makeSelectionRectDraggable()
            }
          }
        }
      }, {
        key: "makeSelectionRectDraggable",
        value: function () {
          var s = this.w;
          if (this.selectionRect) {
            var c = this.selectionRect.node.getBoundingClientRect();
            c.width > 0 && c.height > 0 && this.slDraggableRect.selectize({
              points: "l, r",
              pointSize: 8,
              pointType: "rect"
            }).resize({
              constraint: {
                minX: 0,
                minY: 0,
                maxX: s.globals.gridWidth,
                maxY: s.globals.gridHeight
              }
            }).on("resizing", this.selectionDragging.bind(this, "resizing"))
          }
        }
      }, {
        key: "preselectedSelection",
        value: function () {
          var s = this.w,
            c = this.xyRatios;
          if (!s.globals.zoomEnabled) {
            if (s.globals.selection !== void 0 && s.globals.selection !== null) this.drawSelectionRect(s.globals.selection);
            else if (s.config.chart.selection.xaxis.min !== void 0 && s.config.chart.selection.xaxis.max !== void 0) {
              var u = (s.config.chart.selection.xaxis.min - s.globals.minX) / c.xRatio,
                d = s.globals.gridWidth - (s.globals.maxX - s.config.chart.selection.xaxis.max) / c.xRatio - u;
              s.globals.isRangeBar && (u = (s.config.chart.selection.xaxis.min - s.globals.yAxisScale[0].niceMin) / c.invertedYRatio, d = (s.config.chart.selection.xaxis.max - s.config.chart.selection.xaxis.min) / c.invertedYRatio);
              var f = {
                x: u,
                y: 0,
                width: d,
                height: s.globals.gridHeight,
                translateX: 0,
                translateY: 0,
                selectionEnabled: !0
              };
              this.drawSelectionRect(f), this.makeSelectionRectDraggable(), typeof s.config.chart.events.selection == "function" && s.config.chart.events.selection(this.ctx, {
                xaxis: {
                  min: s.config.chart.selection.xaxis.min,
                  max: s.config.chart.selection.xaxis.max
                },
                yaxis: {}
              })
            }
          }
        }
      }, {
        key: "drawSelectionRect",
        value: function (s) {
          var c = s.x,
            u = s.y,
            d = s.width,
            f = s.height,
            g = s.translateX,
            b = g === void 0 ? 0 : g,
            y = s.translateY,
            x = y === void 0 ? 0 : y,
            _ = this.w,
            T = this.zoomRect,
            P = this.selectionRect;
          if (this.dragged || _.globals.selection !== null) {
            var O = {
              transform: "translate(" + b + ", " + x + ")"
            };
            _.globals.zoomEnabled && this.dragged && (d < 0 && (d = 1), T.attr({
              x: c,
              y: u,
              width: d,
              height: f,
              fill: _.config.chart.zoom.zoomedArea.fill.color,
              "fill-opacity": _.config.chart.zoom.zoomedArea.fill.opacity,
              stroke: _.config.chart.zoom.zoomedArea.stroke.color,
              "stroke-width": _.config.chart.zoom.zoomedArea.stroke.width,
              "stroke-opacity": _.config.chart.zoom.zoomedArea.stroke.opacity
            }), W.setAttrs(T.node, O)), _.globals.selectionEnabled && (P.attr({
              x: c,
              y: u,
              width: d > 0 ? d : 0,
              height: f > 0 ? f : 0,
              fill: _.config.chart.selection.fill.color,
              "fill-opacity": _.config.chart.selection.fill.opacity,
              stroke: _.config.chart.selection.stroke.color,
              "stroke-width": _.config.chart.selection.stroke.width,
              "stroke-dasharray": _.config.chart.selection.stroke.dashArray,
              "stroke-opacity": _.config.chart.selection.stroke.opacity
            }), W.setAttrs(P.node, O))
          }
        }
      }, {
        key: "hideSelectionRect",
        value: function (s) {
          s && s.attr({
            x: 0,
            y: 0,
            width: 0,
            height: 0
          })
        }
      }, {
        key: "selectionDrawing",
        value: function (s) {
          var c = s.context,
            u = s.zoomtype,
            d = this.w,
            f = c,
            g = this.gridRect.getBoundingClientRect(),
            b = f.startX - 1,
            y = f.startY,
            x = !1,
            _ = !1,
            T = f.clientX - g.left - b,
            P = f.clientY - g.top - y,
            O = {};
          return Math.abs(T + b) > d.globals.gridWidth ? T = d.globals.gridWidth - b : f.clientX - g.left < 0 && (T = b), b > f.clientX - g.left && (x = !0, T = Math.abs(T)), y > f.clientY - g.top && (_ = !0, P = Math.abs(P)), O = u === "x" ? {
            x: x ? b - T : b,
            y: 0,
            width: T,
            height: d.globals.gridHeight
          } : u === "y" ? {
            x: 0,
            y: _ ? y - P : y,
            width: d.globals.gridWidth,
            height: P
          } : {
            x: x ? b - T : b,
            y: _ ? y - P : y,
            width: T,
            height: P
          }, f.drawSelectionRect(O), f.selectionDragging("resizing"), O
        }
      }, {
        key: "selectionDragging",
        value: function (s, c) {
          var u = this,
            d = this.w,
            f = this.xyRatios,
            g = this.selectionRect,
            b = 0;
          s === "resizing" && (b = 30);
          var y = function (_) {
              return parseFloat(g.node.getAttribute(_))
            },
            x = {
              x: y("x"),
              y: y("y"),
              width: y("width"),
              height: y("height")
            };
          d.globals.selection = x, typeof d.config.chart.events.selection == "function" && d.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function () {
            var _, T, P, O, $ = u.gridRect.getBoundingClientRect(),
              G = g.node.getBoundingClientRect();
            d.globals.isRangeBar ? (_ = d.globals.yAxisScale[0].niceMin + (G.left - $.left) * f.invertedYRatio, T = d.globals.yAxisScale[0].niceMin + (G.right - $.left) * f.invertedYRatio, P = 0, O = 1) : (_ = d.globals.xAxisScale.niceMin + (G.left - $.left) * f.xRatio, T = d.globals.xAxisScale.niceMin + (G.right - $.left) * f.xRatio, P = d.globals.yAxisScale[0].niceMin + ($.bottom - G.bottom) * f.yRatio[0], O = d.globals.yAxisScale[0].niceMax - (G.top - $.top) * f.yRatio[0]);
            var Q = {
              xaxis: {
                min: _,
                max: T
              },
              yaxis: {
                min: P,
                max: O
              }
            };
            d.config.chart.events.selection(u.ctx, Q), d.config.chart.brush.enabled && d.config.chart.events.brushScrolled !== void 0 && d.config.chart.events.brushScrolled(u.ctx, Q)
          }, b))
        }
      }, {
        key: "selectionDrawn",
        value: function (s) {
          var c = s.context,
            u = s.zoomtype,
            d = this.w,
            f = c,
            g = this.xyRatios,
            b = this.ctx.toolbar;
          if (f.startX > f.endX) {
            var y = f.startX;
            f.startX = f.endX, f.endX = y
          }
          if (f.startY > f.endY) {
            var x = f.startY;
            f.startY = f.endY, f.endY = x
          }
          var _ = void 0,
            T = void 0;
          d.globals.isRangeBar ? (_ = d.globals.yAxisScale[0].niceMin + f.startX * g.invertedYRatio, T = d.globals.yAxisScale[0].niceMin + f.endX * g.invertedYRatio) : (_ = d.globals.xAxisScale.niceMin + f.startX * g.xRatio, T = d.globals.xAxisScale.niceMin + f.endX * g.xRatio);
          var P = [],
            O = [];
          if (d.config.yaxis.forEach(function (q, ee) {
              P.push(d.globals.yAxisScale[ee].niceMax - g.yRatio[ee] * f.startY), O.push(d.globals.yAxisScale[ee].niceMax - g.yRatio[ee] * f.endY)
            }), f.dragged && (f.dragX > 10 || f.dragY > 10) && _ !== T) {
            if (d.globals.zoomEnabled) {
              var $ = I.clone(d.globals.initialConfig.yaxis),
                G = I.clone(d.globals.initialConfig.xaxis);
              if (d.globals.zoomed = !0, d.config.xaxis.convertedCatToNumeric && (_ = Math.floor(_), T = Math.floor(T), _ < 1 && (_ = 1, T = d.globals.dataPoints), T - _ < 2 && (T = _ + 1)), u !== "xy" && u !== "x" || (G = {
                  min: _,
                  max: T
                }), u !== "xy" && u !== "y" || $.forEach(function (q, ee) {
                  $[ee].min = O[ee], $[ee].max = P[ee]
                }), d.config.chart.zoom.autoScaleYaxis) {
                var Q = new We(f.ctx);
                $ = Q.autoScaleY(f.ctx, $, {
                  xaxis: G
                })
              }
              if (b) {
                var v = b.getBeforeZoomRange(G, $);
                v && (G = v.xaxis ? v.xaxis : G, $ = v.yaxis ? v.yaxis : $)
              }
              var C = {
                xaxis: G
              };
              d.config.chart.group || (C.yaxis = $), f.ctx.updateHelpers._updateOptions(C, !1, f.w.config.chart.animations.dynamicAnimation.enabled), typeof d.config.chart.events.zoomed == "function" && b.zoomCallback(G, $)
            } else if (d.globals.selectionEnabled) {
              var L, H = null;
              L = {
                min: _,
                max: T
              }, u !== "xy" && u !== "y" || (H = I.clone(d.config.yaxis)).forEach(function (q, ee) {
                H[ee].min = O[ee], H[ee].max = P[ee]
              }), d.globals.selection = f.selection, typeof d.config.chart.events.selection == "function" && d.config.chart.events.selection(f.ctx, {
                xaxis: L,
                yaxis: H
              })
            }
          }
        }
      }, {
        key: "panDragging",
        value: function (s) {
          var c = s.context,
            u = this.w,
            d = c;
          if (u.globals.lastClientPosition.x !== void 0) {
            var f = u.globals.lastClientPosition.x - d.clientX,
              g = u.globals.lastClientPosition.y - d.clientY;
            Math.abs(f) > Math.abs(g) && f > 0 ? this.moveDirection = "left" : Math.abs(f) > Math.abs(g) && f < 0 ? this.moveDirection = "right" : Math.abs(g) > Math.abs(f) && g > 0 ? this.moveDirection = "up" : Math.abs(g) > Math.abs(f) && g < 0 && (this.moveDirection = "down")
          }
          u.globals.lastClientPosition = {
            x: d.clientX,
            y: d.clientY
          };
          var b = u.globals.isRangeBar ? u.globals.minY : u.globals.minX,
            y = u.globals.isRangeBar ? u.globals.maxY : u.globals.maxX;
          u.config.xaxis.convertedCatToNumeric || d.panScrolled(b, y)
        }
      }, {
        key: "delayedPanScrolled",
        value: function () {
          var s = this.w,
            c = s.globals.minX,
            u = s.globals.maxX,
            d = (s.globals.maxX - s.globals.minX) / 2;
          this.moveDirection === "left" ? (c = s.globals.minX + d, u = s.globals.maxX + d) : this.moveDirection === "right" && (c = s.globals.minX - d, u = s.globals.maxX - d), c = Math.floor(c), u = Math.floor(u), this.updateScrolledChart({
            xaxis: {
              min: c,
              max: u
            }
          }, c, u)
        }
      }, {
        key: "panScrolled",
        value: function (s, c) {
          var u = this.w,
            d = this.xyRatios,
            f = I.clone(u.globals.initialConfig.yaxis),
            g = d.xRatio,
            b = u.globals.minX,
            y = u.globals.maxX;
          u.globals.isRangeBar && (g = d.invertedYRatio, b = u.globals.minY, y = u.globals.maxY), this.moveDirection === "left" ? (s = b + u.globals.gridWidth / 15 * g, c = y + u.globals.gridWidth / 15 * g) : this.moveDirection === "right" && (s = b - u.globals.gridWidth / 15 * g, c = y - u.globals.gridWidth / 15 * g), u.globals.isRangeBar || (s < u.globals.initialMinX || c > u.globals.initialMaxX) && (s = b, c = y);
          var x = {
            min: s,
            max: c
          };
          u.config.chart.zoom.autoScaleYaxis && (f = new We(this.ctx).autoScaleY(this.ctx, f, {
            xaxis: x
          }));
          var _ = {
            xaxis: {
              min: s,
              max: c
            }
          };
          u.config.chart.group || (_.yaxis = f), this.updateScrolledChart(_, s, c)
        }
      }, {
        key: "updateScrolledChart",
        value: function (s, c, u) {
          var d = this.w;
          this.ctx.updateHelpers._updateOptions(s, !1, !1), typeof d.config.chart.events.scrolled == "function" && d.config.chart.events.scrolled(this.ctx, {
            xaxis: {
              min: c,
              max: u
            }
          })
        }
      }]), n
    }(),
    ia = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.ttCtx = r, this.ctx = r.ctx
      }
      return p(Y, [{
        key: "getNearestValues",
        value: function (r) {
          var n = r.hoverArea,
            s = r.elGrid,
            c = r.clientX,
            u = r.clientY,
            d = this.w,
            f = s.getBoundingClientRect(),
            g = f.width,
            b = f.height,
            y = g / (d.globals.dataPoints - 1),
            x = b / d.globals.dataPoints,
            _ = this.hasBars();
          !d.globals.comboCharts && !_ || d.config.xaxis.convertedCatToNumeric || (y = g / d.globals.dataPoints);
          var T = c - f.left - d.globals.barPadForNumericAxis,
            P = u - f.top;
          T < 0 || P < 0 || T > g || P > b ? (n.classList.remove("hovering-zoom"), n.classList.remove("hovering-pan")) : d.globals.zoomEnabled ? (n.classList.remove("hovering-pan"), n.classList.add("hovering-zoom")) : d.globals.panEnabled && (n.classList.remove("hovering-zoom"), n.classList.add("hovering-pan"));
          var O = Math.round(T / y),
            $ = Math.floor(P / x);
          _ && !d.config.xaxis.convertedCatToNumeric && (O = Math.ceil(T / y), O -= 1);
          var G = null,
            Q = null,
            v = d.globals.seriesXvalues.map(function (ee) {
              return ee.filter(function (ge) {
                return I.isNumber(ge)
              })
            }),
            C = d.globals.seriesYvalues.map(function (ee) {
              return ee.filter(function (ge) {
                return I.isNumber(ge)
              })
            });
          if (d.globals.isXNumeric) {
            var L = this.ttCtx.getElGrid().getBoundingClientRect(),
              H = T * (L.width / g),
              q = P * (L.height / b);
            G = (Q = this.closestInMultiArray(H, q, v, C)).index, O = Q.j, G !== null && (v = d.globals.seriesXvalues[G], O = (Q = this.closestInArray(H, v)).index)
          }
          return d.globals.capturedSeriesIndex = G === null ? -1 : G, (!O || O < 1) && (O = 0), d.globals.isBarHorizontal ? d.globals.capturedDataPointIndex = $ : d.globals.capturedDataPointIndex = O, {
            capturedSeries: G,
            j: d.globals.isBarHorizontal ? $ : O,
            hoverX: T,
            hoverY: P
          }
        }
      }, {
        key: "closestInMultiArray",
        value: function (r, n, s, c) {
          var u = this.w,
            d = 0,
            f = null,
            g = -1;
          u.globals.series.length > 1 ? d = this.getFirstActiveXArray(s) : f = 0;
          var b = s[d][0],
            y = Math.abs(r - b);
          if (s.forEach(function (T) {
              T.forEach(function (P, O) {
                var $ = Math.abs(r - P);
                $ <= y && (y = $, g = O)
              })
            }), g !== -1) {
            var x = c[d][g],
              _ = Math.abs(n - x);
            f = d, c.forEach(function (T, P) {
              var O = Math.abs(n - T[g]);
              O <= _ && (_ = O, f = P)
            })
          }
          return {
            index: f,
            j: g
          }
        }
      }, {
        key: "getFirstActiveXArray",
        value: function (r) {
          for (var n = this.w, s = 0, c = r.map(function (d, f) {
              return d.length > 0 ? f : -1
            }), u = 0; u < c.length; u++)
            if (c[u] !== -1 && n.globals.collapsedSeriesIndices.indexOf(u) === -1 && n.globals.ancillaryCollapsedSeriesIndices.indexOf(u) === -1) {
              s = c[u];
              break
            } return s
        }
      }, {
        key: "closestInArray",
        value: function (r, n) {
          for (var s = n[0], c = null, u = Math.abs(r - s), d = 0; d < n.length; d++) {
            var f = Math.abs(r - n[d]);
            f < u && (u = f, c = d)
          }
          return {
            index: c
          }
        }
      }, {
        key: "isXoverlap",
        value: function (r) {
          var n = [],
            s = this.w.globals.seriesX.filter(function (u) {
              return u[0] !== void 0
            });
          if (s.length > 0)
            for (var c = 0; c < s.length - 1; c++) s[c][r] !== void 0 && s[c + 1][r] !== void 0 && s[c][r] !== s[c + 1][r] && n.push("unEqual");
          return n.length === 0
        }
      }, {
        key: "isInitialSeriesSameLen",
        value: function () {
          for (var r = !0, n = this.w.globals.initialSeries, s = 0; s < n.length - 1; s++)
            if (n[s].data.length !== n[s + 1].data.length) {
              r = !1;
              break
            } return r
        }
      }, {
        key: "getBarsHeight",
        value: function (r) {
          return D(r).reduce(function (n, s) {
            return n + s.getBBox().height
          }, 0)
        }
      }, {
        key: "getElMarkers",
        value: function (r) {
          return typeof r == "number" ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(r, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *")
        }
      }, {
        key: "getAllMarkers",
        value: function () {
          var r = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
          (r = D(r)).sort(function (s, c) {
            var u = Number(s.getAttribute("data:realIndex")),
              d = Number(c.getAttribute("data:realIndex"));
            return d < u ? 1 : d > u ? -1 : 0
          });
          var n = [];
          return r.forEach(function (s) {
            n.push(s.querySelector(".apexcharts-marker"))
          }), n
        }
      }, {
        key: "hasMarkers",
        value: function (r) {
          return this.getElMarkers(r).length > 0
        }
      }, {
        key: "getElBars",
        value: function () {
          return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")
        }
      }, {
        key: "hasBars",
        value: function () {
          return this.getElBars().length > 0
        }
      }, {
        key: "getHoverMarkerSize",
        value: function (r) {
          var n = this.w,
            s = n.config.markers.hover.size;
          return s === void 0 && (s = n.globals.markers.size[r] + n.config.markers.hover.sizeOffset), s
        }
      }, {
        key: "toggleAllTooltipSeriesGroups",
        value: function (r) {
          var n = this.w,
            s = this.ttCtx;
          s.allTooltipSeriesGroups.length === 0 && (s.allTooltipSeriesGroups = n.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
          for (var c = s.allTooltipSeriesGroups, u = 0; u < c.length; u++) r === "enable" ? (c[u].classList.add("apexcharts-active"), c[u].style.display = n.config.tooltip.items.display) : (c[u].classList.remove("apexcharts-active"), c[u].style.display = "none")
        }
      }]), Y
    }(),
    xa = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.ctx = r.ctx, this.ttCtx = r, this.tooltipUtil = new ia(r)
      }
      return p(Y, [{
        key: "drawSeriesTexts",
        value: function (r) {
          var n = r.shared,
            s = n === void 0 || n,
            c = r.ttItems,
            u = r.i,
            d = u === void 0 ? 0 : u,
            f = r.j,
            g = f === void 0 ? null : f,
            b = r.y1,
            y = r.y2,
            x = r.e,
            _ = this.w;
          _.config.tooltip.custom !== void 0 ? this.handleCustomTooltip({
            i: d,
            j: g,
            y1: b,
            y2: y,
            w: _
          }) : this.toggleActiveInactiveSeries(s);
          var T = this.getValuesToPrint({
            i: d,
            j: g
          });
          this.printLabels({
            i: d,
            j: g,
            values: T,
            ttItems: c,
            shared: s,
            e: x
          });
          var P = this.ttCtx.getElTooltip();
          this.ttCtx.tooltipRect.ttWidth = P.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = P.getBoundingClientRect().height
        }
      }, {
        key: "printLabels",
        value: function (r) {
          var n, s = this,
            c = r.i,
            u = r.j,
            d = r.values,
            f = r.ttItems,
            g = r.shared,
            b = r.e,
            y = this.w,
            x = [],
            _ = function (L) {
              return y.globals.seriesGoals[L] && y.globals.seriesGoals[L][u] && Array.isArray(y.globals.seriesGoals[L][u])
            },
            T = d.xVal,
            P = d.zVal,
            O = d.xAxisTTVal,
            $ = "",
            G = y.globals.colors[c];
          u !== null && y.config.plotOptions.bar.distributed && (G = y.globals.colors[u]);
          for (var Q = function (L, H) {
              var q = s.getFormatters(c);
              $ = s.getSeriesName({
                fn: q.yLbTitleFormatter,
                index: c,
                seriesIndex: c,
                j: u
              }), y.config.chart.type === "treemap" && ($ = q.yLbTitleFormatter(String(y.config.series[c].data[u].x), {
                series: y.globals.series,
                seriesIndex: c,
                dataPointIndex: u,
                w: y
              }));
              var ee = y.config.tooltip.inverseOrder ? H : L;
              if (y.globals.axisCharts) {
                var ge = function (Ue) {
                  var Ve, it, dt, mt;
                  return y.globals.isRangeData ? q.yLbFormatter((Ve = y.globals.seriesRangeStart) === null || Ve === void 0 || (it = Ve[Ue]) === null || it === void 0 ? void 0 : it[u], {
                    series: y.globals.seriesRangeStart,
                    seriesIndex: Ue,
                    dataPointIndex: u,
                    w: y
                  }) + " - " + q.yLbFormatter((dt = y.globals.seriesRangeEnd) === null || dt === void 0 || (mt = dt[Ue]) === null || mt === void 0 ? void 0 : mt[u], {
                    series: y.globals.seriesRangeEnd,
                    seriesIndex: Ue,
                    dataPointIndex: u,
                    w: y
                  }) : q.yLbFormatter(y.globals.series[Ue][u], {
                    series: y.globals.series,
                    seriesIndex: Ue,
                    dataPointIndex: u,
                    w: y
                  })
                };
                if (g) q = s.getFormatters(ee), $ = s.getSeriesName({
                  fn: q.yLbTitleFormatter,
                  index: ee,
                  seriesIndex: c,
                  j: u
                }), G = y.globals.colors[ee], n = ge(ee), _(ee) && (x = y.globals.seriesGoals[ee][u].map(function (Ue) {
                  return {
                    attrs: Ue,
                    val: q.yLbFormatter(Ue.value, {
                      seriesIndex: ee,
                      dataPointIndex: u,
                      w: y
                    })
                  }
                }));
                else {
                  var pe, Fe = b == null || (pe = b.target) === null || pe === void 0 ? void 0 : pe.getAttribute("fill");
                  Fe && (G = Fe.indexOf("url") !== -1 ? document.querySelector(Fe.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : Fe), n = ge(c), _(c) && Array.isArray(y.globals.seriesGoals[c][u]) && (x = y.globals.seriesGoals[c][u].map(function (Ue) {
                    return {
                      attrs: Ue,
                      val: q.yLbFormatter(Ue.value, {
                        seriesIndex: c,
                        dataPointIndex: u,
                        w: y
                      })
                    }
                  }))
                }
              }
              u === null && (n = q.yLbFormatter(y.globals.series[c], i(i({}, y), {}, {
                seriesIndex: c,
                dataPointIndex: c
              }))), s.DOMHandling({
                i: c,
                t: ee,
                j: u,
                ttItems: f,
                values: {
                  val: n,
                  goalVals: x,
                  xVal: T,
                  xAxisTTVal: O,
                  zVal: P
                },
                seriesName: $,
                shared: g,
                pColor: G
              })
            }, v = 0, C = y.globals.series.length - 1; v < y.globals.series.length; v++, C--) Q(v, C)
        }
      }, {
        key: "getFormatters",
        value: function (r) {
          var n, s = this.w,
            c = s.globals.yLabelFormatters[r];
          return s.globals.ttVal !== void 0 ? Array.isArray(s.globals.ttVal) ? (c = s.globals.ttVal[r] && s.globals.ttVal[r].formatter, n = s.globals.ttVal[r] && s.globals.ttVal[r].title && s.globals.ttVal[r].title.formatter) : (c = s.globals.ttVal.formatter, typeof s.globals.ttVal.title.formatter == "function" && (n = s.globals.ttVal.title.formatter)) : n = s.config.tooltip.y.title.formatter, typeof c != "function" && (c = s.globals.yLabelFormatters[0] ? s.globals.yLabelFormatters[0] : function (u) {
            return u
          }), typeof n != "function" && (n = function (u) {
            return u
          }), {
            yLbFormatter: c,
            yLbTitleFormatter: n
          }
        }
      }, {
        key: "getSeriesName",
        value: function (r) {
          var n = r.fn,
            s = r.index,
            c = r.seriesIndex,
            u = r.j,
            d = this.w;
          return n(String(d.globals.seriesNames[s]), {
            series: d.globals.series,
            seriesIndex: c,
            dataPointIndex: u,
            w: d
          })
        }
      }, {
        key: "DOMHandling",
        value: function (r) {
          r.i;
          var n = r.t,
            s = r.j,
            c = r.ttItems,
            u = r.values,
            d = r.seriesName,
            f = r.shared,
            g = r.pColor,
            b = this.w,
            y = this.ttCtx,
            x = u.val,
            _ = u.goalVals,
            T = u.xVal,
            P = u.xAxisTTVal,
            O = u.zVal,
            $ = null;
          $ = c[n].children, b.config.tooltip.fillSeriesColor && (c[n].style.backgroundColor = g, $[0].style.display = "none"), y.showTooltipTitle && (y.tooltipTitle === null && (y.tooltipTitle = b.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), y.tooltipTitle.innerHTML = T), y.isXAxisTooltipEnabled && (y.xaxisTooltipText.innerHTML = P !== "" ? P : T);
          var G = c[n].querySelector(".apexcharts-tooltip-text-y-label");
          G && (G.innerHTML = d || "");
          var Q = c[n].querySelector(".apexcharts-tooltip-text-y-value");
          Q && (Q.innerHTML = x !== void 0 ? x : ""), $[0] && $[0].classList.contains("apexcharts-tooltip-marker") && (b.config.tooltip.marker.fillColors && Array.isArray(b.config.tooltip.marker.fillColors) && (g = b.config.tooltip.marker.fillColors[n]), $[0].style.backgroundColor = g), b.config.tooltip.marker.show || ($[0].style.display = "none");
          var v = c[n].querySelector(".apexcharts-tooltip-text-goals-label"),
            C = c[n].querySelector(".apexcharts-tooltip-text-goals-value");
          if (_.length && b.globals.seriesGoals[n]) {
            var L = function () {
              var ee = "<div >",
                ge = "<div>";
              _.forEach(function (pe, Fe) {
                ee += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(pe.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(pe.attrs.name, "</div>"), ge += "<div>".concat(pe.val, "</div>")
              }), v.innerHTML = ee + "</div>", C.innerHTML = ge + "</div>"
            };
            f ? b.globals.seriesGoals[n][s] && Array.isArray(b.globals.seriesGoals[n][s]) ? L() : (v.innerHTML = "", C.innerHTML = "") : L()
          } else v.innerHTML = "", C.innerHTML = "";
          if (O !== null && (c[n].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = b.config.tooltip.z.title, c[n].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = O !== void 0 ? O : ""), f && $[0]) {
            if (b.config.tooltip.hideEmptySeries) {
              var H = c[n].querySelector(".apexcharts-tooltip-marker"),
                q = c[n].querySelector(".apexcharts-tooltip-text");
              parseFloat(x) == 0 ? (H.style.display = "none", q.style.display = "none") : (H.style.display = "block", q.style.display = "block")
            }
            x == null || b.globals.ancillaryCollapsedSeriesIndices.indexOf(n) > -1 || b.globals.collapsedSeriesIndices.indexOf(n) > -1 ? $[0].parentNode.style.display = "none" : $[0].parentNode.style.display = b.config.tooltip.items.display
          }
        }
      }, {
        key: "toggleActiveInactiveSeries",
        value: function (r) {
          var n = this.w;
          if (r) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
          else {
            this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
            var s = n.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
            s && (s.classList.add("apexcharts-active"), s.style.display = n.config.tooltip.items.display)
          }
        }
      }, {
        key: "getValuesToPrint",
        value: function (r) {
          var n = r.i,
            s = r.j,
            c = this.w,
            u = this.ctx.series.filteredSeriesX(),
            d = "",
            f = "",
            g = null,
            b = null,
            y = {
              series: c.globals.series,
              seriesIndex: n,
              dataPointIndex: s,
              w: c
            },
            x = c.globals.ttZFormatter;
          s === null ? b = c.globals.series[n] : c.globals.isXNumeric && c.config.chart.type !== "treemap" ? (d = u[n][s], u[n].length === 0 && (d = u[this.tooltipUtil.getFirstActiveXArray(u)][s])) : d = c.globals.labels[s] !== void 0 ? c.globals.labels[s] : "";
          var _ = d;
          return c.globals.isXNumeric && c.config.xaxis.type === "datetime" ? d = new ve(this.ctx).xLabelFormat(c.globals.ttKeyFormatter, _, _, {
            i: void 0,
            dateFormatter: new ye(this.ctx).formatDate,
            w: this.w
          }) : d = c.globals.isBarHorizontal ? c.globals.yLabelFormatters[0](_, y) : c.globals.xLabelFormatter(_, y), c.config.tooltip.x.formatter !== void 0 && (d = c.globals.ttKeyFormatter(_, y)), c.globals.seriesZ.length > 0 && c.globals.seriesZ[n].length > 0 && (g = x(c.globals.seriesZ[n][s], c)), f = typeof c.config.xaxis.tooltip.formatter == "function" ? c.globals.xaxisTooltipFormatter(_, y) : d, {
            val: Array.isArray(b) ? b.join(" ") : b,
            xVal: Array.isArray(d) ? d.join(" ") : d,
            xAxisTTVal: Array.isArray(f) ? f.join(" ") : f,
            zVal: g
          }
        }
      }, {
        key: "handleCustomTooltip",
        value: function (r) {
          var n = r.i,
            s = r.j,
            c = r.y1,
            u = r.y2,
            d = r.w,
            f = this.ttCtx.getElTooltip(),
            g = d.config.tooltip.custom;
          Array.isArray(g) && g[n] && (g = g[n]), f.innerHTML = g({
            ctx: this.ctx,
            series: d.globals.series,
            seriesIndex: n,
            dataPointIndex: s,
            y1: c,
            y2: u,
            w: d
          })
        }
      }]), Y
    }(),
    yr = function () {
      function Y(r) {
        l(this, Y), this.ttCtx = r, this.ctx = r.ctx, this.w = r.w
      }
      return p(Y, [{
        key: "moveXCrosshairs",
        value: function (r) {
          var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null,
            s = this.ttCtx,
            c = this.w,
            u = s.getElXCrosshairs(),
            d = r - s.xcrosshairsWidth / 2,
            f = c.globals.labels.slice().length;
          if (n !== null && (d = c.globals.gridWidth / f * n), u === null || c.globals.isBarHorizontal || (u.setAttribute("x", d), u.setAttribute("x1", d), u.setAttribute("x2", d), u.setAttribute("y2", c.globals.gridHeight), u.classList.add("apexcharts-active")), d < 0 && (d = 0), d > c.globals.gridWidth && (d = c.globals.gridWidth), s.isXAxisTooltipEnabled) {
            var g = d;
            c.config.xaxis.crosshairs.width !== "tickWidth" && c.config.xaxis.crosshairs.width !== "barWidth" || (g = d + s.xcrosshairsWidth / 2), this.moveXAxisTooltip(g)
          }
        }
      }, {
        key: "moveYCrosshairs",
        value: function (r) {
          var n = this.ttCtx;
          n.ycrosshairs !== null && W.setAttrs(n.ycrosshairs, {
            y1: r,
            y2: r
          }), n.ycrosshairsHidden !== null && W.setAttrs(n.ycrosshairsHidden, {
            y1: r,
            y2: r
          })
        }
      }, {
        key: "moveXAxisTooltip",
        value: function (r) {
          var n = this.w,
            s = this.ttCtx;
          if (s.xaxisTooltip !== null && s.xcrosshairsWidth !== 0) {
            s.xaxisTooltip.classList.add("apexcharts-active");
            var c = s.xaxisOffY + n.config.xaxis.tooltip.offsetY + n.globals.translateY + 1 + n.config.xaxis.offsetY;
            if (r -= s.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(r)) {
              r += n.globals.translateX;
              var u;
              u = new W(this.ctx).getTextRects(s.xaxisTooltipText.innerHTML), s.xaxisTooltipText.style.minWidth = u.width + "px", s.xaxisTooltip.style.left = r + "px", s.xaxisTooltip.style.top = c + "px"
            }
          }
        }
      }, {
        key: "moveYAxisTooltip",
        value: function (r) {
          var n = this.w,
            s = this.ttCtx;
          s.yaxisTTEls === null && (s.yaxisTTEls = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
          var c = parseInt(s.ycrosshairsHidden.getAttribute("y1"), 10),
            u = n.globals.translateY + c,
            d = s.yaxisTTEls[r].getBoundingClientRect().height,
            f = n.globals.translateYAxisX[r] - 2;
          n.config.yaxis[r].opposite && (f -= 26), u -= d / 2, n.globals.ignoreYAxisIndexes.indexOf(r) === -1 ? (s.yaxisTTEls[r].classList.add("apexcharts-active"), s.yaxisTTEls[r].style.top = u + "px", s.yaxisTTEls[r].style.left = f + n.config.yaxis[r].tooltip.offsetX + "px") : s.yaxisTTEls[r].classList.remove("apexcharts-active")
        }
      }, {
        key: "moveTooltip",
        value: function (r, n) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
            c = this.w,
            u = this.ttCtx,
            d = u.getElTooltip(),
            f = u.tooltipRect,
            g = s !== null ? parseFloat(s) : 1,
            b = parseFloat(r) + g + 5,
            y = parseFloat(n) + g / 2;
          if (b > c.globals.gridWidth / 2 && (b = b - f.ttWidth - g - 10), b > c.globals.gridWidth - f.ttWidth - 10 && (b = c.globals.gridWidth - f.ttWidth), b < -20 && (b = -20), c.config.tooltip.followCursor) {
            var x = u.getElGrid().getBoundingClientRect();
            (b = u.e.clientX - x.left) > c.globals.gridWidth / 2 && (b -= u.tooltipRect.ttWidth), (y = u.e.clientY + c.globals.translateY - x.top) > c.globals.gridHeight / 2 && (y -= u.tooltipRect.ttHeight)
          } else c.globals.isBarHorizontal || f.ttHeight / 2 + y > c.globals.gridHeight && (y = c.globals.gridHeight - f.ttHeight + c.globals.translateY);
          isNaN(b) || (b += c.globals.translateX, d.style.left = b + "px", d.style.top = y + "px")
        }
      }, {
        key: "moveMarkers",
        value: function (r, n) {
          var s = this.w,
            c = this.ttCtx;
          if (s.globals.markers.size[r] > 0)
            for (var u = s.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(r, "'] .apexcharts-marker")), d = 0; d < u.length; d++) parseInt(u[d].getAttribute("rel"), 10) === n && (c.marker.resetPointsSize(), c.marker.enlargeCurrentPoint(n, u[d]));
          else c.marker.resetPointsSize(), this.moveDynamicPointOnHover(n, r)
        }
      }, {
        key: "moveDynamicPointOnHover",
        value: function (r, n) {
          var s, c, u = this.w,
            d = this.ttCtx,
            f = u.globals.pointsArray,
            g = d.tooltipUtil.getHoverMarkerSize(n),
            b = u.config.series[n].type;
          if (!b || b !== "column" && b !== "candlestick" && b !== "boxPlot") {
            s = f[n][r][0], c = f[n][r][1] ? f[n][r][1] : 0;
            var y = u.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(n, "'] .apexcharts-series-markers circle"));
            y && c < u.globals.gridHeight && c > 0 && (y.setAttribute("r", g), y.setAttribute("cx", s), y.setAttribute("cy", c)), this.moveXCrosshairs(s), d.fixedTooltip || this.moveTooltip(s, c, g)
          }
        }
      }, {
        key: "moveDynamicPointsOnHover",
        value: function (r) {
          var n, s = this.ttCtx,
            c = s.w,
            u = 0,
            d = 0,
            f = c.globals.pointsArray;
          n = new Be(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
          var g = s.tooltipUtil.getHoverMarkerSize(n);
          f[n] && (u = f[n][r][0], d = f[n][r][1]);
          var b = s.tooltipUtil.getAllMarkers();
          if (b !== null)
            for (var y = 0; y < c.globals.series.length; y++) {
              var x = f[y];
              if (c.globals.comboCharts && x === void 0 && b.splice(y, 0, null), x && x.length) {
                var _ = f[y][r][1],
                  T = void 0;
                if (b[y].setAttribute("cx", u), c.config.chart.type === "rangeArea" && !c.globals.comboCharts) {
                  var P = r + c.globals.series[y].length;
                  T = f[y][P][1], _ -= Math.abs(_ - T) / 2
                }
                _ !== null && !isNaN(_) && _ < c.globals.gridHeight + g && _ + g > 0 ? (b[y] && b[y].setAttribute("r", g), b[y] && b[y].setAttribute("cy", _)) : b[y] && b[y].setAttribute("r", 0)
              }
            }
          this.moveXCrosshairs(u), s.fixedTooltip || this.moveTooltip(u, d || c.globals.gridHeight, g)
        }
      }, {
        key: "moveStickyTooltipOverBars",
        value: function (r, n) {
          var s = this.w,
            c = this.ttCtx,
            u = s.globals.columnSeries ? s.globals.columnSeries.length : s.globals.series.length,
            d = u >= 2 && u % 2 == 0 ? Math.floor(u / 2) : Math.floor(u / 2) + 1;
          s.globals.isBarHorizontal && (d = new Be(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
          var f = s.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(d, "'] path[j='").concat(r, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(d, "'] path[j='").concat(r, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(d, "'] path[j='").concat(r, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(d, "'] path[j='").concat(r, "']"));
          f || typeof n != "number" || (f = s.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(n, "'] path[j='").concat(r, `'],
        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(r, `'],
        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(r, `'],
        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='`).concat(n, "'] path[j='").concat(r, "']")));
          var g = f ? parseFloat(f.getAttribute("cx")) : 0,
            b = f ? parseFloat(f.getAttribute("cy")) : 0,
            y = f ? parseFloat(f.getAttribute("barWidth")) : 0,
            x = c.getElGrid().getBoundingClientRect(),
            _ = f && (f.classList.contains("apexcharts-candlestick-area") || f.classList.contains("apexcharts-boxPlot-area"));
          s.globals.isXNumeric ? (f && !_ && (g -= u % 2 != 0 ? y / 2 : 0), f && _ && s.globals.comboCharts && (g -= y / 2)) : s.globals.isBarHorizontal || (g = c.xAxisTicksPositions[r - 1] + c.dataPointsDividedWidth / 2, isNaN(g) && (g = c.xAxisTicksPositions[r] - c.dataPointsDividedWidth / 2)), s.globals.isBarHorizontal ? b -= c.tooltipRect.ttHeight : s.config.tooltip.followCursor ? b = c.e.clientY - x.top - c.tooltipRect.ttHeight / 2 : b + c.tooltipRect.ttHeight + 15 > s.globals.gridHeight && (b = s.globals.gridHeight), s.globals.isBarHorizontal || this.moveXCrosshairs(g), c.fixedTooltip || this.moveTooltip(g, b || s.globals.gridHeight)
        }
      }]), Y
    }(),
    qa = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.ttCtx = r, this.ctx = r.ctx, this.tooltipPosition = new yr(r)
      }
      return p(Y, [{
        key: "drawDynamicPoints",
        value: function () {
          var r = this.w,
            n = new W(this.ctx),
            s = new ke(this.ctx),
            c = r.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
          c = D(c), r.config.chart.stacked && c.sort(function (x, _) {
            return parseFloat(x.getAttribute("data:realIndex")) - parseFloat(_.getAttribute("data:realIndex"))
          });
          for (var u = 0; u < c.length; u++) {
            var d = c[u].querySelector(".apexcharts-series-markers-wrap");
            if (d !== null) {
              var f = void 0,
                g = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
              r.config.chart.type !== "line" && r.config.chart.type !== "area" || r.globals.comboCharts || r.config.tooltip.intersect || (g += " no-pointer-events");
              var b = s.getMarkerConfig({
                cssClass: g,
                seriesIndex: Number(d.getAttribute("data:realIndex"))
              });
              (f = n.drawMarker(0, 0, b)).node.setAttribute("default-marker-size", 0);
              var y = document.createElementNS(r.globals.SVGNS, "g");
              y.classList.add("apexcharts-series-markers"), y.appendChild(f.node), d.appendChild(y)
            }
          }
        }
      }, {
        key: "enlargeCurrentPoint",
        value: function (r, n) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null,
            c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null,
            u = this.w;
          u.config.chart.type !== "bubble" && this.newPointSize(r, n);
          var d = n.getAttribute("cx"),
            f = n.getAttribute("cy");
          if (s !== null && c !== null && (d = s, f = c), this.tooltipPosition.moveXCrosshairs(d), !this.fixedTooltip) {
            if (u.config.chart.type === "radar") {
              var g = this.ttCtx.getElGrid().getBoundingClientRect();
              d = this.ttCtx.e.clientX - g.left
            }
            this.tooltipPosition.moveTooltip(d, f, u.config.markers.hover.size)
          }
        }
      }, {
        key: "enlargePoints",
        value: function (r) {
          for (var n = this.w, s = this, c = this.ttCtx, u = r, d = n.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), f = n.config.markers.hover.size, g = 0; g < d.length; g++) {
            var b = d[g].getAttribute("rel"),
              y = d[g].getAttribute("index");
            if (f === void 0 && (f = n.globals.markers.size[y] + n.config.markers.hover.sizeOffset), u === parseInt(b, 10)) {
              s.newPointSize(u, d[g]);
              var x = d[g].getAttribute("cx"),
                _ = d[g].getAttribute("cy");
              s.tooltipPosition.moveXCrosshairs(x), c.fixedTooltip || s.tooltipPosition.moveTooltip(x, _, f)
            } else s.oldPointSize(d[g])
          }
        }
      }, {
        key: "newPointSize",
        value: function (r, n) {
          var s = this.w,
            c = s.config.markers.hover.size,
            u = r === 0 ? n.parentNode.firstChild : n.parentNode.lastChild;
          if (u.getAttribute("default-marker-size") !== "0") {
            var d = parseInt(u.getAttribute("index"), 10);
            c === void 0 && (c = s.globals.markers.size[d] + s.config.markers.hover.sizeOffset), c < 0 && (c = 0), u.setAttribute("r", c)
          }
        }
      }, {
        key: "oldPointSize",
        value: function (r) {
          var n = parseFloat(r.getAttribute("default-marker-size"));
          r.setAttribute("r", n)
        }
      }, {
        key: "resetPointsSize",
        value: function () {
          for (var r = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n = 0; n < r.length; n++) {
            var s = parseFloat(r[n].getAttribute("default-marker-size"));
            I.isNumber(s) && s >= 0 ? r[n].setAttribute("r", s) : r[n].setAttribute("r", 0)
          }
        }
      }]), Y
    }(),
    xr = function () {
      function Y(r) {
        l(this, Y), this.w = r.w;
        var n = this.w;
        this.ttCtx = r, this.isVerticalGroupedRangeBar = !n.globals.isBarHorizontal && n.config.chart.type === "rangeBar" && n.config.plotOptions.bar.rangeBarGroupRows
      }
      return p(Y, [{
        key: "getAttr",
        value: function (r, n) {
          return parseFloat(r.target.getAttribute(n))
        }
      }, {
        key: "handleHeatTreeTooltip",
        value: function (r) {
          var n = r.e,
            s = r.opt,
            c = r.x,
            u = r.y,
            d = r.type,
            f = this.ttCtx,
            g = this.w;
          if (n.target.classList.contains("apexcharts-".concat(d, "-rect"))) {
            var b = this.getAttr(n, "i"),
              y = this.getAttr(n, "j"),
              x = this.getAttr(n, "cx"),
              _ = this.getAttr(n, "cy"),
              T = this.getAttr(n, "width"),
              P = this.getAttr(n, "height");
            if (f.tooltipLabels.drawSeriesTexts({
                ttItems: s.ttItems,
                i: b,
                j: y,
                shared: !1,
                e: n
              }), g.globals.capturedSeriesIndex = b, g.globals.capturedDataPointIndex = y, c = x + f.tooltipRect.ttWidth / 2 + T, u = _ + f.tooltipRect.ttHeight / 2 - P / 2, f.tooltipPosition.moveXCrosshairs(x + T / 2), c > g.globals.gridWidth / 2 && (c = x - f.tooltipRect.ttWidth / 2 + T), f.w.config.tooltip.followCursor) {
              var O = g.globals.dom.elWrap.getBoundingClientRect();
              c = g.globals.clientX - O.left - (c > g.globals.gridWidth / 2 ? f.tooltipRect.ttWidth : 0), u = g.globals.clientY - O.top - (u > g.globals.gridHeight / 2 ? f.tooltipRect.ttHeight : 0)
            }
          }
          return {
            x: c,
            y: u
          }
        }
      }, {
        key: "handleMarkerTooltip",
        value: function (r) {
          var n, s, c = r.e,
            u = r.opt,
            d = r.x,
            f = r.y,
            g = this.w,
            b = this.ttCtx;
          if (c.target.classList.contains("apexcharts-marker")) {
            var y = parseInt(u.paths.getAttribute("cx"), 10),
              x = parseInt(u.paths.getAttribute("cy"), 10),
              _ = parseFloat(u.paths.getAttribute("val"));
            if (s = parseInt(u.paths.getAttribute("rel"), 10), n = parseInt(u.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, b.intersect) {
              var T = I.findAncestor(u.paths, "apexcharts-series");
              T && (n = parseInt(T.getAttribute("data:realIndex"), 10))
            }
            if (b.tooltipLabels.drawSeriesTexts({
                ttItems: u.ttItems,
                i: n,
                j: s,
                shared: !b.showOnIntersect && g.config.tooltip.shared,
                e: c
              }), c.type === "mouseup" && b.markerClick(c, n, s), g.globals.capturedSeriesIndex = n, g.globals.capturedDataPointIndex = s, d = y, f = x + g.globals.translateY - 1.4 * b.tooltipRect.ttHeight, b.w.config.tooltip.followCursor) {
              var P = b.getElGrid().getBoundingClientRect();
              f = b.e.clientY + g.globals.translateY - P.top
            }
            _ < 0 && (f = x), b.marker.enlargeCurrentPoint(s, u.paths, d, f)
          }
          return {
            x: d,
            y: f
          }
        }
      }, {
        key: "handleBarTooltip",
        value: function (r) {
          var n, s, c = r.e,
            u = r.opt,
            d = this.w,
            f = this.ttCtx,
            g = f.getElTooltip(),
            b = 0,
            y = 0,
            x = 0,
            _ = this.getBarTooltipXY({
              e: c,
              opt: u
            });
          n = _.i;
          var T = _.barHeight,
            P = _.j;
          d.globals.capturedSeriesIndex = n, d.globals.capturedDataPointIndex = P, d.globals.isBarHorizontal && f.tooltipUtil.hasBars() || !d.config.tooltip.shared ? (y = _.x, x = _.y, s = Array.isArray(d.config.stroke.width) ? d.config.stroke.width[n] : d.config.stroke.width, b = y) : d.globals.comboCharts || d.config.tooltip.shared || (b /= 2), isNaN(x) && (x = d.globals.svgHeight - f.tooltipRect.ttHeight);
          var O = parseInt(u.paths.parentNode.getAttribute("data:realIndex"), 10),
            $ = d.globals.isMultipleYAxis ? d.config.yaxis[O] && d.config.yaxis[O].reversed : d.config.yaxis[0].reversed;
          if (y + f.tooltipRect.ttWidth > d.globals.gridWidth && !$ ? y -= f.tooltipRect.ttWidth : y < 0 && (y = 0), f.w.config.tooltip.followCursor) {
            var G = f.getElGrid().getBoundingClientRect();
            x = f.e.clientY - G.top
          }
          f.tooltip === null && (f.tooltip = d.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), d.config.tooltip.shared || (d.globals.comboBarCount > 0 ? f.tooltipPosition.moveXCrosshairs(b + s / 2) : f.tooltipPosition.moveXCrosshairs(b)), !f.fixedTooltip && (!d.config.tooltip.shared || d.globals.isBarHorizontal && f.tooltipUtil.hasBars()) && ($ && (y -= f.tooltipRect.ttWidth) < 0 && (y = 0), !$ || d.globals.isBarHorizontal && f.tooltipUtil.hasBars() || (x = x + T - 2 * (d.globals.series[n][P] < 0 ? T : 0)), x = x + d.globals.translateY - f.tooltipRect.ttHeight / 2, g.style.left = y + d.globals.translateX + "px", g.style.top = x + "px")
        }
      }, {
        key: "getBarTooltipXY",
        value: function (r) {
          var n = this,
            s = r.e,
            c = r.opt,
            u = this.w,
            d = null,
            f = this.ttCtx,
            g = 0,
            b = 0,
            y = 0,
            x = 0,
            _ = 0,
            T = s.target.classList;
          if (T.contains("apexcharts-bar-area") || T.contains("apexcharts-candlestick-area") || T.contains("apexcharts-boxPlot-area") || T.contains("apexcharts-rangebar-area")) {
            var P = s.target,
              O = P.getBoundingClientRect(),
              $ = c.elGrid.getBoundingClientRect(),
              G = O.height;
            _ = O.height;
            var Q = O.width,
              v = parseInt(P.getAttribute("cx"), 10),
              C = parseInt(P.getAttribute("cy"), 10);
            x = parseFloat(P.getAttribute("barWidth"));
            var L = s.type === "touchmove" ? s.touches[0].clientX : s.clientX;
            d = parseInt(P.getAttribute("j"), 10), g = parseInt(P.parentNode.getAttribute("rel"), 10) - 1;
            var H = P.getAttribute("data-range-y1"),
              q = P.getAttribute("data-range-y2");
            u.globals.comboCharts && (g = parseInt(P.parentNode.getAttribute("data:realIndex"), 10));
            var ee = function (pe) {
                return u.globals.isXNumeric ? v - Q / 2 : n.isVerticalGroupedRangeBar ? v + Q / 2 : v - f.dataPointsDividedWidth + Q / 2
              },
              ge = function () {
                return C - f.dataPointsDividedHeight + G / 2 - f.tooltipRect.ttHeight / 2
              };
            f.tooltipLabels.drawSeriesTexts({
              ttItems: c.ttItems,
              i: g,
              j: d,
              y1: H ? parseInt(H, 10) : null,
              y2: q ? parseInt(q, 10) : null,
              shared: !f.showOnIntersect && u.config.tooltip.shared,
              e: s
            }), u.config.tooltip.followCursor ? u.globals.isBarHorizontal ? (b = L - $.left + 15, y = ge()) : (b = ee(), y = s.clientY - $.top - f.tooltipRect.ttHeight / 2 - 15) : u.globals.isBarHorizontal ? ((b = v) < f.xyRatios.baseLineInvertedY && (b = v - f.tooltipRect.ttWidth), y = ge()) : (b = ee(), y = C)
          }
          return {
            x: b,
            y,
            barHeight: _,
            barWidth: x,
            i: g,
            j: d
          }
        }
      }]), Y
    }(),
    wa = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.ttCtx = r
      }
      return p(Y, [{
        key: "drawXaxisTooltip",
        value: function () {
          var r = this.w,
            n = this.ttCtx,
            s = r.config.xaxis.position === "bottom";
          n.xaxisOffY = s ? r.globals.gridHeight + 1 : -r.globals.xAxisHeight - r.config.xaxis.axisTicks.height + 3;
          var c = s ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top",
            u = r.globals.dom.elWrap;
          n.isXAxisTooltipEnabled && r.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") === null && (n.xaxisTooltip = document.createElement("div"), n.xaxisTooltip.setAttribute("class", c + " apexcharts-theme-" + r.config.tooltip.theme), u.appendChild(n.xaxisTooltip), n.xaxisTooltipText = document.createElement("div"), n.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), n.xaxisTooltipText.style.fontFamily = r.config.xaxis.tooltip.style.fontFamily || r.config.chart.fontFamily, n.xaxisTooltipText.style.fontSize = r.config.xaxis.tooltip.style.fontSize, n.xaxisTooltip.appendChild(n.xaxisTooltipText))
        }
      }, {
        key: "drawYaxisTooltip",
        value: function () {
          for (var r = this.w, n = this.ttCtx, s = function (u) {
              var d = r.config.yaxis[u].opposite || r.config.yaxis[u].crosshairs.opposite;
              n.yaxisOffX = d ? r.globals.gridWidth + 1 : 1;
              var f = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(u, d ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
              r.globals.yAxisSameScaleIndices.map(function (b, y) {
                b.map(function (x, _) {
                  _ === u && (f += r.config.yaxis[_].show ? " " : " apexcharts-yaxistooltip-hidden")
                })
              });
              var g = r.globals.dom.elWrap;
              r.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(u)) === null && (n.yaxisTooltip = document.createElement("div"), n.yaxisTooltip.setAttribute("class", f + " apexcharts-theme-" + r.config.tooltip.theme), g.appendChild(n.yaxisTooltip), u === 0 && (n.yaxisTooltipText = []), n.yaxisTooltipText[u] = document.createElement("div"), n.yaxisTooltipText[u].classList.add("apexcharts-yaxistooltip-text"), n.yaxisTooltip.appendChild(n.yaxisTooltipText[u]))
            }, c = 0; c < r.config.yaxis.length; c++) s(c)
        }
      }, {
        key: "setXCrosshairWidth",
        value: function () {
          var r = this.w,
            n = this.ttCtx,
            s = n.getElXCrosshairs();
          if (n.xcrosshairsWidth = parseInt(r.config.xaxis.crosshairs.width, 10), r.globals.comboCharts) {
            var c = r.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
            if (c !== null && r.config.xaxis.crosshairs.width === "barWidth") {
              var u = parseFloat(c.getAttribute("barWidth"));
              n.xcrosshairsWidth = u
            } else if (r.config.xaxis.crosshairs.width === "tickWidth") {
              var d = r.globals.labels.length;
              n.xcrosshairsWidth = r.globals.gridWidth / d
            }
          } else if (r.config.xaxis.crosshairs.width === "tickWidth") {
            var f = r.globals.labels.length;
            n.xcrosshairsWidth = r.globals.gridWidth / f
          } else if (r.config.xaxis.crosshairs.width === "barWidth") {
            var g = r.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
            if (g !== null) {
              var b = parseFloat(g.getAttribute("barWidth"));
              n.xcrosshairsWidth = b
            } else n.xcrosshairsWidth = 1
          }
          r.globals.isBarHorizontal && (n.xcrosshairsWidth = 0), s !== null && n.xcrosshairsWidth > 0 && s.setAttribute("width", n.xcrosshairsWidth)
        }
      }, {
        key: "handleYCrosshair",
        value: function () {
          var r = this.w,
            n = this.ttCtx;
          n.ycrosshairs = r.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), n.ycrosshairsHidden = r.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
        }
      }, {
        key: "drawYaxisTooltipText",
        value: function (r, n, s) {
          var c = this.ttCtx,
            u = this.w,
            d = u.globals.yLabelFormatters[r];
          if (c.yaxisTooltips[r]) {
            var f = c.getElGrid().getBoundingClientRect(),
              g = (n - f.top) * s.yRatio[r],
              b = u.globals.maxYArr[r] - u.globals.minYArr[r],
              y = u.globals.minYArr[r] + (b - g);
            c.tooltipPosition.moveYCrosshairs(n - f.top), c.yaxisTooltipText[r].innerHTML = d(y), c.tooltipPosition.moveYAxisTooltip(r)
          }
        }
      }]), Y
    }(),
    Me = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w;
        var n = this.w;
        this.tConfig = n.config.tooltip, this.tooltipUtil = new ia(this), this.tooltipLabels = new xa(this), this.tooltipPosition = new yr(this), this.marker = new qa(this), this.intersect = new xr(this), this.axesTooltip = new wa(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !n.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now()
      }
      return p(Y, [{
        key: "getElTooltip",
        value: function (r) {
          return r || (r = this), r.w.globals.dom.baseEl ? r.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null
        }
      }, {
        key: "getElXCrosshairs",
        value: function () {
          return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
        }
      }, {
        key: "getElGrid",
        value: function () {
          return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
        }
      }, {
        key: "drawTooltip",
        value: function (r) {
          var n = this.w;
          this.xyRatios = r, this.isXAxisTooltipEnabled = n.config.xaxis.tooltip.enabled && n.globals.axisCharts, this.yaxisTooltips = n.config.yaxis.map(function (d, f) {
            return !!(d.show && d.tooltip.enabled && n.globals.axisCharts)
          }), this.allTooltipSeriesGroups = [], n.globals.axisCharts || (this.showTooltipTitle = !1);
          var s = document.createElement("div");
          if (s.classList.add("apexcharts-tooltip"), n.config.tooltip.cssClass && s.classList.add(n.config.tooltip.cssClass), s.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), n.globals.dom.elWrap.appendChild(s), n.globals.axisCharts) {
            this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
            var c = new nt(this.ctx);
            this.xAxisTicksPositions = c.getXAxisTicksPositions()
          }
          if (!n.globals.comboCharts && !this.tConfig.intersect && n.config.chart.type !== "rangeBar" || this.tConfig.shared || (this.showOnIntersect = !0), n.config.markers.size !== 0 && n.globals.markers.largestSize !== 0 || this.marker.drawDynamicPoints(this), n.globals.collapsedSeries.length !== n.globals.series.length) {
            this.dataPointsDividedHeight = n.globals.gridHeight / n.globals.dataPoints, this.dataPointsDividedWidth = n.globals.gridWidth / n.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || n.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, s.appendChild(this.tooltipTitle));
            var u = n.globals.series.length;
            (n.globals.xyCharts || n.globals.comboCharts) && this.tConfig.shared && (u = this.showOnIntersect ? 1 : n.globals.series.length), this.legendLabels = n.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(u), this.addSVGEvents()
          }
        }
      }, {
        key: "createTTElements",
        value: function (r) {
          for (var n = this, s = this.w, c = [], u = this.getElTooltip(), d = function (g) {
              var b = document.createElement("div");
              b.classList.add("apexcharts-tooltip-series-group"), b.style.order = s.config.tooltip.inverseOrder ? r - g : g + 1, n.tConfig.shared && n.tConfig.enabledOnSeries && Array.isArray(n.tConfig.enabledOnSeries) && n.tConfig.enabledOnSeries.indexOf(g) < 0 && b.classList.add("apexcharts-tooltip-series-group-hidden");
              var y = document.createElement("span");
              y.classList.add("apexcharts-tooltip-marker"), y.style.backgroundColor = s.globals.colors[g], b.appendChild(y);
              var x = document.createElement("div");
              x.classList.add("apexcharts-tooltip-text"), x.style.fontFamily = n.tConfig.style.fontFamily || s.config.chart.fontFamily, x.style.fontSize = n.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function (_) {
                var T = document.createElement("div");
                T.classList.add("apexcharts-tooltip-".concat(_, "-group"));
                var P = document.createElement("span");
                P.classList.add("apexcharts-tooltip-text-".concat(_, "-label")), T.appendChild(P);
                var O = document.createElement("span");
                O.classList.add("apexcharts-tooltip-text-".concat(_, "-value")), T.appendChild(O), x.appendChild(T)
              }), b.appendChild(x), u.appendChild(b), c.push(b)
            }, f = 0; f < r; f++) d(f);
          return c
        }
      }, {
        key: "addSVGEvents",
        value: function () {
          var r = this.w,
            n = r.config.chart.type,
            s = this.getElTooltip(),
            c = !(n !== "bar" && n !== "candlestick" && n !== "boxPlot" && n !== "rangeBar"),
            u = n === "area" || n === "line" || n === "scatter" || n === "bubble" || n === "radar",
            d = r.globals.dom.Paper.node,
            f = this.getElGrid();
          f && (this.seriesBound = f.getBoundingClientRect());
          var g, b = [],
            y = [],
            x = {
              hoverArea: d,
              elGrid: f,
              tooltipEl: s,
              tooltipY: b,
              tooltipX: y,
              ttItems: this.ttItems
            };
          if (r.globals.axisCharts && (u ? g = r.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : c ? g = r.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : n !== "heatmap" && n !== "treemap" || (g = r.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), g && g.length))
            for (var _ = 0; _ < g.length; _++) b.push(g[_].getAttribute("cy")), y.push(g[_].getAttribute("cx"));
          if (r.globals.xyCharts && !this.showOnIntersect || r.globals.comboCharts && !this.showOnIntersect || c && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([d], x);
          else if (c && !r.globals.comboCharts || u && this.showOnIntersect) this.addDatapointEventsListeners(x);
          else if (!r.globals.axisCharts || n === "heatmap" || n === "treemap") {
            var T = r.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
            this.addPathsEventListeners(T, x)
          }
          if (this.showOnIntersect) {
            var P = r.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
            P.length > 0 && this.addPathsEventListeners(P, x), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(x)
          }
        }
      }, {
        key: "drawFixedTooltipRect",
        value: function () {
          var r = this.w,
            n = this.getElTooltip(),
            s = n.getBoundingClientRect(),
            c = s.width + 10,
            u = s.height + 10,
            d = this.tConfig.fixed.offsetX,
            f = this.tConfig.fixed.offsetY,
            g = this.tConfig.fixed.position.toLowerCase();
          return g.indexOf("right") > -1 && (d = d + r.globals.svgWidth - c + 10), g.indexOf("bottom") > -1 && (f = f + r.globals.svgHeight - u - 10), n.style.left = d + "px", n.style.top = f + "px", {
            x: d,
            y: f,
            ttWidth: c,
            ttHeight: u
          }
        }
      }, {
        key: "addDatapointEventsListeners",
        value: function (r) {
          var n = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
          this.addPathsEventListeners(n, r)
        }
      }, {
        key: "addPathsEventListeners",
        value: function (r, n) {
          for (var s = this, c = function (d) {
              var f = {
                paths: r[d],
                tooltipEl: n.tooltipEl,
                tooltipY: n.tooltipY,
                tooltipX: n.tooltipX,
                elGrid: n.elGrid,
                hoverArea: n.hoverArea,
                ttItems: n.ttItems
              };
              ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function (g) {
                return r[d].addEventListener(g, s.onSeriesHover.bind(s, f), {
                  capture: !1,
                  passive: !0
                })
              })
            }, u = 0; u < r.length; u++) c(u)
        }
      }, {
        key: "onSeriesHover",
        value: function (r, n) {
          var s = this,
            c = Date.now() - this.lastHoverTime;
          c >= 100 ? this.seriesHover(r, n) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function () {
            s.seriesHover(r, n)
          }, 100 - c))
        }
      }, {
        key: "seriesHover",
        value: function (r, n) {
          var s = this;
          this.lastHoverTime = Date.now();
          var c = [],
            u = this.w;
          u.config.chart.group && (c = this.ctx.getGroupedCharts()), u.globals.axisCharts && (u.globals.minX === -1 / 0 && u.globals.maxX === 1 / 0 || u.globals.dataPoints === 0) || (c.length ? c.forEach(function (d) {
            var f = s.getElTooltip(d),
              g = {
                paths: r.paths,
                tooltipEl: f,
                tooltipY: r.tooltipY,
                tooltipX: r.tooltipX,
                elGrid: r.elGrid,
                hoverArea: r.hoverArea,
                ttItems: d.w.globals.tooltip.ttItems
              };
            d.w.globals.minX === s.w.globals.minX && d.w.globals.maxX === s.w.globals.maxX && d.w.globals.tooltip.seriesHoverByContext({
              chartCtx: d,
              ttCtx: d.w.globals.tooltip,
              opt: g,
              e: n
            })
          }) : this.seriesHoverByContext({
            chartCtx: this.ctx,
            ttCtx: this.w.globals.tooltip,
            opt: r,
            e: n
          }))
        }
      }, {
        key: "seriesHoverByContext",
        value: function (r) {
          var n = r.chartCtx,
            s = r.ttCtx,
            c = r.opt,
            u = r.e,
            d = n.w,
            f = this.getElTooltip();
          f && (s.tooltipRect = {
            x: 0,
            y: 0,
            ttWidth: f.getBoundingClientRect().width,
            ttHeight: f.getBoundingClientRect().height
          }, s.e = u, s.tooltipUtil.hasBars() && !d.globals.comboCharts && !s.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new Be(n).toggleSeriesOnHover(u, u.target.parentNode), s.fixedTooltip && s.drawFixedTooltipRect(), d.globals.axisCharts ? s.axisChartsTooltips({
            e: u,
            opt: c,
            tooltipRect: s.tooltipRect
          }) : s.nonAxisChartsTooltips({
            e: u,
            opt: c,
            tooltipRect: s.tooltipRect
          }))
        }
      }, {
        key: "axisChartsTooltips",
        value: function (r) {
          var n, s, c = r.e,
            u = r.opt,
            d = this.w,
            f = u.elGrid.getBoundingClientRect(),
            g = c.type === "touchmove" ? c.touches[0].clientX : c.clientX,
            b = c.type === "touchmove" ? c.touches[0].clientY : c.clientY;
          if (this.clientY = b, this.clientX = g, d.globals.capturedSeriesIndex = -1, d.globals.capturedDataPointIndex = -1, b < f.top || b > f.top + f.height) this.handleMouseOut(u);
          else {
            if (Array.isArray(this.tConfig.enabledOnSeries) && !d.config.tooltip.shared) {
              var y = parseInt(u.paths.getAttribute("index"), 10);
              if (this.tConfig.enabledOnSeries.indexOf(y) < 0) return void this.handleMouseOut(u)
            }
            var x = this.getElTooltip(),
              _ = this.getElXCrosshairs(),
              T = d.globals.xyCharts || d.config.chart.type === "bar" && !d.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || d.globals.comboCharts && this.tooltipUtil.hasBars();
            if (c.type === "mousemove" || c.type === "touchmove" || c.type === "mouseup") {
              if (d.globals.collapsedSeries.length + d.globals.ancillaryCollapsedSeries.length === d.globals.series.length) return;
              _ !== null && _.classList.add("apexcharts-active");
              var P = this.yaxisTooltips.filter(function (G) {
                return G === !0
              });
              if (this.ycrosshairs !== null && P.length && this.ycrosshairs.classList.add("apexcharts-active"), T && !this.showOnIntersect) this.handleStickyTooltip(c, g, b, u);
              else if (d.config.chart.type === "heatmap" || d.config.chart.type === "treemap") {
                var O = this.intersect.handleHeatTreeTooltip({
                  e: c,
                  opt: u,
                  x: n,
                  y: s,
                  type: d.config.chart.type
                });
                n = O.x, s = O.y, x.style.left = n + "px", x.style.top = s + "px"
              } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                e: c,
                opt: u
              }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                e: c,
                opt: u,
                x: n,
                y: s
              });
              if (this.yaxisTooltips.length)
                for (var $ = 0; $ < d.config.yaxis.length; $++) this.axesTooltip.drawYaxisTooltipText($, b, this.xyRatios);
              u.tooltipEl.classList.add("apexcharts-active")
            } else c.type !== "mouseout" && c.type !== "touchend" || this.handleMouseOut(u)
          }
        }
      }, {
        key: "nonAxisChartsTooltips",
        value: function (r) {
          var n = r.e,
            s = r.opt,
            c = r.tooltipRect,
            u = this.w,
            d = s.paths.getAttribute("rel"),
            f = this.getElTooltip(),
            g = u.globals.dom.elWrap.getBoundingClientRect();
          if (n.type === "mousemove" || n.type === "touchmove") {
            f.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
              ttItems: s.ttItems,
              i: parseInt(d, 10) - 1,
              shared: !1
            });
            var b = u.globals.clientX - g.left - c.ttWidth / 2,
              y = u.globals.clientY - g.top - c.ttHeight - 10;
            if (f.style.left = b + "px", f.style.top = y + "px", u.config.legend.tooltipHoverFormatter) {
              var x = d - 1,
                _ = (0, u.config.legend.tooltipHoverFormatter)(this.legendLabels[x].getAttribute("data:default-text"), {
                  seriesIndex: x,
                  dataPointIndex: x,
                  w: u
                });
              this.legendLabels[x].innerHTML = _
            }
          } else n.type !== "mouseout" && n.type !== "touchend" || (f.classList.remove("apexcharts-active"), u.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function (T) {
            var P = T.getAttribute("data:default-text");
            T.innerHTML = decodeURIComponent(P)
          }))
        }
      }, {
        key: "handleStickyTooltip",
        value: function (r, n, s, c) {
          var u = this.w,
            d = this.tooltipUtil.getNearestValues({
              context: this,
              hoverArea: c.hoverArea,
              elGrid: c.elGrid,
              clientX: n,
              clientY: s
            }),
            f = d.j,
            g = d.capturedSeries;
          u.globals.collapsedSeriesIndices.includes(g) && (g = null);
          var b = c.elGrid.getBoundingClientRect();
          if (d.hoverX < 0 || d.hoverX > b.width) this.handleMouseOut(c);
          else if (g !== null) this.handleStickyCapturedSeries(r, g, c, f);
          else if (this.tooltipUtil.isXoverlap(f) || u.globals.isBarHorizontal) {
            var y = u.globals.series.findIndex(function (x, _) {
              return !u.globals.collapsedSeriesIndices.includes(_)
            });
            this.create(r, this, y, f, c.ttItems)
          }
        }
      }, {
        key: "handleStickyCapturedSeries",
        value: function (r, n, s, c) {
          var u = this.w;
          if (!this.tConfig.shared && u.globals.series[n][c] === null) return void this.handleMouseOut(s);
          if (u.globals.series[n][c] !== void 0) this.tConfig.shared && this.tooltipUtil.isXoverlap(c) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(r, this, n, c, s.ttItems) : this.create(r, this, n, c, s.ttItems, !1);
          else if (this.tooltipUtil.isXoverlap(c)) {
            var d = u.globals.series.findIndex(function (f, g) {
              return !u.globals.collapsedSeriesIndices.includes(g)
            });
            this.create(r, this, d, c, s.ttItems)
          }
        }
      }, {
        key: "deactivateHoverFilter",
        value: function () {
          for (var r = this.w, n = new W(this.ctx), s = r.globals.dom.Paper.select(".apexcharts-bar-area"), c = 0; c < s.length; c++) n.pathMouseLeave(s[c])
        }
      }, {
        key: "handleMouseOut",
        value: function (r) {
          var n = this.w,
            s = this.getElXCrosshairs();
          if (r.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), n.config.chart.type !== "bubble" && this.marker.resetPointsSize(), s !== null && s.classList.remove("apexcharts-active"), this.ycrosshairs !== null && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
            this.yaxisTTEls === null && (this.yaxisTTEls = n.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
            for (var c = 0; c < this.yaxisTTEls.length; c++) this.yaxisTTEls[c].classList.remove("apexcharts-active")
          }
          n.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function (u) {
            var d = u.getAttribute("data:default-text");
            u.innerHTML = decodeURIComponent(d)
          })
        }
      }, {
        key: "markerClick",
        value: function (r, n, s) {
          var c = this.w;
          typeof c.config.chart.events.markerClick == "function" && c.config.chart.events.markerClick(r, this.ctx, {
            seriesIndex: n,
            dataPointIndex: s,
            w: c
          }), this.ctx.events.fireEvent("markerClick", [r, this.ctx, {
            seriesIndex: n,
            dataPointIndex: s,
            w: c
          }])
        }
      }, {
        key: "create",
        value: function (r, n, s, c, u) {
          var d, f, g, b, y, x, _, T, P, O, $, G, Q, v, C, L, H = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : null,
            q = this.w,
            ee = n;
          r.type === "mouseup" && this.markerClick(r, s, c), H === null && (H = this.tConfig.shared);
          var ge = this.tooltipUtil.hasMarkers(s),
            pe = this.tooltipUtil.getElBars();
          if (q.config.legend.tooltipHoverFormatter) {
            var Fe = q.config.legend.tooltipHoverFormatter,
              Ue = Array.from(this.legendLabels);
            Ue.forEach(function (wr) {
              var Ya = wr.getAttribute("data:default-text");
              wr.innerHTML = decodeURIComponent(Ya)
            });
            for (var Ve = 0; Ve < Ue.length; Ve++) {
              var it = Ue[Ve],
                dt = parseInt(it.getAttribute("i"), 10),
                mt = decodeURIComponent(it.getAttribute("data:default-text")),
                At = Fe(mt, {
                  seriesIndex: H ? dt : s,
                  dataPointIndex: c,
                  w: q
                });
              if (H) it.innerHTML = q.globals.collapsedSeriesIndices.indexOf(dt) < 0 ? At : mt;
              else if (it.innerHTML = dt === s ? At : mt, s === dt) break
            }
          }
          var _t = i(i({
            ttItems: u,
            i: s,
            j: c
          }, ((d = q.globals.seriesRange) === null || d === void 0 || (f = d[s]) === null || f === void 0 || (g = f[c]) === null || g === void 0 || (b = g.y[0]) === null || b === void 0 ? void 0 : b.y1) !== void 0 && {
            y1: (y = q.globals.seriesRange) === null || y === void 0 || (x = y[s]) === null || x === void 0 || (_ = x[c]) === null || _ === void 0 || (T = _.y[0]) === null || T === void 0 ? void 0 : T.y1
          }), ((P = q.globals.seriesRange) === null || P === void 0 || (O = P[s]) === null || O === void 0 || ($ = O[c]) === null || $ === void 0 || (G = $.y[0]) === null || G === void 0 ? void 0 : G.y2) !== void 0 && {
            y2: (Q = q.globals.seriesRange) === null || Q === void 0 || (v = Q[s]) === null || v === void 0 || (C = v[c]) === null || C === void 0 || (L = C.y[0]) === null || L === void 0 ? void 0 : L.y2
          });
          if (H) {
            if (ee.tooltipLabels.drawSeriesTexts(i(i({}, _t), {}, {
                shared: !this.showOnIntersect && this.tConfig.shared
              })), ge) q.globals.markers.largestSize > 0 ? ee.marker.enlargePoints(c) : ee.tooltipPosition.moveDynamicPointsOnHover(c);
            else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(pe), this.barSeriesHeight > 0)) {
              var Et = new W(this.ctx),
                qt = q.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(c, "']"));
              this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(c, s);
              for (var sa = 0; sa < qt.length; sa++) Et.pathMouseEnter(qt[sa])
            }
          } else ee.tooltipLabels.drawSeriesTexts(i({
            shared: !1
          }, _t)), this.tooltipUtil.hasBars() && ee.tooltipPosition.moveStickyTooltipOverBars(c, s), ge && ee.tooltipPosition.moveMarkers(s, c)
        }
      }]), Y
    }(),
    rt = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.barCtx = r, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter)
      }
      return p(Y, [{
        key: "handleBarDataLabels",
        value: function (r) {
          var n = r.x,
            s = r.y,
            c = r.y1,
            u = r.y2,
            d = r.i,
            f = r.j,
            g = r.realIndex,
            b = r.groupIndex,
            y = r.series,
            x = r.barHeight,
            _ = r.barWidth,
            T = r.barXPosition,
            P = r.barYPosition,
            O = r.visibleSeries,
            $ = r.renderedPath,
            G = this.w,
            Q = new W(this.barCtx.ctx),
            v = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[g] : this.barCtx.strokeWidth,
            C = n + parseFloat(_ * O),
            L = s + parseFloat(x * O);
          G.globals.isXNumeric && !G.globals.isBarHorizontal && (C = n + parseFloat(_ * (O + 1)), L = s + parseFloat(x * (O + 1)) - v);
          var H, q = null,
            ee = n,
            ge = s,
            pe = {},
            Fe = G.config.dataLabels,
            Ue = this.barCtx.barOptions.dataLabels,
            Ve = this.barCtx.barOptions.dataLabels.total;
          P !== void 0 && this.barCtx.isRangeBar && (L = P, ge = P), T !== void 0 && this.barCtx.isVerticalGroupedRangeBar && (C = T, ee = T);
          var it = Fe.offsetX,
            dt = Fe.offsetY,
            mt = {
              width: 0,
              height: 0
            };
          if (G.config.dataLabels.enabled) {
            var At = this.barCtx.series[d][f];
            mt = Q.getTextRects(G.globals.yLabelFormatters[0](At), parseFloat(Fe.style.fontSize))
          }
          var _t = {
            x: n,
            y: s,
            i: d,
            j: f,
            realIndex: g,
            groupIndex: b || -1,
            renderedPath: $,
            bcx: C,
            bcy: L,
            barHeight: x,
            barWidth: _,
            textRects: mt,
            strokeWidth: v,
            dataLabelsX: ee,
            dataLabelsY: ge,
            dataLabelsConfig: Fe,
            barDataLabelsConfig: Ue,
            barTotalDataLabelsConfig: Ve,
            offX: it,
            offY: dt
          };
          return pe = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(_t) : this.calculateColumnsDataLabelsPosition(_t), $.attr({
            cy: pe.bcy,
            cx: pe.bcx,
            j: f,
            val: y[d][f],
            barHeight: x,
            barWidth: _
          }), H = this.drawCalculatedDataLabels({
            x: pe.dataLabelsX,
            y: pe.dataLabelsY,
            val: this.barCtx.isRangeBar ? [c, u] : y[d][f],
            i: g,
            j: f,
            barWidth: _,
            barHeight: x,
            textRects: mt,
            dataLabelsConfig: Fe
          }), G.config.chart.stacked && Ve.enabled && (q = this.drawTotalDataLabels({
            x: pe.totalDataLabelsX,
            y: pe.totalDataLabelsY,
            barWidth: _,
            barHeight: x,
            realIndex: g,
            textAnchor: pe.totalDataLabelsAnchor,
            val: this.getStackedTotalDataLabel({
              realIndex: g,
              j: f
            }),
            dataLabelsConfig: Fe,
            barTotalDataLabelsConfig: Ve
          })), {
            dataLabels: H,
            totalDataLabels: q
          }
        }
      }, {
        key: "getStackedTotalDataLabel",
        value: function (r) {
          var n = r.realIndex,
            s = r.j,
            c = this.w,
            u = this.barCtx.stackedSeriesTotals[s];
          return this.totalFormatter && (u = this.totalFormatter(u, i(i({}, c), {}, {
            seriesIndex: n,
            dataPointIndex: s,
            w: c
          }))), u
        }
      }, {
        key: "calculateColumnsDataLabelsPosition",
        value: function (r) {
          var n, s, c = this.w,
            u = r.i,
            d = r.j,
            f = r.realIndex,
            g = r.groupIndex,
            b = r.y,
            y = r.bcx,
            x = r.barWidth,
            _ = r.barHeight,
            T = r.textRects,
            P = r.dataLabelsX,
            O = r.dataLabelsY,
            $ = r.dataLabelsConfig,
            G = r.barDataLabelsConfig,
            Q = r.barTotalDataLabelsConfig,
            v = r.strokeWidth,
            C = r.offX,
            L = r.offY;
          _ = Math.abs(_);
          var H = c.config.plotOptions.bar.dataLabels.orientation === "vertical",
            q = this.barCtx.barHelpers.getZeroValueEncounters({
              i: u,
              j: d
            }).zeroEncounters;
          y = y - v / 2 + (g !== -1 ? g * x : 0);
          var ee = c.globals.gridWidth / c.globals.dataPoints;
          this.barCtx.isVerticalGroupedRangeBar ? P += x / 2 : (P = c.globals.isXNumeric ? y - x / 2 + C : y - ee + x / 2 + C, q > 0 && c.config.plotOptions.bar.hideZeroBarsWhenGrouped && (P -= x * q)), H && (P = P + T.height / 2 - v / 2 - 2);
          var ge = this.barCtx.series[u][d] < 0,
            pe = b;
          switch (this.barCtx.isReversed && (pe = b - _ + (ge ? 2 * _ : 0), b -= _), G.position) {
            case "center":
              O = H ? ge ? pe - _ / 2 + L : pe + _ / 2 - L : ge ? pe - _ / 2 + T.height / 2 + L : pe + _ / 2 + T.height / 2 - L;
              break;
            case "bottom":
              O = H ? ge ? pe - _ + L : pe + _ - L : ge ? pe - _ + T.height + v + L : pe + _ - T.height / 2 + v - L;
              break;
            case "top":
              O = H ? ge ? pe + L : pe - L : ge ? pe - T.height / 2 - L : pe + T.height + L
          }
          if (this.barCtx.lastActiveBarSerieIndex === f && Q.enabled) {
            var Fe = new W(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
              realIndex: f,
              j: d
            }), $.fontSize);
            n = ge ? pe - Fe.height / 2 - L - Q.offsetY + 18 : pe + Fe.height + L + Q.offsetY - 18, s = P + Q.offsetX
          }
          return c.config.chart.stacked || (O < 0 ? O = 0 + v : O + T.height / 3 > c.globals.gridHeight && (O = c.globals.gridHeight - v)), {
            bcx: y,
            bcy: b,
            dataLabelsX: P,
            dataLabelsY: O,
            totalDataLabelsX: s,
            totalDataLabelsY: n,
            totalDataLabelsAnchor: "middle"
          }
        }
      }, {
        key: "calculateBarsDataLabelsPosition",
        value: function (r) {
          var n = this.w,
            s = r.x,
            c = r.i,
            u = r.j,
            d = r.realIndex,
            f = r.groupIndex,
            g = r.bcy,
            b = r.barHeight,
            y = r.barWidth,
            x = r.textRects,
            _ = r.dataLabelsX,
            T = r.strokeWidth,
            P = r.dataLabelsConfig,
            O = r.barDataLabelsConfig,
            $ = r.barTotalDataLabelsConfig,
            G = r.offX,
            Q = r.offY,
            v = n.globals.gridHeight / n.globals.dataPoints;
          y = Math.abs(y);
          var C, L, H = (g += f !== -1 ? f * b : 0) - (this.barCtx.isRangeBar ? 0 : v) + b / 2 + x.height / 2 + Q - 3,
            q = "start",
            ee = this.barCtx.series[c][u] < 0,
            ge = s;
          switch (this.barCtx.isReversed && (ge = s + y - (ee ? 2 * y : 0), s = n.globals.gridWidth - y), O.position) {
            case "center":
              _ = ee ? ge + y / 2 - G : Math.max(x.width / 2, ge - y / 2) + G;
              break;
            case "bottom":
              _ = ee ? ge + y - T - Math.round(x.width / 2) - G : ge - y + T + Math.round(x.width / 2) + G;
              break;
            case "top":
              _ = ee ? ge - T + Math.round(x.width / 2) - G : ge - T - Math.round(x.width / 2) + G
          }
          if (this.barCtx.lastActiveBarSerieIndex === d && $.enabled) {
            var pe = new W(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
              realIndex: d,
              j: u
            }), P.fontSize);
            ee ? (C = ge - T + Math.round(pe.width / 2) - G - $.offsetX - 15, q = "end") : C = ge - T - Math.round(pe.width / 2) + G + $.offsetX + 15, L = H + $.offsetY
          }
          return n.config.chart.stacked || (_ < 0 ? _ = _ + x.width + T : _ + x.width / 2 > n.globals.gridWidth && (_ = n.globals.gridWidth - x.width - T)), {
            bcx: s,
            bcy: g,
            dataLabelsX: _,
            dataLabelsY: H,
            totalDataLabelsX: C,
            totalDataLabelsY: L,
            totalDataLabelsAnchor: q
          }
        }
      }, {
        key: "drawCalculatedDataLabels",
        value: function (r) {
          var n = r.x,
            s = r.y,
            c = r.val,
            u = r.i,
            d = r.j,
            f = r.textRects,
            g = r.barHeight,
            b = r.barWidth,
            y = r.dataLabelsConfig,
            x = this.w,
            _ = "rotate(0)";
          x.config.plotOptions.bar.dataLabels.orientation === "vertical" && (_ = "rotate(-90, ".concat(n, ", ").concat(s, ")"));
          var T = new Se(this.barCtx.ctx),
            P = new W(this.barCtx.ctx),
            O = y.formatter,
            $ = null,
            G = x.globals.collapsedSeriesIndices.indexOf(u) > -1;
          if (y.enabled && !G) {
            $ = P.group({
              class: "apexcharts-data-labels",
              transform: _
            });
            var Q = "";
            c !== void 0 && (Q = O(c, i(i({}, x), {}, {
              seriesIndex: u,
              dataPointIndex: d,
              w: x
            }))), !c && x.config.plotOptions.bar.hideZeroBarsWhenGrouped && (Q = "");
            var v = x.globals.series[u][d] < 0,
              C = x.config.plotOptions.bar.dataLabels.position;
            x.config.plotOptions.bar.dataLabels.orientation === "vertical" && (C === "top" && (y.textAnchor = v ? "end" : "start"), C === "center" && (y.textAnchor = "middle"), C === "bottom" && (y.textAnchor = v ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && b < P.getTextRects(Q, parseFloat(y.style.fontSize)).width && (Q = ""), x.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? f.width / 1.6 > Math.abs(b) && (Q = "") : f.height / 1.6 > Math.abs(g) && (Q = ""));
            var L = i({}, y);
            this.barCtx.isHorizontal && c < 0 && (y.textAnchor === "start" ? L.textAnchor = "end" : y.textAnchor === "end" && (L.textAnchor = "start")), T.plotDataLabelsText({
              x: n,
              y: s,
              text: Q,
              i: u,
              j: d,
              parent: $,
              dataLabelsConfig: L,
              alwaysDrawDataLabel: !0,
              offsetCorrection: !0
            })
          }
          return $
        }
      }, {
        key: "drawTotalDataLabels",
        value: function (r) {
          var n, s = r.x,
            c = r.y,
            u = r.val,
            d = r.barWidth,
            f = r.barHeight,
            g = r.realIndex,
            b = r.textAnchor,
            y = r.barTotalDataLabelsConfig,
            x = this.w,
            _ = new W(this.barCtx.ctx);
          return y.enabled && s !== void 0 && c !== void 0 && this.barCtx.lastActiveBarSerieIndex === g && (n = _.drawText({
            x: s - (!x.globals.isBarHorizontal && x.globals.seriesGroups.length ? d / x.globals.seriesGroups.length : 0),
            y: c - (x.globals.isBarHorizontal && x.globals.seriesGroups.length ? f / x.globals.seriesGroups.length : 0),
            foreColor: y.style.color,
            text: u,
            textAnchor: b,
            fontFamily: y.style.fontFamily,
            fontSize: y.style.fontSize,
            fontWeight: y.style.fontWeight
          })), n
        }
      }]), Y
    }(),
    ze = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.barCtx = r
      }
      return p(Y, [{
        key: "initVariables",
        value: function (r) {
          var n = this.w;
          this.barCtx.series = r, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
          for (var s = 0; s < r.length; s++)
            if (r[s].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += r[s].length), n.globals.isXNumeric)
              for (var c = 0; c < r[s].length; c++) n.globals.seriesX[s][c] > n.globals.minX && n.globals.seriesX[s][c] < n.globals.maxX && this.barCtx.visibleItems++;
            else this.barCtx.visibleItems = n.globals.dataPoints;
          this.barCtx.seriesLen === 0 && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], n.globals.comboCharts || this.checkZeroSeries({
            series: r
          })
        }
      }, {
        key: "initialPositions",
        value: function () {
          var r, n, s, c, u, d, f, g, b = this.w,
            y = b.globals.dataPoints;
          this.barCtx.isRangeBar && (y = b.globals.labels.length);
          var x = this.barCtx.seriesLen;
          if (b.config.plotOptions.bar.rangeBarGroupRows && (x = 1), this.barCtx.isHorizontal) u = (s = b.globals.gridHeight / y) / x, b.globals.isXNumeric && (u = (s = b.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), u = u * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, String(this.barCtx.barOptions.barHeight).indexOf("%") === -1 && (u = parseInt(this.barCtx.barOptions.barHeight, 10)), g = this.barCtx.baseLineInvertedY + b.globals.padHorizontal + (this.barCtx.isReversed ? b.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (g = b.globals.gridWidth / 2), n = (s - u * this.barCtx.seriesLen) / 2;
          else {
            if (c = b.globals.gridWidth / this.barCtx.visibleItems, b.config.xaxis.convertedCatToNumeric && (c = b.globals.gridWidth / b.globals.dataPoints), d = c / x * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, b.globals.isXNumeric) {
              var _ = this.barCtx.xRatio;
              b.globals.minXDiff && b.globals.minXDiff !== .5 && b.globals.minXDiff / _ > 0 && (c = b.globals.minXDiff / _), (d = c / x * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (d = 1)
            }
            String(this.barCtx.barOptions.columnWidth).indexOf("%") === -1 && (d = parseInt(this.barCtx.barOptions.columnWidth, 10)), f = b.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? b.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), r = b.globals.padHorizontal + (c - d * this.barCtx.seriesLen) / 2
          }
          return b.globals.barHeight = u, b.globals.barWidth = d, {
            x: r,
            y: n,
            yDivision: s,
            xDivision: c,
            barHeight: u,
            barWidth: d,
            zeroH: f,
            zeroW: g
          }
        }
      }, {
        key: "initializeStackedPrevVars",
        value: function (r) {
          var n = r.w;
          n.globals.hasSeriesGroups ? n.globals.seriesGroups.forEach(function (s) {
            r[s] || (r[s] = {}), r[s].prevY = [], r[s].prevX = [], r[s].prevYF = [], r[s].prevXF = [], r[s].prevYVal = [], r[s].prevXVal = []
          }) : (r.prevY = [], r.prevX = [], r.prevYF = [], r.prevXF = [], r.prevYVal = [], r.prevXVal = [])
        }
      }, {
        key: "initializeStackedXYVars",
        value: function (r) {
          var n = r.w;
          n.globals.hasSeriesGroups ? n.globals.seriesGroups.forEach(function (s) {
            r[s] || (r[s] = {}), r[s].xArrj = [], r[s].xArrjF = [], r[s].xArrjVal = [], r[s].yArrj = [], r[s].yArrjF = [], r[s].yArrjVal = []
          }) : (r.xArrj = [], r.xArrjF = [], r.xArrjVal = [], r.yArrj = [], r.yArrjF = [], r.yArrjVal = [])
        }
      }, {
        key: "getPathFillColor",
        value: function (r, n, s, c) {
          var u, d, f, g, b = this.w,
            y = new he(this.barCtx.ctx),
            x = null,
            _ = this.barCtx.barOptions.distributed ? s : n;
          return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function (T) {
            r[n][s] >= T.from && r[n][s] <= T.to && (x = T.color)
          }), b.config.series[n].data[s] && b.config.series[n].data[s].fillColor && (x = b.config.series[n].data[s].fillColor), y.fillPath({
            seriesNumber: this.barCtx.barOptions.distributed ? _ : c,
            dataPointIndex: s,
            color: x,
            value: r[n][s],
            fillConfig: (u = b.config.series[n].data[s]) === null || u === void 0 ? void 0 : u.fill,
            fillType: (d = b.config.series[n].data[s]) !== null && d !== void 0 && (f = d.fill) !== null && f !== void 0 && f.type ? (g = b.config.series[n].data[s]) === null || g === void 0 ? void 0 : g.fill.type : Array.isArray(b.config.fill.type) ? b.config.fill.type[n] : b.config.fill.type
          })
        }
      }, {
        key: "getStrokeWidth",
        value: function (r, n, s) {
          var c = 0,
            u = this.w;
          return this.barCtx.series[r][n] === void 0 || this.barCtx.series[r][n] === null ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, u.config.stroke.show && (this.barCtx.isNullValue || (c = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[s] : this.barCtx.strokeWidth)), c
        }
      }, {
        key: "shouldApplyRadius",
        value: function (r) {
          var n = this.w,
            s = !1;
          return n.config.plotOptions.bar.borderRadius > 0 && (n.config.chart.stacked && n.config.plotOptions.bar.borderRadiusWhenStacked === "last" ? this.barCtx.lastActiveBarSerieIndex === r && (s = !0) : s = !0), s
        }
      }, {
        key: "barBackground",
        value: function (r) {
          var n = r.j,
            s = r.i,
            c = r.x1,
            u = r.x2,
            d = r.y1,
            f = r.y2,
            g = r.elSeries,
            b = this.w,
            y = new W(this.barCtx.ctx),
            x = new Be(this.barCtx.ctx).getActiveConfigSeriesIndex();
          if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && x === s) {
            n >= this.barCtx.barOptions.colors.backgroundBarColors.length && (n %= this.barCtx.barOptions.colors.backgroundBarColors.length);
            var _ = this.barCtx.barOptions.colors.backgroundBarColors[n],
              T = y.drawRect(c !== void 0 ? c : 0, d !== void 0 ? d : 0, u !== void 0 ? u : b.globals.gridWidth, f !== void 0 ? f : b.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, _, this.barCtx.barOptions.colors.backgroundBarOpacity);
            g.add(T), T.node.classList.add("apexcharts-backgroundBar")
          }
        }
      }, {
        key: "getColumnPaths",
        value: function (r) {
          var n, s = r.barWidth,
            c = r.barXPosition,
            u = r.y1,
            d = r.y2,
            f = r.strokeWidth,
            g = r.seriesGroup,
            b = r.realIndex,
            y = r.i,
            x = r.j,
            _ = r.w,
            T = new W(this.barCtx.ctx);
          (f = Array.isArray(f) ? f[b] : f) || (f = 0);
          var P = s,
            O = c;
          (n = _.config.series[b].data[x]) !== null && n !== void 0 && n.columnWidthOffset && (O = c - _.config.series[b].data[x].columnWidthOffset / 2, P = s + _.config.series[b].data[x].columnWidthOffset);
          var $ = O,
            G = O + P;
          u += .001, d += .001;
          var Q = T.move($, u),
            v = T.move($, u),
            C = T.line(G - f, u);
          if (_.globals.previousPaths.length > 0 && (v = this.barCtx.getPreviousPath(b, x, !1)), Q = Q + T.line($, d) + T.line(G - f, d) + T.line(G - f, u) + (_.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), v = v + T.line($, u) + C + C + C + C + C + T.line($, u) + (_.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(b) && (Q = T.roundPathCorners(Q, _.config.plotOptions.bar.borderRadius)), _.config.chart.stacked) {
            var L = this.barCtx;
            _.globals.hasSeriesGroups && g && (L = this.barCtx[g]), L.yArrj.push(d), L.yArrjF.push(Math.abs(u - d)), L.yArrjVal.push(this.barCtx.series[y][x])
          }
          return {
            pathTo: Q,
            pathFrom: v
          }
        }
      }, {
        key: "getBarpaths",
        value: function (r) {
          var n, s = r.barYPosition,
            c = r.barHeight,
            u = r.x1,
            d = r.x2,
            f = r.strokeWidth,
            g = r.seriesGroup,
            b = r.realIndex,
            y = r.i,
            x = r.j,
            _ = r.w,
            T = new W(this.barCtx.ctx);
          (f = Array.isArray(f) ? f[b] : f) || (f = 0);
          var P = s,
            O = c;
          (n = _.config.series[b].data[x]) !== null && n !== void 0 && n.barHeightOffset && (P = s - _.config.series[b].data[x].barHeightOffset / 2, O = c + _.config.series[b].data[x].barHeightOffset);
          var $ = P,
            G = P + O;
          u += .001, d += .001;
          var Q = T.move(u, $),
            v = T.move(u, $);
          _.globals.previousPaths.length > 0 && (v = this.barCtx.getPreviousPath(b, x, !1));
          var C = T.line(u, G - f);
          if (Q = Q + T.line(d, $) + T.line(d, G - f) + C + (_.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), v = v + T.line(u, $) + C + C + C + C + C + T.line(u, $) + (_.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z"), this.shouldApplyRadius(b) && (Q = T.roundPathCorners(Q, _.config.plotOptions.bar.borderRadius)), _.config.chart.stacked) {
            var L = this.barCtx;
            _.globals.hasSeriesGroups && g && (L = this.barCtx[g]), L.xArrj.push(d), L.xArrjF.push(Math.abs(u - d)), L.xArrjVal.push(this.barCtx.series[y][x])
          }
          return {
            pathTo: Q,
            pathFrom: v
          }
        }
      }, {
        key: "checkZeroSeries",
        value: function (r) {
          for (var n = r.series, s = this.w, c = 0; c < n.length; c++) {
            for (var u = 0, d = 0; d < n[s.globals.maxValsInArrayIndex].length; d++) u += n[c][d];
            u === 0 && this.barCtx.zeroSerieses.push(c)
          }
        }
      }, {
        key: "getXForValue",
        value: function (r, n) {
          var s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? n : null;
          return r != null && (s = n + r / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? r / this.barCtx.invertedYRatio : 0)), s
        }
      }, {
        key: "getYForValue",
        value: function (r, n) {
          var s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2] ? n : null;
          return r != null && (s = n - r / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? r / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), s
        }
      }, {
        key: "getGoalValues",
        value: function (r, n, s, c, u) {
          var d = this,
            f = this.w,
            g = [],
            b = function (_, T) {
              var P;
              g.push((m(P = {}, r, r === "x" ? d.getXForValue(_, n, !1) : d.getYForValue(_, s, !1)), m(P, "attrs", T), P))
            };
          if (f.globals.seriesGoals[c] && f.globals.seriesGoals[c][u] && Array.isArray(f.globals.seriesGoals[c][u]) && f.globals.seriesGoals[c][u].forEach(function (_) {
              b(_.value, _)
            }), this.barCtx.barOptions.isDumbbell && f.globals.seriesRange.length) {
            var y = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : f.globals.colors,
              x = {
                strokeHeight: r === "x" ? 0 : f.globals.markers.size[c],
                strokeWidth: r === "x" ? f.globals.markers.size[c] : 0,
                strokeDashArray: 0,
                strokeLineCap: "round",
                strokeColor: Array.isArray(y[c]) ? y[c][0] : y[c]
              };
            b(f.globals.seriesRangeStart[c][u], x), b(f.globals.seriesRangeEnd[c][u], i(i({}, x), {}, {
              strokeColor: Array.isArray(y[c]) ? y[c][1] : y[c]
            }))
          }
          return g
        }
      }, {
        key: "drawGoalLine",
        value: function (r) {
          var n = r.barXPosition,
            s = r.barYPosition,
            c = r.goalX,
            u = r.goalY,
            d = r.barWidth,
            f = r.barHeight,
            g = new W(this.barCtx.ctx),
            b = g.group({
              className: "apexcharts-bar-goals-groups"
            });
          b.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({
            el: b.node
          }), b.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
          var y = null;
          return this.barCtx.isHorizontal ? Array.isArray(c) && c.forEach(function (x) {
            var _ = x.attrs.strokeHeight !== void 0 ? x.attrs.strokeHeight : f / 2,
              T = s + _ + f / 2;
            y = g.drawLine(x.x, T - 2 * _, x.x, T, x.attrs.strokeColor ? x.attrs.strokeColor : void 0, x.attrs.strokeDashArray, x.attrs.strokeWidth ? x.attrs.strokeWidth : 2, x.attrs.strokeLineCap), b.add(y)
          }) : Array.isArray(u) && u.forEach(function (x) {
            var _ = x.attrs.strokeWidth !== void 0 ? x.attrs.strokeWidth : d / 2,
              T = n + _ + d / 2;
            y = g.drawLine(T - 2 * _, x.y, T, x.y, x.attrs.strokeColor ? x.attrs.strokeColor : void 0, x.attrs.strokeDashArray, x.attrs.strokeHeight ? x.attrs.strokeHeight : 2, x.attrs.strokeLineCap), b.add(y)
          }), b
        }
      }, {
        key: "drawBarShadow",
        value: function (r) {
          var n = r.prevPaths,
            s = r.currPaths,
            c = r.color,
            u = this.w,
            d = n.x,
            f = n.x1,
            g = n.barYPosition,
            b = s.x,
            y = s.x1,
            x = s.barYPosition,
            _ = g + s.barHeight,
            T = new W(this.barCtx.ctx),
            P = new I,
            O = T.move(f, _) + T.line(d, _) + T.line(b, x) + T.line(y, x) + T.line(f, _) + (u.config.plotOptions.bar.borderRadiusApplication === "around" ? " Z" : " z");
          return T.drawPath({
            d: O,
            fill: P.shadeColor(.5, I.rgb2hex(c)),
            stroke: "none",
            strokeWidth: 0,
            fillOpacity: 1,
            classes: "apexcharts-bar-shadows"
          })
        }
      }, {
        key: "getZeroValueEncounters",
        value: function (r) {
          var n = r.i,
            s = r.j,
            c = this.w,
            u = 0,
            d = 0;
          return c.globals.seriesPercent.forEach(function (f, g) {
            f[s] && u++, g < n && f[s] === 0 && d++
          }), {
            nonZeroColumns: u,
            zeroEncounters: d
          }
        }
      }]), Y
    }(),
    et = function () {
      function Y(r, n) {
        l(this, Y), this.ctx = r, this.w = r.w;
        var s = this.w;
        this.barOptions = s.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s.config.stroke.width, this.isNullValue = !1, this.isRangeBar = s.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s.globals.isBarHorizontal && s.globals.seriesRange.length && s.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = n, this.xyRatios !== null && (this.xRatio = n.xRatio, this.yRatio = n.yRatio, this.invertedXRatio = n.invertedXRatio, this.invertedYRatio = n.invertedYRatio, this.baseLineY = n.baseLineY, this.baseLineInvertedY = n.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.pathArr = [];
        var c = new Be(this.ctx);
        this.lastActiveBarSerieIndex = c.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
        var u = c.getBarSeriesIndices(),
          d = new X(this.ctx);
        this.stackedSeriesTotals = d.getStackedSeriesTotals(this.w.config.series.map(function (f, g) {
          return u.indexOf(g) === -1 ? g : -1
        }).filter(function (f) {
          return f !== -1
        })), this.barHelpers = new ze(this)
      }
      return p(Y, [{
        key: "draw",
        value: function (r, n) {
          var s = this.w,
            c = new W(this.ctx),
            u = new X(this.ctx, s);
          r = u.getLogSeries(r), this.series = r, this.yRatio = u.getLogYRatios(this.yRatio), this.barHelpers.initVariables(r);
          var d = c.group({
            class: "apexcharts-bar-series apexcharts-plot-series"
          });
          s.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
          for (var f = 0, g = 0; f < r.length; f++, g++) {
            var b, y, x, _, T = void 0,
              P = void 0,
              O = [],
              $ = [],
              G = s.globals.comboCharts ? n[f] : f,
              Q = c.group({
                class: "apexcharts-series",
                rel: f + 1,
                seriesName: I.escapeString(s.globals.seriesNames[G]),
                "data:realIndex": G
              });
            this.ctx.series.addCollapsedClassToSeries(Q, G), r[f].length > 0 && (this.visibleI = this.visibleI + 1);
            var v = 0,
              C = 0;
            this.yRatio.length > 1 && (this.yaxisIndex = G), this.isReversed = s.config.yaxis[this.yaxisIndex] && s.config.yaxis[this.yaxisIndex].reversed;
            var L = this.barHelpers.initialPositions();
            P = L.y, v = L.barHeight, y = L.yDivision, _ = L.zeroW, T = L.x, C = L.barWidth, b = L.xDivision, x = L.zeroH, this.horizontal || $.push(T + C / 2);
            var H = c.group({
              class: "apexcharts-datalabels",
              "data:realIndex": G
            });
            s.globals.delayedElements.push({
              el: H.node
            }), H.node.classList.add("apexcharts-element-hidden");
            var q = c.group({
                class: "apexcharts-bar-goals-markers"
              }),
              ee = c.group({
                class: "apexcharts-bar-shadows"
              });
            s.globals.delayedElements.push({
              el: ee.node
            }), ee.node.classList.add("apexcharts-element-hidden");
            for (var ge = 0; ge < s.globals.dataPoints; ge++) {
              var pe = this.barHelpers.getStrokeWidth(f, ge, G),
                Fe = null,
                Ue = {
                  indexes: {
                    i: f,
                    j: ge,
                    realIndex: G,
                    bc: g
                  },
                  x: T,
                  y: P,
                  strokeWidth: pe,
                  elSeries: Q
                };
              this.isHorizontal ? (Fe = this.drawBarPaths(i(i({}, Ue), {}, {
                barHeight: v,
                zeroW: _,
                yDivision: y
              })), C = this.series[f][ge] / this.invertedYRatio) : (Fe = this.drawColumnPaths(i(i({}, Ue), {}, {
                xDivision: b,
                barWidth: C,
                zeroH: x
              })), v = this.series[f][ge] / this.yRatio[this.yaxisIndex]);
              var Ve = this.barHelpers.getPathFillColor(r, f, ge, G);
              if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && ge > 0) {
                var it = this.barHelpers.drawBarShadow({
                  color: typeof Ve == "string" && (Ve == null ? void 0 : Ve.indexOf("url")) === -1 ? Ve : I.hexToRgba(s.globals.colors[f]),
                  prevPaths: this.pathArr[this.pathArr.length - 1],
                  currPaths: Fe
                });
                it && ee.add(it)
              }
              this.pathArr.push(Fe);
              var dt = this.barHelpers.drawGoalLine({
                barXPosition: Fe.barXPosition,
                barYPosition: Fe.barYPosition,
                goalX: Fe.goalX,
                goalY: Fe.goalY,
                barHeight: v,
                barWidth: C
              });
              dt && q.add(dt), P = Fe.y, T = Fe.x, ge > 0 && $.push(T + C / 2), O.push(P), this.renderSeries({
                realIndex: G,
                pathFill: Ve,
                j: ge,
                i: f,
                pathFrom: Fe.pathFrom,
                pathTo: Fe.pathTo,
                strokeWidth: pe,
                elSeries: Q,
                x: T,
                y: P,
                series: r,
                barHeight: Fe.barHeight ? Fe.barHeight : v,
                barWidth: Fe.barWidth ? Fe.barWidth : C,
                elDataLabelsWrap: H,
                elGoalsMarkers: q,
                elBarShadows: ee,
                visibleSeries: this.visibleI,
                type: "bar"
              })
            }
            s.globals.seriesXvalues[G] = $, s.globals.seriesYvalues[G] = O, d.add(Q)
          }
          return d
        }
      }, {
        key: "renderSeries",
        value: function (r) {
          var n = r.realIndex,
            s = r.pathFill,
            c = r.lineFill,
            u = r.j,
            d = r.i,
            f = r.groupIndex,
            g = r.pathFrom,
            b = r.pathTo,
            y = r.strokeWidth,
            x = r.elSeries,
            _ = r.x,
            T = r.y,
            P = r.y1,
            O = r.y2,
            $ = r.series,
            G = r.barHeight,
            Q = r.barWidth,
            v = r.barXPosition,
            C = r.barYPosition,
            L = r.elDataLabelsWrap,
            H = r.elGoalsMarkers,
            q = r.elBarShadows,
            ee = r.visibleSeries,
            ge = r.type,
            pe = this.w,
            Fe = new W(this.ctx);
          c || (c = this.barOptions.distributed ? pe.globals.stroke.colors[u] : pe.globals.stroke.colors[n]), pe.config.series[d].data[u] && pe.config.series[d].data[u].strokeColor && (c = pe.config.series[d].data[u].strokeColor), this.isNullValue && (s = "none");
          var Ue = u / pe.config.chart.animations.animateGradually.delay * (pe.config.chart.animations.speed / pe.globals.dataPoints) / 2.4,
            Ve = Fe.renderPaths({
              i: d,
              j: u,
              realIndex: n,
              pathFrom: g,
              pathTo: b,
              stroke: c,
              strokeWidth: y,
              strokeLineCap: pe.config.stroke.lineCap,
              fill: s,
              animationDelay: Ue,
              initialSpeed: pe.config.chart.animations.speed,
              dataChangeSpeed: pe.config.chart.animations.dynamicAnimation.speed,
              className: "apexcharts-".concat(ge, "-area")
            });
          Ve.attr("clip-path", "url(#gridRectMask".concat(pe.globals.cuid, ")"));
          var it = pe.config.forecastDataPoints;
          it.count > 0 && u >= pe.globals.dataPoints - it.count && (Ve.node.setAttribute("stroke-dasharray", it.dashArray), Ve.node.setAttribute("stroke-width", it.strokeWidth), Ve.node.setAttribute("fill-opacity", it.fillOpacity)), P !== void 0 && O !== void 0 && (Ve.attr("data-range-y1", P), Ve.attr("data-range-y2", O)), new U(this.ctx).setSelectionFilter(Ve, n, u), x.add(Ve);
          var dt = new rt(this).handleBarDataLabels({
            x: _,
            y: T,
            y1: P,
            y2: O,
            i: d,
            j: u,
            series: $,
            realIndex: n,
            groupIndex: f,
            barHeight: G,
            barWidth: Q,
            barXPosition: v,
            barYPosition: C,
            renderedPath: Ve,
            visibleSeries: ee
          });
          return dt.dataLabels !== null && L.add(dt.dataLabels), dt.totalDataLabels && L.add(dt.totalDataLabels), x.add(L), H && x.add(H), q && x.add(q), x
        }
      }, {
        key: "drawBarPaths",
        value: function (r) {
          var n, s = r.indexes,
            c = r.barHeight,
            u = r.strokeWidth,
            d = r.zeroW,
            f = r.x,
            g = r.y,
            b = r.yDivision,
            y = r.elSeries,
            x = this.w,
            _ = s.i,
            T = s.j;
          if (x.globals.isXNumeric) n = (g = (x.globals.seriesX[_][T] - x.globals.minX) / this.invertedXRatio - c) + c * this.visibleI;
          else if (x.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
            var P = 0,
              O = 0;
            x.globals.seriesPercent.forEach(function (G, Q) {
              G[T] && P++, Q < _ && G[T] === 0 && O++
            }), P > 0 && (c = this.seriesLen * c / P), n = g + c * this.visibleI, n -= c * O
          } else n = g + c * this.visibleI;
          this.isFunnel && (d -= (this.barHelpers.getXForValue(this.series[_][T], d) - d) / 2), f = this.barHelpers.getXForValue(this.series[_][T], d);
          var $ = this.barHelpers.getBarpaths({
            barYPosition: n,
            barHeight: c,
            x1: d,
            x2: f,
            strokeWidth: u,
            series: this.series,
            realIndex: s.realIndex,
            i: _,
            j: T,
            w: x
          });
          return x.globals.isXNumeric || (g += b), this.barHelpers.barBackground({
            j: T,
            i: _,
            y1: n - c * this.visibleI,
            y2: c * this.seriesLen,
            elSeries: y
          }), {
            pathTo: $.pathTo,
            pathFrom: $.pathFrom,
            x1: d,
            x: f,
            y: g,
            goalX: this.barHelpers.getGoalValues("x", d, null, _, T),
            barYPosition: n,
            barHeight: c
          }
        }
      }, {
        key: "drawColumnPaths",
        value: function (r) {
          var n, s = r.indexes,
            c = r.x,
            u = r.y,
            d = r.xDivision,
            f = r.barWidth,
            g = r.zeroH,
            b = r.strokeWidth,
            y = r.elSeries,
            x = this.w,
            _ = s.realIndex,
            T = s.i,
            P = s.j,
            O = s.bc;
          if (x.globals.isXNumeric) {
            var $ = this.getBarXForNumericXAxis({
              x: c,
              j: P,
              realIndex: _,
              barWidth: f
            });
            c = $.x, n = $.barXPosition
          } else if (x.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
            var G = this.barHelpers.getZeroValueEncounters({
                i: T,
                j: P
              }),
              Q = G.nonZeroColumns,
              v = G.zeroEncounters;
            Q > 0 && (f = this.seriesLen * f / Q), n = c + f * this.visibleI, n -= f * v
          } else n = c + f * this.visibleI;
          u = this.barHelpers.getYForValue(this.series[T][P], g);
          var C = this.barHelpers.getColumnPaths({
            barXPosition: n,
            barWidth: f,
            y1: g,
            y2: u,
            strokeWidth: b,
            series: this.series,
            realIndex: s.realIndex,
            i: T,
            j: P,
            w: x
          });
          return x.globals.isXNumeric || (c += d), this.barHelpers.barBackground({
            bc: O,
            j: P,
            i: T,
            x1: n - b / 2 - f * this.visibleI,
            x2: f * this.seriesLen + b / 2,
            elSeries: y
          }), {
            pathTo: C.pathTo,
            pathFrom: C.pathFrom,
            x: c,
            y: u,
            goalY: this.barHelpers.getGoalValues("y", null, g, T, P),
            barXPosition: n,
            barWidth: f
          }
        }
      }, {
        key: "getBarXForNumericXAxis",
        value: function (r) {
          var n = r.x,
            s = r.barWidth,
            c = r.realIndex,
            u = r.j,
            d = this.w,
            f = c;
          return d.globals.seriesX[c].length || (f = d.globals.maxValsInArrayIndex), d.globals.seriesX[f][u] && (n = (d.globals.seriesX[f][u] - d.globals.minX) / this.xRatio - s * this.seriesLen / 2), {
            barXPosition: n + s * this.visibleI,
            x: n
          }
        }
      }, {
        key: "getPreviousPath",
        value: function (r, n) {
          for (var s, c = this.w, u = 0; u < c.globals.previousPaths.length; u++) {
            var d = c.globals.previousPaths[u];
            d.paths && d.paths.length > 0 && parseInt(d.realIndex, 10) === parseInt(r, 10) && c.globals.previousPaths[u].paths[n] !== void 0 && (s = c.globals.previousPaths[u].paths[n].d)
          }
          return s
        }
      }]), Y
    }(),
    ct = function (Y) {
      k(n, et);
      var r = E(n);

      function n() {
        return l(this, n), r.apply(this, arguments)
      }
      return p(n, [{
        key: "draw",
        value: function (s, c) {
          var u = this,
            d = this.w;
          this.graphics = new W(this.ctx), this.bar = new et(this.ctx, this.xyRatios);
          var f = new X(this.ctx, d);
          s = f.getLogSeries(s), this.yRatio = f.getLogYRatios(this.yRatio), this.barHelpers.initVariables(s), d.config.chart.stackType === "100%" && (s = d.globals.seriesPercent.slice()), this.series = s, this.barHelpers.initializeStackedPrevVars(this);
          for (var g = this.graphics.group({
              class: "apexcharts-bar-series apexcharts-plot-series"
            }), b = 0, y = 0, x = function (P, O) {
              var $ = void 0,
                G = void 0,
                Q = void 0,
                v = void 0,
                C = -1;
              u.groupCtx = u, d.globals.seriesGroups.forEach(function (qt, sa) {
                qt.indexOf(d.config.series[P].name) > -1 && (C = sa)
              }), C !== -1 && (u.groupCtx = u[d.globals.seriesGroups[C]]);
              var L = [],
                H = [],
                q = d.globals.comboCharts ? c[P] : P;
              u.yRatio.length > 1 && (u.yaxisIndex = q), u.isReversed = d.config.yaxis[u.yaxisIndex] && d.config.yaxis[u.yaxisIndex].reversed;
              var ee = u.graphics.group({
                class: "apexcharts-series",
                seriesName: I.escapeString(d.globals.seriesNames[q]),
                rel: P + 1,
                "data:realIndex": q
              });
              u.ctx.series.addCollapsedClassToSeries(ee, q);
              var ge = u.graphics.group({
                  class: "apexcharts-datalabels",
                  "data:realIndex": q
                }),
                pe = u.graphics.group({
                  class: "apexcharts-bar-goals-markers"
                }),
                Fe = 0,
                Ue = 0,
                Ve = u.initialPositions(b, y, $, G, Q, v);
              y = Ve.y, Fe = Ve.barHeight, G = Ve.yDivision, v = Ve.zeroW, b = Ve.x, Ue = Ve.barWidth, $ = Ve.xDivision, Q = Ve.zeroH, d.globals.barHeight = Fe, d.globals.barWidth = Ue, u.barHelpers.initializeStackedXYVars(u), u.groupCtx.prevY.length === 1 && u.groupCtx.prevY[0].every(function (qt) {
                return isNaN(qt)
              }) && (u.groupCtx.prevY[0] = u.groupCtx.prevY[0].map(function (qt) {
                return Q
              }), u.groupCtx.prevYF[0] = u.groupCtx.prevYF[0].map(function (qt) {
                return 0
              }));
              for (var it = 0; it < d.globals.dataPoints; it++) {
                var dt = u.barHelpers.getStrokeWidth(P, it, q),
                  mt = {
                    indexes: {
                      i: P,
                      j: it,
                      realIndex: q,
                      bc: O
                    },
                    strokeWidth: dt,
                    x: b,
                    y,
                    elSeries: ee,
                    groupIndex: C,
                    seriesGroup: d.globals.seriesGroups[C]
                  },
                  At = null;
                u.isHorizontal ? (At = u.drawStackedBarPaths(i(i({}, mt), {}, {
                  zeroW: v,
                  barHeight: Fe,
                  yDivision: G
                })), Ue = u.series[P][it] / u.invertedYRatio) : (At = u.drawStackedColumnPaths(i(i({}, mt), {}, {
                  xDivision: $,
                  barWidth: Ue,
                  zeroH: Q
                })), Fe = u.series[P][it] / u.yRatio[u.yaxisIndex]);
                var _t = u.barHelpers.drawGoalLine({
                  barXPosition: At.barXPosition,
                  barYPosition: At.barYPosition,
                  goalX: At.goalX,
                  goalY: At.goalY,
                  barHeight: Fe,
                  barWidth: Ue
                });
                _t && pe.add(_t), y = At.y, b = At.x, L.push(b), H.push(y);
                var Et = u.barHelpers.getPathFillColor(s, P, it, q);
                ee = u.renderSeries({
                  realIndex: q,
                  pathFill: Et,
                  j: it,
                  i: P,
                  groupIndex: C,
                  pathFrom: At.pathFrom,
                  pathTo: At.pathTo,
                  strokeWidth: dt,
                  elSeries: ee,
                  x: b,
                  y,
                  series: s,
                  barHeight: Fe,
                  barWidth: Ue,
                  elDataLabelsWrap: ge,
                  elGoalsMarkers: pe,
                  type: "bar",
                  visibleSeries: 0
                })
              }
              d.globals.seriesXvalues[q] = L, d.globals.seriesYvalues[q] = H, u.groupCtx.prevY.push(u.groupCtx.yArrj), u.groupCtx.prevYF.push(u.groupCtx.yArrjF), u.groupCtx.prevYVal.push(u.groupCtx.yArrjVal), u.groupCtx.prevX.push(u.groupCtx.xArrj), u.groupCtx.prevXF.push(u.groupCtx.xArrjF), u.groupCtx.prevXVal.push(u.groupCtx.xArrjVal), g.add(ee)
            }, _ = 0, T = 0; _ < s.length; _++, T++) x(_, T);
          return g
        }
      }, {
        key: "initialPositions",
        value: function (s, c, u, d, f, g) {
          var b, y, x, _, T = this.w;
          return this.isHorizontal ? (x = (x = d = T.globals.gridHeight / T.globals.dataPoints) * parseInt(T.config.plotOptions.bar.barHeight, 10) / 100, String(T.config.plotOptions.bar.barHeight).indexOf("%") === -1 && (x = parseInt(T.config.plotOptions.bar.barHeight, 10)), g = this.baseLineInvertedY + T.globals.padHorizontal + (this.isReversed ? T.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), c = (d - x) / 2) : (_ = u = T.globals.gridWidth / T.globals.dataPoints, _ = T.globals.isXNumeric && T.globals.dataPoints > 1 ? (u = T.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : _ * parseInt(T.config.plotOptions.bar.columnWidth, 10) / 100, String(T.config.plotOptions.bar.columnWidth).indexOf("%") === -1 && (_ = parseInt(T.config.plotOptions.bar.columnWidth, 10)), f = T.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? T.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), s = T.globals.padHorizontal + (u - _) / 2), {
            x: s,
            y: c,
            yDivision: d,
            xDivision: u,
            barHeight: (b = T.globals.seriesGroups) !== null && b !== void 0 && b.length ? x / T.globals.seriesGroups.length : x,
            barWidth: (y = T.globals.seriesGroups) !== null && y !== void 0 && y.length ? _ / T.globals.seriesGroups.length : _,
            zeroH: f,
            zeroW: g
          }
        }
      }, {
        key: "drawStackedBarPaths",
        value: function (s) {
          for (var c, u = s.indexes, d = s.barHeight, f = s.strokeWidth, g = s.zeroW, b = s.x, y = s.y, x = s.groupIndex, _ = s.seriesGroup, T = s.yDivision, P = s.elSeries, O = this.w, $ = y + (x !== -1 ? x * d : 0), G = u.i, Q = u.j, v = 0, C = 0; C < this.groupCtx.prevXF.length; C++) v += this.groupCtx.prevXF[C][Q];
          var L = G;
          if (_ && (L = _.indexOf(O.config.series[G].name)), L > 0) {
            var H = g;
            this.groupCtx.prevXVal[L - 1][Q] < 0 ? H = this.series[G][Q] >= 0 ? this.groupCtx.prevX[L - 1][Q] + v - 2 * (this.isReversed ? v : 0) : this.groupCtx.prevX[L - 1][Q] : this.groupCtx.prevXVal[L - 1][Q] >= 0 && (H = this.series[G][Q] >= 0 ? this.groupCtx.prevX[L - 1][Q] : this.groupCtx.prevX[L - 1][Q] - v + 2 * (this.isReversed ? v : 0)), c = H
          } else c = g;
          b = this.series[G][Q] === null ? c : c + this.series[G][Q] / this.invertedYRatio - 2 * (this.isReversed ? this.series[G][Q] / this.invertedYRatio : 0);
          var q = this.barHelpers.getBarpaths({
            barYPosition: $,
            barHeight: d,
            x1: c,
            x2: b,
            strokeWidth: f,
            series: this.series,
            realIndex: u.realIndex,
            seriesGroup: _,
            i: G,
            j: Q,
            w: O
          });
          return this.barHelpers.barBackground({
            j: Q,
            i: G,
            y1: $,
            y2: d,
            elSeries: P
          }), y += T, {
            pathTo: q.pathTo,
            pathFrom: q.pathFrom,
            goalX: this.barHelpers.getGoalValues("x", g, null, G, Q),
            barYPosition: $,
            x: b,
            y
          }
        }
      }, {
        key: "drawStackedColumnPaths",
        value: function (s) {
          var c = s.indexes,
            u = s.x,
            d = s.y,
            f = s.xDivision,
            g = s.barWidth,
            b = s.zeroH,
            y = s.groupIndex,
            x = s.seriesGroup,
            _ = s.elSeries,
            T = this.w,
            P = c.i,
            O = c.j,
            $ = c.bc;
          if (T.globals.isXNumeric) {
            var G = T.globals.seriesX[P][O];
            G || (G = 0), u = (G - T.globals.minX) / this.xRatio - g / 2, T.globals.seriesGroups.length && (u = (G - T.globals.minX) / this.xRatio - g / 2 * T.globals.seriesGroups.length)
          }
          for (var Q, v = u + (y !== -1 ? y * g : 0), C = 0, L = 0; L < this.groupCtx.prevYF.length; L++) C += isNaN(this.groupCtx.prevYF[L][O]) ? 0 : this.groupCtx.prevYF[L][O];
          var H = P;
          if (x && (H = x.indexOf(T.config.series[P].name)), H > 0 && !T.globals.isXNumeric || H > 0 && T.globals.isXNumeric && T.globals.seriesX[P - 1][O] === T.globals.seriesX[P][O]) {
            var q, ee, ge, pe = Math.min(this.yRatio.length + 1, P + 1);
            if (this.groupCtx.prevY[H - 1] !== void 0 && this.groupCtx.prevY[H - 1].length)
              for (var Fe = 1; Fe < pe; Fe++) {
                var Ue;
                if (!isNaN((Ue = this.groupCtx.prevY[H - Fe]) === null || Ue === void 0 ? void 0 : Ue[O])) {
                  ge = this.groupCtx.prevY[H - Fe][O];
                  break
                }
              }
            for (var Ve = 1; Ve < pe; Ve++) {
              var it, dt;
              if (((it = this.groupCtx.prevYVal[H - Ve]) === null || it === void 0 ? void 0 : it[O]) < 0) {
                ee = this.series[P][O] >= 0 ? ge - C + 2 * (this.isReversed ? C : 0) : ge;
                break
              }
              if (((dt = this.groupCtx.prevYVal[H - Ve]) === null || dt === void 0 ? void 0 : dt[O]) >= 0) {
                ee = this.series[P][O] >= 0 ? ge : ge + C - 2 * (this.isReversed ? C : 0);
                break
              }
            }
            ee === void 0 && (ee = T.globals.gridHeight), Q = (q = this.groupCtx.prevYF[0]) !== null && q !== void 0 && q.every(function (At) {
              return At === 0
            }) && this.groupCtx.prevYF.slice(1, H).every(function (At) {
              return At.every(function (_t) {
                return isNaN(_t)
              })
            }) ? b : ee
          } else Q = b;
          d = this.series[P][O] ? Q - this.series[P][O] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[P][O] / this.yRatio[this.yaxisIndex] : 0) : Q;
          var mt = this.barHelpers.getColumnPaths({
            barXPosition: v,
            barWidth: g,
            y1: Q,
            y2: d,
            yRatio: this.yRatio[this.yaxisIndex],
            strokeWidth: this.strokeWidth,
            series: this.series,
            seriesGroup: x,
            realIndex: c.realIndex,
            i: P,
            j: O,
            w: T
          });
          return this.barHelpers.barBackground({
            bc: $,
            j: O,
            i: P,
            x1: v,
            x2: g,
            elSeries: _
          }), u += f, {
            pathTo: mt.pathTo,
            pathFrom: mt.pathFrom,
            goalY: this.barHelpers.getGoalValues("y", null, b, P, O),
            barXPosition: v,
            x: T.globals.isXNumeric ? u - f : u,
            y: d
          }
        }
      }]), n
    }(),
    ca = function (Y) {
      k(n, et);
      var r = E(n);

      function n() {
        return l(this, n), r.apply(this, arguments)
      }
      return p(n, [{
        key: "draw",
        value: function (s, c, u) {
          var d = this,
            f = this.w,
            g = new W(this.ctx),
            b = f.globals.comboCharts ? c : f.config.chart.type,
            y = new he(this.ctx);
          this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = f.config.plotOptions.bar.horizontal;
          var x = new X(this.ctx, f);
          s = x.getLogSeries(s), this.series = s, this.yRatio = x.getLogYRatios(this.yRatio), this.barHelpers.initVariables(s);
          for (var _ = g.group({
              class: "apexcharts-".concat(b, "-series apexcharts-plot-series")
            }), T = function (O) {
              d.isBoxPlot = f.config.chart.type === "boxPlot" || f.config.series[O].type === "boxPlot";
              var $, G, Q, v, C = void 0,
                L = void 0,
                H = [],
                q = [],
                ee = f.globals.comboCharts ? u[O] : O,
                ge = g.group({
                  class: "apexcharts-series",
                  seriesName: I.escapeString(f.globals.seriesNames[ee]),
                  rel: O + 1,
                  "data:realIndex": ee
                });
              d.ctx.series.addCollapsedClassToSeries(ge, ee), s[O].length > 0 && (d.visibleI = d.visibleI + 1);
              var pe, Fe;
              d.yRatio.length > 1 && (d.yaxisIndex = ee);
              var Ue = d.barHelpers.initialPositions();
              L = Ue.y, pe = Ue.barHeight, G = Ue.yDivision, v = Ue.zeroW, C = Ue.x, Fe = Ue.barWidth, $ = Ue.xDivision, Q = Ue.zeroH, q.push(C + Fe / 2);
              for (var Ve = g.group({
                  class: "apexcharts-datalabels",
                  "data:realIndex": ee
                }), it = function (mt) {
                  var At = d.barHelpers.getStrokeWidth(O, mt, ee),
                    _t = null,
                    Et = {
                      indexes: {
                        i: O,
                        j: mt,
                        realIndex: ee
                      },
                      x: C,
                      y: L,
                      strokeWidth: At,
                      elSeries: ge
                    };
                  _t = d.isHorizontal ? d.drawHorizontalBoxPaths(i(i({}, Et), {}, {
                    yDivision: G,
                    barHeight: pe,
                    zeroW: v
                  })) : d.drawVerticalBoxPaths(i(i({}, Et), {}, {
                    xDivision: $,
                    barWidth: Fe,
                    zeroH: Q
                  })), L = _t.y, C = _t.x, mt > 0 && q.push(C + Fe / 2), H.push(L), _t.pathTo.forEach(function (qt, sa) {
                    var wr = !d.isBoxPlot && d.candlestickOptions.wick.useFillColor ? _t.color[sa] : f.globals.stroke.colors[O],
                      Ya = y.fillPath({
                        seriesNumber: ee,
                        dataPointIndex: mt,
                        color: _t.color[sa],
                        value: s[O][mt]
                      });
                    d.renderSeries({
                      realIndex: ee,
                      pathFill: Ya,
                      lineFill: wr,
                      j: mt,
                      i: O,
                      pathFrom: _t.pathFrom,
                      pathTo: qt,
                      strokeWidth: At,
                      elSeries: ge,
                      x: C,
                      y: L,
                      series: s,
                      barHeight: pe,
                      barWidth: Fe,
                      elDataLabelsWrap: Ve,
                      visibleSeries: d.visibleI,
                      type: f.config.chart.type
                    })
                  })
                }, dt = 0; dt < f.globals.dataPoints; dt++) it(dt);
              f.globals.seriesXvalues[ee] = q, f.globals.seriesYvalues[ee] = H, _.add(ge)
            }, P = 0; P < s.length; P++) T(P);
          return _
        }
      }, {
        key: "drawVerticalBoxPaths",
        value: function (s) {
          var c = s.indexes,
            u = s.x;
          s.y;
          var d = s.xDivision,
            f = s.barWidth,
            g = s.zeroH,
            b = s.strokeWidth,
            y = this.w,
            x = new W(this.ctx),
            _ = c.i,
            T = c.j,
            P = !0,
            O = y.config.plotOptions.candlestick.colors.upward,
            $ = y.config.plotOptions.candlestick.colors.downward,
            G = "";
          this.isBoxPlot && (G = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
          var Q = this.yRatio[this.yaxisIndex],
            v = c.realIndex,
            C = this.getOHLCValue(v, T),
            L = g,
            H = g;
          C.o > C.c && (P = !1);
          var q = Math.min(C.o, C.c),
            ee = Math.max(C.o, C.c),
            ge = C.m;
          y.globals.isXNumeric && (u = (y.globals.seriesX[v][T] - y.globals.minX) / this.xRatio - f / 2);
          var pe = u + f * this.visibleI;
          this.series[_][T] === void 0 || this.series[_][T] === null ? (q = g, ee = g) : (q = g - q / Q, ee = g - ee / Q, L = g - C.h / Q, H = g - C.l / Q, ge = g - C.m / Q);
          var Fe = x.move(pe, g),
            Ue = x.move(pe + f / 2, q);
          return y.globals.previousPaths.length > 0 && (Ue = this.getPreviousPath(v, T, !0)), Fe = this.isBoxPlot ? [x.move(pe, q) + x.line(pe + f / 2, q) + x.line(pe + f / 2, L) + x.line(pe + f / 4, L) + x.line(pe + f - f / 4, L) + x.line(pe + f / 2, L) + x.line(pe + f / 2, q) + x.line(pe + f, q) + x.line(pe + f, ge) + x.line(pe, ge) + x.line(pe, q + b / 2), x.move(pe, ge) + x.line(pe + f, ge) + x.line(pe + f, ee) + x.line(pe + f / 2, ee) + x.line(pe + f / 2, H) + x.line(pe + f - f / 4, H) + x.line(pe + f / 4, H) + x.line(pe + f / 2, H) + x.line(pe + f / 2, ee) + x.line(pe, ee) + x.line(pe, ge) + "z"] : [x.move(pe, ee) + x.line(pe + f / 2, ee) + x.line(pe + f / 2, L) + x.line(pe + f / 2, ee) + x.line(pe + f, ee) + x.line(pe + f, q) + x.line(pe + f / 2, q) + x.line(pe + f / 2, H) + x.line(pe + f / 2, q) + x.line(pe, q) + x.line(pe, ee - b / 2)], Ue += x.move(pe, q), y.globals.isXNumeric || (u += d), {
            pathTo: Fe,
            pathFrom: Ue,
            x: u,
            y: ee,
            barXPosition: pe,
            color: this.isBoxPlot ? G : P ? [O] : [$]
          }
        }
      }, {
        key: "drawHorizontalBoxPaths",
        value: function (s) {
          var c = s.indexes;
          s.x;
          var u = s.y,
            d = s.yDivision,
            f = s.barHeight,
            g = s.zeroW,
            b = s.strokeWidth,
            y = this.w,
            x = new W(this.ctx),
            _ = c.i,
            T = c.j,
            P = this.boxOptions.colors.lower;
          this.isBoxPlot && (P = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
          var O = this.invertedYRatio,
            $ = c.realIndex,
            G = this.getOHLCValue($, T),
            Q = g,
            v = g,
            C = Math.min(G.o, G.c),
            L = Math.max(G.o, G.c),
            H = G.m;
          y.globals.isXNumeric && (u = (y.globals.seriesX[$][T] - y.globals.minX) / this.invertedXRatio - f / 2);
          var q = u + f * this.visibleI;
          this.series[_][T] === void 0 || this.series[_][T] === null ? (C = g, L = g) : (C = g + C / O, L = g + L / O, Q = g + G.h / O, v = g + G.l / O, H = g + G.m / O);
          var ee = x.move(g, q),
            ge = x.move(C, q + f / 2);
          return y.globals.previousPaths.length > 0 && (ge = this.getPreviousPath($, T, !0)), ee = [x.move(C, q) + x.line(C, q + f / 2) + x.line(Q, q + f / 2) + x.line(Q, q + f / 2 - f / 4) + x.line(Q, q + f / 2 + f / 4) + x.line(Q, q + f / 2) + x.line(C, q + f / 2) + x.line(C, q + f) + x.line(H, q + f) + x.line(H, q) + x.line(C + b / 2, q), x.move(H, q) + x.line(H, q + f) + x.line(L, q + f) + x.line(L, q + f / 2) + x.line(v, q + f / 2) + x.line(v, q + f - f / 4) + x.line(v, q + f / 4) + x.line(v, q + f / 2) + x.line(L, q + f / 2) + x.line(L, q) + x.line(H, q) + "z"], ge += x.move(C, q), y.globals.isXNumeric || (u += d), {
            pathTo: ee,
            pathFrom: ge,
            x: L,
            y: u,
            barYPosition: q,
            color: P
          }
        }
      }, {
        key: "getOHLCValue",
        value: function (s, c) {
          var u = this.w;
          return {
            o: this.isBoxPlot ? u.globals.seriesCandleH[s][c] : u.globals.seriesCandleO[s][c],
            h: this.isBoxPlot ? u.globals.seriesCandleO[s][c] : u.globals.seriesCandleH[s][c],
            m: u.globals.seriesCandleM[s][c],
            l: this.isBoxPlot ? u.globals.seriesCandleC[s][c] : u.globals.seriesCandleL[s][c],
            c: this.isBoxPlot ? u.globals.seriesCandleL[s][c] : u.globals.seriesCandleC[s][c]
          }
        }
      }]), n
    }(),
    Oa = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "checkColorRange",
        value: function () {
          var r = this.w,
            n = !1,
            s = r.config.plotOptions[r.config.chart.type];
          return s.colorScale.ranges.length > 0 && s.colorScale.ranges.map(function (c, u) {
            c.from <= 0 && (n = !0)
          }), n
        }
      }, {
        key: "getShadeColor",
        value: function (r, n, s, c) {
          var u = this.w,
            d = 1,
            f = u.config.plotOptions[r].shadeIntensity,
            g = this.determineColor(r, n, s);
          u.globals.hasNegs || c ? d = u.config.plotOptions[r].reverseNegativeShade ? g.percent < 0 ? g.percent / 100 * (1.25 * f) : (1 - g.percent / 100) * (1.25 * f) : g.percent <= 0 ? 1 - (1 + g.percent / 100) * f : (1 - g.percent / 100) * f : (d = 1 - g.percent / 100, r === "treemap" && (d = (1 - g.percent / 100) * (1.25 * f)));
          var b = g.color,
            y = new I;
          return u.config.plotOptions[r].enableShades && (b = this.w.config.theme.mode === "dark" ? I.hexToRgba(y.shadeColor(-1 * d, g.color), u.config.fill.opacity) : I.hexToRgba(y.shadeColor(d, g.color), u.config.fill.opacity)), {
            color: b,
            colorProps: g
          }
        }
      }, {
        key: "determineColor",
        value: function (r, n, s) {
          var c = this.w,
            u = c.globals.series[n][s],
            d = c.config.plotOptions[r],
            f = d.colorScale.inverse ? s : n;
          d.distributed && c.config.chart.type === "treemap" && (f = s);
          var g = c.globals.colors[f],
            b = null,
            y = Math.min.apply(Math, D(c.globals.series[n])),
            x = Math.max.apply(Math, D(c.globals.series[n]));
          d.distributed || r !== "heatmap" || (y = c.globals.minY, x = c.globals.maxY), d.colorScale.min !== void 0 && (y = d.colorScale.min < c.globals.minY ? d.colorScale.min : c.globals.minY, x = d.colorScale.max > c.globals.maxY ? d.colorScale.max : c.globals.maxY);
          var _ = Math.abs(x) + Math.abs(y),
            T = 100 * u / (_ === 0 ? _ - 1e-6 : _);
          return d.colorScale.ranges.length > 0 && d.colorScale.ranges.map(function (P, O) {
            if (u >= P.from && u <= P.to) {
              g = P.color, b = P.foreColor ? P.foreColor : null, y = P.from, x = P.to;
              var $ = Math.abs(x) + Math.abs(y);
              T = 100 * u / ($ === 0 ? $ - 1e-6 : $)
            }
          }), {
            color: g,
            foreColor: b,
            percent: T
          }
        }
      }, {
        key: "calculateDataLabels",
        value: function (r) {
          var n = r.text,
            s = r.x,
            c = r.y,
            u = r.i,
            d = r.j,
            f = r.colorProps,
            g = r.fontSize,
            b = this.w.config.dataLabels,
            y = new W(this.ctx),
            x = new Se(this.ctx),
            _ = null;
          if (b.enabled) {
            _ = y.group({
              class: "apexcharts-data-labels"
            });
            var T = b.offsetX,
              P = b.offsetY,
              O = s + T,
              $ = c + parseFloat(b.style.fontSize) / 3 + P;
            x.plotDataLabelsText({
              x: O,
              y: $,
              text: n,
              i: u,
              j: d,
              color: f.foreColor,
              parent: _,
              fontSize: g,
              dataLabelsConfig: b
            })
          }
          return _
        }
      }, {
        key: "addListeners",
        value: function (r) {
          var n = new W(this.ctx);
          r.node.addEventListener("mouseenter", n.pathMouseEnter.bind(this, r)), r.node.addEventListener("mouseleave", n.pathMouseLeave.bind(this, r)), r.node.addEventListener("mousedown", n.pathMouseDown.bind(this, r))
        }
      }]), Y
    }(),
    nr = function () {
      function Y(r, n) {
        l(this, Y), this.ctx = r, this.w = r.w, this.xRatio = n.xRatio, this.yRatio = n.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new Oa(r), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
      }
      return p(Y, [{
        key: "draw",
        value: function (r) {
          var n = this.w,
            s = new W(this.ctx),
            c = s.group({
              class: "apexcharts-heatmap"
            });
          c.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")"));
          var u = n.globals.gridWidth / n.globals.dataPoints,
            d = n.globals.gridHeight / n.globals.series.length,
            f = 0,
            g = !1;
          this.negRange = this.helpers.checkColorRange();
          var b = r.slice();
          n.config.yaxis[0].reversed && (g = !0, b.reverse());
          for (var y = g ? 0 : b.length - 1; g ? y < b.length : y >= 0; g ? y++ : y--) {
            var x = s.group({
              class: "apexcharts-series apexcharts-heatmap-series",
              seriesName: I.escapeString(n.globals.seriesNames[y]),
              rel: y + 1,
              "data:realIndex": y
            });
            if (this.ctx.series.addCollapsedClassToSeries(x, y), n.config.chart.dropShadow.enabled) {
              var _ = n.config.chart.dropShadow;
              new U(this.ctx).dropShadow(x, _, y)
            }
            for (var T = 0, P = n.config.plotOptions.heatmap.shadeIntensity, O = 0; O < b[y].length; O++) {
              var $ = this.helpers.getShadeColor(n.config.chart.type, y, O, this.negRange),
                G = $.color,
                Q = $.colorProps;
              n.config.fill.type === "image" && (G = new he(this.ctx).fillPath({
                seriesNumber: y,
                dataPointIndex: O,
                opacity: n.globals.hasNegs ? Q.percent < 0 ? 1 - (1 + Q.percent / 100) : P + Q.percent / 100 : Q.percent / 100,
                patternID: I.randomId(),
                width: n.config.fill.image.width ? n.config.fill.image.width : u,
                height: n.config.fill.image.height ? n.config.fill.image.height : d
              }));
              var v = this.rectRadius,
                C = s.drawRect(T, f, u, d, v);
              if (C.attr({
                  cx: T,
                  cy: f
                }), C.node.classList.add("apexcharts-heatmap-rect"), x.add(C), C.attr({
                  fill: G,
                  i: y,
                  index: y,
                  j: O,
                  val: r[y][O],
                  "stroke-width": this.strokeWidth,
                  stroke: n.config.plotOptions.heatmap.useFillColorAsStroke ? G : n.globals.stroke.colors[0],
                  color: G
                }), this.helpers.addListeners(C), n.config.chart.animations.enabled && !n.globals.dataChanged) {
                var L = 1;
                n.globals.resized || (L = n.config.chart.animations.speed), this.animateHeatMap(C, T, f, u, d, L)
              }
              if (n.globals.dataChanged) {
                var H = 1;
                if (this.dynamicAnim.enabled && n.globals.shouldAnimate) {
                  H = this.dynamicAnim.speed;
                  var q = n.globals.previousPaths[y] && n.globals.previousPaths[y][O] && n.globals.previousPaths[y][O].color;
                  q || (q = "rgba(255, 255, 255, 0)"), this.animateHeatColor(C, I.isColorHex(q) ? q : I.rgb2hex(q), I.isColorHex(G) ? G : I.rgb2hex(G), H)
                }
              }
              var ee = (0, n.config.dataLabels.formatter)(n.globals.series[y][O], {
                  value: n.globals.series[y][O],
                  seriesIndex: y,
                  dataPointIndex: O,
                  w: n
                }),
                ge = this.helpers.calculateDataLabels({
                  text: ee,
                  x: T + u / 2,
                  y: f + d / 2,
                  i: y,
                  j: O,
                  colorProps: Q,
                  series: b
                });
              ge !== null && x.add(ge), T += u
            }
            f += d, c.add(x)
          }
          var pe = n.globals.yAxisScale[0].result.slice();
          return n.config.yaxis[0].reversed ? pe.unshift("") : pe.push(""), n.globals.yAxisScale[0].result = pe, c
        }
      }, {
        key: "animateHeatMap",
        value: function (r, n, s, c, u, d) {
          var f = new N(this.ctx);
          f.animateRect(r, {
            x: n + c / 2,
            y: s + u / 2,
            width: 0,
            height: 0
          }, {
            x: n,
            y: s,
            width: c,
            height: u
          }, d, function () {
            f.animationCompleted(r)
          })
        }
      }, {
        key: "animateHeatColor",
        value: function (r, n, s, c) {
          r.attr({
            fill: n
          }).animate(c).attr({
            fill: s
          })
        }
      }]), Y
    }(),
    zr = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "drawYAxisTexts",
        value: function (r, n, s, c) {
          var u = this.w,
            d = u.config.yaxis[0],
            f = u.globals.yLabelFormatters[0];
          return new W(this.ctx).drawText({
            x: r + d.labels.offsetX,
            y: n + d.labels.offsetY,
            text: f(c, s),
            textAnchor: "middle",
            fontSize: d.labels.style.fontSize,
            fontFamily: d.labels.style.fontFamily,
            foreColor: Array.isArray(d.labels.style.colors) ? d.labels.style.colors[s] : d.labels.style.colors
          })
        }
      }]), Y
    }(),
    Lr = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w;
        var n = this.w;
        this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = n.globals.stroke.colors !== void 0 ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = Math.min(n.globals.gridWidth, n.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = n.globals.gridWidth / 2, n.config.chart.type === "radialBar" ? this.fullAngle = 360 : this.fullAngle = Math.abs(n.config.plotOptions.pie.endAngle - n.config.plotOptions.pie.startAngle), this.initialAngle = n.config.plotOptions.pie.startAngle % this.fullAngle, n.globals.radialSize = this.defaultSize / 2.05 - n.config.stroke.width - (n.config.chart.sparkline.enabled ? 0 : n.config.chart.dropShadow.blur), this.donutSize = n.globals.radialSize * parseInt(n.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = []
      }
      return p(Y, [{
        key: "draw",
        value: function (r) {
          var n = this,
            s = this.w,
            c = new W(this.ctx);
          if (this.ret = c.group({
              class: "apexcharts-pie"
            }), s.globals.noData) return this.ret;
          for (var u = 0, d = 0; d < r.length; d++) u += I.negToZero(r[d]);
          var f = [],
            g = c.group();
          u === 0 && (u = 1e-5), r.forEach(function (q) {
            n.maxY = Math.max(n.maxY, q)
          }), s.config.yaxis[0].max && (this.maxY = s.config.yaxis[0].max), s.config.grid.position === "back" && this.chartType === "polarArea" && this.drawPolarElements(this.ret);
          for (var b = 0; b < r.length; b++) {
            var y = this.fullAngle * I.negToZero(r[b]) / u;
            f.push(y), this.chartType === "polarArea" ? (f[b] = this.fullAngle / r.length, this.sliceSizes.push(s.globals.radialSize * r[b] / this.maxY)) : this.sliceSizes.push(s.globals.radialSize)
          }
          if (s.globals.dataChanged) {
            for (var x, _ = 0, T = 0; T < s.globals.previousPaths.length; T++) _ += I.negToZero(s.globals.previousPaths[T]);
            for (var P = 0; P < s.globals.previousPaths.length; P++) x = this.fullAngle * I.negToZero(s.globals.previousPaths[P]) / _, this.prevSectorAngleArr.push(x)
          }
          this.donutSize < 0 && (this.donutSize = 0);
          var O = s.config.plotOptions.pie.customScale,
            $ = s.globals.gridWidth / 2,
            G = s.globals.gridHeight / 2,
            Q = $ - s.globals.gridWidth / 2 * O,
            v = G - s.globals.gridHeight / 2 * O;
          if (this.chartType === "donut") {
            var C = c.drawCircle(this.donutSize);
            C.attr({
              cx: this.centerX,
              cy: this.centerY,
              fill: s.config.plotOptions.pie.donut.background ? s.config.plotOptions.pie.donut.background : "transparent"
            }), g.add(C)
          }
          var L = this.drawArcs(f, r);
          if (this.sliceLabels.forEach(function (q) {
              L.add(q)
            }), g.attr({
              transform: "translate(".concat(Q, ", ").concat(v, ") scale(").concat(O, ")")
            }), g.add(L), this.ret.add(g), this.donutDataLabels.show) {
            var H = this.renderInnerDataLabels(this.donutDataLabels, {
              hollowSize: this.donutSize,
              centerX: this.centerX,
              centerY: this.centerY,
              opacity: this.donutDataLabels.show,
              translateX: Q,
              translateY: v
            });
            this.ret.add(H)
          }
          return s.config.grid.position === "front" && this.chartType === "polarArea" && this.drawPolarElements(this.ret), this.ret
        }
      }, {
        key: "drawArcs",
        value: function (r, n) {
          var s = this.w,
            c = new U(this.ctx),
            u = new W(this.ctx),
            d = new he(this.ctx),
            f = u.group({
              class: "apexcharts-slices"
            }),
            g = this.initialAngle,
            b = this.initialAngle,
            y = this.initialAngle,
            x = this.initialAngle;
          this.strokeWidth = s.config.stroke.show ? s.config.stroke.width : 0;
          for (var _ = 0; _ < r.length; _++) {
            var T = u.group({
              class: "apexcharts-series apexcharts-pie-series",
              seriesName: I.escapeString(s.globals.seriesNames[_]),
              rel: _ + 1,
              "data:realIndex": _
            });
            f.add(T), b = x, y = (g = y) + r[_], x = b + this.prevSectorAngleArr[_];
            var P = y < g ? this.fullAngle + y - g : y - g,
              O = d.fillPath({
                seriesNumber: _,
                size: this.sliceSizes[_],
                value: n[_]
              }),
              $ = this.getChangedPath(b, x),
              G = u.drawPath({
                d: $,
                stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[_] : this.lineColorArr,
                strokeWidth: 0,
                fill: O,
                fillOpacity: s.config.fill.opacity,
                classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(_)
              });
            if (G.attr({
                index: 0,
                j: _
              }), c.setSelectionFilter(G, 0, _), s.config.chart.dropShadow.enabled) {
              var Q = s.config.chart.dropShadow;
              c.dropShadow(G, Q, _)
            }
            this.addListeners(G, this.donutDataLabels), W.setAttrs(G.node, {
              "data:angle": P,
              "data:startAngle": g,
              "data:strokeWidth": this.strokeWidth,
              "data:value": n[_]
            });
            var v = {
              x: 0,
              y: 0
            };
            this.chartType === "pie" || this.chartType === "polarArea" ? v = I.polarToCartesian(this.centerX, this.centerY, s.globals.radialSize / 1.25 + s.config.plotOptions.pie.dataLabels.offset, (g + P / 2) % this.fullAngle) : this.chartType === "donut" && (v = I.polarToCartesian(this.centerX, this.centerY, (s.globals.radialSize + this.donutSize) / 2 + s.config.plotOptions.pie.dataLabels.offset, (g + P / 2) % this.fullAngle)), T.add(G);
            var C = 0;
            if (!this.initialAnim || s.globals.resized || s.globals.dataChanged ? this.animBeginArr.push(0) : ((C = P / this.fullAngle * s.config.chart.animations.speed) === 0 && (C = 1), this.animDur = C + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && s.globals.dataChanged ? this.animatePaths(G, {
                size: this.sliceSizes[_],
                endAngle: y,
                startAngle: g,
                prevStartAngle: b,
                prevEndAngle: x,
                animateStartingPos: !0,
                i: _,
                animBeginArr: this.animBeginArr,
                shouldSetPrevPaths: !0,
                dur: s.config.chart.animations.dynamicAnimation.speed
              }) : this.animatePaths(G, {
                size: this.sliceSizes[_],
                endAngle: y,
                startAngle: g,
                i: _,
                totalItems: r.length - 1,
                animBeginArr: this.animBeginArr,
                dur: C
              }), s.config.plotOptions.pie.expandOnClick && this.chartType !== "polarArea" && G.click(this.pieClicked.bind(this, _)), s.globals.selectedDataPoints[0] !== void 0 && s.globals.selectedDataPoints[0].indexOf(_) > -1 && this.pieClicked(_), s.config.dataLabels.enabled) {
              var L = v.x,
                H = v.y,
                q = 100 * P / this.fullAngle + "%";
              if (P !== 0 && s.config.plotOptions.pie.dataLabels.minAngleToShowLabel < r[_]) {
                var ee = s.config.dataLabels.formatter;
                ee !== void 0 && (q = ee(s.globals.seriesPercent[_][0], {
                  seriesIndex: _,
                  w: s
                }));
                var ge = s.globals.dataLabels.style.colors[_],
                  pe = u.group({
                    class: "apexcharts-datalabels"
                  }),
                  Fe = u.drawText({
                    x: L,
                    y: H,
                    text: q,
                    textAnchor: "middle",
                    fontSize: s.config.dataLabels.style.fontSize,
                    fontFamily: s.config.dataLabels.style.fontFamily,
                    fontWeight: s.config.dataLabels.style.fontWeight,
                    foreColor: ge
                  });
                if (pe.add(Fe), s.config.dataLabels.dropShadow.enabled) {
                  var Ue = s.config.dataLabels.dropShadow;
                  c.dropShadow(Fe, Ue)
                }
                Fe.node.classList.add("apexcharts-pie-label"), s.config.chart.animations.animate && s.globals.resized === !1 && (Fe.node.classList.add("apexcharts-pie-label-delay"), Fe.node.style.animationDelay = s.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(pe)
              }
            }
          }
          return f
        }
      }, {
        key: "addListeners",
        value: function (r, n) {
          var s = new W(this.ctx);
          r.node.addEventListener("mouseenter", s.pathMouseEnter.bind(this, r)), r.node.addEventListener("mouseleave", s.pathMouseLeave.bind(this, r)), r.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, r.node, n)), r.node.addEventListener("mousedown", s.pathMouseDown.bind(this, r)), this.donutDataLabels.total.showAlways || (r.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, r.node, n)), r.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, r.node, n)))
        }
      }, {
        key: "animatePaths",
        value: function (r, n) {
          var s = this.w,
            c = n.endAngle < n.startAngle ? this.fullAngle + n.endAngle - n.startAngle : n.endAngle - n.startAngle,
            u = c,
            d = n.startAngle,
            f = n.startAngle;
          n.prevStartAngle !== void 0 && n.prevEndAngle !== void 0 && (d = n.prevEndAngle, u = n.prevEndAngle < n.prevStartAngle ? this.fullAngle + n.prevEndAngle - n.prevStartAngle : n.prevEndAngle - n.prevStartAngle), n.i === s.config.series.length - 1 && (c + f > this.fullAngle ? n.endAngle = n.endAngle - (c + f) : c + f < this.fullAngle && (n.endAngle = n.endAngle + (this.fullAngle - (c + f)))), c === this.fullAngle && (c = this.fullAngle - .01), this.animateArc(r, d, f, c, u, n)
        }
      }, {
        key: "animateArc",
        value: function (r, n, s, c, u, d) {
          var f, g = this,
            b = this.w,
            y = new N(this.ctx),
            x = d.size;
          (isNaN(n) || isNaN(u)) && (n = s, u = c, d.dur = 0);
          var _ = c,
            T = s,
            P = n < s ? this.fullAngle + n - s : n - s;
          b.globals.dataChanged && d.shouldSetPrevPaths && d.prevEndAngle && (f = g.getPiePath({
            me: g,
            startAngle: d.prevStartAngle,
            angle: d.prevEndAngle < d.prevStartAngle ? this.fullAngle + d.prevEndAngle - d.prevStartAngle : d.prevEndAngle - d.prevStartAngle,
            size: x
          }), r.attr({
            d: f
          })), d.dur !== 0 ? r.animate(d.dur, b.globals.easing, d.animBeginArr[d.i]).afterAll(function () {
            g.chartType !== "pie" && g.chartType !== "donut" && g.chartType !== "polarArea" || this.animate(b.config.chart.animations.dynamicAnimation.speed).attr({
              "stroke-width": g.strokeWidth
            }), d.i === b.config.series.length - 1 && y.animationCompleted(r)
          }).during(function (O) {
            _ = P + (c - P) * O, d.animateStartingPos && (_ = u + (c - u) * O, T = n - u + (s - (n - u)) * O), f = g.getPiePath({
              me: g,
              startAngle: T,
              angle: _,
              size: x
            }), r.node.setAttribute("data:pathOrig", f), r.attr({
              d: f
            })
          }) : (f = g.getPiePath({
            me: g,
            startAngle: T,
            angle: c,
            size: x
          }), d.isTrack || (b.globals.animationEnded = !0), r.node.setAttribute("data:pathOrig", f), r.attr({
            d: f,
            "stroke-width": g.strokeWidth
          }))
        }
      }, {
        key: "pieClicked",
        value: function (r) {
          var n, s = this.w,
            c = this,
            u = c.sliceSizes[r] + (s.config.plotOptions.pie.expandOnClick ? 4 : 0),
            d = s.globals.dom.Paper.select(".apexcharts-".concat(c.chartType.toLowerCase(), "-slice-").concat(r)).members[0];
          if (d.attr("data:pieClicked") !== "true") {
            var f = s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
            Array.prototype.forEach.call(f, function (x) {
              x.setAttribute("data:pieClicked", "false");
              var _ = x.getAttribute("data:pathOrig");
              _ && x.setAttribute("d", _)
            }), d.attr("data:pieClicked", "true");
            var g = parseInt(d.attr("data:startAngle"), 10),
              b = parseInt(d.attr("data:angle"), 10);
            n = c.getPiePath({
              me: c,
              startAngle: g,
              angle: b,
              size: u
            }), b !== 360 && d.plot(n)
          } else {
            d.attr({
              "data:pieClicked": "false"
            }), this.revertDataLabelsInner(d.node, this.donutDataLabels);
            var y = d.attr("data:pathOrig");
            d.attr({
              d: y
            })
          }
        }
      }, {
        key: "getChangedPath",
        value: function (r, n) {
          var s = "";
          return this.dynamicAnim && this.w.globals.dataChanged && (s = this.getPiePath({
            me: this,
            startAngle: r,
            angle: n - r,
            size: this.size
          })), s
        }
      }, {
        key: "getPiePath",
        value: function (r) {
          var n, s = r.me,
            c = r.startAngle,
            u = r.angle,
            d = r.size,
            f = new W(this.ctx),
            g = c,
            b = Math.PI * (g - 90) / 180,
            y = u + c;
          Math.ceil(y) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (y = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(y) > this.fullAngle && (y -= this.fullAngle);
          var x = Math.PI * (y - 90) / 180,
            _ = s.centerX + d * Math.cos(b),
            T = s.centerY + d * Math.sin(b),
            P = s.centerX + d * Math.cos(x),
            O = s.centerY + d * Math.sin(x),
            $ = I.polarToCartesian(s.centerX, s.centerY, s.donutSize, y),
            G = I.polarToCartesian(s.centerX, s.centerY, s.donutSize, g),
            Q = u > 180 ? 1 : 0,
            v = ["M", _, T, "A", d, d, 0, Q, 1, P, O];
          return n = s.chartType === "donut" ? [].concat(v, ["L", $.x, $.y, "A", s.donutSize, s.donutSize, 0, Q, 0, G.x, G.y, "L", _, T, "z"]).join(" ") : s.chartType === "pie" || s.chartType === "polarArea" ? [].concat(v, ["L", s.centerX, s.centerY, "L", _, T]).join(" ") : [].concat(v).join(" "), f.roundPathCorners(n, 2 * this.strokeWidth)
        }
      }, {
        key: "drawPolarElements",
        value: function (r) {
          var n = this.w,
            s = new We(this.ctx),
            c = new W(this.ctx),
            u = new zr(this.ctx),
            d = c.group(),
            f = c.group(),
            g = s.niceScale(0, Math.ceil(this.maxY), n.config.yaxis[0].tickAmount, 0, !0),
            b = g.result.reverse(),
            y = g.result.length;
          this.maxY = g.niceMax;
          for (var x = n.globals.radialSize, _ = x / (y - 1), T = 0; T < y - 1; T++) {
            var P = c.drawCircle(x);
            if (P.attr({
                cx: this.centerX,
                cy: this.centerY,
                fill: "none",
                "stroke-width": n.config.plotOptions.polarArea.rings.strokeWidth,
                stroke: n.config.plotOptions.polarArea.rings.strokeColor
              }), n.config.yaxis[0].show) {
              var O = u.drawYAxisTexts(this.centerX, this.centerY - x + parseInt(n.config.yaxis[0].labels.style.fontSize, 10) / 2, T, b[T]);
              f.add(O)
            }
            d.add(P), x -= _
          }
          this.drawSpokes(r), r.add(d), r.add(f)
        }
      }, {
        key: "renderInnerDataLabels",
        value: function (r, n) {
          var s = this.w,
            c = new W(this.ctx),
            u = c.group({
              class: "apexcharts-datalabels-group",
              transform: "translate(".concat(n.translateX ? n.translateX : 0, ", ").concat(n.translateY ? n.translateY : 0, ") scale(").concat(s.config.plotOptions.pie.customScale, ")")
            }),
            d = r.total.show;
          u.node.style.opacity = n.opacity;
          var f, g, b = n.centerX,
            y = n.centerY;
          f = r.name.color === void 0 ? s.globals.colors[0] : r.name.color;
          var x = r.name.fontSize,
            _ = r.name.fontFamily,
            T = r.name.fontWeight;
          g = r.value.color === void 0 ? s.config.chart.foreColor : r.value.color;
          var P = r.value.formatter,
            O = "",
            $ = "";
          if (d ? (f = r.total.color, x = r.total.fontSize, _ = r.total.fontFamily, T = r.total.fontWeight, $ = r.total.label, O = r.total.formatter(s)) : s.globals.series.length === 1 && (O = P(s.globals.series[0], s), $ = s.globals.seriesNames[0]), $ && ($ = r.name.formatter($, r.total.show, s)), r.name.show) {
            var G = c.drawText({
              x: b,
              y: y + parseFloat(r.name.offsetY),
              text: $,
              textAnchor: "middle",
              foreColor: f,
              fontSize: x,
              fontWeight: T,
              fontFamily: _
            });
            G.node.classList.add("apexcharts-datalabel-label"), u.add(G)
          }
          if (r.value.show) {
            var Q = r.name.show ? parseFloat(r.value.offsetY) + 16 : r.value.offsetY,
              v = c.drawText({
                x: b,
                y: y + Q,
                text: O,
                textAnchor: "middle",
                foreColor: g,
                fontWeight: r.value.fontWeight,
                fontSize: r.value.fontSize,
                fontFamily: r.value.fontFamily
              });
            v.node.classList.add("apexcharts-datalabel-value"), u.add(v)
          }
          return u
        }
      }, {
        key: "printInnerLabels",
        value: function (r, n, s, c) {
          var u, d = this.w;
          c ? u = r.name.color === void 0 ? d.globals.colors[parseInt(c.parentNode.getAttribute("rel"), 10) - 1] : r.name.color : d.globals.series.length > 1 && r.total.show && (u = r.total.color);
          var f = d.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),
            g = d.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
          s = (0, r.value.formatter)(s, d), c || typeof r.total.formatter != "function" || (s = r.total.formatter(d));
          var b = n === r.total.label;
          n = r.name.formatter(n, b, d), f !== null && (f.textContent = n), g !== null && (g.textContent = s), f !== null && (f.style.fill = u)
        }
      }, {
        key: "printDataLabelsInner",
        value: function (r, n) {
          var s = this.w,
            c = r.getAttribute("data:value"),
            u = s.globals.seriesNames[parseInt(r.parentNode.getAttribute("rel"), 10) - 1];
          s.globals.series.length > 1 && this.printInnerLabels(n, u, c, r);
          var d = s.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
          d !== null && (d.style.opacity = 1)
        }
      }, {
        key: "drawSpokes",
        value: function (r) {
          var n = this,
            s = this.w,
            c = new W(this.ctx),
            u = s.config.plotOptions.polarArea.spokes;
          if (u.strokeWidth !== 0) {
            for (var d = [], f = 360 / s.globals.series.length, g = 0; g < s.globals.series.length; g++) d.push(I.polarToCartesian(this.centerX, this.centerY, s.globals.radialSize, s.config.plotOptions.pie.startAngle + f * g));
            d.forEach(function (b, y) {
              var x = c.drawLine(b.x, b.y, n.centerX, n.centerY, Array.isArray(u.connectorColors) ? u.connectorColors[y] : u.connectorColors);
              r.add(x)
            })
          }
        }
      }, {
        key: "revertDataLabelsInner",
        value: function (r, n, s) {
          var c = this,
            u = this.w,
            d = u.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),
            f = !1,
            g = u.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),
            b = function (_) {
              var T = _.makeSliceOut,
                P = _.printLabel;
              Array.prototype.forEach.call(g, function (O) {
                O.getAttribute("data:pieClicked") === "true" && (T && (f = !0), P && c.printDataLabelsInner(O, n))
              })
            };
          if (b({
              makeSliceOut: !0,
              printLabel: !1
            }), n.total.show && u.globals.series.length > 1) f && !n.total.showAlways ? b({
            makeSliceOut: !1,
            printLabel: !0
          }) : this.printInnerLabels(n, n.total.label, n.total.formatter(u));
          else if (b({
              makeSliceOut: !1,
              printLabel: !0
            }), !f)
            if (u.globals.selectedDataPoints.length && u.globals.series.length > 1)
              if (u.globals.selectedDataPoints[0].length > 0) {
                var y = u.globals.selectedDataPoints[0],
                  x = u.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(y));
                this.printDataLabelsInner(x, n)
              } else d && u.globals.selectedDataPoints.length && u.globals.selectedDataPoints[0].length === 0 && (d.style.opacity = 0);
          else d && u.globals.series.length > 1 && (d.style.opacity = 0)
        }
      }]), Y
    }(),
    lr = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
        var n = this.w;
        this.graphics = new W(this.ctx), this.lineColorArr = n.globals.stroke.colors !== void 0 ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = n.globals.svgHeight < n.globals.svgWidth ? n.globals.gridHeight + 1.5 * n.globals.goldenPadding : n.globals.gridWidth, this.isLog = n.config.yaxis[0].logarithmic, this.coreUtils = new X(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(n.globals.maxY, 0) : n.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : n.globals.minY, this.polygons = n.config.plotOptions.radar.polygons, this.strokeWidth = n.config.stroke.show ? n.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - n.config.chart.dropShadow.blur, n.config.xaxis.labels.show && (this.size = this.size - n.globals.xAxisLabelsWidth / 1.75), n.config.plotOptions.radar.size !== void 0 && (this.size = n.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = []
      }
      return p(Y, [{
        key: "draw",
        value: function (r) {
          var n = this,
            s = this.w,
            c = new he(this.ctx),
            u = [],
            d = new Se(this.ctx);
          r.length && (this.dataPointsLen = r[s.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
          var f = s.globals.gridWidth / 2,
            g = s.globals.gridHeight / 2,
            b = f + s.config.plotOptions.radar.offsetX,
            y = g + s.config.plotOptions.radar.offsetY,
            x = this.graphics.group({
              class: "apexcharts-radar-series apexcharts-plot-series",
              transform: "translate(".concat(b || 0, ", ").concat(y || 0, ")")
            }),
            _ = [],
            T = null,
            P = null;
          if (this.yaxisLabels = this.graphics.group({
              class: "apexcharts-yaxis"
            }), r.forEach(function ($, G) {
              var Q = $.length === s.globals.dataPoints,
                v = n.graphics.group().attr({
                  class: "apexcharts-series",
                  "data:longestSeries": Q,
                  seriesName: I.escapeString(s.globals.seriesNames[G]),
                  rel: G + 1,
                  "data:realIndex": G
                });
              n.dataRadiusOfPercent[G] = [], n.dataRadius[G] = [], n.angleArr[G] = [], $.forEach(function (Ve, it) {
                var dt = Math.abs(n.maxValue - n.minValue);
                Ve += Math.abs(n.minValue), n.isLog && (Ve = n.coreUtils.getLogVal(Ve, 0)), n.dataRadiusOfPercent[G][it] = Ve / dt, n.dataRadius[G][it] = n.dataRadiusOfPercent[G][it] * n.size, n.angleArr[G][it] = it * n.disAngle
              }), _ = n.getDataPointsPos(n.dataRadius[G], n.angleArr[G]);
              var C = n.createPaths(_, {
                x: 0,
                y: 0
              });
              T = n.graphics.group({
                class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
              }), P = n.graphics.group({
                class: "apexcharts-datalabels",
                "data:realIndex": G
              }), s.globals.delayedElements.push({
                el: T.node,
                index: G
              });
              var L = {
                  i: G,
                  realIndex: G,
                  animationDelay: G,
                  initialSpeed: s.config.chart.animations.speed,
                  dataChangeSpeed: s.config.chart.animations.dynamicAnimation.speed,
                  className: "apexcharts-radar",
                  shouldClipToGrid: !1,
                  bindEventsOnPaths: !1,
                  stroke: s.globals.stroke.colors[G],
                  strokeLineCap: s.config.stroke.lineCap
                },
                H = null;
              s.globals.previousPaths.length > 0 && (H = n.getPreviousPath(G));
              for (var q = 0; q < C.linePathsTo.length; q++) {
                var ee = n.graphics.renderPaths(i(i({}, L), {}, {
                  pathFrom: H === null ? C.linePathsFrom[q] : H,
                  pathTo: C.linePathsTo[q],
                  strokeWidth: Array.isArray(n.strokeWidth) ? n.strokeWidth[G] : n.strokeWidth,
                  fill: "none",
                  drawShadow: !1
                }));
                v.add(ee);
                var ge = c.fillPath({
                    seriesNumber: G
                  }),
                  pe = n.graphics.renderPaths(i(i({}, L), {}, {
                    pathFrom: H === null ? C.areaPathsFrom[q] : H,
                    pathTo: C.areaPathsTo[q],
                    strokeWidth: 0,
                    fill: ge,
                    drawShadow: !1
                  }));
                if (s.config.chart.dropShadow.enabled) {
                  var Fe = new U(n.ctx),
                    Ue = s.config.chart.dropShadow;
                  Fe.dropShadow(pe, Object.assign({}, Ue, {
                    noUserSpaceOnUse: !0
                  }), G)
                }
                v.add(pe)
              }
              $.forEach(function (Ve, it) {
                var dt = new ke(n.ctx).getMarkerConfig({
                    cssClass: "apexcharts-marker",
                    seriesIndex: G,
                    dataPointIndex: it
                  }),
                  mt = n.graphics.drawMarker(_[it].x, _[it].y, dt);
                mt.attr("rel", it), mt.attr("j", it), mt.attr("index", G), mt.node.setAttribute("default-marker-size", dt.pSize);
                var At = n.graphics.group({
                  class: "apexcharts-series-markers"
                });
                At && At.add(mt), T.add(At), v.add(T);
                var _t = s.config.dataLabels;
                if (_t.enabled) {
                  var Et = _t.formatter(s.globals.series[G][it], {
                    seriesIndex: G,
                    dataPointIndex: it,
                    w: s
                  });
                  d.plotDataLabelsText({
                    x: _[it].x,
                    y: _[it].y,
                    text: Et,
                    textAnchor: "middle",
                    i: G,
                    j: G,
                    parent: P,
                    offsetCorrection: !1,
                    dataLabelsConfig: i({}, _t)
                  })
                }
                v.add(P)
              }), u.push(v)
            }), this.drawPolygons({
              parent: x
            }), s.config.xaxis.labels.show) {
            var O = this.drawXAxisTexts();
            x.add(O)
          }
          return u.forEach(function ($) {
            x.add($)
          }), x.add(this.yaxisLabels), x
        }
      }, {
        key: "drawPolygons",
        value: function (r) {
          for (var n = this, s = this.w, c = r.parent, u = new zr(this.ctx), d = s.globals.yAxisScale[0].result.reverse(), f = d.length, g = [], b = this.size / (f - 1), y = 0; y < f; y++) g[y] = b * y;
          g.reverse();
          var x = [],
            _ = [];
          g.forEach(function (T, P) {
            var O = I.getPolygonPos(T, n.dataPointsLen),
              $ = "";
            O.forEach(function (G, Q) {
              if (P === 0) {
                var v = n.graphics.drawLine(G.x, G.y, 0, 0, Array.isArray(n.polygons.connectorColors) ? n.polygons.connectorColors[Q] : n.polygons.connectorColors);
                _.push(v)
              }
              Q === 0 && n.yaxisLabelsTextsPos.push({
                x: G.x,
                y: G.y
              }), $ += G.x + "," + G.y + " "
            }), x.push($)
          }), x.forEach(function (T, P) {
            var O = n.polygons.strokeColors,
              $ = n.polygons.strokeWidth,
              G = n.graphics.drawPolygon(T, Array.isArray(O) ? O[P] : O, Array.isArray($) ? $[P] : $, s.globals.radarPolygons.fill.colors[P]);
            c.add(G)
          }), _.forEach(function (T) {
            c.add(T)
          }), s.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function (T, P) {
            var O = u.drawYAxisTexts(T.x, T.y, P, d[P]);
            n.yaxisLabels.add(O)
          })
        }
      }, {
        key: "drawXAxisTexts",
        value: function () {
          var r = this,
            n = this.w,
            s = n.config.xaxis.labels,
            c = this.graphics.group({
              class: "apexcharts-xaxis"
            }),
            u = I.getPolygonPos(this.size, this.dataPointsLen);
          return n.globals.labels.forEach(function (d, f) {
            var g = n.config.xaxis.labels.formatter,
              b = new Se(r.ctx);
            if (u[f]) {
              var y = r.getTextPos(u[f], r.size),
                x = g(d, {
                  seriesIndex: -1,
                  dataPointIndex: f,
                  w: n
                });
              b.plotDataLabelsText({
                x: y.newX,
                y: y.newY,
                text: x,
                textAnchor: y.textAnchor,
                i: f,
                j: f,
                parent: c,
                color: Array.isArray(s.style.colors) && s.style.colors[f] ? s.style.colors[f] : "#a8a8a8",
                dataLabelsConfig: i({
                  textAnchor: y.textAnchor,
                  dropShadow: {
                    enabled: !1
                  }
                }, s),
                offsetCorrection: !1
              })
            }
          }), c
        }
      }, {
        key: "createPaths",
        value: function (r, n) {
          var s = this,
            c = [],
            u = [],
            d = [],
            f = [];
          if (r.length) {
            u = [this.graphics.move(n.x, n.y)], f = [this.graphics.move(n.x, n.y)];
            var g = this.graphics.move(r[0].x, r[0].y),
              b = this.graphics.move(r[0].x, r[0].y);
            r.forEach(function (y, x) {
              g += s.graphics.line(y.x, y.y), b += s.graphics.line(y.x, y.y), x === r.length - 1 && (g += "Z", b += "Z")
            }), c.push(g), d.push(b)
          }
          return {
            linePathsFrom: u,
            linePathsTo: c,
            areaPathsFrom: f,
            areaPathsTo: d
          }
        }
      }, {
        key: "getTextPos",
        value: function (r, n) {
          var s = "middle",
            c = r.x,
            u = r.y;
          return Math.abs(r.x) >= 10 ? r.x > 0 ? (s = "start", c += 10) : r.x < 0 && (s = "end", c -= 10) : s = "middle", Math.abs(r.y) >= n - 10 && (r.y < 0 ? u -= 10 : r.y > 0 && (u += 10)), {
            textAnchor: s,
            newX: c,
            newY: u
          }
        }
      }, {
        key: "getPreviousPath",
        value: function (r) {
          for (var n = this.w, s = null, c = 0; c < n.globals.previousPaths.length; c++) {
            var u = n.globals.previousPaths[c];
            u.paths.length > 0 && parseInt(u.realIndex, 10) === parseInt(r, 10) && n.globals.previousPaths[c].paths[0] !== void 0 && (s = n.globals.previousPaths[c].paths[0].d)
          }
          return s
        }
      }, {
        key: "getDataPointsPos",
        value: function (r, n) {
          var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.dataPointsLen;
          r = r || [], n = n || [];
          for (var c = [], u = 0; u < s; u++) {
            var d = {};
            d.x = r[u] * Math.sin(n[u]), d.y = -r[u] * Math.cos(n[u]), c.push(d)
          }
          return c
        }
      }]), Y
    }(),
    Or = function (Y) {
      k(n, Lr);
      var r = E(n);

      function n(s) {
        var c;
        l(this, n), (c = r.call(this, s)).ctx = s, c.w = s.w, c.animBeginArr = [0], c.animDur = 0;
        var u = c.w;
        return c.startAngle = u.config.plotOptions.radialBar.startAngle, c.endAngle = u.config.plotOptions.radialBar.endAngle, c.totalAngle = Math.abs(u.config.plotOptions.radialBar.endAngle - u.config.plotOptions.radialBar.startAngle), c.trackStartAngle = u.config.plotOptions.radialBar.track.startAngle, c.trackEndAngle = u.config.plotOptions.radialBar.track.endAngle, c.barLabels = c.w.config.plotOptions.radialBar.barLabels, c.donutDataLabels = c.w.config.plotOptions.radialBar.dataLabels, c.radialDataLabels = c.donutDataLabels, c.trackStartAngle || (c.trackStartAngle = c.startAngle), c.trackEndAngle || (c.trackEndAngle = c.endAngle), c.endAngle === 360 && (c.endAngle = 359.99), c.margin = parseInt(u.config.plotOptions.radialBar.track.margin, 10), c.onBarLabelClick = c.onBarLabelClick.bind(A(c)), c
      }
      return p(n, [{
        key: "draw",
        value: function (s) {
          var c = this.w,
            u = new W(this.ctx),
            d = u.group({
              class: "apexcharts-radialbar"
            });
          if (c.globals.noData) return d;
          var f = u.group(),
            g = this.defaultSize / 2,
            b = c.globals.gridWidth / 2,
            y = this.defaultSize / 2.05;
          c.config.chart.sparkline.enabled || (y = y - c.config.stroke.width - c.config.chart.dropShadow.blur);
          var x = c.globals.fill.colors;
          if (c.config.plotOptions.radialBar.track.show) {
            var _ = this.drawTracks({
              size: y,
              centerX: b,
              centerY: g,
              colorArr: x,
              series: s
            });
            f.add(_)
          }
          var T = this.drawArcs({
              size: y,
              centerX: b,
              centerY: g,
              colorArr: x,
              series: s
            }),
            P = 360;
          c.config.plotOptions.radialBar.startAngle < 0 && (P = this.totalAngle);
          var O = (360 - P) / 360;
          if (c.globals.radialSize = y - y * O, this.radialDataLabels.value.show) {
            var $ = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
            c.globals.radialSize += $ * O
          }
          return f.add(T.g), c.config.plotOptions.radialBar.hollow.position === "front" && (T.g.add(T.elHollow), T.dataLabels && T.g.add(T.dataLabels)), d.add(f), d
        }
      }, {
        key: "drawTracks",
        value: function (s) {
          var c = this.w,
            u = new W(this.ctx),
            d = u.group({
              class: "apexcharts-tracks"
            }),
            f = new U(this.ctx),
            g = new he(this.ctx),
            b = this.getStrokeWidth(s);
          s.size = s.size - b / 2;
          for (var y = 0; y < s.series.length; y++) {
            var x = u.group({
              class: "apexcharts-radialbar-track apexcharts-track"
            });
            d.add(x), x.attr({
              rel: y + 1
            }), s.size = s.size - b - this.margin;
            var _ = c.config.plotOptions.radialBar.track,
              T = g.fillPath({
                seriesNumber: 0,
                size: s.size,
                fillColors: Array.isArray(_.background) ? _.background[y] : _.background,
                solid: !0
              }),
              P = this.trackStartAngle,
              O = this.trackEndAngle;
            Math.abs(O) + Math.abs(P) >= 360 && (O = 360 - Math.abs(this.startAngle) - .1);
            var $ = u.drawPath({
              d: "",
              stroke: T,
              strokeWidth: b * parseInt(_.strokeWidth, 10) / 100,
              fill: "none",
              strokeOpacity: _.opacity,
              classes: "apexcharts-radialbar-area"
            });
            if (_.dropShadow.enabled) {
              var G = _.dropShadow;
              f.dropShadow($, G)
            }
            x.add($), $.attr("id", "apexcharts-radialbarTrack-" + y), this.animatePaths($, {
              centerX: s.centerX,
              centerY: s.centerY,
              endAngle: O,
              startAngle: P,
              size: s.size,
              i: y,
              totalItems: 2,
              animBeginArr: 0,
              dur: 0,
              isTrack: !0,
              easing: c.globals.easing
            })
          }
          return d
        }
      }, {
        key: "drawArcs",
        value: function (s) {
          var c = this.w,
            u = new W(this.ctx),
            d = new he(this.ctx),
            f = new U(this.ctx),
            g = u.group(),
            b = this.getStrokeWidth(s);
          s.size = s.size - b / 2;
          var y = c.config.plotOptions.radialBar.hollow.background,
            x = s.size - b * s.series.length - this.margin * s.series.length - b * parseInt(c.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2,
            _ = x - c.config.plotOptions.radialBar.hollow.margin;
          c.config.plotOptions.radialBar.hollow.image !== void 0 && (y = this.drawHollowImage(s, g, x, y));
          var T = this.drawHollow({
            size: _,
            centerX: s.centerX,
            centerY: s.centerY,
            fill: y || "transparent"
          });
          if (c.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
            var P = c.config.plotOptions.radialBar.hollow.dropShadow;
            f.dropShadow(T, P)
          }
          var O = 1;
          !this.radialDataLabels.total.show && c.globals.series.length > 1 && (O = 0);
          var $ = null;
          this.radialDataLabels.show && ($ = this.renderInnerDataLabels(this.radialDataLabels, {
            hollowSize: x,
            centerX: s.centerX,
            centerY: s.centerY,
            opacity: O
          })), c.config.plotOptions.radialBar.hollow.position === "back" && (g.add(T), $ && g.add($));
          var G = !1;
          c.config.plotOptions.radialBar.inverseOrder && (G = !0);
          for (var Q = G ? s.series.length - 1 : 0; G ? Q >= 0 : Q < s.series.length; G ? Q-- : Q++) {
            var v = u.group({
              class: "apexcharts-series apexcharts-radial-series",
              seriesName: I.escapeString(c.globals.seriesNames[Q])
            });
            g.add(v), v.attr({
              rel: Q + 1,
              "data:realIndex": Q
            }), this.ctx.series.addCollapsedClassToSeries(v, Q), s.size = s.size - b - this.margin;
            var C = d.fillPath({
                seriesNumber: Q,
                size: s.size,
                value: s.series[Q]
              }),
              L = this.startAngle,
              H = void 0,
              q = I.negToZero(s.series[Q] > 100 ? 100 : s.series[Q]) / 100,
              ee = Math.round(this.totalAngle * q) + this.startAngle,
              ge = void 0;
            c.globals.dataChanged && (H = this.startAngle, ge = Math.round(this.totalAngle * I.negToZero(c.globals.previousPaths[Q]) / 100) + H), Math.abs(ee) + Math.abs(L) >= 360 && (ee -= .01), Math.abs(ge) + Math.abs(H) >= 360 && (ge -= .01);
            var pe = ee - L,
              Fe = Array.isArray(c.config.stroke.dashArray) ? c.config.stroke.dashArray[Q] : c.config.stroke.dashArray,
              Ue = u.drawPath({
                d: "",
                stroke: C,
                strokeWidth: b,
                fill: "none",
                fillOpacity: c.config.fill.opacity,
                classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + Q,
                strokeDashArray: Fe
              });
            if (W.setAttrs(Ue.node, {
                "data:angle": pe,
                "data:value": s.series[Q]
              }), c.config.chart.dropShadow.enabled) {
              var Ve = c.config.chart.dropShadow;
              f.dropShadow(Ue, Ve, Q)
            }
            if (f.setSelectionFilter(Ue, 0, Q), this.addListeners(Ue, this.radialDataLabels), v.add(Ue), Ue.attr({
                index: 0,
                j: Q
              }), this.barLabels.enabled) {
              var it = I.polarToCartesian(s.centerX, s.centerY, s.size, L),
                dt = this.barLabels.formatter(c.globals.seriesNames[Q], {
                  seriesIndex: Q,
                  w: c
                }),
                mt = ["apexcharts-radialbar-label"];
              this.barLabels.onClick || mt.push("apexcharts-no-click");
              var At = this.barLabels.useSeriesColors ? c.globals.colors[Q] : c.config.chart.foreColor;
              At || (At = c.config.chart.foreColor);
              var _t = it.x - this.barLabels.margin,
                Et = it.y,
                qt = u.drawText({
                  x: _t,
                  y: Et,
                  text: dt,
                  textAnchor: "end",
                  dominantBaseline: "middle",
                  fontFamily: this.barLabels.fontFamily,
                  fontWeight: this.barLabels.fontWeight,
                  fontSize: this.barLabels.fontSize,
                  foreColor: At,
                  cssClass: mt.join(" ")
                });
              qt.on("click", this.onBarLabelClick), qt.attr({
                rel: Q + 1
              }), L !== 0 && qt.attr({
                "transform-origin": "".concat(_t, " ").concat(Et),
                transform: "rotate(".concat(L, " 0 0)")
              }), v.add(qt)
            }
            var sa = 0;
            !this.initialAnim || c.globals.resized || c.globals.dataChanged || (sa = c.config.chart.animations.speed), c.globals.dataChanged && (sa = c.config.chart.animations.dynamicAnimation.speed), this.animDur = sa / (1.2 * s.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(Ue, {
              centerX: s.centerX,
              centerY: s.centerY,
              endAngle: ee,
              startAngle: L,
              prevEndAngle: ge,
              prevStartAngle: H,
              size: s.size,
              i: Q,
              totalItems: 2,
              animBeginArr: this.animBeginArr,
              dur: sa,
              shouldSetPrevPaths: !0,
              easing: c.globals.easing
            })
          }
          return {
            g,
            elHollow: T,
            dataLabels: $
          }
        }
      }, {
        key: "drawHollow",
        value: function (s) {
          var c = new W(this.ctx).drawCircle(2 * s.size);
          return c.attr({
            class: "apexcharts-radialbar-hollow",
            cx: s.centerX,
            cy: s.centerY,
            r: s.size,
            fill: s.fill
          }), c
        }
      }, {
        key: "drawHollowImage",
        value: function (s, c, u, d) {
          var f = this.w,
            g = new he(this.ctx),
            b = I.randomId(),
            y = f.config.plotOptions.radialBar.hollow.image;
          if (f.config.plotOptions.radialBar.hollow.imageClipped) g.clippedImgArea({
            width: u,
            height: u,
            image: y,
            patternID: "pattern".concat(f.globals.cuid).concat(b)
          }), d = "url(#pattern".concat(f.globals.cuid).concat(b, ")");
          else {
            var x = f.config.plotOptions.radialBar.hollow.imageWidth,
              _ = f.config.plotOptions.radialBar.hollow.imageHeight;
            if (x === void 0 && _ === void 0) {
              var T = f.globals.dom.Paper.image(y).loaded(function (O) {
                this.move(s.centerX - O.width / 2 + f.config.plotOptions.radialBar.hollow.imageOffsetX, s.centerY - O.height / 2 + f.config.plotOptions.radialBar.hollow.imageOffsetY)
              });
              c.add(T)
            } else {
              var P = f.globals.dom.Paper.image(y).loaded(function (O) {
                this.move(s.centerX - x / 2 + f.config.plotOptions.radialBar.hollow.imageOffsetX, s.centerY - _ / 2 + f.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(x, _)
              });
              c.add(P)
            }
          }
          return d
        }
      }, {
        key: "getStrokeWidth",
        value: function (s) {
          var c = this.w;
          return s.size * (100 - parseInt(c.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (s.series.length + 1) - this.margin
        }
      }, {
        key: "onBarLabelClick",
        value: function (s) {
          var c = parseInt(s.target.getAttribute("rel"), 10) - 1,
            u = this.barLabels.onClick,
            d = this.w;
          u && u(d.globals.seriesNames[c], {
            w: d,
            seriesIndex: c
          })
        }
      }]), n
    }(),
    Jn = function (Y) {
      k(n, et);
      var r = E(n);

      function n() {
        return l(this, n), r.apply(this, arguments)
      }
      return p(n, [{
        key: "draw",
        value: function (s, c) {
          var u = this.w,
            d = new W(this.ctx);
          this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = s, this.seriesRangeStart = u.globals.seriesRangeStart, this.seriesRangeEnd = u.globals.seriesRangeEnd, this.barHelpers.initVariables(s);
          for (var f = d.group({
              class: "apexcharts-rangebar-series apexcharts-plot-series"
            }), g = 0; g < s.length; g++) {
            var b, y, x, _, T = void 0,
              P = void 0,
              O = u.globals.comboCharts ? c[g] : g,
              $ = d.group({
                class: "apexcharts-series",
                seriesName: I.escapeString(u.globals.seriesNames[O]),
                rel: g + 1,
                "data:realIndex": O
              });
            this.ctx.series.addCollapsedClassToSeries($, O), s[g].length > 0 && (this.visibleI = this.visibleI + 1);
            var G = 0,
              Q = 0;
            this.yRatio.length > 1 && (this.yaxisIndex = O);
            var v = this.barHelpers.initialPositions();
            P = v.y, _ = v.zeroW, T = v.x, Q = v.barWidth, G = v.barHeight, b = v.xDivision, y = v.yDivision, x = v.zeroH;
            for (var C = d.group({
                class: "apexcharts-datalabels",
                "data:realIndex": O
              }), L = d.group({
                class: "apexcharts-rangebar-goals-markers"
              }), H = 0; H < u.globals.dataPoints; H++) {
              var q, ee = this.barHelpers.getStrokeWidth(g, H, O),
                ge = this.seriesRangeStart[g][H],
                pe = this.seriesRangeEnd[g][H],
                Fe = null,
                Ue = null,
                Ve = null,
                it = {
                  x: T,
                  y: P,
                  strokeWidth: ee,
                  elSeries: $
                },
                dt = this.seriesLen;
              if (u.config.plotOptions.bar.rangeBarGroupRows && (dt = 1), u.config.series[g].data[H] === void 0) break;
              if (this.isHorizontal) {
                Ve = P + G * this.visibleI;
                var mt = (y - G * dt) / 2;
                if (u.config.series[g].data[H].x) {
                  var At = this.detectOverlappingBars({
                    i: g,
                    j: H,
                    barYPosition: Ve,
                    srty: mt,
                    barHeight: G,
                    yDivision: y,
                    initPositions: v
                  });
                  G = At.barHeight, Ve = At.barYPosition
                }
                Q = (Fe = this.drawRangeBarPaths(i({
                  indexes: {
                    i: g,
                    j: H,
                    realIndex: O
                  },
                  barHeight: G,
                  barYPosition: Ve,
                  zeroW: _,
                  yDivision: y,
                  y1: ge,
                  y2: pe
                }, it))).barWidth
              } else {
                u.globals.isXNumeric && (T = (u.globals.seriesX[g][H] - u.globals.minX) / this.xRatio - Q / 2), Ue = T + Q * this.visibleI;
                var _t = (b - Q * dt) / 2;
                if (u.config.series[g].data[H].x) {
                  var Et = this.detectOverlappingBars({
                    i: g,
                    j: H,
                    barXPosition: Ue,
                    srtx: _t,
                    barWidth: Q,
                    xDivision: b,
                    initPositions: v
                  });
                  Q = Et.barWidth, Ue = Et.barXPosition
                }
                G = (Fe = this.drawRangeColumnPaths(i({
                  indexes: {
                    i: g,
                    j: H,
                    realIndex: O
                  },
                  barWidth: Q,
                  barXPosition: Ue,
                  zeroH: x,
                  xDivision: b
                }, it))).barHeight
              }
              var qt = this.barHelpers.drawGoalLine({
                barXPosition: Fe.barXPosition,
                barYPosition: Ve,
                goalX: Fe.goalX,
                goalY: Fe.goalY,
                barHeight: G,
                barWidth: Q
              });
              qt && L.add(qt), P = Fe.y, T = Fe.x;
              var sa = this.barHelpers.getPathFillColor(s, g, H, O),
                wr = u.globals.stroke.colors[O];
              this.renderSeries((m(q = {
                realIndex: O,
                pathFill: sa,
                lineFill: wr,
                j: H,
                i: g,
                x: T,
                y: P,
                y1: ge,
                y2: pe,
                pathFrom: Fe.pathFrom,
                pathTo: Fe.pathTo,
                strokeWidth: ee,
                elSeries: $,
                series: s,
                barHeight: G,
                barWidth: Q,
                barXPosition: Ue,
                barYPosition: Ve
              }, "barWidth", Q), m(q, "elDataLabelsWrap", C), m(q, "elGoalsMarkers", L), m(q, "visibleSeries", this.visibleI), m(q, "type", "rangebar"), q))
            }
            f.add($)
          }
          return f
        }
      }, {
        key: "detectOverlappingBars",
        value: function (s) {
          var c = s.i,
            u = s.j,
            d = s.barYPosition,
            f = s.barXPosition,
            g = s.srty,
            b = s.srtx,
            y = s.barHeight,
            x = s.barWidth,
            _ = s.yDivision,
            T = s.xDivision,
            P = s.initPositions,
            O = this.w,
            $ = [],
            G = O.config.series[c].data[u].rangeName,
            Q = O.config.series[c].data[u].x,
            v = Array.isArray(Q) ? Q.join(" ") : Q,
            C = O.globals.labels.map(function (H) {
              return Array.isArray(H) ? H.join(" ") : H
            }).indexOf(v),
            L = O.globals.seriesRange[c].findIndex(function (H) {
              return H.x === v && H.overlaps.length > 0
            });
          return this.isHorizontal ? (d = O.config.plotOptions.bar.rangeBarGroupRows ? g + _ * C : g + y * this.visibleI + _ * C, L > -1 && !O.config.plotOptions.bar.rangeBarOverlap && ($ = O.globals.seriesRange[c][L].overlaps).indexOf(G) > -1 && (d = (y = P.barHeight / $.length) * this.visibleI + _ * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + y * (this.visibleI + $.indexOf(G)) + _ * C)) : (C > -1 && (f = O.config.plotOptions.bar.rangeBarGroupRows ? b + T * C : b + x * this.visibleI + T * C), L > -1 && !O.config.plotOptions.bar.rangeBarOverlap && ($ = O.globals.seriesRange[c][L].overlaps).indexOf(G) > -1 && (f = (x = P.barWidth / $.length) * this.visibleI + T * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + x * (this.visibleI + $.indexOf(G)) + T * C)), {
            barYPosition: d,
            barXPosition: f,
            barHeight: y,
            barWidth: x
          }
        }
      }, {
        key: "drawRangeColumnPaths",
        value: function (s) {
          var c = s.indexes,
            u = s.x,
            d = s.xDivision,
            f = s.barWidth,
            g = s.barXPosition,
            b = s.zeroH,
            y = this.w,
            x = c.i,
            _ = c.j,
            T = this.yRatio[this.yaxisIndex],
            P = c.realIndex,
            O = this.getRangeValue(P, _),
            $ = Math.min(O.start, O.end),
            G = Math.max(O.start, O.end);
          this.series[x][_] === void 0 || this.series[x][_] === null ? $ = b : ($ = b - $ / T, G = b - G / T);
          var Q = Math.abs(G - $),
            v = this.barHelpers.getColumnPaths({
              barXPosition: g,
              barWidth: f,
              y1: $,
              y2: G,
              strokeWidth: this.strokeWidth,
              series: this.seriesRangeEnd,
              realIndex: c.realIndex,
              i: P,
              j: _,
              w: y
            });
          if (y.globals.isXNumeric) {
            var C = this.getBarXForNumericXAxis({
              x: u,
              j: _,
              realIndex: P,
              barWidth: f
            });
            u = C.x, g = C.barXPosition
          } else u += d;
          return {
            pathTo: v.pathTo,
            pathFrom: v.pathFrom,
            barHeight: Q,
            x: u,
            y: G,
            goalY: this.barHelpers.getGoalValues("y", null, b, x, _),
            barXPosition: g
          }
        }
      }, {
        key: "drawRangeBarPaths",
        value: function (s) {
          var c = s.indexes,
            u = s.y,
            d = s.y1,
            f = s.y2,
            g = s.yDivision,
            b = s.barHeight,
            y = s.barYPosition,
            x = s.zeroW,
            _ = this.w,
            T = x + d / this.invertedYRatio,
            P = x + f / this.invertedYRatio,
            O = Math.abs(P - T),
            $ = this.barHelpers.getBarpaths({
              barYPosition: y,
              barHeight: b,
              x1: T,
              x2: P,
              strokeWidth: this.strokeWidth,
              series: this.seriesRangeEnd,
              i: c.realIndex,
              realIndex: c.realIndex,
              j: c.j,
              w: _
            });
          return _.globals.isXNumeric || (u += g), {
            pathTo: $.pathTo,
            pathFrom: $.pathFrom,
            barWidth: O,
            x: P,
            goalX: this.barHelpers.getGoalValues("x", x, null, c.realIndex, c.j),
            y: u
          }
        }
      }, {
        key: "getRangeValue",
        value: function (s, c) {
          var u = this.w;
          return {
            start: u.globals.seriesRangeStart[s][c],
            end: u.globals.seriesRangeEnd[s][c]
          }
        }
      }]), n
    }(),
    tn = function () {
      function Y(r) {
        l(this, Y), this.w = r.w, this.lineCtx = r
      }
      return p(Y, [{
        key: "sameValueSeriesFix",
        value: function (r, n) {
          var s = this.w;
          if ((s.config.fill.type === "gradient" || s.config.fill.type[r] === "gradient") && new X(this.lineCtx.ctx, s).seriesHaveSameValues(r)) {
            var c = n[r].slice();
            c[c.length - 1] = c[c.length - 1] + 1e-6, n[r] = c
          }
          return n
        }
      }, {
        key: "calculatePoints",
        value: function (r) {
          var n = r.series,
            s = r.realIndex,
            c = r.x,
            u = r.y,
            d = r.i,
            f = r.j,
            g = r.prevY,
            b = this.w,
            y = [],
            x = [];
          if (f === 0) {
            var _ = this.lineCtx.categoryAxisCorrection + b.config.markers.offsetX;
            b.globals.isXNumeric && (_ = (b.globals.seriesX[s][0] - b.globals.minX) / this.lineCtx.xRatio + b.config.markers.offsetX), y.push(_), x.push(I.isNumber(n[d][0]) ? g + b.config.markers.offsetY : null), y.push(c + b.config.markers.offsetX), x.push(I.isNumber(n[d][f + 1]) ? u + b.config.markers.offsetY : null)
          } else y.push(c + b.config.markers.offsetX), x.push(I.isNumber(n[d][f + 1]) ? u + b.config.markers.offsetY : null);
          return {
            x: y,
            y: x
          }
        }
      }, {
        key: "checkPreviousPaths",
        value: function (r) {
          for (var n = r.pathFromLine, s = r.pathFromArea, c = r.realIndex, u = this.w, d = 0; d < u.globals.previousPaths.length; d++) {
            var f = u.globals.previousPaths[d];
            (f.type === "line" || f.type === "area") && f.paths.length > 0 && parseInt(f.realIndex, 10) === parseInt(c, 10) && (f.type === "line" ? (this.lineCtx.appendPathFrom = !1, n = u.globals.previousPaths[d].paths[0].d) : f.type === "area" && (this.lineCtx.appendPathFrom = !1, s = u.globals.previousPaths[d].paths[0].d, u.config.stroke.show && u.globals.previousPaths[d].paths[1] && (n = u.globals.previousPaths[d].paths[1].d)))
          }
          return {
            pathFromLine: n,
            pathFromArea: s
          }
        }
      }, {
        key: "determineFirstPrevY",
        value: function (r) {
          var n, s, c = r.i,
            u = r.series,
            d = r.prevY,
            f = r.lineYPosition,
            g = this.w,
            b = g.config.chart.stacked && !g.globals.comboCharts || g.config.chart.stacked && g.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((n = this.w.config.series[c]) === null || n === void 0 ? void 0 : n.type) === "bar");
          if (((s = u[c]) === null || s === void 0 ? void 0 : s[0]) !== void 0) d = (f = b && c > 0 ? this.lineCtx.prevSeriesY[c - 1][0] : this.lineCtx.zeroY) - u[c][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? u[c][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
          else if (b && c > 0 && u[c][0] === void 0) {
            for (var y = c - 1; y >= 0; y--)
              if (u[y][0] !== null && u[y][0] !== void 0) {
                d = f = this.lineCtx.prevSeriesY[y][0];
                break
              }
          }
          return {
            prevY: d,
            lineYPosition: f
          }
        }
      }]), Y
    }(),
    wo = function (Y) {
      for (var r, n, s, c, u = function (y) {
          for (var x = [], _ = y[0], T = y[1], P = x[0] = ei(_, T), O = 1, $ = y.length - 1; O < $; O++) _ = T, T = y[O + 1], x[O] = .5 * (P + (P = ei(_, T)));
          return x[O] = P, x
        }(Y), d = Y.length - 1, f = [], g = 0; g < d; g++) s = ei(Y[g], Y[g + 1]), Math.abs(s) < 1e-6 ? u[g] = u[g + 1] = 0 : (c = (r = u[g] / s) * r + (n = u[g + 1] / s) * n) > 9 && (c = 3 * s / Math.sqrt(c), u[g] = c * r, u[g + 1] = c * n);
      for (var b = 0; b <= d; b++) c = (Y[Math.min(d, b + 1)][0] - Y[Math.max(0, b - 1)][0]) / (6 * (1 + u[b] * u[b])), f.push([c || 0, u[b] * c || 0]);
      return f
    },
    zi = function (Y) {
      for (var r = "", n = 0; n < Y.length; n++) {
        var s = Y[n],
          c = s.length;
        c > 4 ? (r += "C".concat(s[0], ", ").concat(s[1]), r += ", ".concat(s[2], ", ").concat(s[3]), r += ", ".concat(s[4], ", ").concat(s[5])) : c > 2 && (r += "S".concat(s[0], ", ").concat(s[1]), r += ", ".concat(s[2], ", ").concat(s[3]))
      }
      return r
    },
    ws = function (Y) {
      var r = wo(Y),
        n = Y[1],
        s = Y[0],
        c = [],
        u = r[1],
        d = r[0];
      c.push(s, [s[0] + d[0], s[1] + d[1], n[0] - u[0], n[1] - u[1], n[0], n[1]]);
      for (var f = 2, g = r.length; f < g; f++) {
        var b = Y[f],
          y = r[f];
        c.push([b[0] - y[0], b[1] - y[1], b[0], b[1]])
      }
      return c
    };

  function ei(Y, r) {
    return (r[1] - Y[1]) / (r[0] - Y[0])
  }
  var Dn = function () {
    function Y(r, n, s) {
      l(this, Y), this.ctx = r, this.w = r.w, this.xyRatios = n, this.pointsChart = !(this.w.config.chart.type !== "bubble" && this.w.config.chart.type !== "scatter") || s, this.scatter = new re(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new tn(this), this.markers = new ke(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0
    }
    return p(Y, [{
      key: "draw",
      value: function (r, n, s, c) {
        var u, d = this.w,
          f = new W(this.ctx),
          g = d.globals.comboCharts ? n : d.config.chart.type,
          b = f.group({
            class: "apexcharts-".concat(g, "-series apexcharts-plot-series")
          }),
          y = new X(this.ctx, d);
        this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, r = y.getLogSeries(r), this.yRatio = y.getLogYRatios(this.yRatio);
        for (var x = [], _ = 0; _ < r.length; _++) {
          r = this.lineHelpers.sameValueSeriesFix(_, r);
          var T = d.globals.comboCharts ? s[_] : _;
          this._initSerieVariables(r, _, T);
          var P = [],
            O = [],
            $ = [],
            G = d.globals.padHorizontal + this.categoryAxisCorrection;
          this.ctx.series.addCollapsedClassToSeries(this.elSeries, T), d.globals.isXNumeric && d.globals.seriesX.length > 0 && (G = (d.globals.seriesX[T][0] - d.globals.minX) / this.xRatio), $.push(G);
          var Q, v = G,
            C = void 0,
            L = v,
            H = this.zeroY,
            q = this.zeroY;
          H = this.lineHelpers.determineFirstPrevY({
            i: _,
            series: r,
            prevY: H,
            lineYPosition: 0
          }).prevY, d.config.stroke.curve === "monotonCubic" && r[_][0] === null ? P.push(null) : P.push(H), Q = H, g === "rangeArea" && (C = q = this.lineHelpers.determineFirstPrevY({
            i: _,
            series: c,
            prevY: q,
            lineYPosition: 0
          }).prevY, O.push(q));
          var ee = {
              type: g,
              series: r,
              realIndex: T,
              i: _,
              x: G,
              y: 1,
              pX: v,
              pY: Q,
              pathsFrom: this._calculatePathsFrom({
                type: g,
                series: r,
                i: _,
                realIndex: T,
                prevX: L,
                prevY: H,
                prevY2: q
              }),
              linePaths: [],
              areaPaths: [],
              seriesIndex: s,
              lineYPosition: 0,
              xArrj: $,
              yArrj: P,
              y2Arrj: O,
              seriesRangeEnd: c
            },
            ge = this._iterateOverDataPoints(i(i({}, ee), {}, {
              iterations: g === "rangeArea" ? r[_].length - 1 : void 0,
              isRangeStart: !0
            }));
          if (g === "rangeArea") {
            var pe = this._calculatePathsFrom({
                series: c,
                i: _,
                realIndex: T,
                prevX: L,
                prevY: q
              }),
              Fe = this._iterateOverDataPoints(i(i({}, ee), {}, {
                series: c,
                pY: C,
                pathsFrom: pe,
                iterations: c[_].length - 1,
                isRangeStart: !1
              }));
            ge.linePaths[0] = Fe.linePath + ge.linePath, ge.pathFromLine = Fe.pathFromLine + ge.pathFromLine
          }
          this._handlePaths({
            type: g,
            realIndex: T,
            i: _,
            paths: ge
          }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), x.push(this.elSeries)
        }
        if (((u = d.config.series[0]) === null || u === void 0 ? void 0 : u.zIndex) !== void 0 && x.sort(function (it, dt) {
            return Number(it.node.getAttribute("zIndex")) - Number(dt.node.getAttribute("zIndex"))
          }), d.config.chart.stacked)
          for (var Ue = x.length; Ue > 0; Ue--) b.add(x[Ue - 1]);
        else
          for (var Ve = 0; Ve < x.length; Ve++) b.add(x[Ve]);
        return b
      }
    }, {
      key: "_initSerieVariables",
      value: function (r, n, s) {
        var c = this.w,
          u = new W(this.ctx);
        this.xDivision = c.globals.gridWidth / (c.globals.dataPoints - (c.config.xaxis.tickPlacement === "on" ? 1 : 0)), this.strokeWidth = Array.isArray(c.config.stroke.width) ? c.config.stroke.width[s] : c.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = s), this.isReversed = c.config.yaxis[this.yaxisIndex] && c.config.yaxis[this.yaxisIndex].reversed, this.zeroY = c.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? c.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > c.globals.gridHeight || c.config.plotOptions.area.fillTo === "end") && (this.areaBottomY = c.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = u.group({
          class: "apexcharts-series",
          zIndex: c.config.series[s].zIndex !== void 0 ? c.config.series[s].zIndex : s,
          seriesName: I.escapeString(c.globals.seriesNames[s])
        }), this.elPointsMain = u.group({
          class: "apexcharts-series-markers-wrap",
          "data:realIndex": s
        }), this.elDataLabelsWrap = u.group({
          class: "apexcharts-datalabels",
          "data:realIndex": s
        });
        var d = r[n].length === c.globals.dataPoints;
        this.elSeries.attr({
          "data:longestSeries": d,
          rel: n + 1,
          "data:realIndex": s
        }), this.appendPathFrom = !0
      }
    }, {
      key: "_calculatePathsFrom",
      value: function (r) {
        var n, s, c, u, d = r.type,
          f = r.series,
          g = r.i,
          b = r.realIndex,
          y = r.prevX,
          x = r.prevY,
          _ = r.prevY2,
          T = this.w,
          P = new W(this.ctx);
        if (f[g][0] === null) {
          for (var O = 0; O < f[g].length; O++)
            if (f[g][O] !== null) {
              y = this.xDivision * O, x = this.zeroY - f[g][O] / this.yRatio[this.yaxisIndex], n = P.move(y, x), s = P.move(y, this.areaBottomY);
              break
            }
        } else n = P.move(y, x), d === "rangeArea" && (n = P.move(y, _) + P.line(y, x)), s = P.move(y, this.areaBottomY) + P.line(y, x);
        if (c = P.move(-1, this.zeroY) + P.line(-1, this.zeroY), u = P.move(-1, this.zeroY) + P.line(-1, this.zeroY), T.globals.previousPaths.length > 0) {
          var $ = this.lineHelpers.checkPreviousPaths({
            pathFromLine: c,
            pathFromArea: u,
            realIndex: b
          });
          c = $.pathFromLine, u = $.pathFromArea
        }
        return {
          prevX: y,
          prevY: x,
          linePath: n,
          areaPath: s,
          pathFromLine: c,
          pathFromArea: u
        }
      }
    }, {
      key: "_handlePaths",
      value: function (r) {
        var n = r.type,
          s = r.realIndex,
          c = r.i,
          u = r.paths,
          d = this.w,
          f = new W(this.ctx),
          g = new he(this.ctx);
        this.prevSeriesY.push(u.yArrj), d.globals.seriesXvalues[s] = u.xArrj, d.globals.seriesYvalues[s] = u.yArrj;
        var b = d.config.forecastDataPoints;
        if (b.count > 0 && n !== "rangeArea") {
          var y = d.globals.seriesXvalues[s][d.globals.seriesXvalues[s].length - b.count - 1],
            x = f.drawRect(y, 0, d.globals.gridWidth, d.globals.gridHeight, 0);
          d.globals.dom.elForecastMask.appendChild(x.node);
          var _ = f.drawRect(0, 0, y, d.globals.gridHeight, 0);
          d.globals.dom.elNonForecastMask.appendChild(_.node)
        }
        this.pointsChart || d.globals.delayedElements.push({
          el: this.elPointsMain.node,
          index: s
        });
        var T = {
          i: c,
          realIndex: s,
          animationDelay: c,
          initialSpeed: d.config.chart.animations.speed,
          dataChangeSpeed: d.config.chart.animations.dynamicAnimation.speed,
          className: "apexcharts-".concat(n)
        };
        if (n === "area")
          for (var P = g.fillPath({
              seriesNumber: s
            }), O = 0; O < u.areaPaths.length; O++) {
            var $ = f.renderPaths(i(i({}, T), {}, {
              pathFrom: u.pathFromArea,
              pathTo: u.areaPaths[O],
              stroke: "none",
              strokeWidth: 0,
              strokeLineCap: null,
              fill: P
            }));
            this.elSeries.add($)
          }
        if (d.config.stroke.show && !this.pointsChart) {
          var G = null;
          if (n === "line") G = g.fillPath({
            seriesNumber: s,
            i: c
          });
          else if (d.config.stroke.fill.type === "solid") G = d.globals.stroke.colors[s];
          else {
            var Q = d.config.fill;
            d.config.fill = d.config.stroke.fill, G = g.fillPath({
              seriesNumber: s,
              i: c
            }), d.config.fill = Q
          }
          for (var v = 0; v < u.linePaths.length; v++) {
            var C = G;
            n === "rangeArea" && (C = g.fillPath({
              seriesNumber: s
            }));
            var L = i(i({}, T), {}, {
                pathFrom: u.pathFromLine,
                pathTo: u.linePaths[v],
                stroke: G,
                strokeWidth: this.strokeWidth,
                strokeLineCap: d.config.stroke.lineCap,
                fill: n === "rangeArea" ? C : "none"
              }),
              H = f.renderPaths(L);
            if (this.elSeries.add(H), H.attr("fill-rule", "evenodd"), b.count > 0 && n !== "rangeArea") {
              var q = f.renderPaths(L);
              q.node.setAttribute("stroke-dasharray", b.dashArray), b.strokeWidth && q.node.setAttribute("stroke-width", b.strokeWidth), this.elSeries.add(q), q.attr("clip-path", "url(#forecastMask".concat(d.globals.cuid, ")")), H.attr("clip-path", "url(#nonForecastMask".concat(d.globals.cuid, ")"))
            }
          }
        }
      }
    }, {
      key: "_iterateOverDataPoints",
      value: function (r) {
        var n, s = this,
          c = r.type,
          u = r.series,
          d = r.iterations,
          f = r.realIndex,
          g = r.i,
          b = r.x,
          y = r.y,
          x = r.pX,
          _ = r.pY,
          T = r.pathsFrom,
          P = r.linePaths,
          O = r.areaPaths,
          $ = r.seriesIndex,
          G = r.lineYPosition,
          Q = r.xArrj,
          v = r.yArrj,
          C = r.y2Arrj,
          L = r.isRangeStart,
          H = r.seriesRangeEnd,
          q = this.w,
          ee = new W(this.ctx),
          ge = this.yRatio,
          pe = T.prevY,
          Fe = T.linePath,
          Ue = T.areaPath,
          Ve = T.pathFromLine,
          it = T.pathFromArea,
          dt = I.isNumber(q.globals.minYArr[f]) ? q.globals.minYArr[f] : q.globals.minY;
        d || (d = q.globals.dataPoints > 1 ? q.globals.dataPoints - 1 : q.globals.dataPoints);
        for (var mt = function (ma, Mr) {
            return Mr - ma / ge[s.yaxisIndex] + 2 * (s.isReversed ? ma / ge[s.yaxisIndex] : 0)
          }, At = y, _t = q.config.chart.stacked && !q.globals.comboCharts || q.config.chart.stacked && q.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || ((n = this.w.config.series[f]) === null || n === void 0 ? void 0 : n.type) === "bar"), Et = 0; Et < d; Et++) {
          var qt = u[g][Et + 1] === void 0 || u[g][Et + 1] === null;
          if (q.globals.isXNumeric) {
            var sa = q.globals.seriesX[f][Et + 1];
            q.globals.seriesX[f][Et + 1] === void 0 && (sa = q.globals.seriesX[f][d - 1]), b = (sa - q.globals.minX) / this.xRatio
          } else b += this.xDivision;
          _t ? g > 0 && q.globals.collapsedSeries.length < q.config.series.length - 1 ? G = this.prevSeriesY[function (ma) {
            for (var Mr = ma, Ta = 0; Ta < q.globals.series.length; Ta++)
              if (q.globals.collapsedSeriesIndices.indexOf(ma) > -1) {
                Mr--;
                break
              } return Mr >= 0 ? Mr : 0
          }(g - 1)][Et + 1] : G = this.zeroY : G = this.zeroY, qt ? y = mt(dt, G) : (y = mt(u[g][Et + 1], G), c === "rangeArea" && (At = mt(H[g][Et + 1], G))), Q.push(b), qt && q.config.stroke.curve === "smooth" ? v.push(null) : v.push(y), C.push(At);
          var wr = this.lineHelpers.calculatePoints({
              series: u,
              x: b,
              y,
              realIndex: f,
              i: g,
              j: Et,
              prevY: pe
            }),
            Ya = this._createPaths({
              type: c,
              series: u,
              i: g,
              realIndex: f,
              j: Et,
              x: b,
              y,
              y2: At,
              xArrj: Q,
              yArrj: v,
              y2Arrj: C,
              pX: x,
              pY: _,
              linePath: Fe,
              areaPath: Ue,
              linePaths: P,
              areaPaths: O,
              seriesIndex: $,
              isRangeStart: L
            });
          O = Ya.areaPaths, P = Ya.linePaths, x = Ya.pX, _ = Ya.pY, Ue = Ya.areaPath, Fe = Ya.linePath, !this.appendPathFrom || q.config.stroke.curve === "monotoneCubic" && c === "rangeArea" || (Ve += ee.line(b, this.zeroY), it += ee.line(b, this.zeroY)), this.handleNullDataPoints(u, wr, g, Et, f), this._handleMarkersAndLabels({
            type: c,
            pointsPos: wr,
            i: g,
            j: Et,
            realIndex: f,
            isRangeStart: L
          })
        }
        return {
          yArrj: v,
          xArrj: Q,
          pathFromArea: it,
          areaPaths: O,
          pathFromLine: Ve,
          linePaths: P,
          linePath: Fe,
          areaPath: Ue
        }
      }
    }, {
      key: "_handleMarkersAndLabels",
      value: function (r) {
        var n = r.type,
          s = r.pointsPos,
          c = r.isRangeStart,
          u = r.i,
          d = r.j,
          f = r.realIndex,
          g = this.w,
          b = new Se(this.ctx);
        if (this.pointsChart) this.scatter.draw(this.elSeries, d, {
          realIndex: f,
          pointsPos: s,
          zRatio: this.zRatio,
          elParent: this.elPointsMain
        });
        else {
          g.globals.series[u].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
          var y = this.markers.plotChartMarkers(s, f, d + 1);
          y !== null && this.elPointsMain.add(y)
        }
        var x = b.drawDataLabel({
          type: n,
          isRangeStart: c,
          pos: s,
          i: f,
          j: d + 1
        });
        x !== null && this.elDataLabelsWrap.add(x)
      }
    }, {
      key: "_createPaths",
      value: function (r) {
        var n = r.type,
          s = r.series,
          c = r.i,
          u = r.realIndex,
          d = r.j,
          f = r.x,
          g = r.y,
          b = r.xArrj,
          y = r.yArrj,
          x = r.y2,
          _ = r.y2Arrj,
          T = r.pX,
          P = r.pY,
          O = r.linePath,
          $ = r.areaPath,
          G = r.linePaths,
          Q = r.areaPaths,
          v = r.seriesIndex,
          C = r.isRangeStart,
          L = this.w,
          H = new W(this.ctx),
          q = L.config.stroke.curve,
          ee = this.areaBottomY;
        if (Array.isArray(L.config.stroke.curve) && (q = Array.isArray(v) ? L.config.stroke.curve[v[c]] : L.config.stroke.curve[c]), n === "rangeArea" && (L.globals.hasNullValues || L.config.forecastDataPoints.count > 0) && q === "monotoneCubic" && (q = "straight"), q === "monotoneCubic") {
          var ge = n === "rangeArea" ? b.length === L.globals.dataPoints : d === s[c].length - 2,
            pe = b.map(function (_t, Et) {
              return [b[Et], y[Et]]
            }).filter(function (_t) {
              return _t[1] !== null
            });
          if (ge && pe.length > 1) {
            var Fe = ws(pe);
            if (O += zi(Fe), s[c][0] === null ? $ = O : $ += zi(Fe), n === "rangeArea" && C) {
              O += H.line(b[b.length - 1], _[_.length - 1]);
              var Ue = b.slice().reverse(),
                Ve = _.slice().reverse(),
                it = Ue.map(function (_t, Et) {
                  return [Ue[Et], Ve[Et]]
                }),
                dt = ws(it);
              $ = O += zi(dt)
            } else $ += H.line(pe[pe.length - 1][0], ee) + H.line(pe[0][0], ee) + H.move(pe[0][0], pe[0][1]) + "z";
            G.push(O), Q.push($)
          }
        } else if (q === "smooth") {
          var mt = .35 * (f - T);
          L.globals.hasNullValues ? (s[c][d] !== null && (s[c][d + 1] !== null ? (O = H.move(T, P) + H.curve(T + mt, P, f - mt, g, f + 1, g), $ = H.move(T + 1, P) + H.curve(T + mt, P, f - mt, g, f + 1, g) + H.line(f, ee) + H.line(T, ee) + "z") : (O = H.move(T, P), $ = H.move(T, P) + "z")), G.push(O), Q.push($)) : (O += H.curve(T + mt, P, f - mt, g, f, g), $ += H.curve(T + mt, P, f - mt, g, f, g)), T = f, P = g, d === s[c].length - 2 && ($ = $ + H.curve(T, P, f, g, f, ee) + H.move(f, g) + "z", n === "rangeArea" && C ? O = O + H.curve(T, P, f, g, f, x) + H.move(f, x) + "z" : L.globals.hasNullValues || (G.push(O), Q.push($)))
        } else {
          if (s[c][d + 1] === null) {
            O += H.move(f, g);
            var At = L.globals.isXNumeric ? (L.globals.seriesX[u][d] - L.globals.minX) / this.xRatio : f - this.xDivision;
            $ = $ + H.line(At, ee) + H.move(f, g) + "z"
          }
          s[c][d] === null && (O += H.move(f, g), $ += H.move(f, ee)), q === "stepline" ? (O = O + H.line(f, null, "H") + H.line(null, g, "V"), $ = $ + H.line(f, null, "H") + H.line(null, g, "V")) : q === "straight" && (O += H.line(f, g), $ += H.line(f, g)), d === s[c].length - 2 && ($ = $ + H.line(f, ee) + H.move(f, g) + "z", n === "rangeArea" && C ? O = O + H.line(f, x) + H.move(f, x) + "z" : (G.push(O), Q.push($)))
        }
        return {
          linePaths: G,
          areaPaths: Q,
          pX: T,
          pY: P,
          linePath: O,
          areaPath: $
        }
      }
    }, {
      key: "handleNullDataPoints",
      value: function (r, n, s, c, u) {
        var d = this.w;
        if (r[s][c] === null && d.config.markers.showNullDataPoints || r[s].length === 1) {
          var f = this.markers.plotChartMarkers(n, u, c + 1, this.strokeWidth - d.config.markers.strokeWidth / 2, !0);
          f !== null && this.elPointsMain.add(f)
        }
      }
    }]), Y
  }();
  window.TreemapSquared = {}, window.TreemapSquared.generate = function () {
    function Y(f, g, b, y) {
      this.xoffset = f, this.yoffset = g, this.height = y, this.width = b, this.shortestEdge = function () {
        return Math.min(this.height, this.width)
      }, this.getCoordinates = function (x) {
        var _, T = [],
          P = this.xoffset,
          O = this.yoffset,
          $ = u(x) / this.height,
          G = u(x) / this.width;
        if (this.width >= this.height)
          for (_ = 0; _ < x.length; _++) T.push([P, O, P + $, O + x[_] / $]), O += x[_] / $;
        else
          for (_ = 0; _ < x.length; _++) T.push([P, O, P + x[_] / G, O + G]), P += x[_] / G;
        return T
      }, this.cutArea = function (x) {
        var _;
        if (this.width >= this.height) {
          var T = x / this.height,
            P = this.width - T;
          _ = new Y(this.xoffset + T, this.yoffset, P, this.height)
        } else {
          var O = x / this.width,
            $ = this.height - O;
          _ = new Y(this.xoffset, this.yoffset + O, this.width, $)
        }
        return _
      }
    }

    function r(f, g, b, y, x) {
      y = y === void 0 ? 0 : y, x = x === void 0 ? 0 : x;
      var _ = n(function (T, P) {
        var O, $ = [],
          G = P / u(T);
        for (O = 0; O < T.length; O++) $[O] = T[O] * G;
        return $
      }(f, g * b), [], new Y(y, x, g, b), []);
      return function (T) {
        var P, O, $ = [];
        for (P = 0; P < T.length; P++)
          for (O = 0; O < T[P].length; O++) $.push(T[P][O]);
        return $
      }(_)
    }

    function n(f, g, b, y) {
      var x, _, T;
      if (f.length !== 0) return x = b.shortestEdge(),
        function (P, O, $) {
          var G;
          if (P.length === 0) return !0;
          (G = P.slice()).push(O);
          var Q = s(P, $),
            v = s(G, $);
          return Q >= v
        }(g, _ = f[0], x) ? (g.push(_), n(f.slice(1), g, b, y)) : (T = b.cutArea(u(g), y), y.push(b.getCoordinates(g)), n(f, [], T, y)), y;
      y.push(b.getCoordinates(g))
    }

    function s(f, g) {
      var b = Math.min.apply(Math, f),
        y = Math.max.apply(Math, f),
        x = u(f);
      return Math.max(Math.pow(g, 2) * y / Math.pow(x, 2), Math.pow(x, 2) / (Math.pow(g, 2) * b))
    }

    function c(f) {
      return f && f.constructor === Array
    }

    function u(f) {
      var g, b = 0;
      for (g = 0; g < f.length; g++) b += f[g];
      return b
    }

    function d(f) {
      var g, b = 0;
      if (c(f[0]))
        for (g = 0; g < f.length; g++) b += d(f[g]);
      else b = u(f);
      return b
    }
    return function f(g, b, y, x, _) {
      x = x === void 0 ? 0 : x, _ = _ === void 0 ? 0 : _;
      var T, P, O = [],
        $ = [];
      if (c(g[0])) {
        for (P = 0; P < g.length; P++) O[P] = d(g[P]);
        for (T = r(O, b, y, x, _), P = 0; P < g.length; P++) $.push(f(g[P], T[P][2] - T[P][0], T[P][3] - T[P][1], T[P][0], T[P][1]))
      } else $ = r(g, b, y, x, _);
      return $
    }
  }();
  var ga, ti, ko = function () {
      function Y(r, n) {
        l(this, Y), this.ctx = r, this.w = r.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new Oa(r), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = []
      }
      return p(Y, [{
        key: "draw",
        value: function (r) {
          var n = this,
            s = this.w,
            c = new W(this.ctx),
            u = new he(this.ctx),
            d = c.group({
              class: "apexcharts-treemap"
            });
          if (s.globals.noData) return d;
          var f = [];
          return r.forEach(function (g) {
            var b = g.map(function (y) {
              return Math.abs(y)
            });
            f.push(b)
          }), this.negRange = this.helpers.checkColorRange(), s.config.series.forEach(function (g, b) {
            g.data.forEach(function (y) {
              Array.isArray(n.labels[b]) || (n.labels[b] = []), n.labels[b].push(y.x)
            })
          }), window.TreemapSquared.generate(f, s.globals.gridWidth, s.globals.gridHeight).forEach(function (g, b) {
            var y = c.group({
              class: "apexcharts-series apexcharts-treemap-series",
              seriesName: I.escapeString(s.globals.seriesNames[b]),
              rel: b + 1,
              "data:realIndex": b
            });
            if (s.config.chart.dropShadow.enabled) {
              var x = s.config.chart.dropShadow;
              new U(n.ctx).dropShadow(d, x, b)
            }
            var _ = c.group({
              class: "apexcharts-data-labels"
            });
            g.forEach(function (T, P) {
              var O = T[0],
                $ = T[1],
                G = T[2],
                Q = T[3],
                v = c.drawRect(O, $, G - O, Q - $, s.config.plotOptions.treemap.borderRadius, "#fff", 1, n.strokeWidth, s.config.plotOptions.treemap.useFillColorAsStroke ? L : s.globals.stroke.colors[b]);
              v.attr({
                cx: O,
                cy: $,
                index: b,
                i: b,
                j: P,
                width: G - O,
                height: Q - $
              });
              var C = n.helpers.getShadeColor(s.config.chart.type, b, P, n.negRange),
                L = C.color;
              s.config.series[b].data[P] !== void 0 && s.config.series[b].data[P].fillColor && (L = s.config.series[b].data[P].fillColor);
              var H = u.fillPath({
                color: L,
                seriesNumber: b,
                dataPointIndex: P
              });
              v.node.classList.add("apexcharts-treemap-rect"), v.attr({
                fill: H
              }), n.helpers.addListeners(v);
              var q = {
                  x: O + (G - O) / 2,
                  y: $ + (Q - $) / 2,
                  width: 0,
                  height: 0
                },
                ee = {
                  x: O,
                  y: $,
                  width: G - O,
                  height: Q - $
                };
              if (s.config.chart.animations.enabled && !s.globals.dataChanged) {
                var ge = 1;
                s.globals.resized || (ge = s.config.chart.animations.speed), n.animateTreemap(v, q, ee, ge)
              }
              if (s.globals.dataChanged) {
                var pe = 1;
                n.dynamicAnim.enabled && s.globals.shouldAnimate && (pe = n.dynamicAnim.speed, s.globals.previousPaths[b] && s.globals.previousPaths[b][P] && s.globals.previousPaths[b][P].rect && (q = s.globals.previousPaths[b][P].rect), n.animateTreemap(v, q, ee, pe))
              }
              var Fe = n.getFontSize(T),
                Ue = s.config.dataLabels.formatter(n.labels[b][P], {
                  value: s.globals.series[b][P],
                  seriesIndex: b,
                  dataPointIndex: P,
                  w: s
                });
              s.config.plotOptions.treemap.dataLabels.format === "truncate" && (Fe = parseInt(s.config.dataLabels.style.fontSize, 10), Ue = n.truncateLabels(Ue, Fe, O, $, G, Q));
              var Ve = n.helpers.calculateDataLabels({
                text: Ue,
                x: (O + G) / 2,
                y: ($ + Q) / 2 + n.strokeWidth / 2 + Fe / 3,
                i: b,
                j: P,
                colorProps: C,
                fontSize: Fe,
                series: r
              });
              s.config.dataLabels.enabled && Ve && n.rotateToFitLabel(Ve, Fe, Ue, O, $, G, Q), y.add(v), Ve !== null && y.add(Ve)
            }), y.add(_), d.add(y)
          }), d
        }
      }, {
        key: "getFontSize",
        value: function (r) {
          var n = this.w,
            s, c, u, d, f = function g(b) {
              var y, x = 0;
              if (Array.isArray(b[0]))
                for (y = 0; y < b.length; y++) x += g(b[y]);
              else
                for (y = 0; y < b.length; y++) x += b[y].length;
              return x
            }(this.labels) / function g(b) {
              var y, x = 0;
              if (Array.isArray(b[0]))
                for (y = 0; y < b.length; y++) x += g(b[y]);
              else
                for (y = 0; y < b.length; y++) x += 1;
              return x
            }(this.labels);
          return s = r[2] - r[0], c = r[3] - r[1], u = s * c, d = Math.pow(u, .5), Math.min(d / f, parseInt(n.config.dataLabels.style.fontSize, 10))
        }
      }, {
        key: "rotateToFitLabel",
        value: function (r, n, s, c, u, d, f) {
          var g = new W(this.ctx),
            b = g.getTextRects(s, n);
          if (b.width + this.w.config.stroke.width + 5 > d - c && b.width <= f - u) {
            var y = g.rotateAroundCenter(r.node);
            r.node.setAttribute("transform", "rotate(-90 ".concat(y.x, " ").concat(y.y, ") translate(").concat(b.height / 3, ")"))
          }
        }
      }, {
        key: "truncateLabels",
        value: function (r, n, s, c, u, d) {
          var f = new W(this.ctx),
            g = f.getTextRects(r, n).width + this.w.config.stroke.width + 5 > u - s && d - c > u - s ? d - c : u - s,
            b = f.getTextBasedOnMaxWidth({
              text: r,
              maxWidth: g,
              fontSize: n
            });
          return r.length !== b.length && g / n < 5 ? "" : b
        }
      }, {
        key: "animateTreemap",
        value: function (r, n, s, c) {
          var u = new N(this.ctx);
          u.animateRect(r, {
            x: n.x,
            y: n.y,
            width: n.width,
            height: n.height
          }, {
            x: s.x,
            y: s.y,
            width: s.width,
            height: s.height
          }, c, function () {
            u.animationCompleted(r)
          })
        }
      }]), Y
    }(),
    _o = 86400,
    So = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC
      }
      return p(Y, [{
        key: "calculateTimeScaleTicks",
        value: function (r, n) {
          var s = this,
            c = this.w;
          if (c.globals.allSeriesCollapsed) return c.globals.labels = [], c.globals.timescaleLabels = [], [];
          var u = new ye(this.ctx),
            d = (n - r) / 864e5;
          this.determineInterval(d), c.globals.disableZoomIn = !1, c.globals.disableZoomOut = !1, d < .00011574074074074075 ? c.globals.disableZoomIn = !0 : d > 5e4 && (c.globals.disableZoomOut = !0);
          var f = u.getTimeUnitsfromTimestamp(r, n, this.utc),
            g = c.globals.gridWidth / d,
            b = g / 24,
            y = b / 60,
            x = y / 60,
            _ = Math.floor(24 * d),
            T = Math.floor(1440 * d),
            P = Math.floor(d * _o),
            O = Math.floor(d),
            $ = Math.floor(d / 30),
            G = Math.floor(d / 365),
            Q = {
              minMillisecond: f.minMillisecond,
              minSecond: f.minSecond,
              minMinute: f.minMinute,
              minHour: f.minHour,
              minDate: f.minDate,
              minMonth: f.minMonth,
              minYear: f.minYear
            },
            v = {
              firstVal: Q,
              currentMillisecond: Q.minMillisecond,
              currentSecond: Q.minSecond,
              currentMinute: Q.minMinute,
              currentHour: Q.minHour,
              currentMonthDate: Q.minDate,
              currentDate: Q.minDate,
              currentMonth: Q.minMonth,
              currentYear: Q.minYear,
              daysWidthOnXAxis: g,
              hoursWidthOnXAxis: b,
              minutesWidthOnXAxis: y,
              secondsWidthOnXAxis: x,
              numberOfSeconds: P,
              numberOfMinutes: T,
              numberOfHours: _,
              numberOfDays: O,
              numberOfMonths: $,
              numberOfYears: G
            };
          switch (this.tickInterval) {
            case "years":
              this.generateYearScale(v);
              break;
            case "months":
            case "half_year":
              this.generateMonthScale(v);
              break;
            case "months_days":
            case "months_fortnight":
            case "days":
            case "week_days":
              this.generateDayScale(v);
              break;
            case "hours":
              this.generateHourScale(v);
              break;
            case "minutes_fives":
            case "minutes":
              this.generateMinuteScale(v);
              break;
            case "seconds_tens":
            case "seconds_fives":
            case "seconds":
              this.generateSecondScale(v)
          }
          var C = this.timeScaleArray.map(function (L) {
            var H = {
              position: L.position,
              unit: L.unit,
              year: L.year,
              day: L.day ? L.day : 1,
              hour: L.hour ? L.hour : 0,
              month: L.month + 1
            };
            return L.unit === "month" ? i(i({}, H), {}, {
              day: 1,
              value: L.value + 1
            }) : L.unit === "day" || L.unit === "hour" ? i(i({}, H), {}, {
              value: L.value
            }) : L.unit === "minute" ? i(i({}, H), {}, {
              value: L.value,
              minute: L.value
            }) : L.unit === "second" ? i(i({}, H), {}, {
              value: L.value,
              minute: L.minute,
              second: L.second
            }) : L
          });
          return C.filter(function (L) {
            var H = 1,
              q = Math.ceil(c.globals.gridWidth / 120),
              ee = L.value;
            c.config.xaxis.tickAmount !== void 0 && (q = c.config.xaxis.tickAmount), C.length > q && (H = Math.floor(C.length / q));
            var ge = !1,
              pe = !1;
            switch (s.tickInterval) {
              case "years":
                L.unit === "year" && (ge = !0);
                break;
              case "half_year":
                H = 7, L.unit === "year" && (ge = !0);
                break;
              case "months":
                H = 1, L.unit === "year" && (ge = !0);
                break;
              case "months_fortnight":
                H = 15, L.unit !== "year" && L.unit !== "month" || (ge = !0), ee === 30 && (pe = !0);
                break;
              case "months_days":
                H = 10, L.unit === "month" && (ge = !0), ee === 30 && (pe = !0);
                break;
              case "week_days":
                H = 8, L.unit === "month" && (ge = !0);
                break;
              case "days":
                H = 1, L.unit === "month" && (ge = !0);
                break;
              case "hours":
                L.unit === "day" && (ge = !0);
                break;
              case "minutes_fives":
              case "seconds_fives":
                ee % 5 != 0 && (pe = !0);
                break;
              case "seconds_tens":
                ee % 10 != 0 && (pe = !0)
            }
            if (s.tickInterval === "hours" || s.tickInterval === "minutes_fives" || s.tickInterval === "seconds_tens" || s.tickInterval === "seconds_fives") {
              if (!pe) return !0
            } else if ((ee % H == 0 || ge) && !pe) return !0
          })
        }
      }, {
        key: "recalcDimensionsBasedOnFormat",
        value: function (r, n) {
          var s = this.w,
            c = this.formatDates(r),
            u = this.removeOverlappingTS(c);
          s.globals.timescaleLabels = u.slice(), new Te(this.ctx).plotCoords()
        }
      }, {
        key: "determineInterval",
        value: function (r) {
          var n = 24 * r,
            s = 60 * n;
          switch (!0) {
            case r / 365 > 5:
              this.tickInterval = "years";
              break;
            case r > 800:
              this.tickInterval = "half_year";
              break;
            case r > 180:
              this.tickInterval = "months";
              break;
            case r > 90:
              this.tickInterval = "months_fortnight";
              break;
            case r > 60:
              this.tickInterval = "months_days";
              break;
            case r > 30:
              this.tickInterval = "week_days";
              break;
            case r > 2:
              this.tickInterval = "days";
              break;
            case n > 2.4:
              this.tickInterval = "hours";
              break;
            case s > 15:
              this.tickInterval = "minutes_fives";
              break;
            case s > 5:
              this.tickInterval = "minutes";
              break;
            case s > 1:
              this.tickInterval = "seconds_tens";
              break;
            case 60 * s > 20:
              this.tickInterval = "seconds_fives";
              break;
            default:
              this.tickInterval = "seconds"
          }
        }
      }, {
        key: "generateYearScale",
        value: function (r) {
          var n = r.firstVal,
            s = r.currentMonth,
            c = r.currentYear,
            u = r.daysWidthOnXAxis,
            d = r.numberOfYears,
            f = n.minYear,
            g = 0,
            b = new ye(this.ctx),
            y = "year";
          if (n.minDate > 1 || n.minMonth > 0) {
            var x = b.determineRemainingDaysOfYear(n.minYear, n.minMonth, n.minDate);
            g = (b.determineDaysOfYear(n.minYear) - x + 1) * u, f = n.minYear + 1, this.timeScaleArray.push({
              position: g,
              value: f,
              unit: y,
              year: f,
              month: I.monthMod(s + 1)
            })
          } else n.minDate === 1 && n.minMonth === 0 && this.timeScaleArray.push({
            position: g,
            value: f,
            unit: y,
            year: c,
            month: I.monthMod(s + 1)
          });
          for (var _ = f, T = g, P = 0; P < d; P++) _++, T = b.determineDaysOfYear(_ - 1) * u + T, this.timeScaleArray.push({
            position: T,
            value: _,
            unit: y,
            year: _,
            month: 1
          })
        }
      }, {
        key: "generateMonthScale",
        value: function (r) {
          var n = r.firstVal,
            s = r.currentMonthDate,
            c = r.currentMonth,
            u = r.currentYear,
            d = r.daysWidthOnXAxis,
            f = r.numberOfMonths,
            g = c,
            b = 0,
            y = new ye(this.ctx),
            x = "month",
            _ = 0;
          if (n.minDate > 1) {
            b = (y.determineDaysOfMonths(c + 1, n.minYear) - s + 1) * d, g = I.monthMod(c + 1);
            var T = u + _,
              P = I.monthMod(g),
              O = g;
            g === 0 && (x = "year", O = T, P = 1, T += _ += 1), this.timeScaleArray.push({
              position: b,
              value: O,
              unit: x,
              year: T,
              month: P
            })
          } else this.timeScaleArray.push({
            position: b,
            value: g,
            unit: x,
            year: u,
            month: I.monthMod(c)
          });
          for (var $ = g + 1, G = b, Q = 0, v = 1; Q < f; Q++, v++) {
            ($ = I.monthMod($)) === 0 ? (x = "year", _ += 1) : x = "month";
            var C = this._getYear(u, $, _);
            G = y.determineDaysOfMonths($, C) * d + G;
            var L = $ === 0 ? C : $;
            this.timeScaleArray.push({
              position: G,
              value: L,
              unit: x,
              year: C,
              month: $ === 0 ? 1 : $
            }), $++
          }
        }
      }, {
        key: "generateDayScale",
        value: function (r) {
          var n = r.firstVal,
            s = r.currentMonth,
            c = r.currentYear,
            u = r.hoursWidthOnXAxis,
            d = r.numberOfDays,
            f = new ye(this.ctx),
            g = "day",
            b = n.minDate + 1,
            y = b,
            x = function (v, C, L) {
              return v > f.determineDaysOfMonths(C + 1, L) && (y = 1, g = "month", T = C += 1), C
            },
            _ = (24 - n.minHour) * u,
            T = b,
            P = x(y, s, c);
          n.minHour === 0 && n.minDate === 1 ? (_ = 0, T = I.monthMod(n.minMonth), g = "month", y = n.minDate) : n.minDate !== 1 && n.minHour === 0 && n.minMinute === 0 && (_ = 0, b = n.minDate, T = b, P = x(y = b, s, c)), this.timeScaleArray.push({
            position: _,
            value: T,
            unit: g,
            year: this._getYear(c, P, 0),
            month: I.monthMod(P),
            day: y
          });
          for (var O = _, $ = 0; $ < d; $++) {
            g = "day", P = x(y += 1, P, this._getYear(c, P, 0));
            var G = this._getYear(c, P, 0);
            O = 24 * u + O;
            var Q = y === 1 ? I.monthMod(P) : y;
            this.timeScaleArray.push({
              position: O,
              value: Q,
              unit: g,
              year: G,
              month: I.monthMod(P),
              day: Q
            })
          }
        }
      }, {
        key: "generateHourScale",
        value: function (r) {
          var n = r.firstVal,
            s = r.currentDate,
            c = r.currentMonth,
            u = r.currentYear,
            d = r.minutesWidthOnXAxis,
            f = r.numberOfHours,
            g = new ye(this.ctx),
            b = "hour",
            y = function (H, q) {
              return H > g.determineDaysOfMonths(q + 1, u) && ($ = 1, q += 1), {
                month: q,
                date: $
              }
            },
            x = function (H, q) {
              return H > g.determineDaysOfMonths(q + 1, u) ? q += 1 : q
            },
            _ = 60 - (n.minMinute + n.minSecond / 60),
            T = _ * d,
            P = n.minHour + 1,
            O = P;
          _ === 60 && (T = 0, O = P = n.minHour);
          var $ = s;
          O >= 24 && (O = 0, $ += 1, b = "day");
          var G = y($, c).month;
          G = x($, G), this.timeScaleArray.push({
            position: T,
            value: P,
            unit: b,
            day: $,
            hour: O,
            year: u,
            month: I.monthMod(G)
          }), O++;
          for (var Q = T, v = 0; v < f; v++) {
            b = "hour", O >= 24 && (O = 0, b = "day", G = y($ += 1, G).month, G = x($, G));
            var C = this._getYear(u, G, 0);
            Q = 60 * d + Q;
            var L = O === 0 ? $ : O;
            this.timeScaleArray.push({
              position: Q,
              value: L,
              unit: b,
              hour: O,
              day: $,
              year: C,
              month: I.monthMod(G)
            }), O++
          }
        }
      }, {
        key: "generateMinuteScale",
        value: function (r) {
          for (var n = r.currentMillisecond, s = r.currentSecond, c = r.currentMinute, u = r.currentHour, d = r.currentDate, f = r.currentMonth, g = r.currentYear, b = r.minutesWidthOnXAxis, y = r.secondsWidthOnXAxis, x = r.numberOfMinutes, _ = c + 1, T = d, P = f, O = g, $ = u, G = (60 - s - n / 1e3) * y, Q = 0; Q < x; Q++) _ >= 60 && (_ = 0, ($ += 1) === 24 && ($ = 0)), this.timeScaleArray.push({
            position: G,
            value: _,
            unit: "minute",
            hour: $,
            minute: _,
            day: T,
            year: this._getYear(O, P, 0),
            month: I.monthMod(P)
          }), G += b, _++
        }
      }, {
        key: "generateSecondScale",
        value: function (r) {
          for (var n = r.currentMillisecond, s = r.currentSecond, c = r.currentMinute, u = r.currentHour, d = r.currentDate, f = r.currentMonth, g = r.currentYear, b = r.secondsWidthOnXAxis, y = r.numberOfSeconds, x = s + 1, _ = c, T = d, P = f, O = g, $ = u, G = (1e3 - n) / 1e3 * b, Q = 0; Q < y; Q++) x >= 60 && (x = 0, ++_ >= 60 && (_ = 0, ++$ === 24 && ($ = 0))), this.timeScaleArray.push({
            position: G,
            value: x,
            unit: "second",
            hour: $,
            minute: _,
            second: x,
            day: T,
            year: this._getYear(O, P, 0),
            month: I.monthMod(P)
          }), G += b, x++
        }
      }, {
        key: "createRawDateString",
        value: function (r, n) {
          var s = r.year;
          return r.month === 0 && (r.month = 1), s += "-" + ("0" + r.month.toString()).slice(-2), r.unit === "day" ? s += r.unit === "day" ? "-" + ("0" + n).slice(-2) : "-01" : s += "-" + ("0" + (r.day ? r.day : "1")).slice(-2), r.unit === "hour" ? s += r.unit === "hour" ? "T" + ("0" + n).slice(-2) : "T00" : s += "T" + ("0" + (r.hour ? r.hour : "0")).slice(-2), r.unit === "minute" ? s += ":" + ("0" + n).slice(-2) : s += ":" + (r.minute ? ("0" + r.minute).slice(-2) : "00"), r.unit === "second" ? s += ":" + ("0" + n).slice(-2) : s += ":00", this.utc && (s += ".000Z"), s
        }
      }, {
        key: "formatDates",
        value: function (r) {
          var n = this,
            s = this.w;
          return r.map(function (c) {
            var u = c.value.toString(),
              d = new ye(n.ctx),
              f = n.createRawDateString(c, u),
              g = d.getDate(d.parseDate(f));
            if (n.utc || (g = d.getDate(d.parseDateWithTimezone(f))), s.config.xaxis.labels.format === void 0) {
              var b = "dd MMM",
                y = s.config.xaxis.labels.datetimeFormatter;
              c.unit === "year" && (b = y.year), c.unit === "month" && (b = y.month), c.unit === "day" && (b = y.day), c.unit === "hour" && (b = y.hour), c.unit === "minute" && (b = y.minute), c.unit === "second" && (b = y.second), u = d.formatDate(g, b)
            } else u = d.formatDate(g, s.config.xaxis.labels.format);
            return {
              dateString: f,
              position: c.position,
              value: u,
              unit: c.unit,
              year: c.year,
              month: c.month
            }
          })
        }
      }, {
        key: "removeOverlappingTS",
        value: function (r) {
          var n, s = this,
            c = new W(this.ctx),
            u = !1;
          r.length > 0 && r[0].value && r.every(function (g) {
            return g.value.length === r[0].value.length
          }) && (u = !0, n = c.getTextRects(r[0].value).width);
          var d = 0,
            f = r.map(function (g, b) {
              if (b > 0 && s.w.config.xaxis.labels.hideOverlappingLabels) {
                var y = u ? n : c.getTextRects(r[d].value).width,
                  x = r[d].position;
                return g.position > x + y + 10 ? (d = b, g) : null
              }
              return g
            });
          return f = f.filter(function (g) {
            return g !== null
          })
        }
      }, {
        key: "_getYear",
        value: function (r, n, s) {
          return r + Math.floor(n / 12) + s
        }
      }]), Y
    }(),
    Ao = function () {
      function Y(r, n) {
        l(this, Y), this.ctx = n, this.w = n.w, this.el = r
      }
      return p(Y, [{
        key: "setupElements",
        value: function () {
          var r = this.w.globals,
            n = this.w.config,
            s = n.chart.type;
          r.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(s) > -1, r.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(s) > -1, r.isBarHorizontal = (n.chart.type === "bar" || n.chart.type === "rangeBar" || n.chart.type === "boxPlot") && n.plotOptions.bar.horizontal, r.chartClass = ".apexcharts" + r.chartID, r.dom.baseEl = this.el, r.dom.elWrap = document.createElement("div"), W.setAttrs(r.dom.elWrap, {
            id: r.chartClass.substring(1),
            class: "apexcharts-canvas " + r.chartClass.substring(1)
          }), this.el.appendChild(r.dom.elWrap), r.dom.Paper = new window.SVG.Doc(r.dom.elWrap), r.dom.Paper.attr({
            class: "apexcharts-svg",
            "xmlns:data": "ApexChartsNS",
            transform: "translate(".concat(n.chart.offsetX, ", ").concat(n.chart.offsetY, ")")
          }), r.dom.Paper.node.style.background = n.theme.mode !== "dark" || n.chart.background ? n.chart.background : "rgba(0, 0, 0, 0.8)", this.setSVGDimensions(), r.dom.elLegendForeign = document.createElementNS(r.SVGNS, "foreignObject"), W.setAttrs(r.dom.elLegendForeign, {
            x: 0,
            y: 0,
            width: r.svgWidth,
            height: r.svgHeight
          }), r.dom.elLegendWrap = document.createElement("div"), r.dom.elLegendWrap.classList.add("apexcharts-legend"), r.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), r.dom.elLegendForeign.appendChild(r.dom.elLegendWrap), r.dom.Paper.node.appendChild(r.dom.elLegendForeign), r.dom.elGraphical = r.dom.Paper.group().attr({
            class: "apexcharts-inner apexcharts-graphical"
          }), r.dom.elDefs = r.dom.Paper.defs(), r.dom.Paper.add(r.dom.elGraphical), r.dom.elGraphical.add(r.dom.elDefs)
        }
      }, {
        key: "plotChartType",
        value: function (r, n) {
          var s = this.w,
            c = s.config,
            u = s.globals,
            d = {
              series: [],
              i: []
            },
            f = {
              series: [],
              i: []
            },
            g = {
              series: [],
              i: []
            },
            b = {
              series: [],
              i: []
            },
            y = {
              series: [],
              i: []
            },
            x = {
              series: [],
              i: []
            },
            _ = {
              series: [],
              i: []
            },
            T = {
              series: [],
              i: []
            },
            P = {
              series: [],
              seriesRangeEnd: [],
              i: []
            };
          u.series.map(function (q, ee) {
            var ge = 0;
            r[ee].type !== void 0 ? (r[ee].type === "column" || r[ee].type === "bar" ? (u.series.length > 1 && c.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), y.series.push(q), y.i.push(ee), ge++, s.globals.columnSeries = y.series) : r[ee].type === "area" ? (f.series.push(q), f.i.push(ee), ge++) : r[ee].type === "line" ? (d.series.push(q), d.i.push(ee), ge++) : r[ee].type === "scatter" ? (g.series.push(q), g.i.push(ee)) : r[ee].type === "bubble" ? (b.series.push(q), b.i.push(ee), ge++) : r[ee].type === "candlestick" ? (x.series.push(q), x.i.push(ee), ge++) : r[ee].type === "boxPlot" ? (_.series.push(q), _.i.push(ee), ge++) : r[ee].type === "rangeBar" ? (T.series.push(q), T.i.push(ee), ge++) : r[ee].type === "rangeArea" ? (P.series.push(u.seriesRangeStart[ee]), P.seriesRangeEnd.push(u.seriesRangeEnd[ee]), P.i.push(ee), ge++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble/candlestick/boxPlot/rangeBar/rangeArea"), ge > 1 && (u.comboCharts = !0)) : (d.series.push(q), d.i.push(ee))
          });
          var O = new Dn(this.ctx, n),
            $ = new ca(this.ctx, n);
          this.ctx.pie = new Lr(this.ctx);
          var G = new Or(this.ctx);
          this.ctx.rangeBar = new Jn(this.ctx, n);
          var Q = new lr(this.ctx),
            v = [];
          if (u.comboCharts) {
            if (f.series.length > 0 && v.push(O.draw(f.series, "area", f.i)), y.series.length > 0)
              if (s.config.chart.stacked) {
                var C = new ct(this.ctx, n);
                v.push(C.draw(y.series, y.i))
              } else this.ctx.bar = new et(this.ctx, n), v.push(this.ctx.bar.draw(y.series, y.i));
            if (P.series.length > 0 && v.push(O.draw(P.series, "rangeArea", P.i, P.seriesRangeEnd)), d.series.length > 0 && v.push(O.draw(d.series, "line", d.i)), x.series.length > 0 && v.push($.draw(x.series, "candlestick", x.i)), _.series.length > 0 && v.push($.draw(_.series, "boxPlot", _.i)), T.series.length > 0 && v.push(this.ctx.rangeBar.draw(T.series, T.i)), g.series.length > 0) {
              var L = new Dn(this.ctx, n, !0);
              v.push(L.draw(g.series, "scatter", g.i))
            }
            if (b.series.length > 0) {
              var H = new Dn(this.ctx, n, !0);
              v.push(H.draw(b.series, "bubble", b.i))
            }
          } else switch (c.chart.type) {
            case "line":
              v = O.draw(u.series, "line");
              break;
            case "area":
              v = O.draw(u.series, "area");
              break;
            case "bar":
              c.chart.stacked ? v = new ct(this.ctx, n).draw(u.series) : (this.ctx.bar = new et(this.ctx, n), v = this.ctx.bar.draw(u.series));
              break;
            case "candlestick":
              v = new ca(this.ctx, n).draw(u.series, "candlestick");
              break;
            case "boxPlot":
              v = new ca(this.ctx, n).draw(u.series, c.chart.type);
              break;
            case "rangeBar":
              v = this.ctx.rangeBar.draw(u.series);
              break;
            case "rangeArea":
              v = O.draw(u.seriesRangeStart, "rangeArea", void 0, u.seriesRangeEnd);
              break;
            case "heatmap":
              v = new nr(this.ctx, n).draw(u.series);
              break;
            case "treemap":
              v = new ko(this.ctx, n).draw(u.series);
              break;
            case "pie":
            case "donut":
            case "polarArea":
              v = this.ctx.pie.draw(u.series);
              break;
            case "radialBar":
              v = G.draw(u.series);
              break;
            case "radar":
              v = Q.draw(u.series);
              break;
            default:
              v = O.draw(u.series)
          }
          return v
        }
      }, {
        key: "setSVGDimensions",
        value: function () {
          var r = this.w.globals,
            n = this.w.config;
          r.svgWidth = n.chart.width, r.svgHeight = n.chart.height;
          var s = I.getDimensions(this.el),
            c = n.chart.width.toString().split(/[0-9]+/g).pop();
          c === "%" ? I.isNumber(s[0]) && (s[0].width === 0 && (s = I.getDimensions(this.el.parentNode)), r.svgWidth = s[0] * parseInt(n.chart.width, 10) / 100) : c !== "px" && c !== "" || (r.svgWidth = parseInt(n.chart.width, 10));
          var u = n.chart.height.toString().split(/[0-9]+/g).pop();
          if (r.svgHeight !== "auto" && r.svgHeight !== "")
            if (u === "%") {
              var d = I.getDimensions(this.el.parentNode);
              r.svgHeight = d[1] * parseInt(n.chart.height, 10) / 100
            } else r.svgHeight = parseInt(n.chart.height, 10);
          else r.axisCharts ? r.svgHeight = r.svgWidth / 1.61 : r.svgHeight = r.svgWidth / 1.2;
          if (r.svgWidth < 0 && (r.svgWidth = 0), r.svgHeight < 0 && (r.svgHeight = 0), W.setAttrs(r.dom.Paper.node, {
              width: r.svgWidth,
              height: r.svgHeight
            }), u !== "%") {
            var f = n.chart.sparkline.enabled ? 0 : r.axisCharts ? n.chart.parentHeightOffset : 0;
            r.dom.Paper.node.parentNode.parentNode.style.minHeight = r.svgHeight + f + "px"
          }
          r.dom.elWrap.style.width = r.svgWidth + "px", r.dom.elWrap.style.height = r.svgHeight + "px"
        }
      }, {
        key: "shiftGraphPosition",
        value: function () {
          var r = this.w.globals,
            n = r.translateY,
            s = {
              transform: "translate(" + r.translateX + ", " + n + ")"
            };
          W.setAttrs(r.dom.elGraphical.node, s)
        }
      }, {
        key: "resizeNonAxisCharts",
        value: function () {
          var r = this.w,
            n = r.globals,
            s = 0,
            c = r.config.chart.sparkline.enabled ? 1 : 15;
          c += r.config.grid.padding.bottom, r.config.legend.position !== "top" && r.config.legend.position !== "bottom" || !r.config.legend.show || r.config.legend.floating || (s = new ft(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
          var u = r.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),
            d = 2.05 * r.globals.radialSize;
          if (u && !r.config.chart.sparkline.enabled && r.config.plotOptions.radialBar.startAngle !== 0) {
            var f = I.getBoundingClientRect(u);
            d = f.bottom;
            var g = f.bottom - f.top;
            d = Math.max(2.05 * r.globals.radialSize, g)
          }
          var b = d + n.translateY + s + c;
          n.dom.elLegendForeign && n.dom.elLegendForeign.setAttribute("height", b), r.config.chart.height && String(r.config.chart.height).indexOf("%") > 0 || (n.dom.elWrap.style.height = b + "px", W.setAttrs(n.dom.Paper.node, {
            height: b
          }), n.dom.Paper.node.parentNode.parentNode.style.minHeight = b + "px")
        }
      }, {
        key: "coreCalculations",
        value: function () {
          new F(this.ctx).init()
        }
      }, {
        key: "resetGlobals",
        value: function () {
          var r = this,
            n = function () {
              return r.w.config.series.map(function (u) {
                return []
              })
            },
            s = new Ye,
            c = this.w.globals;
          s.initGlobalVars(c), c.seriesXvalues = n(), c.seriesYvalues = n()
        }
      }, {
        key: "isMultipleY",
        value: function () {
          if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0
        }
      }, {
        key: "xySettings",
        value: function () {
          var r = null,
            n = this.w;
          if (n.globals.axisCharts) {
            if (n.config.xaxis.crosshairs.position === "back" && new ue(this.ctx).drawXCrosshairs(), n.config.yaxis[0].crosshairs.position === "back" && new ue(this.ctx).drawYCrosshairs(), n.config.xaxis.type === "datetime" && n.config.xaxis.labels.formatter === void 0) {
              this.ctx.timeScale = new So(this.ctx);
              var s = [];
              isFinite(n.globals.minX) && isFinite(n.globals.maxX) && !n.globals.isBarHorizontal ? s = this.ctx.timeScale.calculateTimeScaleTicks(n.globals.minX, n.globals.maxX) : n.globals.isBarHorizontal && (s = this.ctx.timeScale.calculateTimeScaleTicks(n.globals.minY, n.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(s)
            }
            r = new X(this.ctx).getCalculatedRatios()
          }
          return r
        }
      }, {
        key: "updateSourceChart",
        value: function (r) {
          this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
            chart: {
              selection: {
                xaxis: {
                  min: r.w.globals.minX,
                  max: r.w.globals.maxX
                }
              }
            }
          }, !1, !1)
        }
      }, {
        key: "setupBrushHandler",
        value: function () {
          var r = this,
            n = this.w;
          if (n.config.chart.brush.enabled && typeof n.config.chart.events.selection != "function") {
            var s = Array.isArray(n.config.chart.brush.targets) ? n.config.chart.brush.targets : [n.config.chart.brush.target];
            s.forEach(function (c) {
              var u = ApexCharts.getChartByID(c);
              u.w.globals.brushSource = r.ctx, typeof u.w.config.chart.events.zoomed != "function" && (u.w.config.chart.events.zoomed = function () {
                r.updateSourceChart(u)
              }), typeof u.w.config.chart.events.scrolled != "function" && (u.w.config.chart.events.scrolled = function () {
                r.updateSourceChart(u)
              })
            }), n.config.chart.events.selection = function (c, u) {
              s.forEach(function (d) {
                var f = ApexCharts.getChartByID(d),
                  g = I.clone(n.config.yaxis);
                if (n.config.chart.brush.autoScaleYaxis && f.w.globals.series.length === 1) {
                  var b = new We(f);
                  g = b.autoScaleY(f, g, u)
                }
                var y = f.w.config.yaxis.reduce(function (x, _, T) {
                  return [].concat(D(x), [i(i({}, f.w.config.yaxis[T]), {}, {
                    min: g[0].min,
                    max: g[0].max
                  })])
                }, []);
                f.ctx.updateHelpers._updateOptions({
                  xaxis: {
                    min: u.xaxis.min,
                    max: u.xaxis.max
                  },
                  yaxis: y
                }, !1, !1, !1, !1)
              })
            }
          }
        }
      }]), Y
    }(),
    Ka = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "_updateOptions",
        value: function (r) {
          var n = this,
            s = arguments.length > 1 && arguments[1] !== void 0 && arguments[1],
            c = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2],
            u = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3],
            d = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
          return new Promise(function (f) {
            var g = [n.ctx];
            u && (g = n.ctx.getSyncedCharts()), n.ctx.w.globals.isExecCalled && (g = [n.ctx], n.ctx.w.globals.isExecCalled = !1), g.forEach(function (b, y) {
              var x = b.w;
              if (x.globals.shouldAnimate = c, s || (x.globals.resized = !0, x.globals.dataChanged = !0, c && b.series.getPreviousPaths()), r && o(r) === "object" && (b.config = new De(r), r = X.extendArrayProps(b.config, r, x), b.w.globals.chartID !== n.ctx.w.globals.chartID && delete r.series, x.config = I.extend(x.config, r), d && (x.globals.lastXAxis = r.xaxis ? I.clone(r.xaxis) : [], x.globals.lastYAxis = r.yaxis ? I.clone(r.yaxis) : [], x.globals.initialConfig = I.extend({}, x.config), x.globals.initialSeries = I.clone(x.config.series), r.series))) {
                for (var _ = 0; _ < x.globals.collapsedSeriesIndices.length; _++) {
                  var T = x.config.series[x.globals.collapsedSeriesIndices[_]];
                  x.globals.collapsedSeries[_].data = x.globals.axisCharts ? T.data.slice() : T
                }
                for (var P = 0; P < x.globals.ancillaryCollapsedSeriesIndices.length; P++) {
                  var O = x.config.series[x.globals.ancillaryCollapsedSeriesIndices[P]];
                  x.globals.ancillaryCollapsedSeries[P].data = x.globals.axisCharts ? O.data.slice() : O
                }
                b.series.emptyCollapsedSeries(x.config.series)
              }
              return b.update(r).then(function () {
                y === g.length - 1 && f(b)
              })
            })
          })
        }
      }, {
        key: "_updateSeries",
        value: function (r, n) {
          var s = this,
            c = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
          return new Promise(function (u) {
            var d, f = s.w;
            return f.globals.shouldAnimate = n, f.globals.dataChanged = !0, n && s.ctx.series.getPreviousPaths(), f.globals.axisCharts ? ((d = r.map(function (g, b) {
              return s._extendSeries(g, b)
            })).length === 0 && (d = [{
              data: []
            }]), f.config.series = d) : f.config.series = r.slice(), c && (f.globals.initialConfig.series = I.clone(f.config.series), f.globals.initialSeries = I.clone(f.config.series)), s.ctx.update().then(function () {
              u(s.ctx)
            })
          })
        }
      }, {
        key: "_extendSeries",
        value: function (r, n) {
          var s = this.w,
            c = s.config.series[n];
          return i(i({}, s.config.series[n]), {}, {
            name: r.name ? r.name : c == null ? void 0 : c.name,
            color: r.color ? r.color : c == null ? void 0 : c.color,
            type: r.type ? r.type : c == null ? void 0 : c.type,
            group: r.group ? r.group : c == null ? void 0 : c.group,
            data: r.data ? r.data : c == null ? void 0 : c.data,
            zIndex: r.zIndex !== void 0 ? r.zIndex : n
          })
        }
      }, {
        key: "toggleDataPointSelection",
        value: function (r, n) {
          var s = this.w,
            c = null,
            u = ".apexcharts-series[data\\:realIndex='".concat(r, "']");
          return s.globals.axisCharts ? c = s.globals.dom.Paper.select("".concat(u, " path[j='").concat(n, "'], ").concat(u, " circle[j='").concat(n, "'], ").concat(u, " rect[j='").concat(n, "']")).members[0] : n === void 0 && (c = s.globals.dom.Paper.select("".concat(u, " path[j='").concat(r, "']")).members[0], s.config.chart.type !== "pie" && s.config.chart.type !== "polarArea" && s.config.chart.type !== "donut" || this.ctx.pie.pieClicked(r)), c ? (new W(this.ctx).pathMouseDown(c, null), c.node ? c.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null)
        }
      }, {
        key: "forceXAxisUpdate",
        value: function (r) {
          var n = this.w;
          if (["min", "max"].forEach(function (c) {
              r.xaxis[c] !== void 0 && (n.config.xaxis[c] = r.xaxis[c], n.globals.lastXAxis[c] = r.xaxis[c])
            }), r.xaxis.categories && r.xaxis.categories.length && (n.config.xaxis.categories = r.xaxis.categories), n.config.xaxis.convertedCatToNumeric) {
            var s = new He(r);
            r = s.convertCatToNumericXaxis(r, this.ctx)
          }
          return r
        }
      }, {
        key: "forceYAxisUpdate",
        value: function (r) {
          return r.chart && r.chart.stacked && r.chart.stackType === "100%" && (Array.isArray(r.yaxis) ? r.yaxis.forEach(function (n, s) {
            r.yaxis[s].min = 0, r.yaxis[s].max = 100
          }) : (r.yaxis.min = 0, r.yaxis.max = 100)), r
        }
      }, {
        key: "revertDefaultAxisMinMax",
        value: function (r) {
          var n = this,
            s = this.w,
            c = s.globals.lastXAxis,
            u = s.globals.lastYAxis;
          r && r.xaxis && (c = r.xaxis), r && r.yaxis && (u = r.yaxis), s.config.xaxis.min = c.min, s.config.xaxis.max = c.max;
          var d = function (f) {
            u[f] !== void 0 && (s.config.yaxis[f].min = u[f].min, s.config.yaxis[f].max = u[f].max)
          };
          s.config.yaxis.map(function (f, g) {
            s.globals.zoomed || u[g] !== void 0 ? d(g) : n.ctx.opts.yaxis[g] !== void 0 && (f.min = n.ctx.opts.yaxis[g].min, f.max = n.ctx.opts.yaxis[g].max)
          })
        }
      }]), Y
    }();
  ga = typeof window < "u" ? window : void 0, ti = function (Y, r) {
      var n = (this !== void 0 ? this : Y).SVG = function (v) {
        if (n.supported) return v = new n.Doc(v), n.parser.draw || n.prepare(), v
      };
      if (n.ns = "http://www.w3.org/2000/svg", n.xmlns = "http://www.w3.org/2000/xmlns/", n.xlink = "http://www.w3.org/1999/xlink", n.svgjs = "http://svgjs.dev", n.supported = !0, !n.supported) return !1;
      n.did = 1e3, n.eid = function (v) {
        return "Svgjs" + y(v) + n.did++
      }, n.create = function (v) {
        var C = r.createElementNS(this.ns, v);
        return C.setAttribute("id", this.eid(v)), C
      }, n.extend = function () {
        var v, C;
        C = (v = [].slice.call(arguments)).pop();
        for (var L = v.length - 1; L >= 0; L--)
          if (v[L])
            for (var H in C) v[L].prototype[H] = C[H];
        n.Set && n.Set.inherit && n.Set.inherit()
      }, n.invent = function (v) {
        var C = typeof v.create == "function" ? v.create : function () {
          this.constructor.call(this, n.create(v.create))
        };
        return v.inherit && (C.prototype = new v.inherit), v.extend && n.extend(C, v.extend), v.construct && n.extend(v.parent || n.Container, v.construct), C
      }, n.adopt = function (v) {
        return v ? v.instance ? v.instance : ((C = v.nodeName == "svg" ? v.parentNode instanceof Y.SVGElement ? new n.Nested : new n.Doc : v.nodeName == "linearGradient" ? new n.Gradient("linear") : v.nodeName == "radialGradient" ? new n.Gradient("radial") : n[y(v.nodeName)] ? new n[y(v.nodeName)] : new n.Element(v)).type = v.nodeName, C.node = v, v.instance = C, C instanceof n.Doc && C.namespace().defs(), C.setData(JSON.parse(v.getAttribute("svgjs:data")) || {}), C) : null;
        var C
      }, n.prepare = function () {
        var v = r.getElementsByTagName("body")[0],
          C = (v ? new n.Doc(v) : n.adopt(r.documentElement).nested()).size(2, 0);
        n.parser = {
          body: v || r.documentElement,
          draw: C.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
          poly: C.polyline().node,
          path: C.path().node,
          native: n.create("svg")
        }
      }, n.parser = {
        native: n.create("svg")
      }, r.addEventListener("DOMContentLoaded", function () {
        n.parser.draw || n.prepare()
      }, !1), n.regex = {
        numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
        hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
        rgb: /rgb\((\d+),(\d+),(\d+)\)/,
        reference: /#([a-z0-9\-_]+)/i,
        transforms: /\)\s*,?\s*/,
        whitespace: /\s/g,
        isHex: /^#[a-f0-9]{3,6}$/i,
        isRgb: /^rgb\(/,
        isCss: /[^:]+:[^;]+;?/,
        isBlank: /^(\s+)?$/,
        isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        isPercent: /^-?[\d\.]+%$/,
        isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
        delimiter: /[\s,]+/,
        hyphen: /([^e])\-/gi,
        pathLetters: /[MLHVCSQTAZ]/gi,
        isPathLetter: /[MLHVCSQTAZ]/i,
        numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
        dots: /\./g
      }, n.utils = {
        map: function (v, C) {
          for (var L = v.length, H = [], q = 0; q < L; q++) H.push(C(v[q]));
          return H
        },
        filter: function (v, C) {
          for (var L = v.length, H = [], q = 0; q < L; q++) C(v[q]) && H.push(v[q]);
          return H
        },
        filterSVGElements: function (v) {
          return this.filter(v, function (C) {
            return C instanceof Y.SVGElement
          })
        }
      }, n.defaults = {
        attrs: {
          "fill-opacity": 1,
          "stroke-opacity": 1,
          "stroke-width": 0,
          "stroke-linejoin": "miter",
          "stroke-linecap": "butt",
          fill: "#000000",
          stroke: "#000000",
          opacity: 1,
          x: 0,
          y: 0,
          cx: 0,
          cy: 0,
          width: 0,
          height: 0,
          r: 0,
          rx: 0,
          ry: 0,
          offset: 0,
          "stop-opacity": 1,
          "stop-color": "#000000",
          "font-size": 16,
          "font-family": "Helvetica, Arial, sans-serif",
          "text-anchor": "start"
        }
      }, n.Color = function (v) {
        var C, L;
        this.r = 0, this.g = 0, this.b = 0, v && (typeof v == "string" ? n.regex.isRgb.test(v) ? (C = n.regex.rgb.exec(v.replace(n.regex.whitespace, "")), this.r = parseInt(C[1]), this.g = parseInt(C[2]), this.b = parseInt(C[3])) : n.regex.isHex.test(v) && (C = n.regex.hex.exec((L = v).length == 4 ? ["#", L.substring(1, 2), L.substring(1, 2), L.substring(2, 3), L.substring(2, 3), L.substring(3, 4), L.substring(3, 4)].join("") : L), this.r = parseInt(C[1], 16), this.g = parseInt(C[2], 16), this.b = parseInt(C[3], 16)) : o(v) === "object" && (this.r = v.r, this.g = v.g, this.b = v.b))
      }, n.extend(n.Color, {
        toString: function () {
          return this.toHex()
        },
        toHex: function () {
          return "#" + x(this.r) + x(this.g) + x(this.b)
        },
        toRgb: function () {
          return "rgb(" + [this.r, this.g, this.b].join() + ")"
        },
        brightness: function () {
          return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
        },
        morph: function (v) {
          return this.destination = new n.Color(v), this
        },
        at: function (v) {
          return this.destination ? (v = v < 0 ? 0 : v > 1 ? 1 : v, new n.Color({
            r: ~~(this.r + (this.destination.r - this.r) * v),
            g: ~~(this.g + (this.destination.g - this.g) * v),
            b: ~~(this.b + (this.destination.b - this.b) * v)
          })) : this
        }
      }), n.Color.test = function (v) {
        return v += "", n.regex.isHex.test(v) || n.regex.isRgb.test(v)
      }, n.Color.isRgb = function (v) {
        return v && typeof v.r == "number" && typeof v.g == "number" && typeof v.b == "number"
      }, n.Color.isColor = function (v) {
        return n.Color.isRgb(v) || n.Color.test(v)
      }, n.Array = function (v, C) {
        (v = (v || []).valueOf()).length == 0 && C && (v = C.valueOf()), this.value = this.parse(v)
      }, n.extend(n.Array, {
        toString: function () {
          return this.value.join(" ")
        },
        valueOf: function () {
          return this.value
        },
        parse: function (v) {
          return v = v.valueOf(), Array.isArray(v) ? v : this.split(v)
        }
      }), n.PointArray = function (v, C) {
        n.Array.call(this, v, C || [
          [0, 0]
        ])
      }, n.PointArray.prototype = new n.Array, n.PointArray.prototype.constructor = n.PointArray;
      for (var s = {
          M: function (v, C, L) {
            return C.x = L.x = v[0], C.y = L.y = v[1], ["M", C.x, C.y]
          },
          L: function (v, C) {
            return C.x = v[0], C.y = v[1], ["L", v[0], v[1]]
          },
          H: function (v, C) {
            return C.x = v[0], ["H", v[0]]
          },
          V: function (v, C) {
            return C.y = v[0], ["V", v[0]]
          },
          C: function (v, C) {
            return C.x = v[4], C.y = v[5], ["C", v[0], v[1], v[2], v[3], v[4], v[5]]
          },
          Q: function (v, C) {
            return C.x = v[2], C.y = v[3], ["Q", v[0], v[1], v[2], v[3]]
          },
          S: function (v, C) {
            return C.x = v[2], C.y = v[3], ["S", v[0], v[1], v[2], v[3]]
          },
          Z: function (v, C, L) {
            return C.x = L.x, C.y = L.y, ["Z"]
          }
        }, c = "mlhvqtcsaz".split(""), u = 0, d = c.length; u < d; ++u) s[c[u]] = function (v) {
        return function (C, L, H) {
          if (v == "H") C[0] = C[0] + L.x;
          else if (v == "V") C[0] = C[0] + L.y;
          else if (v == "A") C[5] = C[5] + L.x, C[6] = C[6] + L.y;
          else
            for (var q = 0, ee = C.length; q < ee; ++q) C[q] = C[q] + (q % 2 ? L.y : L.x);
          if (s && typeof s[v] == "function") return s[v](C, L, H)
        }
      }(c[u].toUpperCase());
      n.PathArray = function (v, C) {
        n.Array.call(this, v, C || [
          ["M", 0, 0]
        ])
      }, n.PathArray.prototype = new n.Array, n.PathArray.prototype.constructor = n.PathArray, n.extend(n.PathArray, {
        toString: function () {
          return function (v) {
            for (var C = 0, L = v.length, H = ""; C < L; C++) H += v[C][0], v[C][1] != null && (H += v[C][1], v[C][2] != null && (H += " ", H += v[C][2], v[C][3] != null && (H += " ", H += v[C][3], H += " ", H += v[C][4], v[C][5] != null && (H += " ", H += v[C][5], H += " ", H += v[C][6], v[C][7] != null && (H += " ", H += v[C][7])))));
            return H + " "
          }(this.value)
        },
        move: function (v, C) {
          var L = this.bbox();
          return L.x, L.y, this
        },
        at: function (v) {
          if (!this.destination) return this;
          for (var C = this.value, L = this.destination.value, H = [], q = new n.PathArray, ee = 0, ge = C.length; ee < ge; ee++) {
            H[ee] = [C[ee][0]];
            for (var pe = 1, Fe = C[ee].length; pe < Fe; pe++) H[ee][pe] = C[ee][pe] + (L[ee][pe] - C[ee][pe]) * v;
            H[ee][0] === "A" && (H[ee][4] = +(H[ee][4] != 0), H[ee][5] = +(H[ee][5] != 0))
          }
          return q.value = H, q
        },
        parse: function (v) {
          if (v instanceof n.PathArray) return v.valueOf();
          var C, L = {
            M: 2,
            L: 2,
            H: 1,
            V: 1,
            C: 6,
            S: 4,
            Q: 4,
            T: 2,
            A: 7,
            Z: 0
          };
          v = typeof v == "string" ? v.replace(n.regex.numbersWithDots, g).replace(n.regex.pathLetters, " $& ").replace(n.regex.hyphen, "$1 -").trim().split(n.regex.delimiter) : v.reduce(function (Fe, Ue) {
            return [].concat.call(Fe, Ue)
          }, []);
          var H = [],
            q = new n.Point,
            ee = new n.Point,
            ge = 0,
            pe = v.length;
          do n.regex.isPathLetter.test(v[ge]) ? (C = v[ge], ++ge) : C == "M" ? C = "L" : C == "m" && (C = "l"), H.push(s[C].call(null, v.slice(ge, ge += L[C.toUpperCase()]).map(parseFloat), q, ee)); while (pe > ge);
          return H
        },
        bbox: function () {
          return n.parser.draw || n.prepare(), n.parser.path.setAttribute("d", this.toString()), n.parser.path.getBBox()
        }
      }), n.Number = n.invent({
        create: function (v, C) {
          this.value = 0, this.unit = C || "", typeof v == "number" ? this.value = isNaN(v) ? 0 : isFinite(v) ? v : v < 0 ? -34e37 : 34e37 : typeof v == "string" ? (C = v.match(n.regex.numberAndUnit)) && (this.value = parseFloat(C[1]), C[5] == "%" ? this.value /= 100 : C[5] == "s" && (this.value *= 1e3), this.unit = C[5]) : v instanceof n.Number && (this.value = v.valueOf(), this.unit = v.unit)
        },
        extend: {
          toString: function () {
            return (this.unit == "%" ? ~~(1e8 * this.value) / 1e6 : this.unit == "s" ? this.value / 1e3 : this.value) + this.unit
          },
          toJSON: function () {
            return this.toString()
          },
          valueOf: function () {
            return this.value
          },
          plus: function (v) {
            return v = new n.Number(v), new n.Number(this + v, this.unit || v.unit)
          },
          minus: function (v) {
            return v = new n.Number(v), new n.Number(this - v, this.unit || v.unit)
          },
          times: function (v) {
            return v = new n.Number(v), new n.Number(this * v, this.unit || v.unit)
          },
          divide: function (v) {
            return v = new n.Number(v), new n.Number(this / v, this.unit || v.unit)
          },
          to: function (v) {
            var C = new n.Number(this);
            return typeof v == "string" && (C.unit = v), C
          },
          morph: function (v) {
            return this.destination = new n.Number(v), v.relative && (this.destination.value += this.value), this
          },
          at: function (v) {
            return this.destination ? new n.Number(this.destination).minus(this).times(v).plus(this) : this
          }
        }
      }), n.Element = n.invent({
        create: function (v) {
          this._stroke = n.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = v) && (this.type = v.nodeName, this.node.instance = this, this._stroke = v.getAttribute("stroke") || this._stroke)
        },
        extend: {
          x: function (v) {
            return this.attr("x", v)
          },
          y: function (v) {
            return this.attr("y", v)
          },
          cx: function (v) {
            return v == null ? this.x() + this.width() / 2 : this.x(v - this.width() / 2)
          },
          cy: function (v) {
            return v == null ? this.y() + this.height() / 2 : this.y(v - this.height() / 2)
          },
          move: function (v, C) {
            return this.x(v).y(C)
          },
          center: function (v, C) {
            return this.cx(v).cy(C)
          },
          width: function (v) {
            return this.attr("width", v)
          },
          height: function (v) {
            return this.attr("height", v)
          },
          size: function (v, C) {
            var L = _(this, v, C);
            return this.width(new n.Number(L.width)).height(new n.Number(L.height))
          },
          clone: function (v) {
            this.writeDataToDom();
            var C = O(this.node.cloneNode(!0));
            return v ? v.add(C) : this.after(C), C
          },
          remove: function () {
            return this.parent() && this.parent().removeElement(this), this
          },
          replace: function (v) {
            return this.after(v).remove(), v
          },
          addTo: function (v) {
            return v.put(this)
          },
          putIn: function (v) {
            return v.add(this)
          },
          id: function (v) {
            return this.attr("id", v)
          },
          show: function () {
            return this.style("display", "")
          },
          hide: function () {
            return this.style("display", "none")
          },
          visible: function () {
            return this.style("display") != "none"
          },
          toString: function () {
            return this.attr("id")
          },
          classes: function () {
            var v = this.attr("class");
            return v == null ? [] : v.trim().split(n.regex.delimiter)
          },
          hasClass: function (v) {
            return this.classes().indexOf(v) != -1
          },
          addClass: function (v) {
            if (!this.hasClass(v)) {
              var C = this.classes();
              C.push(v), this.attr("class", C.join(" "))
            }
            return this
          },
          removeClass: function (v) {
            return this.hasClass(v) && this.attr("class", this.classes().filter(function (C) {
              return C != v
            }).join(" ")), this
          },
          toggleClass: function (v) {
            return this.hasClass(v) ? this.removeClass(v) : this.addClass(v)
          },
          reference: function (v) {
            return n.get(this.attr(v))
          },
          parent: function (v) {
            var C = this;
            if (!C.node.parentNode) return null;
            if (C = n.adopt(C.node.parentNode), !v) return C;
            for (; C && C.node instanceof Y.SVGElement;) {
              if (typeof v == "string" ? C.matches(v) : C instanceof v) return C;
              if (!C.node.parentNode || C.node.parentNode.nodeName == "#document") return null;
              C = n.adopt(C.node.parentNode)
            }
          },
          doc: function () {
            return this instanceof n.Doc ? this : this.parent(n.Doc)
          },
          parents: function (v) {
            var C = [],
              L = this;
            do {
              if (!(L = L.parent(v)) || !L.node) break;
              C.push(L)
            } while (L.parent);
            return C
          },
          matches: function (v) {
            return function (C, L) {
              return (C.matches || C.matchesSelector || C.msMatchesSelector || C.mozMatchesSelector || C.webkitMatchesSelector || C.oMatchesSelector).call(C, L)
            }(this.node, v)
          },
          native: function () {
            return this.node
          },
          svg: function (v) {
            var C = r.createElement("svg");
            if (!(v && this instanceof n.Parent)) return C.appendChild(v = r.createElement("svg")), this.writeDataToDom(), v.appendChild(this.node.cloneNode(!0)), C.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
            C.innerHTML = "<svg>" + v.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
            for (var L = 0, H = C.firstChild.childNodes.length; L < H; L++) this.node.appendChild(C.firstChild.firstChild);
            return this
          },
          writeDataToDom: function () {
            return (this.each || this.lines) && (this.each ? this : this.lines()).each(function () {
              this.writeDataToDom()
            }), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this
          },
          setData: function (v) {
            return this.dom = v, this
          },
          is: function (v) {
            return function (C, L) {
              return C instanceof L
            }(this, v)
          }
        }
      }), n.easing = {
        "-": function (v) {
          return v
        },
        "<>": function (v) {
          return -Math.cos(v * Math.PI) / 2 + .5
        },
        ">": function (v) {
          return Math.sin(v * Math.PI / 2)
        },
        "<": function (v) {
          return 1 - Math.cos(v * Math.PI / 2)
        }
      }, n.morph = function (v) {
        return function (C, L) {
          return new n.MorphObj(C, L).at(v)
        }
      }, n.Situation = n.invent({
        create: function (v) {
          this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new n.Number(v.duration).valueOf(), this.delay = new n.Number(v.delay).valueOf(), this.start = +new Date + this.delay, this.finish = this.start + this.duration, this.ease = v.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {}
        }
      }), n.FX = n.invent({
        create: function (v) {
          this._target = v, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1
        },
        extend: {
          animate: function (v, C, L) {
            o(v) === "object" && (C = v.ease, L = v.delay, v = v.duration);
            var H = new n.Situation({
              duration: v || 1e3,
              delay: L || 0,
              ease: n.easing[C || "-"] || C
            });
            return this.queue(H), this
          },
          target: function (v) {
            return v && v instanceof n.Element ? (this._target = v, this) : this._target
          },
          timeToAbsPos: function (v) {
            return (v - this.situation.start) / (this.situation.duration / this._speed)
          },
          absPosToTime: function (v) {
            return this.situation.duration / this._speed * v + this.situation.start
          },
          startAnimFrame: function () {
            this.stopAnimFrame(), this.animationFrame = Y.requestAnimationFrame((function () {
              this.step()
            }).bind(this))
          },
          stopAnimFrame: function () {
            Y.cancelAnimationFrame(this.animationFrame)
          },
          start: function () {
            return !this.active && this.situation && (this.active = !0, this.startCurrent()), this
          },
          startCurrent: function () {
            return this.situation.start = +new Date + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step()
          },
          queue: function (v) {
            return (typeof v == "function" || v instanceof n.Situation) && this.situations.push(v), this.situation || (this.situation = this.situations.shift()), this
          },
          dequeue: function () {
            return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof n.Situation ? this.start() : this.situation.call(this)), this
          },
          initAnimations: function () {
            var v, C = this.situation;
            if (C.init) return this;
            for (var L in C.animations) {
              v = this.target()[L](), Array.isArray(v) || (v = [v]), Array.isArray(C.animations[L]) || (C.animations[L] = [C.animations[L]]);
              for (var H = v.length; H--;) C.animations[L][H] instanceof n.Number && (v[H] = new n.Number(v[H])), C.animations[L][H] = v[H].morph(C.animations[L][H])
            }
            for (var L in C.attrs) C.attrs[L] = new n.MorphObj(this.target().attr(L), C.attrs[L]);
            for (var L in C.styles) C.styles[L] = new n.MorphObj(this.target().style(L), C.styles[L]);
            return C.initialTransformation = this.target().matrixify(), C.init = !0, this
          },
          clearQueue: function () {
            return this.situations = [], this
          },
          clearCurrent: function () {
            return this.situation = null, this
          },
          stop: function (v, C) {
            var L = this.active;
            return this.active = !1, C && this.clearQueue(), v && this.situation && (!L && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent()
          },
          after: function (v) {
            var C = this.last();
            return this.target().on("finished.fx", function L(H) {
              H.detail.situation == C && (v.call(this, C), this.off("finished.fx", L))
            }), this._callStart()
          },
          during: function (v) {
            var C = this.last(),
              L = function (H) {
                H.detail.situation == C && v.call(this, H.detail.pos, n.morph(H.detail.pos), H.detail.eased, C)
              };
            return this.target().off("during.fx", L).on("during.fx", L), this.after(function () {
              this.off("during.fx", L)
            }), this._callStart()
          },
          afterAll: function (v) {
            var C = function L(H) {
              v.call(this), this.off("allfinished.fx", L)
            };
            return this.target().off("allfinished.fx", C).on("allfinished.fx", C), this._callStart()
          },
          last: function () {
            return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
          },
          add: function (v, C, L) {
            return this.last()[L || "animations"][v] = C, this._callStart()
          },
          step: function (v) {
            var C, L, H;
            v || (this.absPos = this.timeToAbsPos(+new Date)), this.situation.loops !== !1 ? (C = Math.max(this.absPos, 0), L = Math.floor(C), this.situation.loops === !0 || L < this.situation.loops ? (this.pos = C - L, H = this.situation.loop, this.situation.loop = L) : (this.absPos = this.situation.loops, this.pos = 1, H = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != !!((this.situation.loop - H) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
            var q = this.situation.ease(this.pos);
            for (var ee in this.situation.once) ee > this.lastPos && ee <= q && (this.situation.once[ee].call(this.target(), this.pos, q), delete this.situation.once[ee]);
            return this.active && this.target().fire("during", {
              pos: this.pos,
              eased: q,
              fx: this,
              situation: this.situation
            }), this.situation ? (this.eachAt(), this.pos == 1 && !this.situation.reversed || this.situation.reversed && this.pos == 0 ? (this.stopAnimFrame(), this.target().fire("finished", {
              fx: this,
              situation: this.situation
            }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = q, this) : this
          },
          eachAt: function () {
            var v, C = this,
              L = this.target(),
              H = this.situation;
            for (var q in H.animations) v = [].concat(H.animations[q]).map(function (pe) {
              return typeof pe != "string" && pe.at ? pe.at(H.ease(C.pos), C.pos) : pe
            }), L[q].apply(L, v);
            for (var q in H.attrs) v = [q].concat(H.attrs[q]).map(function (Fe) {
              return typeof Fe != "string" && Fe.at ? Fe.at(H.ease(C.pos), C.pos) : Fe
            }), L.attr.apply(L, v);
            for (var q in H.styles) v = [q].concat(H.styles[q]).map(function (Fe) {
              return typeof Fe != "string" && Fe.at ? Fe.at(H.ease(C.pos), C.pos) : Fe
            }), L.style.apply(L, v);
            if (H.transforms.length) {
              v = H.initialTransformation, q = 0;
              for (var ee = H.transforms.length; q < ee; q++) {
                var ge = H.transforms[q];
                ge instanceof n.Matrix ? v = ge.relative ? v.multiply(new n.Matrix().morph(ge).at(H.ease(this.pos))) : v.morph(ge).at(H.ease(this.pos)) : (ge.relative || ge.undo(v.extract()), v = v.multiply(ge.at(H.ease(this.pos))))
              }
              L.matrix(v)
            }
            return this
          },
          once: function (v, C, L) {
            var H = this.last();
            return L || (v = H.ease(v)), H.once[v] = C, this
          },
          _callStart: function () {
            return setTimeout((function () {
              this.start()
            }).bind(this), 0), this
          }
        },
        parent: n.Element,
        construct: {
          animate: function (v, C, L) {
            return (this.fx || (this.fx = new n.FX(this))).animate(v, C, L)
          },
          delay: function (v) {
            return (this.fx || (this.fx = new n.FX(this))).delay(v)
          },
          stop: function (v, C) {
            return this.fx && this.fx.stop(v, C), this
          },
          finish: function () {
            return this.fx && this.fx.finish(), this
          }
        }
      }), n.MorphObj = n.invent({
        create: function (v, C) {
          return n.Color.isColor(C) ? new n.Color(v).morph(C) : n.regex.delimiter.test(v) ? n.regex.pathLetters.test(v) ? new n.PathArray(v).morph(C) : new n.Array(v).morph(C) : n.regex.numberAndUnit.test(C) ? new n.Number(v).morph(C) : (this.value = v, void(this.destination = C))
        },
        extend: {
          at: function (v, C) {
            return C < 1 ? this.value : this.destination
          },
          valueOf: function () {
            return this.value
          }
        }
      }), n.extend(n.FX, {
        attr: function (v, C, L) {
          if (o(v) === "object")
            for (var H in v) this.attr(H, v[H]);
          else this.add(v, C, "attrs");
          return this
        },
        plot: function (v, C, L, H) {
          return arguments.length == 4 ? this.plot([v, C, L, H]) : this.add("plot", new(this.target()).morphArray(v))
        }
      }), n.Box = n.invent({
        create: function (v, C, L, H) {
          if (!(o(v) !== "object" || v instanceof n.Element)) return n.Box.call(this, v.left != null ? v.left : v.x, v.top != null ? v.top : v.y, v.width, v.height);
          var q;
          arguments.length == 4 && (this.x = v, this.y = C, this.width = L, this.height = H), (q = this).x == null && (q.x = 0, q.y = 0, q.width = 0, q.height = 0), q.w = q.width, q.h = q.height, q.x2 = q.x + q.width, q.y2 = q.y + q.height, q.cx = q.x + q.width / 2, q.cy = q.y + q.height / 2
        }
      }), n.BBox = n.invent({
        create: function (v) {
          if (n.Box.apply(this, [].slice.call(arguments)), v instanceof n.Element) {
            var C;
            try {
              if (!r.documentElement.contains) {
                for (var L = v.node; L.parentNode;) L = L.parentNode;
                if (L != r) throw new Error("Element not in the dom")
              }
              C = v.node.getBBox()
            } catch {
              if (v instanceof n.Shape) {
                n.parser.draw || n.prepare();
                var H = v.clone(n.parser.draw.instance).show();
                H && H.node && typeof H.node.getBBox == "function" && (C = H.node.getBBox()), H && typeof H.remove == "function" && H.remove()
              } else C = {
                x: v.node.clientLeft,
                y: v.node.clientTop,
                width: v.node.clientWidth,
                height: v.node.clientHeight
              }
            }
            n.Box.call(this, C)
          }
        },
        inherit: n.Box,
        parent: n.Element,
        construct: {
          bbox: function () {
            return new n.BBox(this)
          }
        }
      }), n.BBox.prototype.constructor = n.BBox, n.Matrix = n.invent({
        create: function (v) {
          var C = P([1, 0, 0, 1, 0, 0]);
          v = v === null ? C : v instanceof n.Element ? v.matrixify() : typeof v == "string" ? P(v.split(n.regex.delimiter).map(parseFloat)) : arguments.length == 6 ? P([].slice.call(arguments)) : Array.isArray(v) ? P(v) : v && o(v) === "object" ? v : C;
          for (var L = G.length - 1; L >= 0; --L) this[G[L]] = v[G[L]] != null ? v[G[L]] : C[G[L]]
        },
        extend: {
          extract: function () {
            var v = T(this, 0, 1);
            T(this, 1, 0);
            var C = 180 / Math.PI * Math.atan2(v.y, v.x) - 90;
            return {
              x: this.e,
              y: this.f,
              transformedX: (this.e * Math.cos(C * Math.PI / 180) + this.f * Math.sin(C * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
              transformedY: (this.f * Math.cos(C * Math.PI / 180) + this.e * Math.sin(-C * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
              rotation: C,
              a: this.a,
              b: this.b,
              c: this.c,
              d: this.d,
              e: this.e,
              f: this.f,
              matrix: new n.Matrix(this)
            }
          },
          clone: function () {
            return new n.Matrix(this)
          },
          morph: function (v) {
            return this.destination = new n.Matrix(v), this
          },
          multiply: function (v) {
            return new n.Matrix(this.native().multiply(function (C) {
              return C instanceof n.Matrix || (C = new n.Matrix(C)), C
            }(v).native()))
          },
          inverse: function () {
            return new n.Matrix(this.native().inverse())
          },
          translate: function (v, C) {
            return new n.Matrix(this.native().translate(v || 0, C || 0))
          },
          native: function () {
            for (var v = n.parser.native.createSVGMatrix(), C = G.length - 1; C >= 0; C--) v[G[C]] = this[G[C]];
            return v
          },
          toString: function () {
            return "matrix(" + $(this.a) + "," + $(this.b) + "," + $(this.c) + "," + $(this.d) + "," + $(this.e) + "," + $(this.f) + ")"
          }
        },
        parent: n.Element,
        construct: {
          ctm: function () {
            return new n.Matrix(this.node.getCTM())
          },
          screenCTM: function () {
            if (this instanceof n.Nested) {
              var v = this.rect(1, 1),
                C = v.node.getScreenCTM();
              return v.remove(), new n.Matrix(C)
            }
            return new n.Matrix(this.node.getScreenCTM())
          }
        }
      }), n.Point = n.invent({
        create: function (v, C) {
          var L;
          L = Array.isArray(v) ? {
            x: v[0],
            y: v[1]
          } : o(v) === "object" ? {
            x: v.x,
            y: v.y
          } : v != null ? {
            x: v,
            y: C ?? v
          } : {
            x: 0,
            y: 0
          }, this.x = L.x, this.y = L.y
        },
        extend: {
          clone: function () {
            return new n.Point(this)
          },
          morph: function (v, C) {
            return this.destination = new n.Point(v, C), this
          }
        }
      }), n.extend(n.Element, {
        point: function (v, C) {
          return new n.Point(v, C).transform(this.screenCTM().inverse())
        }
      }), n.extend(n.Element, {
        attr: function (v, C, L) {
          if (v == null) {
            for (v = {}, L = (C = this.node.attributes).length - 1; L >= 0; L--) v[C[L].nodeName] = n.regex.isNumber.test(C[L].nodeValue) ? parseFloat(C[L].nodeValue) : C[L].nodeValue;
            return v
          }
          if (o(v) === "object")
            for (var H in v) this.attr(H, v[H]);
          else if (C === null) this.node.removeAttribute(v);
          else {
            if (C == null) return (C = this.node.getAttribute(v)) == null ? n.defaults.attrs[v] : n.regex.isNumber.test(C) ? parseFloat(C) : C;
            v == "stroke-width" ? this.attr("stroke", parseFloat(C) > 0 ? this._stroke : null) : v == "stroke" && (this._stroke = C), v != "fill" && v != "stroke" || (n.regex.isImage.test(C) && (C = this.doc().defs().image(C, 0, 0)), C instanceof n.Image && (C = this.doc().defs().pattern(0, 0, function () {
              this.add(C)
            }))), typeof C == "number" ? C = new n.Number(C) : n.Color.isColor(C) ? C = new n.Color(C) : Array.isArray(C) && (C = new n.Array(C)), v == "leading" ? this.leading && this.leading(C) : typeof L == "string" ? this.node.setAttributeNS(L, v, C.toString()) : this.node.setAttribute(v, C.toString()), !this.rebuild || v != "font-size" && v != "x" || this.rebuild(v, C)
          }
          return this
        }
      }), n.extend(n.Element, {
        transform: function (v, C) {
          var L;
          return o(v) !== "object" ? (L = new n.Matrix(this).extract(), typeof v == "string" ? L[v] : L) : (L = new n.Matrix(this), C = !!C || !!v.relative, v.a != null && (L = C ? L.multiply(new n.Matrix(v)) : new n.Matrix(v)), this.attr("transform", L))
        }
      }), n.extend(n.Element, {
        untransform: function () {
          return this.attr("transform", null)
        },
        matrixify: function () {
          return (this.attr("transform") || "").split(n.regex.transforms).slice(0, -1).map(function (v) {
            var C = v.trim().split("(");
            return [C[0], C[1].split(n.regex.delimiter).map(function (L) {
              return parseFloat(L)
            })]
          }).reduce(function (v, C) {
            return C[0] == "matrix" ? v.multiply(P(C[1])) : v[C[0]].apply(v, C[1])
          }, new n.Matrix)
        },
        toParent: function (v) {
          if (this == v) return this;
          var C = this.screenCTM(),
            L = v.screenCTM().inverse();
          return this.addTo(v).untransform().transform(L.multiply(C)), this
        },
        toDoc: function () {
          return this.toParent(this.doc())
        }
      }), n.Transformation = n.invent({
        create: function (v, C) {
          if (arguments.length > 1 && typeof C != "boolean") return this.constructor.call(this, [].slice.call(arguments));
          if (Array.isArray(v))
            for (var L = 0, H = this.arguments.length; L < H; ++L) this[this.arguments[L]] = v[L];
          else if (v && o(v) === "object")
            for (L = 0, H = this.arguments.length; L < H; ++L) this[this.arguments[L]] = v[this.arguments[L]];
          this.inversed = !1, C === !0 && (this.inversed = !0)
        }
      }), n.Translate = n.invent({
        parent: n.Matrix,
        inherit: n.Transformation,
        create: function (v, C) {
          this.constructor.apply(this, [].slice.call(arguments))
        },
        extend: {
          arguments: ["transformedX", "transformedY"],
          method: "translate"
        }
      }), n.extend(n.Element, {
        style: function (v, C) {
          if (arguments.length == 0) return this.node.style.cssText || "";
          if (arguments.length < 2)
            if (o(v) === "object")
              for (var L in v) this.style(L, v[L]);
            else {
              if (!n.regex.isCss.test(v)) return this.node.style[b(v)];
              for (v = v.split(/\s*;\s*/).filter(function (H) {
                  return !!H
                }).map(function (H) {
                  return H.split(/\s*:\s*/)
                }); C = v.pop();) this.style(C[0], C[1])
            }
          else this.node.style[b(v)] = C === null || n.regex.isBlank.test(C) ? "" : C;
          return this
        }
      }), n.Parent = n.invent({
        create: function (v) {
          this.constructor.call(this, v)
        },
        inherit: n.Element,
        extend: {
          children: function () {
            return n.utils.map(n.utils.filterSVGElements(this.node.childNodes), function (v) {
              return n.adopt(v)
            })
          },
          add: function (v, C) {
            return C == null ? this.node.appendChild(v.node) : v.node != this.node.childNodes[C] && this.node.insertBefore(v.node, this.node.childNodes[C]), this
          },
          put: function (v, C) {
            return this.add(v, C), v
          },
          has: function (v) {
            return this.index(v) >= 0
          },
          index: function (v) {
            return [].slice.call(this.node.childNodes).indexOf(v.node)
          },
          get: function (v) {
            return n.adopt(this.node.childNodes[v])
          },
          first: function () {
            return this.get(0)
          },
          last: function () {
            return this.get(this.node.childNodes.length - 1)
          },
          each: function (v, C) {
            for (var L = this.children(), H = 0, q = L.length; H < q; H++) L[H] instanceof n.Element && v.apply(L[H], [H, L]), C && L[H] instanceof n.Container && L[H].each(v, C);
            return this
          },
          removeElement: function (v) {
            return this.node.removeChild(v.node), this
          },
          clear: function () {
            for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
            return delete this._defs, this
          },
          defs: function () {
            return this.doc().defs()
          }
        }
      }), n.extend(n.Parent, {
        ungroup: function (v, C) {
          return C === 0 || this instanceof n.Defs || this.node == n.parser.draw || (v = v || (this instanceof n.Doc ? this : this.parent(n.Parent)), C = C || 1 / 0, this.each(function () {
            return this instanceof n.Defs ? this : this instanceof n.Parent ? this.ungroup(v, C - 1) : this.toParent(v)
          }), this.node.firstChild || this.remove()), this
        },
        flatten: function (v, C) {
          return this.ungroup(v, C)
        }
      }), n.Container = n.invent({
        create: function (v) {
          this.constructor.call(this, v)
        },
        inherit: n.Parent
      }), n.ViewBox = n.invent({
        parent: n.Container,
        construct: {}
      }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach(function (v) {
        n.Element.prototype[v] = function (C) {
          return n.on(this.node, v, C), this
        }
      }), n.listeners = [], n.handlerMap = [], n.listenerId = 0, n.on = function (v, C, L, H, q) {
        var ee = L.bind(H || v.instance || v),
          ge = (n.handlerMap.indexOf(v) + 1 || n.handlerMap.push(v)) - 1,
          pe = C.split(".")[0],
          Fe = C.split(".")[1] || "*";
        n.listeners[ge] = n.listeners[ge] || {}, n.listeners[ge][pe] = n.listeners[ge][pe] || {}, n.listeners[ge][pe][Fe] = n.listeners[ge][pe][Fe] || {}, L._svgjsListenerId || (L._svgjsListenerId = ++n.listenerId), n.listeners[ge][pe][Fe][L._svgjsListenerId] = ee, v.addEventListener(pe, ee, q || {
          passive: !0
        })
      }, n.off = function (v, C, L) {
        var H = n.handlerMap.indexOf(v),
          q = C && C.split(".")[0],
          ee = C && C.split(".")[1],
          ge = "";
        if (H != -1)
          if (L) {
            if (typeof L == "function" && (L = L._svgjsListenerId), !L) return;
            n.listeners[H][q] && n.listeners[H][q][ee || "*"] && (v.removeEventListener(q, n.listeners[H][q][ee || "*"][L], !1), delete n.listeners[H][q][ee || "*"][L])
          } else if (ee && q) {
          if (n.listeners[H][q] && n.listeners[H][q][ee]) {
            for (var pe in n.listeners[H][q][ee]) n.off(v, [q, ee].join("."), pe);
            delete n.listeners[H][q][ee]
          }
        } else if (ee)
          for (var Fe in n.listeners[H])
            for (var ge in n.listeners[H][Fe]) ee === ge && n.off(v, [Fe, ee].join("."));
        else if (q) {
          if (n.listeners[H][q]) {
            for (var ge in n.listeners[H][q]) n.off(v, [q, ge].join("."));
            delete n.listeners[H][q]
          }
        } else {
          for (var Fe in n.listeners[H]) n.off(v, Fe);
          delete n.listeners[H], delete n.handlerMap[H]
        }
      }, n.extend(n.Element, {
        on: function (v, C, L, H) {
          return n.on(this.node, v, C, L, H), this
        },
        off: function (v, C) {
          return n.off(this.node, v, C), this
        },
        fire: function (v, C) {
          return v instanceof Y.Event ? this.node.dispatchEvent(v) : this.node.dispatchEvent(v = new n.CustomEvent(v, {
            detail: C,
            cancelable: !0
          })), this._event = v, this
        },
        event: function () {
          return this._event
        }
      }), n.Defs = n.invent({
        create: "defs",
        inherit: n.Container
      }), n.G = n.invent({
        create: "g",
        inherit: n.Container,
        extend: {
          x: function (v) {
            return v == null ? this.transform("x") : this.transform({
              x: v - this.x()
            }, !0)
          }
        },
        construct: {
          group: function () {
            return this.put(new n.G)
          }
        }
      }), n.Doc = n.invent({
        create: function (v) {
          v && ((v = typeof v == "string" ? r.getElementById(v) : v).nodeName == "svg" ? this.constructor.call(this, v) : (this.constructor.call(this, n.create("svg")), v.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs())
        },
        inherit: n.Container,
        extend: {
          namespace: function () {
            return this.attr({
              xmlns: n.ns,
              version: "1.1"
            }).attr("xmlns:xlink", n.xlink, n.xmlns).attr("xmlns:svgjs", n.svgjs, n.xmlns)
          },
          defs: function () {
            var v;
            return this._defs || ((v = this.node.getElementsByTagName("defs")[0]) ? this._defs = n.adopt(v) : this._defs = new n.Defs, this.node.appendChild(this._defs.node)), this._defs
          },
          parent: function () {
            return this.node.parentNode && this.node.parentNode.nodeName != "#document" ? this.node.parentNode : null
          },
          remove: function () {
            return this.parent() && this.parent().removeChild(this.node), this
          },
          clear: function () {
            for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
            return delete this._defs, n.parser.draw && !n.parser.draw.parentNode && this.node.appendChild(n.parser.draw), this
          },
          clone: function (v) {
            this.writeDataToDom();
            var C = this.node,
              L = O(C.cloneNode(!0));
            return v ? (v.node || v).appendChild(L.node) : C.parentNode.insertBefore(L.node, C.nextSibling), L
          }
        }
      }), n.extend(n.Element, {}), n.Gradient = n.invent({
        create: function (v) {
          this.constructor.call(this, n.create(v + "Gradient")), this.type = v
        },
        inherit: n.Container,
        extend: {
          at: function (v, C, L) {
            return this.put(new n.Stop).update(v, C, L)
          },
          update: function (v) {
            return this.clear(), typeof v == "function" && v.call(this, this), this
          },
          fill: function () {
            return "url(#" + this.id() + ")"
          },
          toString: function () {
            return this.fill()
          },
          attr: function (v, C, L) {
            return v == "transform" && (v = "gradientTransform"), n.Container.prototype.attr.call(this, v, C, L)
          }
        },
        construct: {
          gradient: function (v, C) {
            return this.defs().gradient(v, C)
          }
        }
      }), n.extend(n.Gradient, n.FX, {
        from: function (v, C) {
          return (this._target || this).type == "radial" ? this.attr({
            fx: new n.Number(v),
            fy: new n.Number(C)
          }) : this.attr({
            x1: new n.Number(v),
            y1: new n.Number(C)
          })
        },
        to: function (v, C) {
          return (this._target || this).type == "radial" ? this.attr({
            cx: new n.Number(v),
            cy: new n.Number(C)
          }) : this.attr({
            x2: new n.Number(v),
            y2: new n.Number(C)
          })
        }
      }), n.extend(n.Defs, {
        gradient: function (v, C) {
          return this.put(new n.Gradient(v)).update(C)
        }
      }), n.Stop = n.invent({
        create: "stop",
        inherit: n.Element,
        extend: {
          update: function (v) {
            return (typeof v == "number" || v instanceof n.Number) && (v = {
              offset: arguments[0],
              color: arguments[1],
              opacity: arguments[2]
            }), v.opacity != null && this.attr("stop-opacity", v.opacity), v.color != null && this.attr("stop-color", v.color), v.offset != null && this.attr("offset", new n.Number(v.offset)), this
          }
        }
      }), n.Pattern = n.invent({
        create: "pattern",
        inherit: n.Container,
        extend: {
          fill: function () {
            return "url(#" + this.id() + ")"
          },
          update: function (v) {
            return this.clear(), typeof v == "function" && v.call(this, this), this
          },
          toString: function () {
            return this.fill()
          },
          attr: function (v, C, L) {
            return v == "transform" && (v = "patternTransform"), n.Container.prototype.attr.call(this, v, C, L)
          }
        },
        construct: {
          pattern: function (v, C, L) {
            return this.defs().pattern(v, C, L)
          }
        }
      }), n.extend(n.Defs, {
        pattern: function (v, C, L) {
          return this.put(new n.Pattern).update(L).attr({
            x: 0,
            y: 0,
            width: v,
            height: C,
            patternUnits: "userSpaceOnUse"
          })
        }
      }), n.Shape = n.invent({
        create: function (v) {
          this.constructor.call(this, v)
        },
        inherit: n.Element
      }), n.Symbol = n.invent({
        create: "symbol",
        inherit: n.Container,
        construct: {
          symbol: function () {
            return this.put(new n.Symbol)
          }
        }
      }), n.Use = n.invent({
        create: "use",
        inherit: n.Shape,
        extend: {
          element: function (v, C) {
            return this.attr("href", (C || "") + "#" + v, n.xlink)
          }
        },
        construct: {
          use: function (v, C) {
            return this.put(new n.Use).element(v, C)
          }
        }
      }), n.Rect = n.invent({
        create: "rect",
        inherit: n.Shape,
        construct: {
          rect: function (v, C) {
            return this.put(new n.Rect).size(v, C)
          }
        }
      }), n.Circle = n.invent({
        create: "circle",
        inherit: n.Shape,
        construct: {
          circle: function (v) {
            return this.put(new n.Circle).rx(new n.Number(v).divide(2)).move(0, 0)
          }
        }
      }), n.extend(n.Circle, n.FX, {
        rx: function (v) {
          return this.attr("r", v)
        },
        ry: function (v) {
          return this.rx(v)
        }
      }), n.Ellipse = n.invent({
        create: "ellipse",
        inherit: n.Shape,
        construct: {
          ellipse: function (v, C) {
            return this.put(new n.Ellipse).size(v, C).move(0, 0)
          }
        }
      }), n.extend(n.Ellipse, n.Rect, n.FX, {
        rx: function (v) {
          return this.attr("rx", v)
        },
        ry: function (v) {
          return this.attr("ry", v)
        }
      }), n.extend(n.Circle, n.Ellipse, {
        x: function (v) {
          return v == null ? this.cx() - this.rx() : this.cx(v + this.rx())
        },
        y: function (v) {
          return v == null ? this.cy() - this.ry() : this.cy(v + this.ry())
        },
        cx: function (v) {
          return v == null ? this.attr("cx") : this.attr("cx", v)
        },
        cy: function (v) {
          return v == null ? this.attr("cy") : this.attr("cy", v)
        },
        width: function (v) {
          return v == null ? 2 * this.rx() : this.rx(new n.Number(v).divide(2))
        },
        height: function (v) {
          return v == null ? 2 * this.ry() : this.ry(new n.Number(v).divide(2))
        },
        size: function (v, C) {
          var L = _(this, v, C);
          return this.rx(new n.Number(L.width).divide(2)).ry(new n.Number(L.height).divide(2))
        }
      }), n.Line = n.invent({
        create: "line",
        inherit: n.Shape,
        extend: {
          array: function () {
            return new n.PointArray([
              [this.attr("x1"), this.attr("y1")],
              [this.attr("x2"), this.attr("y2")]
            ])
          },
          plot: function (v, C, L, H) {
            return v == null ? this.array() : (v = C !== void 0 ? {
              x1: v,
              y1: C,
              x2: L,
              y2: H
            } : new n.PointArray(v).toLine(), this.attr(v))
          },
          move: function (v, C) {
            return this.attr(this.array().move(v, C).toLine())
          },
          size: function (v, C) {
            var L = _(this, v, C);
            return this.attr(this.array().size(L.width, L.height).toLine())
          }
        },
        construct: {
          line: function (v, C, L, H) {
            return n.Line.prototype.plot.apply(this.put(new n.Line), v != null ? [v, C, L, H] : [0, 0, 0, 0])
          }
        }
      }), n.Polyline = n.invent({
        create: "polyline",
        inherit: n.Shape,
        construct: {
          polyline: function (v) {
            return this.put(new n.Polyline).plot(v || new n.PointArray)
          }
        }
      }), n.Polygon = n.invent({
        create: "polygon",
        inherit: n.Shape,
        construct: {
          polygon: function (v) {
            return this.put(new n.Polygon).plot(v || new n.PointArray)
          }
        }
      }), n.extend(n.Polyline, n.Polygon, {
        array: function () {
          return this._array || (this._array = new n.PointArray(this.attr("points")))
        },
        plot: function (v) {
          return v == null ? this.array() : this.clear().attr("points", typeof v == "string" ? v : this._array = new n.PointArray(v))
        },
        clear: function () {
          return delete this._array, this
        },
        move: function (v, C) {
          return this.attr("points", this.array().move(v, C))
        },
        size: function (v, C) {
          var L = _(this, v, C);
          return this.attr("points", this.array().size(L.width, L.height))
        }
      }), n.extend(n.Line, n.Polyline, n.Polygon, {
        morphArray: n.PointArray,
        x: function (v) {
          return v == null ? this.bbox().x : this.move(v, this.bbox().y)
        },
        y: function (v) {
          return v == null ? this.bbox().y : this.move(this.bbox().x, v)
        },
        width: function (v) {
          var C = this.bbox();
          return v == null ? C.width : this.size(v, C.height)
        },
        height: function (v) {
          var C = this.bbox();
          return v == null ? C.height : this.size(C.width, v)
        }
      }), n.Path = n.invent({
        create: "path",
        inherit: n.Shape,
        extend: {
          morphArray: n.PathArray,
          array: function () {
            return this._array || (this._array = new n.PathArray(this.attr("d")))
          },
          plot: function (v) {
            return v == null ? this.array() : this.clear().attr("d", typeof v == "string" ? v : this._array = new n.PathArray(v))
          },
          clear: function () {
            return delete this._array, this
          }
        },
        construct: {
          path: function (v) {
            return this.put(new n.Path).plot(v || new n.PathArray)
          }
        }
      }), n.Image = n.invent({
        create: "image",
        inherit: n.Shape,
        extend: {
          load: function (v) {
            if (!v) return this;
            var C = this,
              L = new Y.Image;
            return n.on(L, "load", function () {
              n.off(L);
              var H = C.parent(n.Pattern);
              H !== null && (C.width() == 0 && C.height() == 0 && C.size(L.width, L.height), H && H.width() == 0 && H.height() == 0 && H.size(C.width(), C.height()), typeof C._loaded == "function" && C._loaded.call(C, {
                width: L.width,
                height: L.height,
                ratio: L.width / L.height,
                url: v
              }))
            }), n.on(L, "error", function (H) {
              n.off(L), typeof C._error == "function" && C._error.call(C, H)
            }), this.attr("href", L.src = this.src = v, n.xlink)
          },
          loaded: function (v) {
            return this._loaded = v, this
          },
          error: function (v) {
            return this._error = v, this
          }
        },
        construct: {
          image: function (v, C, L) {
            return this.put(new n.Image).load(v).size(C || 0, L || C || 0)
          }
        }
      }), n.Text = n.invent({
        create: function () {
          this.constructor.call(this, n.create("text")), this.dom.leading = new n.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", n.defaults.attrs["font-family"])
        },
        inherit: n.Shape,
        extend: {
          x: function (v) {
            return v == null ? this.attr("x") : this.attr("x", v)
          },
          text: function (v) {
            if (v === void 0) {
              v = "";
              for (var C = this.node.childNodes, L = 0, H = C.length; L < H; ++L) L != 0 && C[L].nodeType != 3 && n.adopt(C[L]).dom.newLined == 1 && (v += `
`), v += C[L].textContent;
              return v
            }
            if (this.clear().build(!0), typeof v == "function") v.call(this, this);
            else {
              L = 0;
              for (var q = (v = v.split(`
`)).length; L < q; L++) this.tspan(v[L]).newLine()
            }
            return this.build(!1).rebuild()
          },
          size: function (v) {
            return this.attr("font-size", v).rebuild()
          },
          leading: function (v) {
            return v == null ? this.dom.leading : (this.dom.leading = new n.Number(v), this.rebuild())
          },
          lines: function () {
            var v = (this.textPath && this.textPath() || this).node,
              C = n.utils.map(n.utils.filterSVGElements(v.childNodes), function (L) {
                return n.adopt(L)
              });
            return new n.Set(C)
          },
          rebuild: function (v) {
            if (typeof v == "boolean" && (this._rebuild = v), this._rebuild) {
              var C = this,
                L = 0,
                H = this.dom.leading * new n.Number(this.attr("font-size"));
              this.lines().each(function () {
                this.dom.newLined && (C.textPath() || this.attr("x", C.attr("x")), this.text() == `
` ? L += H : (this.attr("dy", H + L), L = 0))
              }), this.fire("rebuild")
            }
            return this
          },
          build: function (v) {
            return this._build = !!v, this
          },
          setData: function (v) {
            return this.dom = v, this.dom.leading = new n.Number(v.leading || 1.3), this
          }
        },
        construct: {
          text: function (v) {
            return this.put(new n.Text).text(v)
          },
          plain: function (v) {
            return this.put(new n.Text).plain(v)
          }
        }
      }), n.Tspan = n.invent({
        create: "tspan",
        inherit: n.Shape,
        extend: {
          text: function (v) {
            return v == null ? this.node.textContent + (this.dom.newLined ? `
` : "") : (typeof v == "function" ? v.call(this, this) : this.plain(v), this)
          },
          dx: function (v) {
            return this.attr("dx", v)
          },
          dy: function (v) {
            return this.attr("dy", v)
          },
          newLine: function () {
            var v = this.parent(n.Text);
            return this.dom.newLined = !0, this.dy(v.dom.leading * v.attr("font-size")).attr("x", v.x())
          }
        }
      }), n.extend(n.Text, n.Tspan, {
        plain: function (v) {
          return this._build === !1 && this.clear(), this.node.appendChild(r.createTextNode(v)), this
        },
        tspan: function (v) {
          var C = (this.textPath && this.textPath() || this).node,
            L = new n.Tspan;
          return this._build === !1 && this.clear(), C.appendChild(L.node), L.text(v)
        },
        clear: function () {
          for (var v = (this.textPath && this.textPath() || this).node; v.hasChildNodes();) v.removeChild(v.lastChild);
          return this
        },
        length: function () {
          return this.node.getComputedTextLength()
        }
      }), n.TextPath = n.invent({
        create: "textPath",
        inherit: n.Parent,
        parent: n.Text,
        construct: {
          morphArray: n.PathArray,
          array: function () {
            var v = this.track();
            return v ? v.array() : null
          },
          plot: function (v) {
            var C = this.track(),
              L = null;
            return C && (L = C.plot(v)), v == null ? L : this
          },
          track: function () {
            var v = this.textPath();
            if (v) return v.reference("href")
          },
          textPath: function () {
            if (this.node.firstChild && this.node.firstChild.nodeName == "textPath") return n.adopt(this.node.firstChild)
          }
        }
      }), n.Nested = n.invent({
        create: function () {
          this.constructor.call(this, n.create("svg")), this.style("overflow", "visible")
        },
        inherit: n.Container,
        construct: {
          nested: function () {
            return this.put(new n.Nested)
          }
        }
      });
      var f = {
        stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
        fill: ["color", "opacity", "rule"],
        prefix: function (v, C) {
          return C == "color" ? v : v + "-" + C
        }
      };

      function g(v, C, L, H) {
        return L + H.replace(n.regex.dots, " .")
      }

      function b(v) {
        return v.toLowerCase().replace(/-(.)/g, function (C, L) {
          return L.toUpperCase()
        })
      }

      function y(v) {
        return v.charAt(0).toUpperCase() + v.slice(1)
      }

      function x(v) {
        var C = v.toString(16);
        return C.length == 1 ? "0" + C : C
      }

      function _(v, C, L) {
        if (C == null || L == null) {
          var H = v.bbox();
          C == null ? C = H.width / H.height * L : L == null && (L = H.height / H.width * C)
        }
        return {
          width: C,
          height: L
        }
      }

      function T(v, C, L) {
        return {
          x: C * v.a + L * v.c + 0,
          y: C * v.b + L * v.d + 0
        }
      }

      function P(v) {
        return {
          a: v[0],
          b: v[1],
          c: v[2],
          d: v[3],
          e: v[4],
          f: v[5]
        }
      }

      function O(v) {
        for (var C = v.childNodes.length - 1; C >= 0; C--) v.childNodes[C] instanceof Y.SVGElement && O(v.childNodes[C]);
        return n.adopt(v).id(n.eid(v.nodeName))
      }

      function $(v) {
        return Math.abs(v) > 1e-37 ? v : 0
      } ["fill", "stroke"].forEach(function (v) {
        var C = {};
        C[v] = function (L) {
          if (L === void 0) return this;
          if (typeof L == "string" || n.Color.isRgb(L) || L && typeof L.fill == "function") this.attr(v, L);
          else
            for (var H = f[v].length - 1; H >= 0; H--) L[f[v][H]] != null && this.attr(f.prefix(v, f[v][H]), L[f[v][H]]);
          return this
        }, n.extend(n.Element, n.FX, C)
      }), n.extend(n.Element, n.FX, {
        translate: function (v, C) {
          return this.transform({
            x: v,
            y: C
          })
        },
        matrix: function (v) {
          return this.attr("transform", new n.Matrix(arguments.length == 6 ? [].slice.call(arguments) : v))
        },
        opacity: function (v) {
          return this.attr("opacity", v)
        },
        dx: function (v) {
          return this.x(new n.Number(v).plus(this instanceof n.FX ? 0 : this.x()), !0)
        },
        dy: function (v) {
          return this.y(new n.Number(v).plus(this instanceof n.FX ? 0 : this.y()), !0)
        }
      }), n.extend(n.Path, {
        length: function () {
          return this.node.getTotalLength()
        },
        pointAt: function (v) {
          return this.node.getPointAtLength(v)
        }
      }), n.Set = n.invent({
        create: function (v) {
          Array.isArray(v) ? this.members = v : this.clear()
        },
        extend: {
          add: function () {
            for (var v = [].slice.call(arguments), C = 0, L = v.length; C < L; C++) this.members.push(v[C]);
            return this
          },
          remove: function (v) {
            var C = this.index(v);
            return C > -1 && this.members.splice(C, 1), this
          },
          each: function (v) {
            for (var C = 0, L = this.members.length; C < L; C++) v.apply(this.members[C], [C, this.members]);
            return this
          },
          clear: function () {
            return this.members = [], this
          },
          length: function () {
            return this.members.length
          },
          has: function (v) {
            return this.index(v) >= 0
          },
          index: function (v) {
            return this.members.indexOf(v)
          },
          get: function (v) {
            return this.members[v]
          },
          first: function () {
            return this.get(0)
          },
          last: function () {
            return this.get(this.members.length - 1)
          },
          valueOf: function () {
            return this.members
          }
        },
        construct: {
          set: function (v) {
            return new n.Set(v)
          }
        }
      }), n.FX.Set = n.invent({
        create: function (v) {
          this.set = v
        }
      }), n.Set.inherit = function () {
        var v = [];
        for (var C in n.Shape.prototype) typeof n.Shape.prototype[C] == "function" && typeof n.Set.prototype[C] != "function" && v.push(C);
        for (var C in v.forEach(function (H) {
            n.Set.prototype[H] = function () {
              for (var q = 0, ee = this.members.length; q < ee; q++) this.members[q] && typeof this.members[q][H] == "function" && this.members[q][H].apply(this.members[q], arguments);
              return H == "animate" ? this.fx || (this.fx = new n.FX.Set(this)) : this
            }
          }), v = [], n.FX.prototype) typeof n.FX.prototype[C] == "function" && typeof n.FX.Set.prototype[C] != "function" && v.push(C);
        v.forEach(function (L) {
          n.FX.Set.prototype[L] = function () {
            for (var H = 0, q = this.set.members.length; H < q; H++) this.set.members[H].fx[L].apply(this.set.members[H].fx, arguments);
            return this
          }
        })
      }, n.extend(n.Element, {}), n.extend(n.Element, {
        remember: function (v, C) {
          if (o(arguments[0]) === "object")
            for (var L in v) this.remember(L, v[L]);
          else {
            if (arguments.length == 1) return this.memory()[v];
            this.memory()[v] = C
          }
          return this
        },
        forget: function () {
          if (arguments.length == 0) this._memory = {};
          else
            for (var v = arguments.length - 1; v >= 0; v--) delete this.memory()[arguments[v]];
          return this
        },
        memory: function () {
          return this._memory || (this._memory = {})
        }
      }), n.get = function (v) {
        var C = r.getElementById(function (L) {
          var H = (L || "").toString().match(n.regex.reference);
          if (H) return H[1]
        }(v) || v);
        return n.adopt(C)
      }, n.select = function (v, C) {
        return new n.Set(n.utils.map((C || r).querySelectorAll(v), function (L) {
          return n.adopt(L)
        }))
      }, n.extend(n.Parent, {
        select: function (v) {
          return n.select(v, this.node)
        }
      });
      var G = "abcdef".split("");
      if (typeof Y.CustomEvent != "function") {
        var Q = function (v, C) {
          C = C || {
            bubbles: !1,
            cancelable: !1,
            detail: void 0
          };
          var L = r.createEvent("CustomEvent");
          return L.initCustomEvent(v, C.bubbles, C.cancelable, C.detail), L
        };
        Q.prototype = Y.Event.prototype, n.CustomEvent = Q
      } else n.CustomEvent = Y.CustomEvent;
      return n
    }, o(t) === "object" ? e.exports = ga.document ? ti(ga, ga.document) : function (Y) {
      return ti(Y, Y.document)
    } : ga.SVG = ti(ga, ga.document), (function () {
      SVG.Filter = SVG.invent({
        create: "filter",
        inherit: SVG.Parent,
        extend: {
          source: "SourceGraphic",
          sourceAlpha: "SourceAlpha",
          background: "BackgroundImage",
          backgroundAlpha: "BackgroundAlpha",
          fill: "FillPaint",
          stroke: "StrokePaint",
          autoSetIn: !0,
          put: function (d, f) {
            return this.add(d, f), !d.attr("in") && this.autoSetIn && d.attr("in", this.source), d.attr("result") || d.attr("result", d), d
          },
          blend: function (d, f, g) {
            return this.put(new SVG.BlendEffect(d, f, g))
          },
          colorMatrix: function (d, f) {
            return this.put(new SVG.ColorMatrixEffect(d, f))
          },
          convolveMatrix: function (d) {
            return this.put(new SVG.ConvolveMatrixEffect(d))
          },
          componentTransfer: function (d) {
            return this.put(new SVG.ComponentTransferEffect(d))
          },
          composite: function (d, f, g) {
            return this.put(new SVG.CompositeEffect(d, f, g))
          },
          flood: function (d, f) {
            return this.put(new SVG.FloodEffect(d, f))
          },
          offset: function (d, f) {
            return this.put(new SVG.OffsetEffect(d, f))
          },
          image: function (d) {
            return this.put(new SVG.ImageEffect(d))
          },
          merge: function () {
            var d = [void 0];
            for (var f in arguments) d.push(arguments[f]);
            return this.put(new(SVG.MergeEffect.bind.apply(SVG.MergeEffect, d)))
          },
          gaussianBlur: function (d, f) {
            return this.put(new SVG.GaussianBlurEffect(d, f))
          },
          morphology: function (d, f) {
            return this.put(new SVG.MorphologyEffect(d, f))
          },
          diffuseLighting: function (d, f, g) {
            return this.put(new SVG.DiffuseLightingEffect(d, f, g))
          },
          displacementMap: function (d, f, g, b, y) {
            return this.put(new SVG.DisplacementMapEffect(d, f, g, b, y))
          },
          specularLighting: function (d, f, g, b) {
            return this.put(new SVG.SpecularLightingEffect(d, f, g, b))
          },
          tile: function () {
            return this.put(new SVG.TileEffect)
          },
          turbulence: function (d, f, g, b, y) {
            return this.put(new SVG.TurbulenceEffect(d, f, g, b, y))
          },
          toString: function () {
            return "url(#" + this.attr("id") + ")"
          }
        }
      }), SVG.extend(SVG.Defs, {
        filter: function (d) {
          var f = this.put(new SVG.Filter);
          return typeof d == "function" && d.call(f, f), f
        }
      }), SVG.extend(SVG.Container, {
        filter: function (d) {
          return this.defs().filter(d)
        }
      }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
        filter: function (d) {
          return this.filterer = d instanceof SVG.Element ? d : this.doc().filter(d), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer
        },
        unfilter: function (d) {
          return this.filterer && d === !0 && this.filterer.remove(), delete this.filterer, this.attr("filter", null)
        }
      }), SVG.Effect = SVG.invent({
        create: function () {
          this.constructor.call(this)
        },
        inherit: SVG.Element,
        extend: {
          in: function (d) {
            return d == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", d)
          },
          result: function (d) {
            return d == null ? this.attr("result") : this.attr("result", d)
          },
          toString: function () {
            return this.result()
          }
        }
      }), SVG.ParentEffect = SVG.invent({
        create: function () {
          this.constructor.call(this)
        },
        inherit: SVG.Parent,
        extend: {
          in: function (d) {
            return d == null ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", d)
          },
          result: function (d) {
            return d == null ? this.attr("result") : this.attr("result", d)
          },
          toString: function () {
            return this.result()
          }
        }
      });
      var Y = {
        blend: function (d, f) {
          return this.parent() && this.parent().blend(this, d, f)
        },
        colorMatrix: function (d, f) {
          return this.parent() && this.parent().colorMatrix(d, f).in(this)
        },
        convolveMatrix: function (d) {
          return this.parent() && this.parent().convolveMatrix(d).in(this)
        },
        componentTransfer: function (d) {
          return this.parent() && this.parent().componentTransfer(d).in(this)
        },
        composite: function (d, f) {
          return this.parent() && this.parent().composite(this, d, f)
        },
        flood: function (d, f) {
          return this.parent() && this.parent().flood(d, f)
        },
        offset: function (d, f) {
          return this.parent() && this.parent().offset(d, f).in(this)
        },
        image: function (d) {
          return this.parent() && this.parent().image(d)
        },
        merge: function () {
          return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
        },
        gaussianBlur: function (d, f) {
          return this.parent() && this.parent().gaussianBlur(d, f).in(this)
        },
        morphology: function (d, f) {
          return this.parent() && this.parent().morphology(d, f).in(this)
        },
        diffuseLighting: function (d, f, g) {
          return this.parent() && this.parent().diffuseLighting(d, f, g).in(this)
        },
        displacementMap: function (d, f, g, b) {
          return this.parent() && this.parent().displacementMap(this, d, f, g, b)
        },
        specularLighting: function (d, f, g, b) {
          return this.parent() && this.parent().specularLighting(d, f, g, b).in(this)
        },
        tile: function () {
          return this.parent() && this.parent().tile().in(this)
        },
        turbulence: function (d, f, g, b, y) {
          return this.parent() && this.parent().turbulence(d, f, g, b, y).in(this)
        }
      };
      SVG.extend(SVG.Effect, Y), SVG.extend(SVG.ParentEffect, Y), SVG.ChildEffect = SVG.invent({
        create: function () {
          this.constructor.call(this)
        },
        inherit: SVG.Element,
        extend: {
          in: function (d) {
            this.attr("in", d)
          }
        }
      });
      var r = {
          blend: function (d, f, g) {
            this.attr({
              in: d,
              in2: f,
              mode: g || "normal"
            })
          },
          colorMatrix: function (d, f) {
            d == "matrix" && (f = c(f)), this.attr({
              type: d,
              values: f === void 0 ? null : f
            })
          },
          convolveMatrix: function (d) {
            d = c(d), this.attr({
              order: Math.sqrt(d.split(" ").length),
              kernelMatrix: d
            })
          },
          composite: function (d, f, g) {
            this.attr({
              in: d,
              in2: f,
              operator: g
            })
          },
          flood: function (d, f) {
            this.attr("flood-color", d), f != null && this.attr("flood-opacity", f)
          },
          offset: function (d, f) {
            this.attr({
              dx: d,
              dy: f
            })
          },
          image: function (d) {
            this.attr("href", d, SVG.xlink)
          },
          displacementMap: function (d, f, g, b, y) {
            this.attr({
              in: d,
              in2: f,
              scale: g,
              xChannelSelector: b,
              yChannelSelector: y
            })
          },
          gaussianBlur: function (d, f) {
            d != null || f != null ? this.attr("stdDeviation", function (g) {
              if (!Array.isArray(g)) return g;
              for (var b = 0, y = g.length, x = []; b < y; b++) x.push(g[b]);
              return x.join(" ")
            }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0")
          },
          morphology: function (d, f) {
            this.attr({
              operator: d,
              radius: f
            })
          },
          tile: function () {},
          turbulence: function (d, f, g, b, y) {
            this.attr({
              numOctaves: f,
              seed: g,
              stitchTiles: b,
              baseFrequency: d,
              type: y
            })
          }
        },
        n = {
          merge: function () {
            var d;
            if (arguments[0] instanceof SVG.Set) {
              var f = this;
              arguments[0].each(function (b) {
                this instanceof SVG.MergeNode ? f.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && f.put(new SVG.MergeNode(this))
              })
            } else {
              d = Array.isArray(arguments[0]) ? arguments[0] : arguments;
              for (var g = 0; g < d.length; g++) d[g] instanceof SVG.MergeNode ? this.put(d[g]) : this.put(new SVG.MergeNode(d[g]))
            }
          },
          componentTransfer: function (d) {
            if (this.rgb = new SVG.Set, ["r", "g", "b", "a"].forEach((function (g) {
                this[g] = new SVG["Func" + g.toUpperCase()]("identity"), this.rgb.add(this[g]), this.node.appendChild(this[g].node)
              }).bind(this)), d)
              for (var f in d.rgb && (["r", "g", "b"].forEach((function (g) {
                  this[g].attr(d.rgb)
                }).bind(this)), delete d.rgb), d) this[f].attr(d[f])
          },
          diffuseLighting: function (d, f, g) {
            this.attr({
              surfaceScale: d,
              diffuseConstant: f,
              kernelUnitLength: g
            })
          },
          specularLighting: function (d, f, g, b) {
            this.attr({
              surfaceScale: d,
              diffuseConstant: f,
              specularExponent: g,
              kernelUnitLength: b
            })
          }
        },
        s = {
          distantLight: function (d, f) {
            this.attr({
              azimuth: d,
              elevation: f
            })
          },
          pointLight: function (d, f, g) {
            this.attr({
              x: d,
              y: f,
              z: g
            })
          },
          spotLight: function (d, f, g, b, y, x) {
            this.attr({
              x: d,
              y: f,
              z: g,
              pointsAtX: b,
              pointsAtY: y,
              pointsAtZ: x
            })
          },
          mergeNode: function (d) {
            this.attr("in", d)
          }
        };

      function c(d) {
        return Array.isArray(d) && (d = new SVG.Array(d)), d.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
      }

      function u() {
        var d = function () {};
        for (var f in typeof arguments[arguments.length - 1] == "function" && (d = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
          for (var g in arguments[f]) d(arguments[f][g], g, arguments[f])
      } ["r", "g", "b", "a"].forEach(function (d) {
        s["Func" + d.toUpperCase()] = function (f) {
          switch (this.attr("type", f), f) {
            case "table":
              this.attr("tableValues", arguments[1]);
              break;
            case "linear":
              this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
              break;
            case "gamma":
              this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2])
          }
        }
      }), u(r, function (d, f) {
        var g = f.charAt(0).toUpperCase() + f.slice(1);
        SVG[g + "Effect"] = SVG.invent({
          create: function () {
            this.constructor.call(this, SVG.create("fe" + g)), d.apply(this, arguments), this.result(this.attr("id") + "Out")
          },
          inherit: SVG.Effect,
          extend: {}
        })
      }), u(n, function (d, f) {
        var g = f.charAt(0).toUpperCase() + f.slice(1);
        SVG[g + "Effect"] = SVG.invent({
          create: function () {
            this.constructor.call(this, SVG.create("fe" + g)), d.apply(this, arguments), this.result(this.attr("id") + "Out")
          },
          inherit: SVG.ParentEffect,
          extend: {}
        })
      }), u(s, function (d, f) {
        var g = f.charAt(0).toUpperCase() + f.slice(1);
        SVG[g] = SVG.invent({
          create: function () {
            this.constructor.call(this, SVG.create("fe" + g)), d.apply(this, arguments)
          },
          inherit: SVG.ChildEffect,
          extend: {}
        })
      }), SVG.extend(SVG.MergeEffect, {
        in: function (d) {
          return d instanceof SVG.MergeNode ? this.add(d, 0) : this.add(new SVG.MergeNode(d), 0), this
        }
      }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
        in2: function (d) {
          return d == null ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", d)
        }
      }), SVG.filter = {
        sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
      }
    }).call(void 0),
    function () {
      function Y(u, d, f, g, b, y, x) {
        for (var _ = u.slice(d, f || x), T = g.slice(b, y || x), P = 0, O = {
            pos: [0, 0],
            start: [0, 0]
          }, $ = {
            pos: [0, 0],
            start: [0, 0]
          }; _[P] = r.call(O, _[P]), T[P] = r.call($, T[P]), _[P][0] != T[P][0] || _[P][0] == "M" || _[P][0] == "A" && (_[P][4] != T[P][4] || _[P][5] != T[P][5]) ? (Array.prototype.splice.apply(_, [P, 1].concat(s.call(O, _[P]))), Array.prototype.splice.apply(T, [P, 1].concat(s.call($, T[P])))) : (_[P] = n.call(O, _[P]), T[P] = n.call($, T[P])), !(++P == _.length && P == T.length);) P == _.length && _.push(["C", O.pos[0], O.pos[1], O.pos[0], O.pos[1], O.pos[0], O.pos[1]]), P == T.length && T.push(["C", $.pos[0], $.pos[1], $.pos[0], $.pos[1], $.pos[0], $.pos[1]]);
        return {
          start: _,
          dest: T
        }
      }

      function r(u) {
        switch (u[0]) {
          case "z":
          case "Z":
            u[0] = "L", u[1] = this.start[0], u[2] = this.start[1];
            break;
          case "H":
            u[0] = "L", u[2] = this.pos[1];
            break;
          case "V":
            u[0] = "L", u[2] = u[1], u[1] = this.pos[0];
            break;
          case "T":
            u[0] = "Q", u[3] = u[1], u[4] = u[2], u[1] = this.reflection[1], u[2] = this.reflection[0];
            break;
          case "S":
            u[0] = "C", u[6] = u[4], u[5] = u[3], u[4] = u[2], u[3] = u[1], u[2] = this.reflection[1], u[1] = this.reflection[0]
        }
        return u
      }

      function n(u) {
        var d = u.length;
        return this.pos = [u[d - 2], u[d - 1]], "SCQT".indexOf(u[0]) != -1 && (this.reflection = [2 * this.pos[0] - u[d - 4], 2 * this.pos[1] - u[d - 3]]), u
      }

      function s(u) {
        var d = [u];
        switch (u[0]) {
          case "M":
            return this.pos = this.start = [u[1], u[2]], d;
          case "L":
            u[5] = u[3] = u[1], u[6] = u[4] = u[2], u[1] = this.pos[0], u[2] = this.pos[1];
            break;
          case "Q":
            u[6] = u[4], u[5] = u[3], u[4] = 1 * u[4] / 3 + 2 * u[2] / 3, u[3] = 1 * u[3] / 3 + 2 * u[1] / 3, u[2] = 1 * this.pos[1] / 3 + 2 * u[2] / 3, u[1] = 1 * this.pos[0] / 3 + 2 * u[1] / 3;
            break;
          case "A":
            d = function (f, g) {
              var b, y, x, _, T, P, O, $, G, Q, v, C, L, H, q, ee, ge, pe, Fe, Ue, Ve, it, dt, mt, At, _t, Et = Math.abs(g[1]),
                qt = Math.abs(g[2]),
                sa = g[3] % 360,
                wr = g[4],
                Ya = g[5],
                ma = g[6],
                Mr = g[7],
                Ta = new SVG.Point(f),
                Sa = new SVG.Point(ma, Mr),
                ai = [];
              if (Et === 0 || qt === 0 || Ta.x === Sa.x && Ta.y === Sa.y) return [
                ["C", Ta.x, Ta.y, Sa.x, Sa.y, Sa.x, Sa.y]
              ];
              for (b = new SVG.Point((Ta.x - Sa.x) / 2, (Ta.y - Sa.y) / 2).transform(new SVG.Matrix().rotate(sa)), (y = b.x * b.x / (Et * Et) + b.y * b.y / (qt * qt)) > 1 && (Et *= y = Math.sqrt(y), qt *= y), x = new SVG.Matrix().rotate(sa).scale(1 / Et, 1 / qt).rotate(-sa), Ta = Ta.transform(x), Sa = Sa.transform(x), _ = [Sa.x - Ta.x, Sa.y - Ta.y], P = _[0] * _[0] + _[1] * _[1], T = Math.sqrt(P), _[0] /= T, _[1] /= T, O = P < 4 ? Math.sqrt(1 - P / 4) : 0, wr === Ya && (O *= -1), $ = new SVG.Point((Sa.x + Ta.x) / 2 + O * -_[1], (Sa.y + Ta.y) / 2 + O * _[0]), G = new SVG.Point(Ta.x - $.x, Ta.y - $.y), Q = new SVG.Point(Sa.x - $.x, Sa.y - $.y), v = Math.acos(G.x / Math.sqrt(G.x * G.x + G.y * G.y)), G.y < 0 && (v *= -1), C = Math.acos(Q.x / Math.sqrt(Q.x * Q.x + Q.y * Q.y)), Q.y < 0 && (C *= -1), Ya && v > C && (C += 2 * Math.PI), !Ya && v < C && (C -= 2 * Math.PI), H = Math.ceil(2 * Math.abs(v - C) / Math.PI), ee = [], ge = v, L = (C - v) / H, q = 4 * Math.tan(L / 4) / 3, Ve = 0; Ve <= H; Ve++) Fe = Math.cos(ge), pe = Math.sin(ge), Ue = new SVG.Point($.x + Fe, $.y + pe), ee[Ve] = [new SVG.Point(Ue.x + q * pe, Ue.y - q * Fe), Ue, new SVG.Point(Ue.x - q * pe, Ue.y + q * Fe)], ge += L;
              for (ee[0][0] = ee[0][1].clone(), ee[ee.length - 1][2] = ee[ee.length - 1][1].clone(), x = new SVG.Matrix().rotate(sa).scale(Et, qt).rotate(-sa), Ve = 0, it = ee.length; Ve < it; Ve++) ee[Ve][0] = ee[Ve][0].transform(x), ee[Ve][1] = ee[Ve][1].transform(x), ee[Ve][2] = ee[Ve][2].transform(x);
              for (Ve = 1, it = ee.length; Ve < it; Ve++) dt = (Ue = ee[Ve - 1][2]).x, mt = Ue.y, At = (Ue = ee[Ve][0]).x, _t = Ue.y, ma = (Ue = ee[Ve][1]).x, Mr = Ue.y, ai.push(["C", dt, mt, At, _t, ma, Mr]);
              return ai
            }(this.pos, u), u = d[0]
        }
        return u[0] = "C", this.pos = [u[5], u[6]], this.reflection = [2 * u[5] - u[3], 2 * u[6] - u[4]], d
      }

      function c(u, d) {
        if (d === !1) return !1;
        for (var f = d, g = u.length; f < g; ++f)
          if (u[f][0] == "M") return f;
        return !1
      }
      SVG.extend(SVG.PathArray, {
        morph: function (u) {
          for (var d = this.value, f = this.parse(u), g = 0, b = 0, y = !1, x = !1; g !== !1 || b !== !1;) {
            var _;
            y = c(d, g !== !1 && g + 1), x = c(f, b !== !1 && b + 1), g === !1 && (g = (_ = new SVG.PathArray(T.start).bbox()).height == 0 || _.width == 0 ? d.push(d[0]) - 1 : d.push(["M", _.x + _.width / 2, _.y + _.height / 2]) - 1), b === !1 && (b = (_ = new SVG.PathArray(T.dest).bbox()).height == 0 || _.width == 0 ? f.push(f[0]) - 1 : f.push(["M", _.x + _.width / 2, _.y + _.height / 2]) - 1);
            var T = Y(d, g, y, f, b, x);
            d = d.slice(0, g).concat(T.start, y === !1 ? [] : d.slice(y)), f = f.slice(0, b).concat(T.dest, x === !1 ? [] : f.slice(x)), g = y !== !1 && g + T.start.length, b = x !== !1 && b + T.dest.length
          }
          return this.value = d, this.destination = new SVG.PathArray, this.destination.value = f, this
        }
      })
    }(), (function () {
      function Y(r) {
        r.remember("_draggable", this), this.el = r
      }
      Y.prototype.init = function (r, n) {
        var s = this;
        this.constraint = r, this.value = n, this.el.on("mousedown.drag", function (c) {
          s.start(c)
        }), this.el.on("touchstart.drag", function (c) {
          s.start(c)
        })
      }, Y.prototype.transformPoint = function (r, n) {
        var s = (r = r || window.event).changedTouches && r.changedTouches[0] || r;
        return this.p.x = s.clientX - (n || 0), this.p.y = s.clientY, this.p.matrixTransform(this.m)
      }, Y.prototype.getBBox = function () {
        var r = this.el.bbox();
        return this.el instanceof SVG.Nested && (r = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (r.x = this.el.x(), r.y = this.el.y()), r
      }, Y.prototype.start = function (r) {
        if (r.type != "click" && r.type != "mousedown" && r.type != "mousemove" || (r.which || r.buttons) == 1) {
          var n = this;
          if (this.el.fire("beforedrag", {
              event: r,
              handler: this
            }), !this.el.event().defaultPrevented) {
            r.preventDefault(), r.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
            var s, c = this.getBBox();
            if (this.el instanceof SVG.Text) switch (s = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
              case "middle":
                s /= 2;
                break;
              case "start":
                s = 0
            }
            this.startPoints = {
              point: this.transformPoint(r, s),
              box: c,
              transform: this.el.transform()
            }, SVG.on(window, "mousemove.drag", function (u) {
              n.drag(u)
            }), SVG.on(window, "touchmove.drag", function (u) {
              n.drag(u)
            }), SVG.on(window, "mouseup.drag", function (u) {
              n.end(u)
            }), SVG.on(window, "touchend.drag", function (u) {
              n.end(u)
            }), this.el.fire("dragstart", {
              event: r,
              p: this.startPoints.point,
              m: this.m,
              handler: this
            })
          }
        }
      }, Y.prototype.drag = function (r) {
        var n = this.getBBox(),
          s = this.transformPoint(r),
          c = this.startPoints.box.x + s.x - this.startPoints.point.x,
          u = this.startPoints.box.y + s.y - this.startPoints.point.y,
          d = this.constraint,
          f = s.x - this.startPoints.point.x,
          g = s.y - this.startPoints.point.y;
        if (this.el.fire("dragmove", {
            event: r,
            p: s,
            m: this.m,
            handler: this
          }), this.el.event().defaultPrevented) return s;
        if (typeof d == "function") {
          var b = d.call(this.el, c, u, this.m);
          typeof b == "boolean" && (b = {
            x: b,
            y: b
          }), b.x === !0 ? this.el.x(c) : b.x !== !1 && this.el.x(b.x), b.y === !0 ? this.el.y(u) : b.y !== !1 && this.el.y(b.y)
        } else typeof d == "object" && (d.minX != null && c < d.minX ? f = (c = d.minX) - this.startPoints.box.x : d.maxX != null && c > d.maxX - n.width && (f = (c = d.maxX - n.width) - this.startPoints.box.x), d.minY != null && u < d.minY ? g = (u = d.minY) - this.startPoints.box.y : d.maxY != null && u > d.maxY - n.height && (g = (u = d.maxY - n.height) - this.startPoints.box.y), d.snapToGrid != null && (c -= c % d.snapToGrid, u -= u % d.snapToGrid, f -= f % d.snapToGrid, g -= g % d.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
          x: f,
          y: g
        }, !0) : this.el.move(c, u));
        return s
      }, Y.prototype.end = function (r) {
        var n = this.drag(r);
        this.el.fire("dragend", {
          event: r,
          p: n,
          m: this.m,
          handler: this
        }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag")
      }, SVG.extend(SVG.Element, {
        draggable: function (r, n) {
          typeof r != "function" && typeof r != "object" || (n = r, r = !0);
          var s = this.remember("_draggable") || new Y(this);
          return (r = r === void 0 || r) ? s.init(n || {}, r) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this
        }
      })
    }).call(void 0),
    function () {
      function Y(r) {
        this.el = r, r.remember("_selectHandler", this), this.pointSelection = {
          isSelected: !1
        }, this.rectSelection = {
          isSelected: !1
        }, this.pointsList = {
          lt: [0, 0],
          rt: ["width", 0],
          rb: ["width", "height"],
          lb: [0, "height"],
          t: ["width", 0],
          r: ["width", "height"],
          b: ["width", "height"],
          l: [0, "height"]
        }, this.pointCoord = function (n, s, c) {
          var u = typeof n != "string" ? n : s[n];
          return c ? u / 2 : u
        }, this.pointCoords = function (n, s) {
          var c = this.pointsList[n];
          return {
            x: this.pointCoord(c[0], s, n === "t" || n === "b"),
            y: this.pointCoord(c[1], s, n === "r" || n === "l")
          }
        }
      }
      Y.prototype.init = function (r, n) {
        var s = this.el.bbox();
        this.options = {};
        var c = this.el.selectize.defaults.points;
        for (var u in this.el.selectize.defaults) this.options[u] = this.el.selectize.defaults[u], n[u] !== void 0 && (this.options[u] = n[u]);
        var d = ["points", "pointsExclude"];
        for (var u in d) {
          var f = this.options[d[u]];
          typeof f == "string" ? f = f.length > 0 ? f.split(/\s*,\s*/i) : [] : typeof f == "boolean" && d[u] === "points" && (f = f ? c : []), this.options[d[u]] = f
        }
        this.options.points = [c, this.options.points].reduce(function (g, b) {
          return g.filter(function (y) {
            return b.indexOf(y) > -1
          })
        }), this.options.points = [this.options.points, this.options.pointsExclude].reduce(function (g, b) {
          return g.filter(function (y) {
            return b.indexOf(y) < 0
          })
        }), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(s.x, s.y)), this.options.deepSelect && ["line", "polyline", "polygon"].indexOf(this.el.type) !== -1 ? this.selectPoints(r) : this.selectRect(r), this.observe(), this.cleanup()
      }, Y.prototype.selectPoints = function (r) {
        return this.pointSelection.isSelected = r, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this
      }, Y.prototype.getPointArray = function () {
        var r = this.el.bbox();
        return this.el.array().valueOf().map(function (n) {
          return [n[0] - r.x, n[1] - r.y]
        })
      }, Y.prototype.drawPoints = function () {
        for (var r = this, n = this.getPointArray(), s = 0, c = n.length; s < c; ++s) {
          var u = function (f) {
              return function (g) {
                (g = g || window.event).preventDefault ? g.preventDefault() : g.returnValue = !1, g.stopPropagation();
                var b = g.pageX || g.touches[0].pageX,
                  y = g.pageY || g.touches[0].pageY;
                r.el.fire("point", {
                  x: b,
                  y,
                  i: f,
                  event: g
                })
              }
            }(s),
            d = this.drawPoint(n[s][0], n[s][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", u).on("mousedown", u);
          this.pointSelection.set.add(d)
        }
      }, Y.prototype.drawPoint = function (r, n) {
        var s = this.options.pointType;
        switch (s) {
          case "circle":
            return this.drawCircle(r, n);
          case "rect":
            return this.drawRect(r, n);
          default:
            if (typeof s == "function") return s.call(this, r, n);
            throw new Error("Unknown " + s + " point type!")
        }
      }, Y.prototype.drawCircle = function (r, n) {
        return this.nested.circle(this.options.pointSize).center(r, n)
      }, Y.prototype.drawRect = function (r, n) {
        return this.nested.rect(this.options.pointSize, this.options.pointSize).center(r, n)
      }, Y.prototype.updatePointSelection = function () {
        var r = this.getPointArray();
        this.pointSelection.set.each(function (n) {
          this.cx() === r[n][0] && this.cy() === r[n][1] || this.center(r[n][0], r[n][1])
        })
      }, Y.prototype.updateRectSelection = function () {
        var r = this,
          n = this.el.bbox();
        if (this.rectSelection.set.get(0).attr({
            width: n.width,
            height: n.height
          }), this.options.points.length && this.options.points.map(function (c, u) {
            var d = r.pointCoords(c, n);
            r.rectSelection.set.get(u + 1).center(d.x, d.y)
          }), this.options.rotationPoint) {
          var s = this.rectSelection.set.length();
          this.rectSelection.set.get(s - 1).center(n.width / 2, 20)
        }
      }, Y.prototype.selectRect = function (r) {
        var n = this,
          s = this.el.bbox();

        function c(f) {
          return function (g) {
            (g = g || window.event).preventDefault ? g.preventDefault() : g.returnValue = !1, g.stopPropagation();
            var b = g.pageX || g.touches[0].pageX,
              y = g.pageY || g.touches[0].pageY;
            n.el.fire(f, {
              x: b,
              y,
              event: g
            })
          }
        }
        if (this.rectSelection.isSelected = r, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(s.width, s.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map(function (f, g) {
            var b = n.pointCoords(f, s),
              y = n.drawPoint(b.x, b.y).attr("class", n.options.classPoints + "_" + f).on("mousedown", c(f)).on("touchstart", c(f));
            n.rectSelection.set.add(y)
          }), this.rectSelection.set.each(function () {
            this.addClass(n.options.classPoints)
          })), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
          var u = function (f) {
              (f = f || window.event).preventDefault ? f.preventDefault() : f.returnValue = !1, f.stopPropagation();
              var g = f.pageX || f.touches[0].pageX,
                b = f.pageY || f.touches[0].pageY;
              n.el.fire("rot", {
                x: g,
                y: b,
                event: f
              })
            },
            d = this.drawPoint(s.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", u).on("mousedown", u);
          this.rectSelection.set.add(d)
        }
      }, Y.prototype.handler = function () {
        var r = this.el.bbox();
        this.nested.matrix(new SVG.Matrix(this.el).translate(r.x, r.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection()
      }, Y.prototype.observe = function () {
        var r = this;
        if (MutationObserver)
          if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver(function () {
            r.handler()
          }), this.observerInst.observe(this.el.node, {
            attributes: !0
          });
          else try {
            this.observerInst.disconnect(), delete this.observerInst
          } catch {} else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", function () {
            r.handler()
          })
      }, Y.prototype.cleanup = function () {
        !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each(function () {
          this.remove()
        }), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each(function () {
          this.remove()
        }), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested)
      }, SVG.extend(SVG.Element, {
        selectize: function (r, n) {
          return typeof r == "object" && (n = r, r = !0), (this.remember("_selectHandler") || new Y(this)).init(r === void 0 || r, n || {}), this
        }
      }), SVG.Element.prototype.selectize.defaults = {
        points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
        pointsExclude: [],
        classRect: "svg_select_boundingRect",
        classPoints: "svg_select_points",
        pointSize: 7,
        rotationPoint: !0,
        deepSelect: !1,
        pointType: "circle"
      }
    }(),
    function () {
      (function () {
        function Y(r) {
          r.remember("_resizeHandler", this), this.el = r, this.parameters = {}, this.lastUpdateCall = null, this.p = r.doc().node.createSVGPoint()
        }
        Y.prototype.transformPoint = function (r, n, s) {
          return this.p.x = r - (this.offset.x - window.pageXOffset), this.p.y = n - (this.offset.y - window.pageYOffset), this.p.matrixTransform(s || this.m)
        }, Y.prototype._extractPosition = function (r) {
          return {
            x: r.clientX != null ? r.clientX : r.touches[0].clientX,
            y: r.clientY != null ? r.clientY : r.touches[0].clientY
          }
        }, Y.prototype.init = function (r) {
          var n = this;
          if (this.stop(), r !== "stop") {
            for (var s in this.options = {}, this.el.resize.defaults) this.options[s] = this.el.resize.defaults[s], r[s] !== void 0 && (this.options[s] = r[s]);
            this.el.on("lt.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("rt.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("rb.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("lb.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("t.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("r.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("b.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("l.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("rot.resize", function (c) {
              n.resize(c || window.event)
            }), this.el.on("point.resize", function (c) {
              n.resize(c || window.event)
            }), this.update()
          }
        }, Y.prototype.stop = function () {
          return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this
        }, Y.prototype.resize = function (r) {
          var n = this;
          this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
            x: window.pageXOffset,
            y: window.pageYOffset
          };
          var s = this._extractPosition(r.detail.event);
          if (this.parameters = {
              type: this.el.type,
              p: this.transformPoint(s.x, s.y),
              x: r.detail.x,
              y: r.detail.y,
              box: this.el.bbox(),
              rotation: this.el.transform().rotation
            }, this.el.type === "text" && (this.parameters.fontSize = this.el.attr()["font-size"]), r.detail.i !== void 0) {
            var c = this.el.array().valueOf();
            this.parameters.i = r.detail.i, this.parameters.pointCoords = [c[r.detail.i][0], c[r.detail.i][1]]
          }
          switch (r.type) {
            case "lt":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d);
                if (this.parameters.box.width - f[0] > 0 && this.parameters.box.height - f[1] > 0) {
                  if (this.parameters.type === "text") return this.el.move(this.parameters.box.x + f[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - f[0]);
                  f = this.checkAspectRatio(f), this.el.move(this.parameters.box.x + f[0], this.parameters.box.y + f[1]).size(this.parameters.box.width - f[0], this.parameters.box.height - f[1])
                }
              };
              break;
            case "rt":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d, 2);
                if (this.parameters.box.width + f[0] > 0 && this.parameters.box.height - f[1] > 0) {
                  if (this.parameters.type === "text") return this.el.move(this.parameters.box.x - f[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + f[0]);
                  f = this.checkAspectRatio(f, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + f[1]).size(this.parameters.box.width + f[0], this.parameters.box.height - f[1])
                }
              };
              break;
            case "rb":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d, 0);
                if (this.parameters.box.width + f[0] > 0 && this.parameters.box.height + f[1] > 0) {
                  if (this.parameters.type === "text") return this.el.move(this.parameters.box.x - f[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + f[0]);
                  f = this.checkAspectRatio(f), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + f[0], this.parameters.box.height + f[1])
                }
              };
              break;
            case "lb":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d, 1);
                if (this.parameters.box.width - f[0] > 0 && this.parameters.box.height + f[1] > 0) {
                  if (this.parameters.type === "text") return this.el.move(this.parameters.box.x + f[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - f[0]);
                  f = this.checkAspectRatio(f, !0), this.el.move(this.parameters.box.x + f[0], this.parameters.box.y).size(this.parameters.box.width - f[0], this.parameters.box.height + f[1])
                }
              };
              break;
            case "t":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d, 2);
                if (this.parameters.box.height - f[1] > 0) {
                  if (this.parameters.type === "text") return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y + f[1]).height(this.parameters.box.height - f[1])
                }
              };
              break;
            case "r":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d, 0);
                if (this.parameters.box.width + f[0] > 0) {
                  if (this.parameters.type === "text") return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + f[0])
                }
              };
              break;
            case "b":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d, 0);
                if (this.parameters.box.height + f[1] > 0) {
                  if (this.parameters.type === "text") return;
                  this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + f[1])
                }
              };
              break;
            case "l":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d, 1);
                if (this.parameters.box.width - f[0] > 0) {
                  if (this.parameters.type === "text") return;
                  this.el.move(this.parameters.box.x + f[0], this.parameters.box.y).width(this.parameters.box.width - f[0])
                }
              };
              break;
            case "rot":
              this.calc = function (u, d) {
                var f = u + this.parameters.p.x,
                  g = d + this.parameters.p.y,
                  b = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                  y = Math.atan2(g - this.parameters.box.y - this.parameters.box.height / 2, f - this.parameters.box.x - this.parameters.box.width / 2),
                  x = this.parameters.rotation + 180 * (y - b) / Math.PI + this.options.snapToAngle / 2;
                this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(x - x % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
              };
              break;
            case "point":
              this.calc = function (u, d) {
                var f = this.snapToGrid(u, d, this.parameters.pointCoords[0], this.parameters.pointCoords[1]),
                  g = this.el.array().valueOf();
                g[this.parameters.i][0] = this.parameters.pointCoords[0] + f[0], g[this.parameters.i][1] = this.parameters.pointCoords[1] + f[1], this.el.plot(g)
              }
          }
          this.el.fire("resizestart", {
            dx: this.parameters.x,
            dy: this.parameters.y,
            event: r
          }), SVG.on(window, "touchmove.resize", function (u) {
            n.update(u || window.event)
          }), SVG.on(window, "touchend.resize", function () {
            n.done()
          }), SVG.on(window, "mousemove.resize", function (u) {
            n.update(u || window.event)
          }), SVG.on(window, "mouseup.resize", function () {
            n.done()
          })
        }, Y.prototype.update = function (r) {
          if (r) {
            var n = this._extractPosition(r),
              s = this.transformPoint(n.x, n.y),
              c = s.x - this.parameters.p.x,
              u = s.y - this.parameters.p.y;
            this.lastUpdateCall = [c, u], this.calc(c, u), this.el.fire("resizing", {
              dx: c,
              dy: u,
              event: r
            })
          } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
        }, Y.prototype.done = function () {
          this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone")
        }, Y.prototype.snapToGrid = function (r, n, s, c) {
          var u;
          return c !== void 0 ? u = [(s + r) % this.options.snapToGrid, (c + n) % this.options.snapToGrid] : (s = s ?? 3, u = [(this.parameters.box.x + r + (1 & s ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + n + (2 & s ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), r < 0 && (u[0] -= this.options.snapToGrid), n < 0 && (u[1] -= this.options.snapToGrid), r -= Math.abs(u[0]) < this.options.snapToGrid / 2 ? u[0] : u[0] - (r < 0 ? -this.options.snapToGrid : this.options.snapToGrid), n -= Math.abs(u[1]) < this.options.snapToGrid / 2 ? u[1] : u[1] - (n < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(r, n, s, c)
        }, Y.prototype.constraintToBox = function (r, n, s, c) {
          var u, d, f = this.options.constraint || {};
          return c !== void 0 ? (u = s, d = c) : (u = this.parameters.box.x + (1 & s ? 0 : this.parameters.box.width), d = this.parameters.box.y + (2 & s ? 0 : this.parameters.box.height)), f.minX !== void 0 && u + r < f.minX && (r = f.minX - u), f.maxX !== void 0 && u + r > f.maxX && (r = f.maxX - u), f.minY !== void 0 && d + n < f.minY && (n = f.minY - d), f.maxY !== void 0 && d + n > f.maxY && (n = f.maxY - d), [r, n]
        }, Y.prototype.checkAspectRatio = function (r, n) {
          if (!this.options.saveAspectRatio) return r;
          var s = r.slice(),
            c = this.parameters.box.width / this.parameters.box.height,
            u = this.parameters.box.width + r[0],
            d = this.parameters.box.height - r[1],
            f = u / d;
          return f < c ? (s[1] = u / c - this.parameters.box.height, n && (s[1] = -s[1])) : f > c && (s[0] = this.parameters.box.width - d * c, n && (s[0] = -s[0])), s
        }, SVG.extend(SVG.Element, {
          resize: function (r) {
            return (this.remember("_resizeHandler") || new Y(this)).init(r || {}), this
          }
        }), SVG.Element.prototype.resize.defaults = {
          snapToAngle: .1,
          snapToGrid: 1,
          constraint: {},
          saveAspectRatio: !1
        }
      }).call(this)
    }(), window.Apex === void 0 && (window.Apex = {});
  var ks = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "initModules",
        value: function () {
          this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new N(this.ctx), this.ctx.axes = new Ie(this.ctx), this.ctx.core = new Ao(this.ctx.el, this.ctx), this.ctx.config = new De({}), this.ctx.data = new J(this.ctx), this.ctx.grid = new Pe(this.ctx), this.ctx.graphics = new W(this.ctx), this.ctx.coreUtils = new X(this.ctx), this.ctx.crosshairs = new ue(this.ctx), this.ctx.events = new oe(this.ctx), this.ctx.exports = new Xe(this.ctx), this.ctx.localization = new de(this.ctx), this.ctx.options = new le, this.ctx.responsive = new Le(this.ctx), this.ctx.series = new Be(this.ctx), this.ctx.theme = new K(this.ctx), this.ctx.formatters = new ve(this.ctx), this.ctx.titleSubtitle = new ae(this.ctx), this.ctx.legend = new ft(this.ctx), this.ctx.toolbar = new gt(this.ctx), this.ctx.tooltip = new Me(this.ctx), this.ctx.dimensions = new Te(this.ctx), this.ctx.updateHelpers = new Ka(this.ctx), this.ctx.zoomPanSelection = new Ct(this.ctx), this.ctx.w.globals.tooltip = new Me(this.ctx)
        }
      }]), Y
    }(),
    _s = function () {
      function Y(r) {
        l(this, Y), this.ctx = r, this.w = r.w
      }
      return p(Y, [{
        key: "clear",
        value: function (r) {
          var n = r.isUpdating;
          this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({
            isUpdating: n
          })
        }
      }, {
        key: "killSVG",
        value: function (r) {
          r.each(function (n, s) {
            this.removeClass("*"), this.off(), this.stop()
          }, !0), r.ungroup(), r.clear()
        }
      }, {
        key: "clearDomElements",
        value: function (r) {
          var n = this,
            s = r.isUpdating,
            c = this.w.globals.dom.Paper.node;
          c.parentNode && c.parentNode.parentNode && !s && (c.parentNode.parentNode.style.minHeight = "unset");
          var u = this.w.globals.dom.baseEl;
          u && this.ctx.eventList.forEach(function (f) {
            u.removeEventListener(f, n.ctx.events.documentEvent)
          });
          var d = this.w.globals.dom;
          if (this.ctx.el !== null)
            for (; this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild);
          this.killSVG(d.Paper), d.Paper.remove(), d.elWrap = null, d.elGraphical = null, d.elLegendWrap = null, d.elLegendForeign = null, d.baseEl = null, d.elGridRect = null, d.elGridRectMask = null, d.elGridRectMarkerMask = null, d.elForecastMask = null, d.elNonForecastMask = null, d.elDefs = null
        }
      }]), Y
    }(),
    Xi = new WeakMap,
    Co = function () {
      function Y(r, n) {
        l(this, Y), this.opts = n, this.ctx = this, this.w = new Je(n).init(), this.el = r, this.w.globals.cuid = I.randomId(), this.w.globals.chartID = this.w.config.chart.id ? I.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new ks(this).initModules(), this.create = I.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this)
      }
      return p(Y, [{
        key: "render",
        value: function () {
          var r = this;
          return new Promise(function (n, s) {
            if (r.el !== null) {
              Apex._chartInstances === void 0 && (Apex._chartInstances = []), r.w.config.chart.id && Apex._chartInstances.push({
                id: r.w.globals.chartID,
                group: r.w.config.chart.group,
                chart: r
              }), r.setLocale(r.w.config.chart.defaultLocale);
              var c = r.w.config.chart.events.beforeMount;
              if (typeof c == "function" && c(r, r.w), r.events.fireEvent("beforeMount", [r, r.w]), window.addEventListener("resize", r.windowResizeHandler), function (_, T) {
                  var P = !1;
                  if (_.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                    var O = _.getBoundingClientRect();
                    _.style.display !== "none" && O.width !== 0 || (P = !0)
                  }
                  var $ = new ResizeObserver(function (G) {
                    P && T.call(_, G), P = !0
                  });
                  _.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(_.children).forEach(function (G) {
                    return $.observe(G)
                  }) : $.observe(_), Xi.set(T, $)
                }(r.el.parentNode, r.parentResizeHandler), !r.css) {
                var u = r.el.getRootNode && r.el.getRootNode(),
                  d = I.is("ShadowRoot", u),
                  f = r.el.ownerDocument,
                  g = f.getElementById("apexcharts-css");
                if (d || !g) {
                  var b;
                  r.css = document.createElement("style"), r.css.id = "apexcharts-css", r.css.textContent = `@keyframes opaque {
  0% {
      opacity: 0
  }

  to {
      opacity: 1
  }
}

@keyframes resizeanim {
  0%,to {
      opacity: 0
  }
}

.apexcharts-canvas {
  position: relative;
  user-select: none
}

.apexcharts-canvas ::-webkit-scrollbar {
  -webkit-appearance: none;
  width: 6px
}

.apexcharts-canvas ::-webkit-scrollbar-thumb {
  border-radius: 4px;
  background-color: rgba(0,0,0,.5);
  box-shadow: 0 0 1px rgba(255,255,255,.5);
  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)
}

.apexcharts-inner {
  position: relative
}

.apexcharts-text tspan {
  font-family: inherit
}

.legend-mouseover-inactive {
  transition: .15s ease all;
  opacity: .2
}

.apexcharts-legend-text {
  padding-left: 15px;
  margin-left: -15px;
}

.apexcharts-series-collapsed {
  opacity: 0
}

.apexcharts-tooltip {
  border-radius: 5px;
  box-shadow: 2px 2px 6px -4px #999;
  cursor: default;
  font-size: 14px;
  left: 62px;
  opacity: 0;
  pointer-events: none;
  position: absolute;
  top: 20px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  white-space: nowrap;
  z-index: 12;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-tooltip.apexcharts-theme-light {
  border: 1px solid #e3e3e3;
  background: rgba(255,255,255,.96)
}

.apexcharts-tooltip.apexcharts-theme-dark {
  color: #fff;
  background: rgba(30,30,30,.8)
}

.apexcharts-tooltip * {
  font-family: inherit
}

.apexcharts-tooltip-title {
  padding: 6px;
  font-size: 15px;
  margin-bottom: 4px
}

.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {
  background: #eceff1;
  border-bottom: 1px solid #ddd
}

.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {
  background: rgba(0,0,0,.7);
  border-bottom: 1px solid #333
}

.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {
  display: inline-block;
  margin-left: 5px;
  font-weight: 600
}

.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {
  display: none
}

.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  padding: 6px 0 5px
}

.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {
  display: flex
}

.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {
  margin-top: -6px
}

.apexcharts-tooltip-marker {
  width: 12px;
  height: 12px;
  position: relative;
  top: 0;
  margin-right: 10px;
  border-radius: 50%
}

.apexcharts-tooltip-series-group {
  padding: 0 10px;
  display: none;
  text-align: left;
  justify-content: left;
  align-items: center
}

.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {
  opacity: 1
}

.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {
  padding-bottom: 4px
}

.apexcharts-tooltip-series-group-hidden {
  opacity: 0;
  height: 0;
  line-height: 0;
  padding: 0!important
}

.apexcharts-tooltip-y-group {
  padding: 6px 0 5px
}

.apexcharts-custom-tooltip,.apexcharts-tooltip-box {
  padding: 4px 8px
}

.apexcharts-tooltip-boxPlot {
  display: flex;
  flex-direction: column-reverse
}

.apexcharts-tooltip-box>div {
  margin: 4px 0
}

.apexcharts-tooltip-box span.value {
  font-weight: 700
}

.apexcharts-tooltip-rangebar {
  padding: 5px 8px
}

.apexcharts-tooltip-rangebar .category {
  font-weight: 600;
  color: #777
}

.apexcharts-tooltip-rangebar .series-name {
  font-weight: 700;
  display: block;
  margin-bottom: 5px
}

.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {
  opacity: 0;
  pointer-events: none;
  color: #373d3f;
  font-size: 13px;
  text-align: center;
  border-radius: 2px;
  position: absolute;
  z-index: 10;
  background: #eceff1;
  border: 1px solid #90a4ae
}

.apexcharts-xaxistooltip {
  padding: 9px 10px;
  transition: .15s ease all
}

.apexcharts-xaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {
  left: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-xaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-left: -6px
}

.apexcharts-xaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-left: -7px
}

.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {
  bottom: 100%
}

.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {
  top: 100%
}

.apexcharts-xaxistooltip-bottom:after {
  border-bottom-color: #eceff1
}

.apexcharts-xaxistooltip-bottom:before {
  border-bottom-color: #90a4ae
}

.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {
  border-bottom-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip-top:after {
  border-top-color: #eceff1
}

.apexcharts-xaxistooltip-top:before {
  border-top-color: #90a4ae
}

.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {
  border-top-color: rgba(0,0,0,.5)
}

.apexcharts-xaxistooltip.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-yaxistooltip {
  padding: 4px 10px
}

.apexcharts-yaxistooltip.apexcharts-theme-dark {
  background: rgba(0,0,0,.7);
  border: 1px solid rgba(0,0,0,.5);
  color: #fff
}

.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {
  top: 50%;
  border: solid transparent;
  content: " ";
  height: 0;
  width: 0;
  position: absolute;
  pointer-events: none
}

.apexcharts-yaxistooltip:after {
  border-color: transparent;
  border-width: 6px;
  margin-top: -6px
}

.apexcharts-yaxistooltip:before {
  border-color: transparent;
  border-width: 7px;
  margin-top: -7px
}

.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {
  left: 100%
}

.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {
  right: 100%
}

.apexcharts-yaxistooltip-left:after {
  border-left-color: #eceff1
}

.apexcharts-yaxistooltip-left:before {
  border-left-color: #90a4ae
}

.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {
  border-left-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip-right:after {
  border-right-color: #eceff1
}

.apexcharts-yaxistooltip-right:before {
  border-right-color: #90a4ae
}

.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {
  border-right-color: rgba(0,0,0,.5)
}

.apexcharts-yaxistooltip.apexcharts-active {
  opacity: 1
}

.apexcharts-yaxistooltip-hidden {
  display: none
}

.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {
  pointer-events: none;
  opacity: 0;
  transition: .15s ease all
}

.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {
  opacity: 1;
  transition: .15s ease all
}

.apexcharts-ycrosshairs-hidden {
  opacity: 0
}

.apexcharts-selection-rect {
  cursor: move
}

.svg_select_boundingRect,.svg_select_points_rot {
  pointer-events: none;
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {
  opacity: 0;
  visibility: hidden
}

.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {
  cursor: ew-resize;
  opacity: 1;
  visibility: visible
}

.svg_select_points {
  fill: #efefef;
  stroke: #333;
  rx: 2
}

.apexcharts-svg.apexcharts-zoomable.hovering-zoom {
  cursor: crosshair
}

.apexcharts-svg.apexcharts-zoomable.hovering-pan {
  cursor: move
}

.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  cursor: pointer;
  width: 20px;
  height: 20px;
  line-height: 24px;
  color: #6e8192;
  text-align: center
}

.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {
  fill: #6e8192
}

.apexcharts-selection-icon svg {
  fill: #444;
  transform: scale(.76)
}

.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {
  fill: #f3f4f5
}

.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {
  fill: #008ffb
}

.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {
  fill: #333
}

.apexcharts-menu-icon,.apexcharts-selection-icon {
  position: relative
}

.apexcharts-reset-icon {
  margin-left: 5px
}

.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {
  transform: scale(.85)
}

.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {
  transform: scale(.7)
}

.apexcharts-zoomout-icon {
  margin-right: 3px
}

.apexcharts-pan-icon {
  transform: scale(.62);
  position: relative;
  left: 1px;
  top: 0
}

.apexcharts-pan-icon svg {
  fill: #fff;
  stroke: #6e8192;
  stroke-width: 2
}

.apexcharts-pan-icon.apexcharts-selected svg {
  stroke: #008ffb
}

.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {
  stroke: #333
}

.apexcharts-toolbar {
  position: absolute;
  z-index: 11;
  max-width: 176px;
  text-align: right;
  border-radius: 3px;
  padding: 0 6px 2px;
  display: flex;
  justify-content: space-between;
  align-items: center
}

.apexcharts-menu {
  background: #fff;
  position: absolute;
  top: 100%;
  border: 1px solid #ddd;
  border-radius: 3px;
  padding: 3px;
  right: 10px;
  opacity: 0;
  min-width: 110px;
  transition: .15s ease all;
  pointer-events: none
}

.apexcharts-menu.apexcharts-menu-open {
  opacity: 1;
  pointer-events: all;
  transition: .15s ease all
}

.apexcharts-menu-item {
  padding: 6px 7px;
  font-size: 12px;
  cursor: pointer
}

.apexcharts-theme-light .apexcharts-menu-item:hover {
  background: #eee
}

.apexcharts-theme-dark .apexcharts-menu {
  background: rgba(0,0,0,.7);
  color: #fff
}

@media screen and (min-width:768px) {
  .apexcharts-canvas:hover .apexcharts-toolbar {
      opacity: 1
  }
}

.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {
  opacity: 0
}

.apexcharts-hidden-element-shown {
  opacity: 1;
  transition: 0.25s ease all;
}
.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {
  cursor: default;
  pointer-events: none
}

.apexcharts-pie-label-delay {
  opacity: 0;
  animation-name: opaque;
  animation-duration: .3s;
  animation-fill-mode: forwards;
  animation-timing-function: ease
}

.apexcharts-radialbar-label {
  cursor: pointer;
}

.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {
  pointer-events: none
}

.apexcharts-marker {
  transition: .15s ease all
}

.resize-triggers {
  animation: 1ms resizeanim;
  visibility: hidden;
  opacity: 0;
  height: 100%;
  width: 100%;
  overflow: hidden
}

.contract-trigger:before,.resize-triggers,.resize-triggers>div {
  content: " ";
  display: block;
  position: absolute;
  top: 0;
  left: 0
}

.resize-triggers>div {
  height: 100%;
  width: 100%;
  background: #eee;
  overflow: auto
}

.contract-trigger:before {
  overflow: hidden;
  width: 200%;
  height: 200%
}

.apexcharts-bar-goals-markers{
  pointer-events: none
}

.apexcharts-bar-shadows{
  pointer-events: none
}

.apexcharts-rangebar-goals-markers{
  pointer-events: none
}`;
                  var y = ((b = r.opts.chart) === null || b === void 0 ? void 0 : b.nonce) || r.w.config.chart.nonce;
                  y && r.css.setAttribute("nonce", y), d ? u.prepend(r.css) : f.head.appendChild(r.css)
                }
              }
              var x = r.create(r.w.config.series, {});
              if (!x) return n(r);
              r.mount(x).then(function () {
                typeof r.w.config.chart.events.mounted == "function" && r.w.config.chart.events.mounted(r, r.w), r.events.fireEvent("mounted", [r, r.w]), n(x)
              }).catch(function (_) {
                s(_)
              })
            } else s(new Error("Element not found"))
          })
        }
      }, {
        key: "create",
        value: function (r, n) {
          var s = this.w;
          new ks(this).initModules();
          var c = this.w.globals;
          if (c.noData = !1, c.animationEnded = !1, this.responsive.checkResponsiveConfig(n), s.config.xaxis.convertedCatToNumeric && new He(s.config).convertCatToNumericXaxis(s.config, this.ctx), this.el === null || (this.core.setupElements(), s.config.chart.type === "treemap" && (s.config.grid.show = !1, s.config.yaxis[0].show = !1), c.svgWidth === 0)) return c.animationEnded = !0, null;
          var u = X.checkComboSeries(r);
          c.comboCharts = u.comboCharts, c.comboBarCount = u.comboBarCount;
          var d = r.every(function (y) {
            return y.data && y.data.length === 0
          });
          (r.length === 0 || d) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(r), this.theme.init(), new ke(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), c.noData && c.collapsedSeries.length !== c.series.length && !s.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), c.axisCharts && (this.core.coreCalculations(), s.config.xaxis.type !== "category" && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = s.globals.minX, this.ctx.toolbar.maxX = s.globals.maxX), this.formatters.heatmapLabelFormatters(), new X(this).getLargestMarkerSize(), this.dimensions.plotCoords();
          var f = this.core.xySettings();
          this.grid.createGridMask();
          var g = this.core.plotChartType(r, f),
            b = new Se(this);
          return b.bringForward(), s.config.dataLabels.background.enabled && b.dataLabelsBackground(), this.core.shiftGraphPosition(), {
            elGraph: g,
            xyRatios: f,
            dimensions: {
              plot: {
                left: s.globals.translateX,
                top: s.globals.translateY,
                width: s.globals.gridWidth,
                height: s.globals.gridHeight
              }
            }
          }
        }
      }, {
        key: "mount",
        value: function () {
          var r = this,
            n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null,
            s = this,
            c = s.w;
          return new Promise(function (u, d) {
            if (s.el === null) return d(new Error("Not enough data to display or target element not found"));
            (n === null || c.globals.allSeriesCollapsed) && s.series.handleNoData(), s.grid = new Pe(s);
            var f, g, b = s.grid.drawGrid();
            if (s.annotations = new Ee(s), s.annotations.drawImageAnnos(), s.annotations.drawTextAnnos(), c.config.grid.position === "back" && (b && c.globals.dom.elGraphical.add(b.el), b != null && (f = b.elGridBorders) !== null && f !== void 0 && f.node && c.globals.dom.elGraphical.add(b.elGridBorders)), Array.isArray(n.elGraph))
              for (var y = 0; y < n.elGraph.length; y++) c.globals.dom.elGraphical.add(n.elGraph[y]);
            else c.globals.dom.elGraphical.add(n.elGraph);
            c.config.grid.position === "front" && (b && c.globals.dom.elGraphical.add(b.el), b != null && (g = b.elGridBorders) !== null && g !== void 0 && g.node && c.globals.dom.elGraphical.add(b.elGridBorders)), c.config.xaxis.crosshairs.position === "front" && s.crosshairs.drawXCrosshairs(), c.config.yaxis[0].crosshairs.position === "front" && s.crosshairs.drawYCrosshairs(), c.config.chart.type !== "treemap" && s.axes.drawAxis(c.config.chart.type, b);
            var x = new nt(r.ctx, b),
              _ = new j(r.ctx, b);
            if (b !== null && (x.xAxisLabelCorrections(b.xAxisTickWidth), _.setYAxisTextAlignments(), c.config.yaxis.map(function (P, O) {
                c.globals.ignoreYAxisIndexes.indexOf(O) === -1 && _.yAxisTitleRotate(O, P.opposite)
              })), s.annotations.drawAxesAnnotations(), !c.globals.noData) {
              if (c.config.tooltip.enabled && !c.globals.noData && s.w.globals.tooltip.drawTooltip(n.xyRatios), c.globals.axisCharts && (c.globals.isXNumeric || c.config.xaxis.convertedCatToNumeric || c.globals.isRangeBar))(c.config.chart.zoom.enabled || c.config.chart.selection && c.config.chart.selection.enabled || c.config.chart.pan && c.config.chart.pan.enabled) && s.zoomPanSelection.init({
                xyRatios: n.xyRatios
              });
              else {
                var T = c.config.chart.toolbar.tools;
                ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function (P) {
                  T[P] = !1
                })
              }
              c.config.chart.toolbar.show && !c.globals.allSeriesCollapsed && s.toolbar.createToolbar()
            }
            c.globals.memory.methodsToExec.length > 0 && c.globals.memory.methodsToExec.forEach(function (P) {
              P.method(P.params, !1, P.context)
            }), c.globals.axisCharts || c.globals.noData || s.core.resizeNonAxisCharts(), u(s)
          })
        }
      }, {
        key: "destroy",
        value: function () {
          var r, n;
          window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, r = this.parentResizeHandler, (n = Xi.get(r)) && (n.disconnect(), Xi.delete(r));
          var s = this.w.config.chart.id;
          s && Apex._chartInstances.forEach(function (c, u) {
            c.id === I.escapeString(s) && Apex._chartInstances.splice(u, 1)
          }), new _s(this.ctx).clear({
            isUpdating: !1
          })
        }
      }, {
        key: "updateOptions",
        value: function (r) {
          var n = this,
            s = arguments.length > 1 && arguments[1] !== void 0 && arguments[1],
            c = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2],
            u = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3],
            d = !(arguments.length > 4 && arguments[4] !== void 0) || arguments[4],
            f = this.w;
          return f.globals.selection = void 0, r.series && (this.series.resetSeries(!1, !0, !1), r.series.length && r.series[0].data && (r.series = r.series.map(function (g, b) {
            return n.updateHelpers._extendSeries(g, b)
          })), this.updateHelpers.revertDefaultAxisMinMax()), r.xaxis && (r = this.updateHelpers.forceXAxisUpdate(r)), r.yaxis && (r = this.updateHelpers.forceYAxisUpdate(r)), f.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), r.theme && (r = this.theme.updateThemeOptions(r)), this.updateHelpers._updateOptions(r, s, c, u, d)
        }
      }, {
        key: "updateSeries",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [],
            n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
            s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
          return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(r, n, s)
        }
      }, {
        key: "appendSeries",
        value: function (r) {
          var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
            s = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2],
            c = this.w.config.series.slice();
          return c.push(r), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(c, n, s)
        }
      }, {
        key: "appendData",
        value: function (r) {
          var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
            s = this;
          s.w.globals.dataChanged = !0, s.series.getPreviousPaths();
          for (var c = s.w.config.series.slice(), u = 0; u < c.length; u++)
            if (r[u] !== null && r[u] !== void 0)
              for (var d = 0; d < r[u].data.length; d++) c[u].data.push(r[u].data[d]);
          return s.w.config.series = c, n && (s.w.globals.initialSeries = I.clone(s.w.config.series)), this.update()
        }
      }, {
        key: "update",
        value: function (r) {
          var n = this;
          return new Promise(function (s, c) {
            new _s(n.ctx).clear({
              isUpdating: !0
            });
            var u = n.create(n.w.config.series, r);
            if (!u) return s(n);
            n.mount(u).then(function () {
              typeof n.w.config.chart.events.updated == "function" && n.w.config.chart.events.updated(n, n.w), n.events.fireEvent("updated", [n, n.w]), n.w.globals.isDirty = !0, s(n)
            }).catch(function (d) {
              c(d)
            })
          })
        }
      }, {
        key: "getSyncedCharts",
        value: function () {
          var r = this.getGroupedCharts(),
            n = [this];
          return r.length && (n = [], r.forEach(function (s) {
            n.push(s)
          })), n
        }
      }, {
        key: "getGroupedCharts",
        value: function () {
          var r = this;
          return Apex._chartInstances.filter(function (n) {
            if (n.group) return !0
          }).map(function (n) {
            return r.w.config.chart.group === n.group ? n.chart : r
          })
        }
      }, {
        key: "toggleSeries",
        value: function (r) {
          return this.series.toggleSeries(r)
        }
      }, {
        key: "highlightSeriesOnLegendHover",
        value: function (r, n) {
          return this.series.toggleSeriesOnHover(r, n)
        }
      }, {
        key: "showSeries",
        value: function (r) {
          this.series.showSeries(r)
        }
      }, {
        key: "hideSeries",
        value: function (r) {
          this.series.hideSeries(r)
        }
      }, {
        key: "isSeriesHidden",
        value: function (r) {
          this.series.isSeriesHidden(r)
        }
      }, {
        key: "resetSeries",
        value: function () {
          var r = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0],
            n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
          this.series.resetSeries(r, n)
        }
      }, {
        key: "addEventListener",
        value: function (r, n) {
          this.events.addEventListener(r, n)
        }
      }, {
        key: "removeEventListener",
        value: function (r, n) {
          this.events.removeEventListener(r, n)
        }
      }, {
        key: "addXaxisAnnotation",
        value: function (r) {
          var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
            s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0,
            c = this;
          s && (c = s), c.annotations.addXaxisAnnotationExternal(r, n, c)
        }
      }, {
        key: "addYaxisAnnotation",
        value: function (r) {
          var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
            s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0,
            c = this;
          s && (c = s), c.annotations.addYaxisAnnotationExternal(r, n, c)
        }
      }, {
        key: "addPointAnnotation",
        value: function (r) {
          var n = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1],
            s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0,
            c = this;
          s && (c = s), c.annotations.addPointAnnotationExternal(r, n, c)
        }
      }, {
        key: "clearAnnotations",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0,
            n = this;
          r && (n = r), n.annotations.clearAnnotations(n)
        }
      }, {
        key: "removeAnnotation",
        value: function (r) {
          var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0,
            s = this;
          n && (s = n), s.annotations.removeAnnotation(s, r)
        }
      }, {
        key: "getChartArea",
        value: function () {
          return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
        }
      }, {
        key: "getSeriesTotalXRange",
        value: function (r, n) {
          return this.coreUtils.getSeriesTotalsXRange(r, n)
        }
      }, {
        key: "getHighestValueInSeries",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return new F(this.ctx).getMinYMaxY(r).highestY
        }
      }, {
        key: "getLowestValueInSeries",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          return new F(this.ctx).getMinYMaxY(r).lowestY
        }
      }, {
        key: "getSeriesTotal",
        value: function () {
          return this.w.globals.seriesTotals
        }
      }, {
        key: "toggleDataPointSelection",
        value: function (r, n) {
          return this.updateHelpers.toggleDataPointSelection(r, n)
        }
      }, {
        key: "zoomX",
        value: function (r, n) {
          this.ctx.toolbar.zoomUpdateOptions(r, n)
        }
      }, {
        key: "setLocale",
        value: function (r) {
          this.localization.setCurrentLocaleValues(r)
        }
      }, {
        key: "dataURI",
        value: function (r) {
          return new Xe(this.ctx).dataURI(r)
        }
      }, {
        key: "exportToCSV",
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return new Xe(this.ctx).exportToCSV(r)
        }
      }, {
        key: "paper",
        value: function () {
          return this.w.globals.dom.Paper
        }
      }, {
        key: "_parentResizeCallback",
        value: function () {
          this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
        }
      }, {
        key: "_windowResize",
        value: function () {
          var r = this;
          clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function () {
            r.w.globals.resized = !0, r.w.globals.dataChanged = !1, r.ctx.update()
          }, 150)
        }
      }, {
        key: "_windowResizeHandler",
        value: function () {
          var r = this.w.config.chart.redrawOnWindowResize;
          typeof r == "function" && (r = r()), r && this._windowResize()
        }
      }], [{
        key: "getChartByID",
        value: function (r) {
          var n = I.escapeString(r);
          if (Apex._chartInstances) {
            var s = Apex._chartInstances.filter(function (c) {
              return c.id === n
            })[0];
            return s && s.chart
          }
        }
      }, {
        key: "initOnLoad",
        value: function () {
          for (var r = document.querySelectorAll("[data-apexcharts]"), n = 0; n < r.length; n++) new Y(r[n], JSON.parse(r[n].getAttribute("data-options"))).render()
        }
      }, {
        key: "exec",
        value: function (r, n) {
          var s = this.getChartByID(r);
          if (s) {
            s.w.globals.isExecCalled = !0;
            var c = null;
            if (s.publicMethods.indexOf(n) !== -1) {
              for (var u = arguments.length, d = new Array(u > 2 ? u - 2 : 0), f = 2; f < u; f++) d[f - 2] = arguments[f];
              c = s[n].apply(s, d)
            }
            return c
          }
        }
      }, {
        key: "merge",
        value: function (r, n) {
          return I.extend(r, n)
        }
      }]), Y
    }();
  e.exports = Co
})(_h, _h.exports);
var BC = _h.exports;
const Ug = $C(BC),
  Gg = ["animationEnd", "beforeMount", "mounted", "updated", "click", "mouseMove", "mouseLeave", "legendClick", "markerClick", "selection", "dataPointSelection", "dataPointMouseEnter", "dataPointMouseLeave", "beforeZoom", "beforeResetZoom", "zoomed", "scrolled", "brushScrolled"],
  Rc = Ot({
    name: "apexchart",
    props: {
      options: {
        type: Object
      },
      type: {
        type: String
      },
      series: {
        type: Array,
        required: !0
      },
      width: {
        default: "100%"
      },
      height: {
        default: "auto"
      }
    },
    emits: Gg,
    setup(e, {
      emit: t
    }) {
      const a = _e(null),
        i = _e(null),
        o = fe => fe && typeof fe == "object" && !Array.isArray(fe) && fe != null,
        l = (fe, le) => {
          typeof Object.assign != "function" && function () {
            Object.assign = function (ye) {
              if (ye == null) throw new TypeError("Cannot convert undefined or null to object");
              let ve = Object(ye);
              for (let me = 1; me < arguments.length; me++) {
                let Ae = arguments[me];
                if (Ae != null)
                  for (let He in Ae) Ae.hasOwnProperty(He) && (ve[He] = Ae[He])
              }
              return ve
            }
          }();
          let Ee = Object.assign({}, fe);
          return o(fe) && o(le) && Object.keys(le).forEach(ye => {
            o(le[ye]) ? ye in fe ? Ee[ye] = l(fe[ye], le[ye]) : Object.assign(Ee, {
              [ye]: le[ye]
            }) : Object.assign(Ee, {
              [ye]: le[ye]
            })
          }), Ee
        },
        h = async () => {
          if (await Jt(), i.value) return;
          const fe = {
            chart: {
              type: e.type || e.options.chart.type || "line",
              height: e.height,
              width: e.width,
              events: {}
            },
            series: e.series
          };
          Gg.forEach(Ee => {
            let ye = (...ve) => t(Ee, ...ve);
            fe.chart.events[Ee] = ye
          });
          const le = l(e.options, fe);
          return i.value = new Ug(a.value, le), i.value.render()
        }, p = () => (m(), h()), m = () => {
          i.value.destroy()
        }, k = (fe, le) => i.value.updateSeries(fe, le), w = (fe, le, Ee, ye) => i.value.updateOptions(fe, le, Ee, ye), S = fe => i.value.toggleSeries(fe), A = fe => {
          i.value.showSeries(fe)
        }, E = fe => {
          i.value.hideSeries(fe)
        }, M = (fe, le) => i.value.appendSeries(fe, le), D = () => {
          i.value.resetSeries()
        }, B = (fe, le) => {
          i.value.toggleDataPointSelection(fe, le)
        }, z = fe => i.value.appendData(fe), I = (fe, le) => i.value.zoomX(fe, le), N = fe => i.value.dataURI(fe), U = fe => i.value.setLocale(fe), W = (fe, le) => {
          i.value.addXaxisAnnotation(fe, le)
        }, X = (fe, le) => {
          i.value.addYaxisAnnotation(fe, le)
        }, V = (fe, le) => {
          i.value.addPointAnnotation(fe, le)
        }, ne = (fe, le) => {
          i.value.removeAnnotation(fe, le)
        }, Z = () => {
          i.value.clearAnnotations()
        };
      mf(() => {
        window.ApexCharts = Ug
      }), Dt(() => {
        a.value = hn().proxy.$el, h()
      }), vf(() => {
        i.value && m()
      });
      const ie = Gw(e);
      return Xt(ie.options, () => {
        !i.value && e.options ? h() : i.value.updateOptions(e.options)
      }), Xt(ie.series, () => {
        !i.value && e.series ? h() : i.value.updateSeries(e.series)
      }, {
        deep: !0
      }), Xt(ie.type, () => {
        p()
      }), Xt(ie.width, () => {
        p()
      }), Xt(ie.height, () => {
        p()
      }), {
        chart: i,
        init: h,
        refresh: p,
        destroy: m,
        updateOptions: w,
        updateSeries: k,
        toggleSeries: S,
        showSeries: A,
        hideSeries: E,
        resetSeries: D,
        zoomX: I,
        toggleDataPointSelection: B,
        appendData: z,
        appendSeries: M,
        addXaxisAnnotation: W,
        addYaxisAnnotation: X,
        addPointAnnotation: V,
        removeAnnotation: ne,
        clearAnnotations: Z,
        setLocale: U,
        dataURI: N
      }
    },
    render() {
      return oa("div", {
        class: "vue-apexcharts"
      })
    }
  }),
  HC = e => {
    e.component(Rc.name, Rc)
  };
Rc.install = HC;

function bt(e) {
  const t = Object.prototype.toString.call(e);
  return e instanceof Date || typeof e == "object" && t === "[object Date]" ? new e.constructor(+e) : typeof e == "number" || t === "[object Number]" || typeof e == "string" || t === "[object String]" ? new Date(e) : new Date(NaN)
}

function Zt(e, t) {
  return e instanceof Date ? new e.constructor(t) : new Date(t)
}

function nn(e, t) {
  const a = bt(e);
  return isNaN(t) ? Zt(e, NaN) : (t && a.setDate(a.getDate() + t), a)
}

function cn(e, t) {
  const a = bt(e);
  if (isNaN(t)) return Zt(e, NaN);
  if (!t) return a;
  const i = a.getDate(),
    o = Zt(e, a.getTime());
  o.setMonth(a.getMonth() + t + 1, 0);
  const l = o.getDate();
  return i >= l ? o : (a.setFullYear(o.getFullYear(), o.getMonth(), i), a)
}

function ly(e, t) {
  const {
    years: a = 0,
    months: i = 0,
    weeks: o = 0,
    days: l = 0,
    hours: h = 0,
    minutes: p = 0,
    seconds: m = 0
  } = t, k = bt(e), w = i || a ? cn(k, i + a * 12) : k, S = l || o ? nn(w, l + o * 7) : w, A = p + h * 60, M = (m + A * 60) * 1e3;
  return Zt(e, S.getTime() + M)
}

function YC(e, t) {
  const a = +bt(e);
  return Zt(e, a + t)
}
const cy = 6048e5,
  zC = 864e5,
  XC = 6e4,
  uy = 36e5,
  WC = 1e3;

function VC(e, t) {
  return YC(e, t * uy)
}
let jC = {};

function xs() {
  return jC
}

function pn(e, t) {
  var p, m, k, w;
  const a = xs(),
    i = (t == null ? void 0 : t.weekStartsOn) ?? ((m = (p = t == null ? void 0 : t.locale) == null ? void 0 : p.options) == null ? void 0 : m.weekStartsOn) ?? a.weekStartsOn ?? ((w = (k = a.locale) == null ? void 0 : k.options) == null ? void 0 : w.weekStartsOn) ?? 0,
    o = bt(e),
    l = o.getDay(),
    h = (l < i ? 7 : 0) + l - i;
  return o.setDate(o.getDate() - h), o.setHours(0, 0, 0, 0), o
}

function Qs(e) {
  return pn(e, {
    weekStartsOn: 1
  })
}

function dy(e) {
  const t = bt(e),
    a = t.getFullYear(),
    i = Zt(e, 0);
  i.setFullYear(a + 1, 0, 4), i.setHours(0, 0, 0, 0);
  const o = Qs(i),
    l = Zt(e, 0);
  l.setFullYear(a, 0, 4), l.setHours(0, 0, 0, 0);
  const h = Qs(l);
  return t.getTime() >= o.getTime() ? a + 1 : t.getTime() >= h.getTime() ? a : a - 1
}

function qg(e) {
  const t = bt(e);
  return t.setHours(0, 0, 0, 0), t
}

function Dc(e) {
  const t = bt(e),
    a = new Date(Date.UTC(t.getFullYear(), t.getMonth(), t.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), t.getMilliseconds()));
  return a.setUTCFullYear(t.getFullYear()), +e - +a
}

function hy(e, t) {
  const a = qg(e),
    i = qg(t),
    o = +a - Dc(a),
    l = +i - Dc(i);
  return Math.round((o - l) / zC)
}

function UC(e) {
  const t = dy(e),
    a = Zt(e, 0);
  return a.setFullYear(t, 0, 4), a.setHours(0, 0, 0, 0), Qs(a)
}

function GC(e, t) {
  const a = t * 3;
  return cn(e, a)
}

function If(e, t) {
  return cn(e, t * 12)
}

function Kg(e, t) {
  const a = bt(e),
    i = bt(t),
    o = a.getTime() - i.getTime();
  return o < 0 ? -1 : o > 0 ? 1 : o
}

function fy(e) {
  return e instanceof Date || typeof e == "object" && Object.prototype.toString.call(e) === "[object Date]"
}

function el(e) {
  if (!fy(e) && typeof e != "number") return !1;
  const t = bt(e);
  return !isNaN(Number(t))
}

function Zg(e) {
  const t = bt(e);
  return Math.trunc(t.getMonth() / 3) + 1
}

function qC(e, t) {
  const a = bt(e),
    i = bt(t);
  return a.getFullYear() - i.getFullYear()
}

function KC(e, t) {
  const a = bt(e),
    i = bt(t),
    o = Kg(a, i),
    l = Math.abs(qC(a, i));
  a.setFullYear(1584), i.setFullYear(1584);
  const h = Kg(a, i) === -o,
    p = o * (l - +h);
  return p === 0 ? 0 : p
}

function py(e, t) {
  const a = bt(e.start),
    i = bt(e.end);
  let o = +a > +i;
  const l = o ? +a : +i,
    h = o ? i : a;
  h.setHours(0, 0, 0, 0);
  let p = 1;
  const m = [];
  for (; + h <= l;) m.push(bt(h)), h.setDate(h.getDate() + p), h.setHours(0, 0, 0, 0);
  return o ? m.reverse() : m
}

function ss(e) {
  const t = bt(e),
    a = t.getMonth(),
    i = a - a % 3;
  return t.setMonth(i, 1), t.setHours(0, 0, 0, 0), t
}

function ZC(e, t) {
  const a = bt(e.start),
    i = bt(e.end);
  let o = +a > +i;
  const l = o ? +ss(a) : +ss(i);
  let h = ss(o ? i : a),
    p = 1;
  const m = [];
  for (; + h <= l;) m.push(bt(h)), h = GC(h, p);
  return o ? m.reverse() : m
}

function QC(e) {
  const t = bt(e);
  return t.setDate(1), t.setHours(0, 0, 0, 0), t
}

function gy(e) {
  const t = bt(e),
    a = t.getFullYear();
  return t.setFullYear(a + 1, 0, 0), t.setHours(23, 59, 59, 999), t
}

function gl(e) {
  const t = bt(e),
    a = Zt(e, 0);
  return a.setFullYear(t.getFullYear(), 0, 1), a.setHours(0, 0, 0, 0), a
}

function my(e, t) {
  var p, m, k, w;
  const a = xs(),
    i = (t == null ? void 0 : t.weekStartsOn) ?? ((m = (p = t == null ? void 0 : t.locale) == null ? void 0 : p.options) == null ? void 0 : m.weekStartsOn) ?? a.weekStartsOn ?? ((w = (k = a.locale) == null ? void 0 : k.options) == null ? void 0 : w.weekStartsOn) ?? 0,
    o = bt(e),
    l = o.getDay(),
    h = (l < i ? -7 : 0) + 6 - (l - i);
  return o.setDate(o.getDate() + h), o.setHours(23, 59, 59, 999), o
}

function Qg(e) {
  const t = bt(e),
    a = t.getMonth(),
    i = a - a % 3 + 3;
  return t.setMonth(i, 0), t.setHours(23, 59, 59, 999), t
}
const JC = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  },
  eT = (e, t, a) => {
    let i;
    const o = JC[e];
    return typeof o == "string" ? i = o : t === 1 ? i = o.one : i = o.other.replace("{{count}}", t.toString()), a != null && a.addSuffix ? a.comparison && a.comparison > 0 ? "in " + i : i + " ago" : i
  };

function nd(e) {
  return (t = {}) => {
    const a = t.width ? String(t.width) : e.defaultWidth;
    return e.formats[a] || e.formats[e.defaultWidth]
  }
}
const tT = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  },
  aT = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  },
  rT = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  },
  nT = {
    date: nd({
      formats: tT,
      defaultWidth: "full"
    }),
    time: nd({
      formats: aT,
      defaultWidth: "full"
    }),
    dateTime: nd({
      formats: rT,
      defaultWidth: "full"
    })
  },
  iT = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  },
  sT = (e, t, a, i) => iT[e];

function Io(e) {
  return (t, a) => {
    const i = a != null && a.context ? String(a.context) : "standalone";
    let o;
    if (i === "formatting" && e.formattingValues) {
      const h = e.defaultFormattingWidth || e.defaultWidth,
        p = a != null && a.width ? String(a.width) : h;
      o = e.formattingValues[p] || e.formattingValues[h]
    } else {
      const h = e.defaultWidth,
        p = a != null && a.width ? String(a.width) : e.defaultWidth;
      o = e.values[p] || e.values[h]
    }
    const l = e.argumentCallback ? e.argumentCallback(t) : t;
    return o[l]
  }
}
const oT = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  },
  lT = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  },
  cT = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  },
  uT = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  },
  dT = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  },
  hT = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  },
  fT = (e, t) => {
    const a = Number(e),
      i = a % 100;
    if (i > 20 || i < 10) switch (i % 10) {
      case 1:
        return a + "st";
      case 2:
        return a + "nd";
      case 3:
        return a + "rd"
    }
    return a + "th"
  },
  pT = {
    ordinalNumber: fT,
    era: Io({
      values: oT,
      defaultWidth: "wide"
    }),
    quarter: Io({
      values: lT,
      defaultWidth: "wide",
      argumentCallback: e => e - 1
    }),
    month: Io({
      values: cT,
      defaultWidth: "wide"
    }),
    day: Io({
      values: uT,
      defaultWidth: "wide"
    }),
    dayPeriod: Io({
      values: dT,
      defaultWidth: "wide",
      formattingValues: hT,
      defaultFormattingWidth: "wide"
    })
  };

function Ro(e) {
  return (t, a = {}) => {
    const i = a.width,
      o = i && e.matchPatterns[i] || e.matchPatterns[e.defaultMatchWidth],
      l = t.match(o);
    if (!l) return null;
    const h = l[0],
      p = i && e.parsePatterns[i] || e.parsePatterns[e.defaultParseWidth],
      m = Array.isArray(p) ? mT(p, S => S.test(h)) : gT(p, S => S.test(h));
    let k;
    k = e.valueCallback ? e.valueCallback(m) : m, k = a.valueCallback ? a.valueCallback(k) : k;
    const w = t.slice(h.length);
    return {
      value: k,
      rest: w
    }
  }
}

function gT(e, t) {
  for (const a in e)
    if (Object.prototype.hasOwnProperty.call(e, a) && t(e[a])) return a
}

function mT(e, t) {
  for (let a = 0; a < e.length; a++)
    if (t(e[a])) return a
}

function vT(e) {
  return (t, a = {}) => {
    const i = t.match(e.matchPattern);
    if (!i) return null;
    const o = i[0],
      l = t.match(e.parsePattern);
    if (!l) return null;
    let h = e.valueCallback ? e.valueCallback(l[0]) : l[0];
    h = a.valueCallback ? a.valueCallback(h) : h;
    const p = t.slice(o.length);
    return {
      value: h,
      rest: p
    }
  }
}
const bT = /^(\d+)(th|st|nd|rd)?/i,
  yT = /\d+/i,
  xT = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  },
  wT = {
    any: [/^b/i, /^(a|c)/i]
  },
  kT = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  },
  _T = {
    any: [/1/i, /2/i, /3/i, /4/i]
  },
  ST = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  },
  AT = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  },
  CT = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  },
  TT = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  },
  ET = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  },
  PT = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  },
  LT = {
    ordinalNumber: vT({
      matchPattern: bT,
      parsePattern: yT,
      valueCallback: e => parseInt(e, 10)
    }),
    era: Ro({
      matchPatterns: xT,
      defaultMatchWidth: "wide",
      parsePatterns: wT,
      defaultParseWidth: "any"
    }),
    quarter: Ro({
      matchPatterns: kT,
      defaultMatchWidth: "wide",
      parsePatterns: _T,
      defaultParseWidth: "any",
      valueCallback: e => e + 1
    }),
    month: Ro({
      matchPatterns: ST,
      defaultMatchWidth: "wide",
      parsePatterns: AT,
      defaultParseWidth: "any"
    }),
    day: Ro({
      matchPatterns: CT,
      defaultMatchWidth: "wide",
      parsePatterns: TT,
      defaultParseWidth: "any"
    }),
    dayPeriod: Ro({
      matchPatterns: ET,
      defaultMatchWidth: "any",
      parsePatterns: PT,
      defaultParseWidth: "any"
    })
  },
  vy = {
    code: "en-US",
    formatDistance: eT,
    formatLong: nT,
    formatRelative: sT,
    localize: pT,
    match: LT,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };

function OT(e) {
  const t = bt(e);
  return hy(t, gl(t)) + 1
}

function Rf(e) {
  const t = bt(e),
    a = +Qs(t) - +UC(t);
  return Math.round(a / cy) + 1
}

function Df(e, t) {
  var w, S, A, E;
  const a = bt(e),
    i = a.getFullYear(),
    o = xs(),
    l = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((S = (w = t == null ? void 0 : t.locale) == null ? void 0 : w.options) == null ? void 0 : S.firstWeekContainsDate) ?? o.firstWeekContainsDate ?? ((E = (A = o.locale) == null ? void 0 : A.options) == null ? void 0 : E.firstWeekContainsDate) ?? 1,
    h = Zt(e, 0);
  h.setFullYear(i + 1, 0, l), h.setHours(0, 0, 0, 0);
  const p = pn(h, t),
    m = Zt(e, 0);
  m.setFullYear(i, 0, l), m.setHours(0, 0, 0, 0);
  const k = pn(m, t);
  return a.getTime() >= p.getTime() ? i + 1 : a.getTime() >= k.getTime() ? i : i - 1
}

function MT(e, t) {
  var p, m, k, w;
  const a = xs(),
    i = (t == null ? void 0 : t.firstWeekContainsDate) ?? ((m = (p = t == null ? void 0 : t.locale) == null ? void 0 : p.options) == null ? void 0 : m.firstWeekContainsDate) ?? a.firstWeekContainsDate ?? ((w = (k = a.locale) == null ? void 0 : k.options) == null ? void 0 : w.firstWeekContainsDate) ?? 1,
    o = Df(e, t),
    l = Zt(e, 0);
  return l.setFullYear(o, 0, i), l.setHours(0, 0, 0, 0), pn(l, t)
}

function Nf(e, t) {
  const a = bt(e),
    i = +pn(a, t) - +MT(a, t);
  return Math.round(i / cy) + 1
}

function ra(e, t) {
  const a = e < 0 ? "-" : "",
    i = Math.abs(e).toString().padStart(t, "0");
  return a + i
}
const ci = {
    y(e, t) {
      const a = e.getFullYear(),
        i = a > 0 ? a : 1 - a;
      return ra(t === "yy" ? i % 100 : i, t.length)
    },
    M(e, t) {
      const a = e.getMonth();
      return t === "M" ? String(a + 1) : ra(a + 1, 2)
    },
    d(e, t) {
      return ra(e.getDate(), t.length)
    },
    a(e, t) {
      const a = e.getHours() / 12 >= 1 ? "pm" : "am";
      switch (t) {
        case "a":
        case "aa":
          return a.toUpperCase();
        case "aaa":
          return a;
        case "aaaaa":
          return a[0];
        case "aaaa":
        default:
          return a === "am" ? "a.m." : "p.m."
      }
    },
    h(e, t) {
      return ra(e.getHours() % 12 || 12, t.length)
    },
    H(e, t) {
      return ra(e.getHours(), t.length)
    },
    m(e, t) {
      return ra(e.getMinutes(), t.length)
    },
    s(e, t) {
      return ra(e.getSeconds(), t.length)
    },
    S(e, t) {
      const a = t.length,
        i = e.getMilliseconds(),
        o = Math.trunc(i * Math.pow(10, a - 3));
      return ra(o, t.length)
    }
  },
  Ts = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  Jg = {
    G: function (e, t, a) {
      const i = e.getFullYear() > 0 ? 1 : 0;
      switch (t) {
        case "G":
        case "GG":
        case "GGG":
          return a.era(i, {
            width: "abbreviated"
          });
        case "GGGGG":
          return a.era(i, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return a.era(i, {
            width: "wide"
          })
      }
    },
    y: function (e, t, a) {
      if (t === "yo") {
        const i = e.getFullYear(),
          o = i > 0 ? i : 1 - i;
        return a.ordinalNumber(o, {
          unit: "year"
        })
      }
      return ci.y(e, t)
    },
    Y: function (e, t, a, i) {
      const o = Df(e, i),
        l = o > 0 ? o : 1 - o;
      if (t === "YY") {
        const h = l % 100;
        return ra(h, 2)
      }
      return t === "Yo" ? a.ordinalNumber(l, {
        unit: "year"
      }) : ra(l, t.length)
    },
    R: function (e, t) {
      const a = dy(e);
      return ra(a, t.length)
    },
    u: function (e, t) {
      const a = e.getFullYear();
      return ra(a, t.length)
    },
    Q: function (e, t, a) {
      const i = Math.ceil((e.getMonth() + 1) / 3);
      switch (t) {
        case "Q":
          return String(i);
        case "QQ":
          return ra(i, 2);
        case "Qo":
          return a.ordinalNumber(i, {
            unit: "quarter"
          });
        case "QQQ":
          return a.quarter(i, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return a.quarter(i, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return a.quarter(i, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    q: function (e, t, a) {
      const i = Math.ceil((e.getMonth() + 1) / 3);
      switch (t) {
        case "q":
          return String(i);
        case "qq":
          return ra(i, 2);
        case "qo":
          return a.ordinalNumber(i, {
            unit: "quarter"
          });
        case "qqq":
          return a.quarter(i, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return a.quarter(i, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return a.quarter(i, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    M: function (e, t, a) {
      const i = e.getMonth();
      switch (t) {
        case "M":
        case "MM":
          return ci.M(e, t);
        case "Mo":
          return a.ordinalNumber(i + 1, {
            unit: "month"
          });
        case "MMM":
          return a.month(i, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return a.month(i, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return a.month(i, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    L: function (e, t, a) {
      const i = e.getMonth();
      switch (t) {
        case "L":
          return String(i + 1);
        case "LL":
          return ra(i + 1, 2);
        case "Lo":
          return a.ordinalNumber(i + 1, {
            unit: "month"
          });
        case "LLL":
          return a.month(i, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return a.month(i, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return a.month(i, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    w: function (e, t, a, i) {
      const o = Nf(e, i);
      return t === "wo" ? a.ordinalNumber(o, {
        unit: "week"
      }) : ra(o, t.length)
    },
    I: function (e, t, a) {
      const i = Rf(e);
      return t === "Io" ? a.ordinalNumber(i, {
        unit: "week"
      }) : ra(i, t.length)
    },
    d: function (e, t, a) {
      return t === "do" ? a.ordinalNumber(e.getDate(), {
        unit: "date"
      }) : ci.d(e, t)
    },
    D: function (e, t, a) {
      const i = OT(e);
      return t === "Do" ? a.ordinalNumber(i, {
        unit: "dayOfYear"
      }) : ra(i, t.length)
    },
    E: function (e, t, a) {
      const i = e.getDay();
      switch (t) {
        case "E":
        case "EE":
        case "EEE":
          return a.day(i, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return a.day(i, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return a.day(i, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return a.day(i, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    e: function (e, t, a, i) {
      const o = e.getDay(),
        l = (o - i.weekStartsOn + 8) % 7 || 7;
      switch (t) {
        case "e":
          return String(l);
        case "ee":
          return ra(l, 2);
        case "eo":
          return a.ordinalNumber(l, {
            unit: "day"
          });
        case "eee":
          return a.day(o, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return a.day(o, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return a.day(o, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return a.day(o, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    c: function (e, t, a, i) {
      const o = e.getDay(),
        l = (o - i.weekStartsOn + 8) % 7 || 7;
      switch (t) {
        case "c":
          return String(l);
        case "cc":
          return ra(l, t.length);
        case "co":
          return a.ordinalNumber(l, {
            unit: "day"
          });
        case "ccc":
          return a.day(o, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return a.day(o, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return a.day(o, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return a.day(o, {
            width: "wide",
            context: "standalone"
          })
      }
    },
    i: function (e, t, a) {
      const i = e.getDay(),
        o = i === 0 ? 7 : i;
      switch (t) {
        case "i":
          return String(o);
        case "ii":
          return ra(o, t.length);
        case "io":
          return a.ordinalNumber(o, {
            unit: "day"
          });
        case "iii":
          return a.day(i, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return a.day(i, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return a.day(i, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return a.day(i, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    a: function (e, t, a) {
      const o = e.getHours() / 12 >= 1 ? "pm" : "am";
      switch (t) {
        case "a":
        case "aa":
          return a.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return a.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return a.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return a.dayPeriod(o, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    b: function (e, t, a) {
      const i = e.getHours();
      let o;
      switch (i === 12 ? o = Ts.noon : i === 0 ? o = Ts.midnight : o = i / 12 >= 1 ? "pm" : "am", t) {
        case "b":
        case "bb":
          return a.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return a.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return a.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return a.dayPeriod(o, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    B: function (e, t, a) {
      const i = e.getHours();
      let o;
      switch (i >= 17 ? o = Ts.evening : i >= 12 ? o = Ts.afternoon : i >= 4 ? o = Ts.morning : o = Ts.night, t) {
        case "B":
        case "BB":
        case "BBB":
          return a.dayPeriod(o, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return a.dayPeriod(o, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return a.dayPeriod(o, {
            width: "wide",
            context: "formatting"
          })
      }
    },
    h: function (e, t, a) {
      if (t === "ho") {
        let i = e.getHours() % 12;
        return i === 0 && (i = 12), a.ordinalNumber(i, {
          unit: "hour"
        })
      }
      return ci.h(e, t)
    },
    H: function (e, t, a) {
      return t === "Ho" ? a.ordinalNumber(e.getHours(), {
        unit: "hour"
      }) : ci.H(e, t)
    },
    K: function (e, t, a) {
      const i = e.getHours() % 12;
      return t === "Ko" ? a.ordinalNumber(i, {
        unit: "hour"
      }) : ra(i, t.length)
    },
    k: function (e, t, a) {
      let i = e.getHours();
      return i === 0 && (i = 24), t === "ko" ? a.ordinalNumber(i, {
        unit: "hour"
      }) : ra(i, t.length)
    },
    m: function (e, t, a) {
      return t === "mo" ? a.ordinalNumber(e.getMinutes(), {
        unit: "minute"
      }) : ci.m(e, t)
    },
    s: function (e, t, a) {
      return t === "so" ? a.ordinalNumber(e.getSeconds(), {
        unit: "second"
      }) : ci.s(e, t)
    },
    S: function (e, t) {
      return ci.S(e, t)
    },
    X: function (e, t, a) {
      const i = e.getTimezoneOffset();
      if (i === 0) return "Z";
      switch (t) {
        case "X":
          return tm(i);
        case "XXXX":
        case "XX":
          return Qi(i);
        case "XXXXX":
        case "XXX":
        default:
          return Qi(i, ":")
      }
    },
    x: function (e, t, a) {
      const i = e.getTimezoneOffset();
      switch (t) {
        case "x":
          return tm(i);
        case "xxxx":
        case "xx":
          return Qi(i);
        case "xxxxx":
        case "xxx":
        default:
          return Qi(i, ":")
      }
    },
    O: function (e, t, a) {
      const i = e.getTimezoneOffset();
      switch (t) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + em(i, ":");
        case "OOOO":
        default:
          return "GMT" + Qi(i, ":")
      }
    },
    z: function (e, t, a) {
      const i = e.getTimezoneOffset();
      switch (t) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + em(i, ":");
        case "zzzz":
        default:
          return "GMT" + Qi(i, ":")
      }
    },
    t: function (e, t, a) {
      const i = Math.trunc(e.getTime() / 1e3);
      return ra(i, t.length)
    },
    T: function (e, t, a) {
      const i = e.getTime();
      return ra(i, t.length)
    }
  };

function em(e, t = "") {
  const a = e > 0 ? "-" : "+",
    i = Math.abs(e),
    o = Math.trunc(i / 60),
    l = i % 60;
  return l === 0 ? a + String(o) : a + String(o) + t + ra(l, 2)
}

function tm(e, t) {
  return e % 60 === 0 ? (e > 0 ? "-" : "+") + ra(Math.abs(e) / 60, 2) : Qi(e, t)
}

function Qi(e, t = "") {
  const a = e > 0 ? "-" : "+",
    i = Math.abs(e),
    o = ra(Math.trunc(i / 60), 2),
    l = ra(i % 60, 2);
  return a + o + t + l
}
const am = (e, t) => {
    switch (e) {
      case "P":
        return t.date({
          width: "short"
        });
      case "PP":
        return t.date({
          width: "medium"
        });
      case "PPP":
        return t.date({
          width: "long"
        });
      case "PPPP":
      default:
        return t.date({
          width: "full"
        })
    }
  },
  by = (e, t) => {
    switch (e) {
      case "p":
        return t.time({
          width: "short"
        });
      case "pp":
        return t.time({
          width: "medium"
        });
      case "ppp":
        return t.time({
          width: "long"
        });
      case "pppp":
      default:
        return t.time({
          width: "full"
        })
    }
  },
  IT = (e, t) => {
    const a = e.match(/(P+)(p+)?/) || [],
      i = a[1],
      o = a[2];
    if (!o) return am(e, t);
    let l;
    switch (i) {
      case "P":
        l = t.dateTime({
          width: "short"
        });
        break;
      case "PP":
        l = t.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        l = t.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        l = t.dateTime({
          width: "full"
        });
        break
    }
    return l.replace("{{date}}", am(i, t)).replace("{{time}}", by(o, t))
  },
  Sh = {
    p: by,
    P: IT
  },
  RT = /^D+$/,
  DT = /^Y+$/,
  NT = ["D", "DD", "YY", "YYYY"];

function yy(e) {
  return RT.test(e)
}

function xy(e) {
  return DT.test(e)
}

function Ah(e, t, a) {
  const i = FT(e, t, a);
  if (console.warn(i), NT.includes(e)) throw new RangeError(i)
}

function FT(e, t, a) {
  const i = e[0] === "Y" ? "years" : "days of the month";
  return `Use \`${e.toLowerCase()}\` instead of \`${e}\` (in \`${t}\`) for formatting ${i} to the input \`${a}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`
}
const $T = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
  BT = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
  HT = /^'([^]*?)'?$/,
  YT = /''/g,
  zT = /[a-zA-Z]/;

function On(e, t, a) {
  var w, S, A, E, M, D, B, z;
  const i = xs(),
    o = (a == null ? void 0 : a.locale) ?? i.locale ?? vy,
    l = (a == null ? void 0 : a.firstWeekContainsDate) ?? ((S = (w = a == null ? void 0 : a.locale) == null ? void 0 : w.options) == null ? void 0 : S.firstWeekContainsDate) ?? i.firstWeekContainsDate ?? ((E = (A = i.locale) == null ? void 0 : A.options) == null ? void 0 : E.firstWeekContainsDate) ?? 1,
    h = (a == null ? void 0 : a.weekStartsOn) ?? ((D = (M = a == null ? void 0 : a.locale) == null ? void 0 : M.options) == null ? void 0 : D.weekStartsOn) ?? i.weekStartsOn ?? ((z = (B = i.locale) == null ? void 0 : B.options) == null ? void 0 : z.weekStartsOn) ?? 0,
    p = bt(e);
  if (!el(p)) throw new RangeError("Invalid time value");
  let m = t.match(BT).map(I => {
    const N = I[0];
    if (N === "p" || N === "P") {
      const U = Sh[N];
      return U(I, o.formatLong)
    }
    return I
  }).join("").match($T).map(I => {
    if (I === "''") return {
      isToken: !1,
      value: "'"
    };
    const N = I[0];
    if (N === "'") return {
      isToken: !1,
      value: XT(I)
    };
    if (Jg[N]) return {
      isToken: !0,
      value: I
    };
    if (N.match(zT)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + N + "`");
    return {
      isToken: !1,
      value: I
    }
  });
  o.localize.preprocessor && (m = o.localize.preprocessor(p, m));
  const k = {
    firstWeekContainsDate: l,
    weekStartsOn: h,
    locale: o
  };
  return m.map(I => {
    if (!I.isToken) return I.value;
    const N = I.value;
    (!(a != null && a.useAdditionalWeekYearTokens) && xy(N) || !(a != null && a.useAdditionalDayOfYearTokens) && yy(N)) && Ah(N, t, String(e));
    const U = Jg[N[0]];
    return U(p, N, o.localize, k)
  }).join("")
}

function XT(e) {
  const t = e.match(HT);
  return t ? t[1].replace(YT, "'") : e
}

function WT(e) {
  return bt(e).getDay()
}

function VT(e) {
  const t = bt(e),
    a = t.getFullYear(),
    i = t.getMonth(),
    o = Zt(e, 0);
  return o.setFullYear(a, i + 1, 0), o.setHours(0, 0, 0, 0), o.getDate()
}

function jT() {
  return Object.assign({}, xs())
}

function Kn(e) {
  return bt(e).getHours()
}

function UT(e) {
  let a = bt(e).getDay();
  return a === 0 && (a = 7), a
}

function Ti(e) {
  return bt(e).getMinutes()
}

function zt(e) {
  return bt(e).getMonth()
}

function Js(e) {
  return bt(e).getSeconds()
}

function Tt(e) {
  return bt(e).getFullYear()
}

function eo(e, t) {
  const a = bt(e),
    i = bt(t);
  return a.getTime() > i.getTime()
}

function ml(e, t) {
  const a = bt(e),
    i = bt(t);
  return +a < +i
}

function Hs(e, t) {
  const a = bt(e),
    i = bt(t);
  return +a == +i
}

function GT(e, t) {
  const a = t instanceof Date ? Zt(t, 0) : new t(0);
  return a.setFullYear(e.getFullYear(), e.getMonth(), e.getDate()), a.setHours(e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()), a
}
const qT = 10;
class wy {
  constructor() {
    pt(this, "subPriority", 0)
  }
  validate(t, a) {
    return !0
  }
}
class KT extends wy {
  constructor(t, a, i, o, l) {
    super(), this.value = t, this.validateValue = a, this.setValue = i, this.priority = o, l && (this.subPriority = l)
  }
  validate(t, a) {
    return this.validateValue(t, this.value, a)
  }
  set(t, a, i) {
    return this.setValue(t, a, this.value, i)
  }
}
class ZT extends wy {
  constructor() {
    super(...arguments);
    pt(this, "priority", qT);
    pt(this, "subPriority", -1)
  }
  set(a, i) {
    return i.timestampIsSet ? a : Zt(a, GT(a, Date))
  }
}
class ea {
  run(t, a, i, o) {
    const l = this.parse(t, a, i, o);
    return l ? {
      setter: new KT(l.value, this.validate, this.set, this.priority, this.subPriority),
      rest: l.rest
    } : null
  }
  validate(t, a, i) {
    return !0
  }
}
class QT extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 140);
    pt(this, "incompatibleTokens", ["R", "u", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "G":
      case "GG":
      case "GGG":
        return o.era(a, {
          width: "abbreviated"
        }) || o.era(a, {
          width: "narrow"
        });
      case "GGGGG":
        return o.era(a, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return o.era(a, {
          width: "wide"
        }) || o.era(a, {
          width: "abbreviated"
        }) || o.era(a, {
          width: "narrow"
        })
    }
  }
  set(a, i, o) {
    return i.era = o, a.setFullYear(o, 0, 1), a.setHours(0, 0, 0, 0), a
  }
}
const Da = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
  },
  Cn = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };

function Na(e, t) {
  return e && {
    value: t(e.value),
    rest: e.rest
  }
}

function Aa(e, t) {
  const a = t.match(e);
  return a ? {
    value: parseInt(a[0], 10),
    rest: t.slice(a[0].length)
  } : null
}

function Tn(e, t) {
  const a = t.match(e);
  if (!a) return null;
  if (a[0] === "Z") return {
    value: 0,
    rest: t.slice(1)
  };
  const i = a[1] === "+" ? 1 : -1,
    o = a[2] ? parseInt(a[2], 10) : 0,
    l = a[3] ? parseInt(a[3], 10) : 0,
    h = a[5] ? parseInt(a[5], 10) : 0;
  return {
    value: i * (o * uy + l * XC + h * WC),
    rest: t.slice(a[0].length)
  }
}

function ky(e) {
  return Aa(Da.anyDigitsSigned, e)
}

function La(e, t) {
  switch (e) {
    case 1:
      return Aa(Da.singleDigit, t);
    case 2:
      return Aa(Da.twoDigits, t);
    case 3:
      return Aa(Da.threeDigits, t);
    case 4:
      return Aa(Da.fourDigits, t);
    default:
      return Aa(new RegExp("^\\d{1," + e + "}"), t)
  }
}

function Nc(e, t) {
  switch (e) {
    case 1:
      return Aa(Da.singleDigitSigned, t);
    case 2:
      return Aa(Da.twoDigitsSigned, t);
    case 3:
      return Aa(Da.threeDigitsSigned, t);
    case 4:
      return Aa(Da.fourDigitsSigned, t);
    default:
      return Aa(new RegExp("^-?\\d{1," + e + "}"), t)
  }
}

function Ff(e) {
  switch (e) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0
  }
}

function _y(e, t) {
  const a = t > 0,
    i = a ? t : 1 - t;
  let o;
  if (i <= 50) o = e || 100;
  else {
    const l = i + 50,
      h = Math.trunc(l / 100) * 100,
      p = e >= l % 100;
    o = e + h - (p ? 100 : 0)
  }
  return a ? o : 1 - o
}

function Sy(e) {
  return e % 400 === 0 || e % 4 === 0 && e % 100 !== 0
}
class JT extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 130);
    pt(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    const l = h => ({
      year: h,
      isTwoDigitYear: i === "yy"
    });
    switch (i) {
      case "y":
        return Na(La(4, a), l);
      case "yo":
        return Na(o.ordinalNumber(a, {
          unit: "year"
        }), l);
      default:
        return Na(La(i.length, a), l)
    }
  }
  validate(a, i) {
    return i.isTwoDigitYear || i.year > 0
  }
  set(a, i, o) {
    const l = a.getFullYear();
    if (o.isTwoDigitYear) {
      const p = _y(o.year, l);
      return a.setFullYear(p, 0, 1), a.setHours(0, 0, 0, 0), a
    }
    const h = !("era" in i) || i.era === 1 ? o.year : 1 - o.year;
    return a.setFullYear(h, 0, 1), a.setHours(0, 0, 0, 0), a
  }
}
class eE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 130);
    pt(this, "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"])
  }
  parse(a, i, o) {
    const l = h => ({
      year: h,
      isTwoDigitYear: i === "YY"
    });
    switch (i) {
      case "Y":
        return Na(La(4, a), l);
      case "Yo":
        return Na(o.ordinalNumber(a, {
          unit: "year"
        }), l);
      default:
        return Na(La(i.length, a), l)
    }
  }
  validate(a, i) {
    return i.isTwoDigitYear || i.year > 0
  }
  set(a, i, o, l) {
    const h = Df(a, l);
    if (o.isTwoDigitYear) {
      const m = _y(o.year, h);
      return a.setFullYear(m, 0, l.firstWeekContainsDate), a.setHours(0, 0, 0, 0), pn(a, l)
    }
    const p = !("era" in i) || i.era === 1 ? o.year : 1 - o.year;
    return a.setFullYear(p, 0, l.firstWeekContainsDate), a.setHours(0, 0, 0, 0), pn(a, l)
  }
}
class tE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 130);
    pt(this, "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"])
  }
  parse(a, i) {
    return Nc(i === "R" ? 4 : i.length, a)
  }
  set(a, i, o) {
    const l = Zt(a, 0);
    return l.setFullYear(o, 0, 4), l.setHours(0, 0, 0, 0), Qs(l)
  }
}
class aE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 130);
    pt(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"])
  }
  parse(a, i) {
    return Nc(i === "u" ? 4 : i.length, a)
  }
  set(a, i, o) {
    return a.setFullYear(o, 0, 1), a.setHours(0, 0, 0, 0), a
  }
}
class rE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 120);
    pt(this, "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "Q":
      case "QQ":
        return La(i.length, a);
      case "Qo":
        return o.ordinalNumber(a, {
          unit: "quarter"
        });
      case "QQQ":
        return o.quarter(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.quarter(a, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return o.quarter(a, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return o.quarter(a, {
          width: "wide",
          context: "formatting"
        }) || o.quarter(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.quarter(a, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  validate(a, i) {
    return i >= 1 && i <= 4
  }
  set(a, i, o) {
    return a.setMonth((o - 1) * 3, 1), a.setHours(0, 0, 0, 0), a
  }
}
class nE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 120);
    pt(this, "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "q":
      case "qq":
        return La(i.length, a);
      case "qo":
        return o.ordinalNumber(a, {
          unit: "quarter"
        });
      case "qqq":
        return o.quarter(a, {
          width: "abbreviated",
          context: "standalone"
        }) || o.quarter(a, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return o.quarter(a, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return o.quarter(a, {
          width: "wide",
          context: "standalone"
        }) || o.quarter(a, {
          width: "abbreviated",
          context: "standalone"
        }) || o.quarter(a, {
          width: "narrow",
          context: "standalone"
        })
    }
  }
  validate(a, i) {
    return i >= 1 && i <= 4
  }
  set(a, i, o) {
    return a.setMonth((o - 1) * 3, 1), a.setHours(0, 0, 0, 0), a
  }
}
class iE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    pt(this, "priority", 110)
  }
  parse(a, i, o) {
    const l = h => h - 1;
    switch (i) {
      case "M":
        return Na(Aa(Da.month, a), l);
      case "MM":
        return Na(La(2, a), l);
      case "Mo":
        return Na(o.ordinalNumber(a, {
          unit: "month"
        }), l);
      case "MMM":
        return o.month(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.month(a, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMMM":
        return o.month(a, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return o.month(a, {
          width: "wide",
          context: "formatting"
        }) || o.month(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.month(a, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 11
  }
  set(a, i, o) {
    return a.setMonth(o, 1), a.setHours(0, 0, 0, 0), a
  }
}
class sE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 110);
    pt(this, "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    const l = h => h - 1;
    switch (i) {
      case "L":
        return Na(Aa(Da.month, a), l);
      case "LL":
        return Na(La(2, a), l);
      case "Lo":
        return Na(o.ordinalNumber(a, {
          unit: "month"
        }), l);
      case "LLL":
        return o.month(a, {
          width: "abbreviated",
          context: "standalone"
        }) || o.month(a, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLLL":
        return o.month(a, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return o.month(a, {
          width: "wide",
          context: "standalone"
        }) || o.month(a, {
          width: "abbreviated",
          context: "standalone"
        }) || o.month(a, {
          width: "narrow",
          context: "standalone"
        })
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 11
  }
  set(a, i, o) {
    return a.setMonth(o, 1), a.setHours(0, 0, 0, 0), a
  }
}

function oE(e, t, a) {
  const i = bt(e),
    o = Nf(i, a) - t;
  return i.setDate(i.getDate() - o * 7), i
}
class lE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 100);
    pt(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "w":
        return Aa(Da.week, a);
      case "wo":
        return o.ordinalNumber(a, {
          unit: "week"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    return i >= 1 && i <= 53
  }
  set(a, i, o, l) {
    return pn(oE(a, o, l), l)
  }
}

function cE(e, t) {
  const a = bt(e),
    i = Rf(a) - t;
  return a.setDate(a.getDate() - i * 7), a
}
class uE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 100);
    pt(this, "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "I":
        return Aa(Da.week, a);
      case "Io":
        return o.ordinalNumber(a, {
          unit: "week"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    return i >= 1 && i <= 53
  }
  set(a, i, o) {
    return Qs(cE(a, o))
  }
}
const dE = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  hE = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
class fE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 90);
    pt(this, "subPriority", 1);
    pt(this, "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "d":
        return Aa(Da.date, a);
      case "do":
        return o.ordinalNumber(a, {
          unit: "date"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    const o = a.getFullYear(),
      l = Sy(o),
      h = a.getMonth();
    return l ? i >= 1 && i <= hE[h] : i >= 1 && i <= dE[h]
  }
  set(a, i, o) {
    return a.setDate(o), a.setHours(0, 0, 0, 0), a
  }
}
class pE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 90);
    pt(this, "subpriority", 1);
    pt(this, "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "D":
      case "DD":
        return Aa(Da.dayOfYear, a);
      case "Do":
        return o.ordinalNumber(a, {
          unit: "date"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    const o = a.getFullYear();
    return Sy(o) ? i >= 1 && i <= 366 : i >= 1 && i <= 365
  }
  set(a, i, o) {
    return a.setMonth(0, o), a.setHours(0, 0, 0, 0), a
  }
}

function $f(e, t, a) {
  var S, A, E, M;
  const i = xs(),
    o = (a == null ? void 0 : a.weekStartsOn) ?? ((A = (S = a == null ? void 0 : a.locale) == null ? void 0 : S.options) == null ? void 0 : A.weekStartsOn) ?? i.weekStartsOn ?? ((M = (E = i.locale) == null ? void 0 : E.options) == null ? void 0 : M.weekStartsOn) ?? 0,
    l = bt(e),
    h = l.getDay(),
    m = (t % 7 + 7) % 7,
    k = 7 - o,
    w = t < 0 || t > 6 ? t - (h + k) % 7 : (m + k) % 7 - (h + k) % 7;
  return nn(l, w)
}
class gE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 90);
    pt(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "E":
      case "EE":
      case "EEE":
        return o.day(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEE":
        return o.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEE":
      default:
        return o.day(a, {
          width: "wide",
          context: "formatting"
        }) || o.day(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 6
  }
  set(a, i, o, l) {
    return a = $f(a, o, l), a.setHours(0, 0, 0, 0), a
  }
}
class mE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 90);
    pt(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"])
  }
  parse(a, i, o, l) {
    const h = p => {
      const m = Math.floor((p - 1) / 7) * 7;
      return (p + l.weekStartsOn + 6) % 7 + m
    };
    switch (i) {
      case "e":
      case "ee":
        return Na(La(i.length, a), h);
      case "eo":
        return Na(o.ordinalNumber(a, {
          unit: "day"
        }), h);
      case "eee":
        return o.day(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeee":
        return o.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        });
      case "eeee":
      default:
        return o.day(a, {
          width: "wide",
          context: "formatting"
        }) || o.day(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 6
  }
  set(a, i, o, l) {
    return a = $f(a, o, l), a.setHours(0, 0, 0, 0), a
  }
}
class vE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 90);
    pt(this, "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"])
  }
  parse(a, i, o, l) {
    const h = p => {
      const m = Math.floor((p - 1) / 7) * 7;
      return (p + l.weekStartsOn + 6) % 7 + m
    };
    switch (i) {
      case "c":
      case "cc":
        return Na(La(i.length, a), h);
      case "co":
        return Na(o.ordinalNumber(a, {
          unit: "day"
        }), h);
      case "ccc":
        return o.day(a, {
          width: "abbreviated",
          context: "standalone"
        }) || o.day(a, {
          width: "short",
          context: "standalone"
        }) || o.day(a, {
          width: "narrow",
          context: "standalone"
        });
      case "ccccc":
        return o.day(a, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return o.day(a, {
          width: "short",
          context: "standalone"
        }) || o.day(a, {
          width: "narrow",
          context: "standalone"
        });
      case "cccc":
      default:
        return o.day(a, {
          width: "wide",
          context: "standalone"
        }) || o.day(a, {
          width: "abbreviated",
          context: "standalone"
        }) || o.day(a, {
          width: "short",
          context: "standalone"
        }) || o.day(a, {
          width: "narrow",
          context: "standalone"
        })
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 6
  }
  set(a, i, o, l) {
    return a = $f(a, o, l), a.setHours(0, 0, 0, 0), a
  }
}

function bE(e, t) {
  const a = bt(e),
    i = UT(a),
    o = t - i;
  return nn(a, o)
}
class yE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 90);
    pt(this, "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"])
  }
  parse(a, i, o) {
    const l = h => h === 0 ? 7 : h;
    switch (i) {
      case "i":
      case "ii":
        return La(i.length, a);
      case "io":
        return o.ordinalNumber(a, {
          unit: "day"
        });
      case "iii":
        return Na(o.day(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        }), l);
      case "iiiii":
        return Na(o.day(a, {
          width: "narrow",
          context: "formatting"
        }), l);
      case "iiiiii":
        return Na(o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        }), l);
      case "iiii":
      default:
        return Na(o.day(a, {
          width: "wide",
          context: "formatting"
        }) || o.day(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.day(a, {
          width: "short",
          context: "formatting"
        }) || o.day(a, {
          width: "narrow",
          context: "formatting"
        }), l)
    }
  }
  validate(a, i) {
    return i >= 1 && i <= 7
  }
  set(a, i, o) {
    return a = bE(a, o), a.setHours(0, 0, 0, 0), a
  }
}
class xE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 80);
    pt(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "a":
      case "aa":
      case "aaa":
        return o.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return o.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  set(a, i, o) {
    return a.setHours(Ff(o), 0, 0, 0), a
  }
}
class wE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 80);
    pt(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "b":
      case "bb":
      case "bbb":
        return o.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return o.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  set(a, i, o) {
    return a.setHours(Ff(o), 0, 0, 0), a
  }
}
class kE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 80);
    pt(this, "incompatibleTokens", ["a", "b", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "B":
      case "BB":
      case "BBB":
        return o.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return o.dayPeriod(a, {
          width: "wide",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "abbreviated",
          context: "formatting"
        }) || o.dayPeriod(a, {
          width: "narrow",
          context: "formatting"
        })
    }
  }
  set(a, i, o) {
    return a.setHours(Ff(o), 0, 0, 0), a
  }
}
class _E extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 70);
    pt(this, "incompatibleTokens", ["H", "K", "k", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "h":
        return Aa(Da.hour12h, a);
      case "ho":
        return o.ordinalNumber(a, {
          unit: "hour"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    return i >= 1 && i <= 12
  }
  set(a, i, o) {
    const l = a.getHours() >= 12;
    return l && o < 12 ? a.setHours(o + 12, 0, 0, 0) : !l && o === 12 ? a.setHours(0, 0, 0, 0) : a.setHours(o, 0, 0, 0), a
  }
}
class SE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 70);
    pt(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "H":
        return Aa(Da.hour23h, a);
      case "Ho":
        return o.ordinalNumber(a, {
          unit: "hour"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 23
  }
  set(a, i, o) {
    return a.setHours(o, 0, 0, 0), a
  }
}
class AE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 70);
    pt(this, "incompatibleTokens", ["h", "H", "k", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "K":
        return Aa(Da.hour11h, a);
      case "Ko":
        return o.ordinalNumber(a, {
          unit: "hour"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 11
  }
  set(a, i, o) {
    return a.getHours() >= 12 && o < 12 ? a.setHours(o + 12, 0, 0, 0) : a.setHours(o, 0, 0, 0), a
  }
}
class CE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 70);
    pt(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "k":
        return Aa(Da.hour24h, a);
      case "ko":
        return o.ordinalNumber(a, {
          unit: "hour"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    return i >= 1 && i <= 24
  }
  set(a, i, o) {
    const l = o <= 24 ? o % 24 : o;
    return a.setHours(l, 0, 0, 0), a
  }
}
class TE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 60);
    pt(this, "incompatibleTokens", ["t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "m":
        return Aa(Da.minute, a);
      case "mo":
        return o.ordinalNumber(a, {
          unit: "minute"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 59
  }
  set(a, i, o) {
    return a.setMinutes(o, 0, 0), a
  }
}
class EE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 50);
    pt(this, "incompatibleTokens", ["t", "T"])
  }
  parse(a, i, o) {
    switch (i) {
      case "s":
        return Aa(Da.second, a);
      case "so":
        return o.ordinalNumber(a, {
          unit: "second"
        });
      default:
        return La(i.length, a)
    }
  }
  validate(a, i) {
    return i >= 0 && i <= 59
  }
  set(a, i, o) {
    return a.setSeconds(o, 0), a
  }
}
class PE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 30);
    pt(this, "incompatibleTokens", ["t", "T"])
  }
  parse(a, i) {
    const o = l => Math.trunc(l * Math.pow(10, -i.length + 3));
    return Na(La(i.length, a), o)
  }
  set(a, i, o) {
    return a.setMilliseconds(o), a
  }
}
class LE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 10);
    pt(this, "incompatibleTokens", ["t", "T", "x"])
  }
  parse(a, i) {
    switch (i) {
      case "X":
        return Tn(Cn.basicOptionalMinutes, a);
      case "XX":
        return Tn(Cn.basic, a);
      case "XXXX":
        return Tn(Cn.basicOptionalSeconds, a);
      case "XXXXX":
        return Tn(Cn.extendedOptionalSeconds, a);
      case "XXX":
      default:
        return Tn(Cn.extended, a)
    }
  }
  set(a, i, o) {
    return i.timestampIsSet ? a : Zt(a, a.getTime() - Dc(a) - o)
  }
}
class OE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 10);
    pt(this, "incompatibleTokens", ["t", "T", "X"])
  }
  parse(a, i) {
    switch (i) {
      case "x":
        return Tn(Cn.basicOptionalMinutes, a);
      case "xx":
        return Tn(Cn.basic, a);
      case "xxxx":
        return Tn(Cn.basicOptionalSeconds, a);
      case "xxxxx":
        return Tn(Cn.extendedOptionalSeconds, a);
      case "xxx":
      default:
        return Tn(Cn.extended, a)
    }
  }
  set(a, i, o) {
    return i.timestampIsSet ? a : Zt(a, a.getTime() - Dc(a) - o)
  }
}
class ME extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 40);
    pt(this, "incompatibleTokens", "*")
  }
  parse(a) {
    return ky(a)
  }
  set(a, i, o) {
    return [Zt(a, o * 1e3), {
      timestampIsSet: !0
    }]
  }
}
class IE extends ea {
  constructor() {
    super(...arguments);
    pt(this, "priority", 20);
    pt(this, "incompatibleTokens", "*")
  }
  parse(a) {
    return ky(a)
  }
  set(a, i, o) {
    return [Zt(a, o), {
      timestampIsSet: !0
    }]
  }
}
const RE = {
    G: new QT,
    y: new JT,
    Y: new eE,
    R: new tE,
    u: new aE,
    Q: new rE,
    q: new nE,
    M: new iE,
    L: new sE,
    w: new lE,
    I: new uE,
    d: new fE,
    D: new pE,
    E: new gE,
    e: new mE,
    c: new vE,
    i: new yE,
    a: new xE,
    b: new wE,
    B: new kE,
    h: new _E,
    H: new SE,
    K: new AE,
    k: new CE,
    m: new TE,
    s: new EE,
    S: new PE,
    X: new LE,
    x: new OE,
    t: new ME,
    T: new IE
  },
  DE = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g,
  NE = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g,
  FE = /^'([^]*?)'?$/,
  $E = /''/g,
  BE = /\S/,
  HE = /[a-zA-Z]/;

function Ch(e, t, a, i) {
  var D, B, z, I, N, U, W, X;
  const o = jT(),
    l = (i == null ? void 0 : i.locale) ?? o.locale ?? vy,
    h = (i == null ? void 0 : i.firstWeekContainsDate) ?? ((B = (D = i == null ? void 0 : i.locale) == null ? void 0 : D.options) == null ? void 0 : B.firstWeekContainsDate) ?? o.firstWeekContainsDate ?? ((I = (z = o.locale) == null ? void 0 : z.options) == null ? void 0 : I.firstWeekContainsDate) ?? 1,
    p = (i == null ? void 0 : i.weekStartsOn) ?? ((U = (N = i == null ? void 0 : i.locale) == null ? void 0 : N.options) == null ? void 0 : U.weekStartsOn) ?? o.weekStartsOn ?? ((X = (W = o.locale) == null ? void 0 : W.options) == null ? void 0 : X.weekStartsOn) ?? 0;
  if (t === "") return e === "" ? bt(a) : Zt(a, NaN);
  const m = {
      firstWeekContainsDate: h,
      weekStartsOn: p,
      locale: l
    },
    k = [new ZT],
    w = t.match(NE).map(V => {
      const ne = V[0];
      if (ne in Sh) {
        const Z = Sh[ne];
        return Z(V, l.formatLong)
      }
      return V
    }).join("").match(DE),
    S = [];
  for (let V of w) {
    !(i != null && i.useAdditionalWeekYearTokens) && xy(V) && Ah(V, t, e), !(i != null && i.useAdditionalDayOfYearTokens) && yy(V) && Ah(V, t, e);
    const ne = V[0],
      Z = RE[ne];
    if (Z) {
      const {
        incompatibleTokens: ie
      } = Z;
      if (Array.isArray(ie)) {
        const le = S.find(Ee => ie.includes(Ee.token) || Ee.token === ne);
        if (le) throw new RangeError(`The format string mustn't contain \`${le.fullToken}\` and \`${V}\` at the same time`)
      } else if (Z.incompatibleTokens === "*" && S.length > 0) throw new RangeError(`The format string mustn't contain \`${V}\` and any other token at the same time`);
      S.push({
        token: ne,
        fullToken: V
      });
      const fe = Z.run(e, V, l.match, m);
      if (!fe) return Zt(a, NaN);
      k.push(fe.setter), e = fe.rest
    } else {
      if (ne.match(HE)) throw new RangeError("Format string contains an unescaped latin alphabet character `" + ne + "`");
      if (V === "''" ? V = "'" : ne === "'" && (V = YE(V)), e.indexOf(V) === 0) e = e.slice(V.length);
      else return Zt(a, NaN)
    }
  }
  if (e.length > 0 && BE.test(e)) return Zt(a, NaN);
  const A = k.map(V => V.priority).sort((V, ne) => ne - V).filter((V, ne, Z) => Z.indexOf(V) === ne).map(V => k.filter(ne => ne.priority === V).sort((ne, Z) => Z.subPriority - ne.subPriority)).map(V => V[0]);
  let E = bt(a);
  if (isNaN(E.getTime())) return Zt(a, NaN);
  const M = {};
  for (const V of A) {
    if (!V.validate(E, m)) return Zt(a, NaN);
    const ne = V.set(E, M, m);
    Array.isArray(ne) ? (E = ne[0], Object.assign(M, ne[1])) : E = ne
  }
  return Zt(a, E)
}

function YE(e) {
  return e.match(FE)[1].replace($E, "'")
}

function rm(e, t) {
  const a = ss(e),
    i = ss(t);
  return +a == +i
}

function zE(e, t) {
  return nn(e, -t)
}

function Ay(e, t) {
  const a = bt(e),
    i = a.getFullYear(),
    o = a.getDate(),
    l = Zt(e, 0);
  l.setFullYear(i, t, 15), l.setHours(0, 0, 0, 0);
  const h = VT(l);
  return a.setMonth(t, Math.min(o, h)), a
}

function da(e, t) {
  let a = bt(e);
  return isNaN(+a) ? Zt(e, NaN) : (t.year != null && a.setFullYear(t.year), t.month != null && (a = Ay(a, t.month)), t.date != null && a.setDate(t.date), t.hours != null && a.setHours(t.hours), t.minutes != null && a.setMinutes(t.minutes), t.seconds != null && a.setSeconds(t.seconds), t.milliseconds != null && a.setMilliseconds(t.milliseconds), a)
}

function XE(e, t) {
  const a = bt(e);
  return a.setHours(t), a
}

function Cy(e, t) {
  const a = bt(e);
  return a.setMilliseconds(t), a
}

function WE(e, t) {
  const a = bt(e);
  return a.setMinutes(t), a
}

function Ty(e, t) {
  const a = bt(e);
  return a.setSeconds(t), a
}

function Pn(e, t) {
  const a = bt(e);
  return isNaN(+a) ? Zt(e, NaN) : (a.setFullYear(t), a)
}

function to(e, t) {
  return cn(e, -t)
}

function VE(e, t) {
  const {
    years: a = 0,
    months: i = 0,
    weeks: o = 0,
    days: l = 0,
    hours: h = 0,
    minutes: p = 0,
    seconds: m = 0
  } = t, k = to(e, i + a * 12), w = zE(k, l + o * 7), S = p + h * 60, E = (m + S * 60) * 1e3;
  return Zt(e, w.getTime() - E)
}

function Ey(e, t) {
  return If(e, -t)
}

function mo() {
  const e = pk();
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img",
    ...e
  }, [ce("path", {
    d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z"
  }), ce("path", {
    d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
  }), ce("path", {
    d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
  }), ce("path", {
    d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z"
  })])
}
mo.compatConfig = {
  MODE: 3
};

function Py() {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [ce("path", {
    d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z"
  }), ce("path", {
    d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
  })])
}
Py.compatConfig = {
  MODE: 3
};

function Bf() {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [ce("path", {
    d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
  })])
}
Bf.compatConfig = {
  MODE: 3
};

function Hf() {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [ce("path", {
    d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z"
  })])
}
Hf.compatConfig = {
  MODE: 3
};

function Yf() {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [ce("path", {
    d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z"
  }), ce("path", {
    d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z"
  })])
}
Yf.compatConfig = {
  MODE: 3
};

function zf() {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [ce("path", {
    d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z"
  })])
}
zf.compatConfig = {
  MODE: 3
};

function Xf() {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 32 32",
    fill: "currentColor",
    "aria-hidden": "true",
    class: "dp__icon",
    role: "img"
  }, [ce("path", {
    d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z"
  })])
}
Xf.compatConfig = {
  MODE: 3
};
const $r = (e, t) => t ? new Date(e.toLocaleString("en-US", {
    timeZone: t
  })) : new Date(e),
  Wf = (e, t, a) => Th(e, t, a) || at(),
  jE = (e, t, a) => {
    const i = t.dateInTz ? $r(new Date(e), t.dateInTz) : at(e);
    return a ? Pr(i, !0) : i
  },
  Th = (e, t, a) => {
    if (!e) return null;
    const i = a ? Pr(at(e), !0) : at(e);
    return t ? t.exactMatch ? jE(e, t, a) : $r(i, t.timezone) : i
  },
  UE = e => {
    if (!e) return 0;
    const t = new Date,
      a = new Date(t.toLocaleString("en-US", {
        timeZone: "UTC"
      })),
      i = new Date(t.toLocaleString("en-US", {
        timeZone: e
      })),
      o = i.getTimezoneOffset() / 60;
    return (+a - +i) / (1e3 * 60 * 60) - o
  };
var rn = (e => (e.month = "month", e.year = "year", e))(rn || {}),
  Ji = (e => (e.top = "top", e.bottom = "bottom", e))(Ji || {}),
  ds = (e => (e.header = "header", e.calendar = "calendar", e.timePicker = "timePicker", e))(ds || {}),
  hr = (e => (e.month = "month", e.year = "year", e.calendar = "calendar", e.time = "time", e.minutes = "minutes", e.hours = "hours", e.seconds = "seconds", e))(hr || {});
const GE = ["timestamp", "date", "iso"];
var _r = (e => (e.up = "up", e.down = "down", e.left = "left", e.right = "right", e))(_r || {}),
  ba = (e => (e.arrowUp = "ArrowUp", e.arrowDown = "ArrowDown", e.arrowLeft = "ArrowLeft", e.arrowRight = "ArrowRight", e.enter = "Enter", e.space = " ", e.esc = "Escape", e.tab = "Tab", e.home = "Home", e.end = "End", e.pageUp = "PageUp", e.pageDown = "PageDown", e))(ba || {});

function nm(e) {
  return t => new Intl.DateTimeFormat(e, {
    weekday: "short",
    timeZone: "UTC"
  }).format(new Date(`2017-01-0${t}T00:00:00+00:00`)).slice(0, 2)
}

function qE(e) {
  return t => On($r(new Date(`2017-01-0${t}T00:00:00+00:00`), "UTC"), "EEEEEE", {
    locale: e
  })
}
const KE = (e, t, a) => {
    const i = [1, 2, 3, 4, 5, 6, 7];
    let o;
    if (e !== null) try {
      o = i.map(qE(e))
    } catch {
      o = i.map(nm(t))
    } else o = i.map(nm(t));
    const l = o.slice(0, a),
      h = o.slice(a + 1, o.length);
    return [o[a]].concat(...h).concat(...l)
  },
  Vf = (e, t, a) => {
    const i = [];
    for (let o = +e[0]; o <= +e[1]; o++) i.push({
      value: +o,
      text: Iy(o, t)
    });
    return a ? i.reverse() : i
  },
  Ly = (e, t, a) => {
    const i = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map(l => {
      const h = l < 10 ? `0${l}` : l;
      return new Date(`2017-${h}-01T00:00:00+00:00`)
    });
    if (e !== null) try {
      const l = a === "long" ? "LLLL" : "LLL";
      return i.map((h, p) => {
        const m = On($r(h, "UTC"), l, {
          locale: e
        });
        return {
          text: m.charAt(0).toUpperCase() + m.substring(1),
          value: p
        }
      })
    } catch {}
    const o = new Intl.DateTimeFormat(t, {
      month: a,
      timeZone: "UTC"
    });
    return i.map((l, h) => {
      const p = o.format(l);
      return {
        text: p.charAt(0).toUpperCase() + p.substring(1),
        value: h
      }
    })
  },
  ZE = e => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e],
  Wa = e => {
    const t = se(e);
    return t != null && t.$el ? t == null ? void 0 : t.$el : t
  },
  QE = e => ({
    type: "dot",
    ...e ?? {}
  }),
  Oy = e => Array.isArray(e) ? !!e[0] && !!e[1] : !1,
  jf = {
    prop: e => `"${e}" prop must be enabled!`,
    dateArr: e => `You need to use array as "model-value" binding in order to support "${e}"`
  },
  Za = e => e,
  im = e => e === 0 ? e : !e || isNaN(+e) ? null : +e,
  sm = e => e === null,
  My = e => {
    if (e) return [...e.querySelectorAll("input, button, select, textarea, a[href]")][0]
  },
  JE = e => {
    const t = [],
      a = i => i.filter(o => o);
    for (let i = 0; i < e.length; i += 3) {
      const o = [e[i], e[i + 1], e[i + 2]];
      t.push(a(o))
    }
    return t
  },
  vl = (e, t, a) => {
    const i = a != null,
      o = t != null;
    if (!i && !o) return !1;
    const l = +a,
      h = +t;
    return i && o ? +e > l || +e < h : i ? +e > l : o ? +e < h : !1
  },
  ao = (e, t) => JE(e).map(a => a.map(i => {
    const {
      active: o,
      disabled: l,
      isBetween: h,
      highlighted: p
    } = t(i);
    return {
      ...i,
      active: o,
      disabled: l,
      className: {
        dp__overlay_cell_active: o,
        dp__overlay_cell: !o,
        dp__overlay_cell_disabled: l,
        dp__overlay_cell_pad: !0,
        dp__overlay_cell_active_disabled: l && o,
        dp__cell_in_between: h,
        "dp--highlighted": p
      }
    }
  })),
  _i = (e, t, a = !1) => {
    e && t.allowStopPropagation && (a && e.stopImmediatePropagation(), e.stopPropagation())
  },
  eP = () => ["a[href]", "area[href]", "input:not([disabled]):not([type='hidden'])", "select:not([disabled])", "textarea:not([disabled])", "button:not([disabled])", "[tabindex]:not([tabindex='-1'])", "[data-datepicker-instance]"].join(", ");

function tP(e, t) {
  let a = [...document.querySelectorAll(eP())];
  a = a.filter(o => !e.contains(o) || o.hasAttribute("data-datepicker-instance"));
  const i = a.indexOf(e);
  if (i >= 0 && (t ? i - 1 >= 0 : i + 1 <= a.length)) return a[i + (t ? -1 : 1)]
}
const Eh = (e, t) => e == null ? void 0 : e.querySelector(`[data-dp-element="${t}"]`),
  Iy = (e, t) => new Intl.NumberFormat(t, {
    useGrouping: !1,
    style: "decimal"
  }).format(e),
  Uf = e => On(e, "dd-MM-yyyy"),
  id = e => Array.isArray(e),
  Fc = (e, t) => t.get(Uf(e)),
  aP = (e, t) => e ? t ? t instanceof Map ? !!Fc(e, t) : t(at(e)) : !1 : !0,
  Cr = (e, t, a = !1, i) => {
    if (e.key === ba.enter || e.key === ba.space) return a && e.preventDefault(), t();
    if (i) return i(e)
  },
  rP = () => ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].some(e => navigator.userAgent.includes(e)) || navigator.userAgent.includes("Mac") && "ontouchend" in document,
  om = (e, t, a, i, o, l) => {
    const h = Ch(e, t.slice(0, e.length), new Date, {
      locale: l
    });
    return el(h) && fy(h) ? i || o ? h : da(h, {
      hours: +a.hours,
      minutes: +(a == null ? void 0 : a.minutes),
      seconds: +(a == null ? void 0 : a.seconds),
      milliseconds: 0
    }) : null
  },
  nP = (e, t, a, i, o, l) => {
    const h = Array.isArray(a) ? a[0] : a;
    if (typeof t == "string") return om(e, t, h, i, o, l);
    if (Array.isArray(t)) {
      let p = null;
      for (const m of t)
        if (p = om(e, m, h, i, o, l), p) break;
      return p
    }
    return typeof t == "function" ? t(e) : null
  },
  at = e => e ? new Date(e) : new Date,
  iP = (e, t, a) => {
    if (t) {
      const o = (e.getMonth() + 1).toString().padStart(2, "0"),
        l = e.getDate().toString().padStart(2, "0"),
        h = e.getHours().toString().padStart(2, "0"),
        p = e.getMinutes().toString().padStart(2, "0"),
        m = a ? e.getSeconds().toString().padStart(2, "0") : "00";
      return `${e.getFullYear()}-${o}-${l}T${h}:${p}:${m}.000Z`
    }
    const i = Date.UTC(e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate(), e.getUTCHours(), e.getUTCMinutes(), e.getUTCSeconds());
    return new Date(i).toISOString()
  },
  Pr = (e, t) => {
    const a = at(JSON.parse(JSON.stringify(e))),
      i = da(a, {
        hours: 0,
        minutes: 0,
        seconds: 0,
        milliseconds: 0
      });
    return t ? QC(i) : i
  },
  Si = (e, t, a, i) => {
    let o = e ? at(e) : at();
    return (t || t === 0) && (o = XE(o, +t)), (a || a === 0) && (o = WE(o, +a)), (i || i === 0) && (o = Ty(o, +i)), Cy(o, 0)
  },
  Pa = (e, t) => !e || !t ? !1 : ml(Pr(e), Pr(t)),
  Vt = (e, t) => !e || !t ? !1 : Hs(Pr(e), Pr(t)),
  Ia = (e, t) => !e || !t ? !1 : eo(Pr(e), Pr(t)),
  xu = (e, t, a) => e != null && e[0] && e != null && e[1] ? Ia(a, e[0]) && Pa(a, e[1]) : e != null && e[0] && t ? Ia(a, e[0]) && Pa(a, t) || Pa(a, e[0]) && Ia(a, t) : !1,
  sn = e => {
    const t = da(new Date(e), {
      date: 1
    });
    return Pr(t)
  },
  sd = (e, t, a) => t && (a || a === 0) ? Object.fromEntries(["hours", "minutes", "seconds"].map(i => i === t ? [i, a] : [i, isNaN(+e[i]) ? void 0 : +e[i]])) : {
    hours: isNaN(+e.hours) ? void 0 : +e.hours,
    minutes: isNaN(+e.minutes) ? void 0 : +e.minutes,
    seconds: isNaN(+e.seconds) ? void 0 : +e.seconds
  },
  hs = e => ({
    hours: Kn(e),
    minutes: Ti(e),
    seconds: Js(e)
  }),
  Ry = (e, t) => {
    if (t) {
      const a = Tt(at(t));
      if (a > e) return 12;
      if (a === e) return zt(at(t))
    }
  },
  Dy = (e, t) => {
    if (t) {
      const a = Tt(at(t));
      return a < e ? -1 : a === e ? zt(at(t)) : void 0
    }
  },
  ro = e => {
    if (e) return Tt(at(e))
  },
  Ny = (e, t) => {
    const a = Ia(e, t) ? t : e,
      i = Ia(t, e) ? t : e;
    return py({
      start: a,
      end: i
    })
  },
  sP = e => {
    const t = cn(e, 1);
    return {
      month: zt(t),
      year: Tt(t)
    }
  },
  Xn = (e, t) => {
    const a = pn(e, {
        weekStartsOn: +t
      }),
      i = my(e, {
        weekStartsOn: +t
      });
    return [a, i]
  },
  Fy = (e, t) => {
    const a = {
      hours: Kn(at()),
      minutes: Ti(at()),
      seconds: t ? Js(at()) : 0
    };
    return Object.assign(a, e)
  },
  bi = (e, t, a) => [da(at(e), {
    date: 1
  }), da(at(), {
    month: t,
    year: a,
    date: 1
  })],
  jn = (e, t, a) => {
    let i = e ? at(e) : at();
    return (t || t === 0) && (i = Ay(i, t)), a && (i = Pn(i, a)), i
  },
  $y = (e, t, a, i, o) => {
    if (!i || o && !t || !o && !a) return !1;
    const l = o ? cn(e, 1) : to(e, 1),
      h = [zt(l), Tt(l)];
    return o ? !lP(...h, t) : !oP(...h, a)
  },
  oP = (e, t, a) => Pa(...bi(a, e, t)) || Vt(...bi(a, e, t)),
  lP = (e, t, a) => Ia(...bi(a, e, t)) || Vt(...bi(a, e, t)),
  By = (e, t, a, i, o, l, h) => {
    if (typeof t == "function" && !h) return t(e);
    const p = a ? {
      locale: a
    } : void 0;
    return Array.isArray(e) ? `${On(e[0],l,p)}${o&&!e[1]?"":i}${e[1]?On(e[1],l,p):""}` : On(e, l, p)
  },
  Es = e => {
    if (e) return null;
    throw new Error(jf.prop("partial-range"))
  },
  Ql = (e, t) => {
    if (t) return e();
    throw new Error(jf.prop("range"))
  },
  Ph = e => Array.isArray(e) ? el(e[0]) && (e[1] ? el(e[1]) : !0) : e ? el(e) : !1,
  cP = (e, t) => da(t ?? at(), {
    hours: +e.hours || 0,
    minutes: +e.minutes || 0,
    seconds: +e.seconds || 0
  }),
  od = (e, t, a, i) => {
    if (!e) return !0;
    if (i) {
      const o = a === "max" ? ml(e, t) : eo(e, t),
        l = {
          seconds: 0,
          milliseconds: 0
        };
      return o || Hs(da(e, l), da(t, l))
    }
    return a === "max" ? e.getTime() <= t.getTime() : e.getTime() >= t.getTime()
  },
  ld = (e, t, a) => e ? cP(e, t) : at(a ?? t),
  lm = (e, t, a, i, o) => {
    if (Array.isArray(i)) {
      const h = ld(e, i[0], t),
        p = ld(e, i[1], t);
      return od(i[0], h, a, !!t) && od(i[1], p, a, !!t) && o
    }
    const l = ld(e, i, t);
    return od(i, l, a, !!t) && o
  },
  cd = e => da(at(), hs(e)),
  uP = (e, t) => e instanceof Map ? Array.from(e.values()).filter(a => Tt(at(a)) === t).map(a => zt(a)) : [],
  Hy = (e, t, a) => typeof e == "function" ? e({
    month: t,
    year: a
  }) : !!e.months.find(i => i.month === t && i.year === a),
  Gf = (e, t) => typeof e == "function" ? e(t) : e.years.includes(t),
  Yy = e => On(e, "yyyy-MM-dd"),
  Do = qr({
    menuFocused: !1,
    shiftKeyInMenu: !1
  }),
  zy = () => {
    const e = a => {
        Do.menuFocused = a
      },
      t = a => {
        Do.shiftKeyInMenu !== a && (Do.shiftKeyInMenu = a)
      };
    return {
      control: Oe(() => ({
        shiftKeyInMenu: Do.shiftKeyInMenu,
        menuFocused: Do.menuFocused
      })),
      setMenuFocused: e,
      setShiftKey: t
    }
  },
  va = qr({
    monthYear: [],
    calendar: [],
    time: [],
    actionRow: [],
    selectionGrid: [],
    timePicker: {
      0: [],
      1: []
    },
    monthPicker: []
  }),
  ud = _e(null),
  Jl = _e(!1),
  dd = _e(!1),
  hd = _e(!1),
  fd = _e(!1),
  dr = _e(0),
  Ma = _e(0),
  Ri = () => {
    const e = Oe(() => Jl.value ? [...va.selectionGrid, va.actionRow].filter(S => S.length) : dd.value ? [...va.timePicker[0], ...va.timePicker[1], fd.value ? [] : [ud.value], va.actionRow].filter(S => S.length) : hd.value ? [...va.monthPicker, va.actionRow] : [va.monthYear, ...va.calendar, va.time, va.actionRow].filter(S => S.length)),
      t = S => {
        dr.value = S ? dr.value + 1 : dr.value - 1;
        let A = null;
        e.value[Ma.value] && (A = e.value[Ma.value][dr.value]), !A && e.value[Ma.value + (S ? 1 : -1)] ? (Ma.value = Ma.value + (S ? 1 : -1), dr.value = S ? 0 : e.value[Ma.value].length - 1) : A || (dr.value = S ? dr.value - 1 : dr.value + 1)
      },
      a = S => {
        Ma.value === 0 && !S || Ma.value === e.value.length && S || (Ma.value = S ? Ma.value + 1 : Ma.value - 1, e.value[Ma.value] ? e.value[Ma.value] && !e.value[Ma.value][dr.value] && dr.value !== 0 && (dr.value = e.value[Ma.value].length - 1) : Ma.value = S ? Ma.value - 1 : Ma.value + 1)
      },
      i = S => {
        let A = null;
        e.value[Ma.value] && (A = e.value[Ma.value][dr.value]), A ? A.focus({
          preventScroll: !Jl.value
        }) : dr.value = S ? dr.value - 1 : dr.value + 1
      },
      o = () => {
        t(!0), i(!0)
      },
      l = () => {
        t(!1), i(!1)
      },
      h = () => {
        a(!1), i(!0)
      },
      p = () => {
        a(!0), i(!0)
      },
      m = (S, A) => {
        va[A] = S
      },
      k = (S, A) => {
        va[A] = S
      },
      w = () => {
        dr.value = 0, Ma.value = 0
      };
    return {
      buildMatrix: m,
      buildMultiLevelMatrix: k,
      setTimePickerBackRef: S => {
        ud.value = S
      },
      setSelectionGrid: S => {
        Jl.value = S, w(), S || (va.selectionGrid = [])
      },
      setTimePicker: (S, A = !1) => {
        dd.value = S, fd.value = A, w(), S || (va.timePicker[0] = [], va.timePicker[1] = [])
      },
      setTimePickerElements: (S, A = 0) => {
        va.timePicker[A] = S
      },
      arrowRight: o,
      arrowLeft: l,
      arrowUp: h,
      arrowDown: p,
      clearArrowNav: () => {
        va.monthYear = [], va.calendar = [], va.time = [], va.actionRow = [], va.selectionGrid = [], va.timePicker[0] = [], va.timePicker[1] = [], Jl.value = !1, dd.value = !1, fd.value = !1, hd.value = !1, w(), ud.value = null
      },
      setMonthPicker: S => {
        hd.value = S, w()
      },
      refSets: va
    }
  },
  cm = e => ({
    menuAppearTop: "dp-menu-appear-top",
    menuAppearBottom: "dp-menu-appear-bottom",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down",
    ...e ?? {}
  }),
  dP = e => ({
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: t => `Increment ${t}`,
    decrementValue: t => `Decrement ${t}`,
    openTpOverlay: t => `Open ${t} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month",
    nextYear: "Next year",
    prevYear: "Previous year",
    day: void 0,
    weekDay: void 0,
    clearInput: "Clear value",
    calendarIcon: "Calendar icon",
    timePicker: "Time picker",
    monthPicker: t => `Month picker${t?" overlay":""}`,
    yearPicker: t => `Year picker${t?" overlay":""}`,
    timeOverlay: t => `${t} overlay`,
    ...e ?? {}
  }),
  um = e => e ? typeof e == "boolean" ? e ? 2 : 0 : +e >= 2 ? +e : 2 : 0,
  hP = e => {
    const t = typeof e == "object" && e,
      a = {
        static: !0,
        solo: !1
      };
    if (!e) return {
      ...a,
      count: um(!1)
    };
    const i = t ? e : {},
      o = t ? i.count ?? !0 : e,
      l = um(o);
    return Object.assign(a, i, {
      count: l
    })
  },
  fP = (e, t, a) => e || (typeof a == "string" ? a : t),
  pP = e => typeof e == "boolean" ? e ? cm({}) : !1 : cm(e),
  gP = e => {
    const t = {
      enterSubmit: !0,
      tabSubmit: !0,
      openMenu: "open",
      selectOnFocus: !1,
      rangeSeparator: " - "
    };
    return typeof e == "object" ? {
      ...t,
      ...e ?? {},
      enabled: !0
    } : {
      ...t,
      enabled: e
    }
  },
  mP = e => ({
    months: [],
    years: [],
    times: {
      hours: [],
      minutes: [],
      seconds: []
    },
    ...e ?? {}
  }),
  vP = e => ({
    showSelect: !0,
    showCancel: !0,
    showNow: !1,
    showPreview: !0,
    ...e ?? {}
  }),
  bP = e => {
    const t = {
      input: !1
    };
    return typeof e == "object" ? {
      ...t,
      ...e ?? {},
      enabled: !0
    } : {
      enabled: e,
      ...t
    }
  },
  yP = e => ({
    allowStopPropagation: !0,
    closeOnScroll: !1,
    modeHeight: 255,
    allowPreventDefault: !1,
    closeOnClearValue: !0,
    closeOnAutoApply: !0,
    noSwipe: !1,
    keepActionRow: !1,
    onClickOutside: void 0,
    tabOutClosesMenu: !0,
    arrowLeft: void 0,
    keepViewOnOffsetClick: !1,
    timeArrowHoldThreshold: 0,
    shadowDom: !1,
    ...e ?? {}
  }),
  xP = e => {
    const t = {
      dates: Array.isArray(e) ? e.map(a => at(a)) : [],
      years: [],
      months: [],
      quarters: [],
      weeks: [],
      weekdays: [],
      options: {
        highlightDisabled: !1
      }
    };
    return typeof e == "function" ? e : {
      ...t,
      ...e ?? {}
    }
  },
  wP = e => typeof e == "object" ? {
    type: (e == null ? void 0 : e.type) ?? "local",
    hideOnOffsetDates: (e == null ? void 0 : e.hideOnOffsetDates) ?? !1
  } : {
    type: e,
    hideOnOffsetDates: !1
  },
  kP = e => {
    const t = {
      noDisabledRange: !1,
      showLastInRange: !0,
      minMaxRawRange: !1,
      partialRange: !0,
      disableTimeRangeValidation: !1,
      maxRange: void 0,
      minRange: void 0,
      autoRange: void 0,
      fixedStart: !1,
      fixedEnd: !1
    };
    return typeof e == "object" ? {
      enabled: !0,
      ...t,
      ...e
    } : {
      enabled: e,
      ...t
    }
  },
  _P = e => e ? typeof e == "string" ? {
    timezone: e,
    exactMatch: !1,
    dateInTz: void 0,
    emitTimezone: void 0,
    convertModel: !0
  } : {
    timezone: e.timezone,
    exactMatch: e.exactMatch ?? !1,
    dateInTz: e.dateInTz ?? void 0,
    emitTimezone: e.emitTimezone ?? void 0,
    convertModel: e.convertModel ?? !0
  } : {
    timezone: void 0,
    exactMatch: !1,
    emitTimezone: void 0
  },
  pd = (e, t, a) => new Map(e.map(i => {
    const o = Wf(i, t, a);
    return [Uf(o), o]
  })),
  SP = (e, t) => e.length ? new Map(e.map(a => {
    const i = Wf(a.date, t);
    return [Uf(i), a]
  })) : null,
  AP = e => {
    var t;
    return {
      minDate: Th(e.minDate, e.timezone, e.isSpecific),
      maxDate: Th(e.maxDate, e.timezone, e.isSpecific),
      disabledDates: id(e.disabledDates) ? pd(e.disabledDates, e.timezone, e.isSpecific) : e.disabledDates,
      allowedDates: id(e.allowedDates) ? pd(e.allowedDates, e.timezone, e.isSpecific) : null,
      highlight: typeof e.highlight == "object" && id((t = e.highlight) == null ? void 0 : t.dates) ? pd(e.highlight.dates, e.timezone) : e.highlight,
      markers: SP(e.markers, e.timezone)
    }
  },
  CP = e => typeof e == "boolean" ? {
    enabled: e,
    dragSelect: !0,
    limit: null
  } : {
    enabled: !!e,
    limit: e.limit ? +e.limit : null,
    dragSelect: e.dragSelect ?? !0
  },
  TP = e => ({
    ...Object.fromEntries(Object.keys(e).map(t => {
      const a = t,
        i = e[a],
        o = typeof e[a] == "string" ? {
          [i]: !0
        } : Object.fromEntries(i.map(l => [l, !0]));
      return [t, o]
    }))
  }),
  _a = e => {
    const t = () => {
        const X = e.enableSeconds ? ":ss" : "",
          V = e.enableMinutes ? ":mm" : "";
        return e.is24 ? `HH${V}${X}` : `hh${V}${X} aa`
      },
      a = () => {
        var X;
        return e.format ? e.format : e.monthPicker ? "MM/yyyy" : e.timePicker ? t() : e.weekPicker ? `${((X=B.value)==null?void 0:X.type)==="iso"?"RR":"ww"}-yyyy` : e.yearPicker ? "yyyy" : e.quarterPicker ? "QQQ/yyyy" : e.enableTimePicker ? `MM/dd/yyyy, ${t()}` : "MM/dd/yyyy"
      },
      i = X => Fy(X, e.enableSeconds),
      o = () => U.value.enabled ? e.startTime && Array.isArray(e.startTime) ? [i(e.startTime[0]), i(e.startTime[1])] : null : e.startTime && !Array.isArray(e.startTime) ? i(e.startTime) : null,
      l = Oe(() => hP(e.multiCalendars)),
      h = Oe(() => o()),
      p = Oe(() => dP(e.ariaLabels)),
      m = Oe(() => mP(e.filters)),
      k = Oe(() => pP(e.transitions)),
      w = Oe(() => vP(e.actionRow)),
      S = Oe(() => fP(e.previewFormat, e.format, a())),
      A = Oe(() => gP(e.textInput)),
      E = Oe(() => bP(e.inline)),
      M = Oe(() => yP(e.config)),
      D = Oe(() => xP(e.highlight)),
      B = Oe(() => wP(e.weekNumbers)),
      z = Oe(() => _P(e.timezone)),
      I = Oe(() => CP(e.multiDates)),
      N = Oe(() => AP({
        minDate: e.minDate,
        maxDate: e.maxDate,
        disabledDates: e.disabledDates,
        allowedDates: e.allowedDates,
        highlight: D.value,
        markers: e.markers,
        timezone: z.value,
        isSpecific: e.monthPicker || e.yearPicker || e.quarterPicker
      })),
      U = Oe(() => kP(e.range)),
      W = Oe(() => TP(e.ui));
    return {
      defaultedTransitions: k,
      defaultedMultiCalendars: l,
      defaultedStartTime: h,
      defaultedAriaLabels: p,
      defaultedFilters: m,
      defaultedActionRow: w,
      defaultedPreviewFormat: S,
      defaultedTextInput: A,
      defaultedInline: E,
      defaultedConfig: M,
      defaultedHighlight: D,
      defaultedWeekNumbers: B,
      defaultedRange: U,
      propDates: N,
      defaultedTz: z,
      defaultedMultiDates: I,
      defaultedUI: W,
      getDefaultPattern: a,
      getDefaultStartTime: o
    }
  },
  EP = (e, t, a) => {
    const i = _e(),
      {
        defaultedTextInput: o,
        defaultedRange: l,
        defaultedTz: h,
        defaultedMultiDates: p,
        getDefaultPattern: m
      } = _a(t),
      k = _e(""),
      w = ol(t, "format"),
      S = ol(t, "formatLocale");
    Xt(i, () => {
      typeof t.onInternalModelChange == "function" && e("internal-model-change", i.value, Be(!0))
    }, {
      deep: !0
    }), Xt(l, (J, Re) => {
      J.enabled !== Re.enabled && (i.value = null)
    }), Xt(w, () => {
      He()
    });
    const A = J => h.value.timezone && h.value.convertModel ? $r(J, h.value.timezone) : J,
      E = J => {
        if (h.value.timezone && h.value.convertModel) {
          const Re = UE(h.value.timezone);
          return VC(J, Re)
        }
        return J
      },
      M = (J, Re, Xe = !1) => By(J, t.format, t.formatLocale, o.value.rangeSeparator, t.modelAuto, Re ?? m(), Xe),
      D = J => J ? t.modelType ? Ye(J) : {
        hours: Kn(J),
        minutes: Ti(J),
        seconds: t.enableSeconds ? Js(J) : 0
      } : null,
      B = J => t.modelType ? Ye(J) : {
        month: zt(J),
        year: Tt(J)
      },
      z = J => Array.isArray(J) ? p.value.enabled ? J.map(Re => I(Re, Pn(at(), Re))) : Ql(() => [Pn(at(), J[0]), J[1] ? Pn(at(), J[1]) : Es(l.value.partialRange)], l.value.enabled) : Pn(at(), +J),
      I = (J, Re) => (typeof J == "string" || typeof J == "number") && t.modelType ? De(J) : Re,
      N = J => Array.isArray(J) ? [I(J[0], Si(null, +J[0].hours, +J[0].minutes, J[0].seconds)), I(J[1], Si(null, +J[1].hours, +J[1].minutes, J[1].seconds))] : I(J, Si(null, J.hours, J.minutes, J.seconds)),
      U = J => {
        const Re = da(at(), {
          date: 1
        });
        return Array.isArray(J) ? p.value.enabled ? J.map(Xe => I(Xe, jn(Re, +Xe.month, +Xe.year))) : Ql(() => [I(J[0], jn(Re, +J[0].month, +J[0].year)), I(J[1], J[1] ? jn(Re, +J[1].month, +J[1].year) : Es(l.value.partialRange))], l.value.enabled) : I(J, jn(Re, +J.month, +J.year))
      },
      W = J => {
        if (Array.isArray(J)) return J.map(Re => De(Re));
        throw new Error(jf.dateArr("multi-dates"))
      },
      X = J => {
        if (Array.isArray(J) && l.value.enabled) {
          const Re = J[0],
            Xe = J[1];
          return [at(Array.isArray(Re) ? Re[0] : null), at(Array.isArray(Xe) ? Xe[0] : null)]
        }
        return at(J[0])
      },
      V = J => t.modelAuto ? Array.isArray(J) ? [De(J[0]), De(J[1])] : t.autoApply ? [De(J)] : [De(J), null] : Array.isArray(J) ? Ql(() => J[1] ? [De(J[0]), J[1] ? De(J[1]) : Es(l.value.partialRange)] : [De(J[0])], l.value.enabled) : De(J),
      ne = () => {
        Array.isArray(i.value) && l.value.enabled && i.value.length === 1 && i.value.push(Es(l.value.partialRange))
      },
      Z = () => {
        const J = i.value;
        return [Ye(J[0]), J[1] ? Ye(J[1]) : Es(l.value.partialRange)]
      },
      ie = () => i.value[1] ? Z() : Ye(Za(i.value[0])),
      fe = () => (i.value || []).map(J => Ye(J)),
      le = (J = !1) => (J || ne(), t.modelAuto ? ie() : p.value.enabled ? fe() : Array.isArray(i.value) ? Ql(() => Z(), l.value.enabled) : Ye(Za(i.value))),
      Ee = J => !J || Array.isArray(J) && !J.length ? null : t.timePicker ? N(Za(J)) : t.monthPicker ? U(Za(J)) : t.yearPicker ? z(Za(J)) : p.value.enabled ? W(Za(J)) : t.weekPicker ? X(Za(J)) : V(Za(J)),
      ye = J => {
        const Re = Ee(J);
        Ph(Za(Re)) ? (i.value = Za(Re), He()) : (i.value = null, k.value = "")
      },
      ve = () => {
        const J = Re => On(Re, o.value.format);
        return `${J(i.value[0])} ${o.value.rangeSeparator} ${i.value[1]?J(i.value[1]):""}`
      },
      me = () => a.value && i.value ? Array.isArray(i.value) ? ve() : On(i.value, o.value.format) : M(i.value),
      Ae = () => i.value ? p.value.enabled ? i.value.map(J => M(J)).join("; ") : o.value.enabled && typeof o.value.format == "string" ? me() : M(i.value) : "",
      He = () => {
        !t.format || typeof t.format == "string" || o.value.enabled && typeof o.value.format == "string" ? k.value = Ae() : k.value = t.format(i.value)
      },
      De = J => {
        if (t.utc) {
          const Re = new Date(J);
          return t.utc === "preserve" ? new Date(Re.getTime() + Re.getTimezoneOffset() * 6e4) : Re
        }
        return t.modelType ? GE.includes(t.modelType) ? A(new Date(J)) : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? A(Ch(J, m(), new Date, {
          locale: S.value
        })) : A(Ch(J, t.modelType, new Date, {
          locale: S.value
        })) : A(new Date(J))
      },
      Ye = J => J ? t.utc ? iP(J, t.utc === "preserve", t.enableSeconds) : t.modelType ? t.modelType === "timestamp" ? +E(J) : t.modelType === "iso" ? E(J).toISOString() : t.modelType === "format" && (typeof t.format == "string" || !t.format) ? M(E(J)) : M(E(J), t.modelType, !0) : E(J) : "",
      Je = (J, Re = !1, Xe = !1) => {
        if (Xe) return J;
        if (e("update:model-value", J), h.value.emitTimezone && Re) {
          const nt = Array.isArray(J) ? J.map(Pe => $r(Za(Pe), h.value.emitTimezone)) : $r(Za(J), h.value.emitTimezone);
          e("update:model-timezone-value", nt)
        }
      },
      he = J => Array.isArray(i.value) ? p.value.enabled ? i.value.map(Re => J(Re)) : [J(i.value[0]), i.value[1] ? J(i.value[1]) : Es(l.value.partialRange)] : J(Za(i.value)),
      ke = () => {
        if (Array.isArray(i.value)) {
          const J = Xn(i.value[0], t.weekStart),
            Re = i.value[1] ? Xn(i.value[1], t.weekStart) : [];
          return [J.map(Xe => at(Xe)), Re.map(Xe => at(Xe))]
        }
        return Xn(i.value, t.weekStart).map(J => at(J))
      },
      re = (J, Re) => Je(Za(he(J)), !1, Re),
      Se = J => {
        const Re = ke();
        return J ? Re : e("update:model-value", ke())
      },
      Be = (J = !1) => (J || He(), t.monthPicker ? re(B, J) : t.timePicker ? re(D, J) : t.yearPicker ? re(Tt, J) : t.weekPicker ? Se(J) : Je(le(J), !0, J));
    return {
      inputValue: k,
      internalModelValue: i,
      checkBeforeEmit: () => i.value ? l.value.enabled ? l.value.partialRange ? i.value.length >= 1 : i.value.length === 2 : !!i.value : !1,
      parseExternalModelValue: ye,
      formatInputValue: He,
      emitModelValue: Be
    }
  },
  PP = (e, t) => {
    const {
      defaultedFilters: a,
      propDates: i
    } = _a(e), {
      validateMonthYearInRange: o
    } = Di(e), l = (w, S) => {
      let A = w;
      return a.value.months.includes(zt(A)) ? (A = S ? cn(w, 1) : to(w, 1), l(A, S)) : A
    }, h = (w, S) => {
      let A = w;
      return a.value.years.includes(Tt(A)) ? (A = S ? If(w, 1) : Ey(w, 1), h(A, S)) : A
    }, p = (w, S = !1) => {
      const A = da(at(), {
        month: e.month,
        year: e.year
      });
      let E = w ? cn(A, 1) : to(A, 1);
      e.disableYearSelect && (E = Pn(E, e.year));
      let M = zt(E),
        D = Tt(E);
      a.value.months.includes(M) && (E = l(E, w), M = zt(E), D = Tt(E)), a.value.years.includes(D) && (E = h(E, w), D = Tt(E)), o(M, D, w, e.preventMinMaxNavigation) && m(M, D, S)
    }, m = (w, S, A) => {
      t("update-month-year", {
        month: w,
        year: S,
        fromNav: A
      })
    }, k = Oe(() => w => $y(da(at(), {
      month: e.month,
      year: e.year
    }), i.value.maxDate, i.value.minDate, e.preventMinMaxNavigation, w));
    return {
      handleMonthYearChange: p,
      isDisabled: k,
      updateMonthYear: m
    }
  },
  wu = {
    multiCalendars: {
      type: [Boolean, Number, String, Object],
      default: void 0
    },
    modelValue: {
      type: [String, Date, Array, Object, Number],
      default: null
    },
    modelType: {
      type: String,
      default: null
    },
    position: {
      type: String,
      default: "center"
    },
    dark: {
      type: Boolean,
      default: !1
    },
    format: {
      type: [String, Function],
      default: () => null
    },
    autoPosition: {
      type: Boolean,
      default: !0
    },
    altPosition: {
      type: Function,
      default: null
    },
    transitions: {
      type: [Boolean, Object],
      default: !0
    },
    formatLocale: {
      type: Object,
      default: null
    },
    utc: {
      type: [Boolean, String],
      default: !1
    },
    ariaLabels: {
      type: Object,
      default: () => ({})
    },
    offset: {
      type: [Number, String],
      default: 10
    },
    hideNavigation: {
      type: Array,
      default: () => []
    },
    timezone: {
      type: [String, Object],
      default: null
    },
    vertical: {
      type: Boolean,
      default: !1
    },
    disableMonthYearSelect: {
      type: Boolean,
      default: !1
    },
    disableYearSelect: {
      type: Boolean,
      default: !1
    },
    dayClass: {
      type: Function,
      default: null
    },
    yearRange: {
      type: Array,
      default: () => [1900, 2100]
    },
    enableTimePicker: {
      type: Boolean,
      default: !0
    },
    autoApply: {
      type: Boolean,
      default: !1
    },
    disabledDates: {
      type: [Array, Function],
      default: () => []
    },
    monthNameFormat: {
      type: String,
      default: "short"
    },
    startDate: {
      type: [Date, String],
      default: null
    },
    startTime: {
      type: [Object, Array],
      default: null
    },
    hideOffsetDates: {
      type: Boolean,
      default: !1
    },
    noToday: {
      type: Boolean,
      default: !1
    },
    disabledWeekDays: {
      type: Array,
      default: () => []
    },
    allowedDates: {
      type: Array,
      default: null
    },
    nowButtonLabel: {
      type: String,
      default: "Now"
    },
    markers: {
      type: Array,
      default: () => []
    },
    escClose: {
      type: Boolean,
      default: !0
    },
    spaceConfirm: {
      type: Boolean,
      default: !0
    },
    monthChangeOnArrows: {
      type: Boolean,
      default: !0
    },
    presetDates: {
      type: Array,
      default: () => []
    },
    flow: {
      type: Array,
      default: () => []
    },
    partialFlow: {
      type: Boolean,
      default: !1
    },
    preventMinMaxNavigation: {
      type: Boolean,
      default: !1
    },
    reverseYears: {
      type: Boolean,
      default: !1
    },
    weekPicker: {
      type: Boolean,
      default: !1
    },
    filters: {
      type: Object,
      default: () => ({})
    },
    arrowNavigation: {
      type: Boolean,
      default: !1
    },
    highlight: {
      type: [Function, Object],
      default: null
    },
    teleport: {
      type: [Boolean, String, Object],
      default: null
    },
    teleportCenter: {
      type: Boolean,
      default: !1
    },
    locale: {
      type: String,
      default: "en-Us"
    },
    weekNumName: {
      type: String,
      default: "W"
    },
    weekStart: {
      type: [Number, String],
      default: 1
    },
    weekNumbers: {
      type: [String, Function, Object],
      default: null
    },
    monthChangeOnScroll: {
      type: [Boolean, String],
      default: !0
    },
    dayNames: {
      type: [Function, Array],
      default: null
    },
    monthPicker: {
      type: Boolean,
      default: !1
    },
    customProps: {
      type: Object,
      default: null
    },
    yearPicker: {
      type: Boolean,
      default: !1
    },
    modelAuto: {
      type: Boolean,
      default: !1
    },
    selectText: {
      type: String,
      default: "Select"
    },
    cancelText: {
      type: String,
      default: "Cancel"
    },
    previewFormat: {
      type: [String, Function],
      default: () => ""
    },
    multiDates: {
      type: [Object, Boolean],
      default: !1
    },
    ignoreTimeValidation: {
      type: Boolean,
      default: !1
    },
    minDate: {
      type: [Date, String],
      default: null
    },
    maxDate: {
      type: [Date, String],
      default: null
    },
    minTime: {
      type: Object,
      default: null
    },
    maxTime: {
      type: Object,
      default: null
    },
    name: {
      type: String,
      default: null
    },
    placeholder: {
      type: String,
      default: ""
    },
    hideInputIcon: {
      type: Boolean,
      default: !1
    },
    clearable: {
      type: Boolean,
      default: !0
    },
    state: {
      type: Boolean,
      default: null
    },
    required: {
      type: Boolean,
      default: !1
    },
    autocomplete: {
      type: String,
      default: "off"
    },
    timePicker: {
      type: Boolean,
      default: !1
    },
    enableSeconds: {
      type: Boolean,
      default: !1
    },
    is24: {
      type: Boolean,
      default: !0
    },
    noHoursOverlay: {
      type: Boolean,
      default: !1
    },
    noMinutesOverlay: {
      type: Boolean,
      default: !1
    },
    noSecondsOverlay: {
      type: Boolean,
      default: !1
    },
    hoursGridIncrement: {
      type: [String, Number],
      default: 1
    },
    minutesGridIncrement: {
      type: [String, Number],
      default: 5
    },
    secondsGridIncrement: {
      type: [String, Number],
      default: 5
    },
    hoursIncrement: {
      type: [Number, String],
      default: 1
    },
    minutesIncrement: {
      type: [Number, String],
      default: 1
    },
    secondsIncrement: {
      type: [Number, String],
      default: 1
    },
    range: {
      type: [Boolean, Object],
      default: !1
    },
    uid: {
      type: String,
      default: null
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    readonly: {
      type: Boolean,
      default: !1
    },
    inline: {
      type: [Boolean, Object],
      default: !1
    },
    textInput: {
      type: [Boolean, Object],
      default: !1
    },
    sixWeeks: {
      type: [Boolean, String],
      default: !1
    },
    actionRow: {
      type: Object,
      default: () => ({})
    },
    focusStartDate: {
      type: Boolean,
      default: !1
    },
    disabledTimes: {
      type: [Function, Array],
      default: void 0
    },
    timePickerInline: {
      type: Boolean,
      default: !1
    },
    calendar: {
      type: Function,
      default: null
    },
    config: {
      type: Object,
      default: void 0
    },
    quarterPicker: {
      type: Boolean,
      default: !1
    },
    yearFirst: {
      type: Boolean,
      default: !1
    },
    loading: {
      type: Boolean,
      default: !1
    },
    onInternalModelChange: {
      type: [Function, Object],
      default: null
    },
    enableMinutes: {
      type: Boolean,
      default: !0
    },
    ui: {
      type: Object,
      default: () => ({})
    }
  },
  bn = {
    ...wu,
    shadow: {
      type: Boolean,
      default: !1
    },
    flowStep: {
      type: Number,
      default: 0
    },
    internalModelValue: {
      type: [Date, Array],
      default: null
    },
    noOverlayFocus: {
      type: Boolean,
      default: !1
    },
    collapse: {
      type: Boolean,
      default: !1
    },
    menuWrapRef: {
      type: Object,
      default: null
    },
    getInputRect: {
      type: Function,
      default: () => ({})
    },
    isTextInputDate: {
      type: Boolean,
      default: !1
    }
  },
  LP = ["title"],
  OP = ["disabled"],
  MP = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "ActionRow",
    props: {
      menuMount: {
        type: Boolean,
        default: !1
      },
      calendarWidth: {
        type: Number,
        default: 0
      },
      ...bn
    },
    emits: ["close-picker", "select-date", "select-now", "invalid-select"],
    setup(e, {
      emit: t
    }) {
      const a = t,
        i = e,
        {
          defaultedActionRow: o,
          defaultedPreviewFormat: l,
          defaultedMultiCalendars: h,
          defaultedTextInput: p,
          defaultedInline: m,
          defaultedRange: k,
          defaultedMultiDates: w,
          getDefaultPattern: S
        } = _a(i),
        {
          isTimeValid: A,
          isMonthValid: E
        } = Di(i),
        {
          buildMatrix: M
        } = Ri(),
        D = _e(null),
        B = _e(null),
        z = _e(!1),
        I = _e({}),
        N = _e(null),
        U = _e(null);
      Dt(() => {
        i.arrowNavigation && M([Wa(D), Wa(B)], "actionRow"), W(), window.addEventListener("resize", W)
      }), Ha(() => {
        window.removeEventListener("resize", W)
      });
      const W = () => {
          z.value = !1, setTimeout(() => {
            var ve, me;
            const Ae = (ve = N.value) == null ? void 0 : ve.getBoundingClientRect(),
              He = (me = U.value) == null ? void 0 : me.getBoundingClientRect();
            Ae && He && (I.value.maxWidth = `${He.width-Ae.width-20}px`), z.value = !0
          }, 0)
        },
        X = Oe(() => k.value.enabled && !k.value.partialRange && i.internalModelValue ? i.internalModelValue.length === 2 : !0),
        V = Oe(() => !A.value(i.internalModelValue) || !E.value(i.internalModelValue) || !X.value),
        ne = () => {
          const ve = l.value;
          return i.timePicker || i.monthPicker, ve(Za(i.internalModelValue))
        },
        Z = () => {
          const ve = i.internalModelValue;
          return h.value.count > 0 ? `${ie(ve[0])} - ${ie(ve[1])}` : [ie(ve[0]), ie(ve[1])]
        },
        ie = ve => By(ve, l.value, i.formatLocale, p.value.rangeSeparator, i.modelAuto, S()),
        fe = Oe(() => !i.internalModelValue || !i.menuMount ? "" : typeof l.value == "string" ? Array.isArray(i.internalModelValue) ? i.internalModelValue.length === 2 && i.internalModelValue[1] ? Z() : w.value.enabled ? i.internalModelValue.map(ve => `${ie(ve)}`) : i.modelAuto ? `${ie(i.internalModelValue[0])}` : `${ie(i.internalModelValue[0])} -` : ie(i.internalModelValue) : ne()),
        le = () => w.value.enabled ? "; " : " - ",
        Ee = Oe(() => Array.isArray(fe.value) ? fe.value.join(le()) : fe.value),
        ye = () => {
          A.value(i.internalModelValue) && E.value(i.internalModelValue) && X.value ? a("select-date") : a("invalid-select")
        };
      return (ve, me) => (be(), Ne("div", {
        ref_key: "actionRowRef",
        ref: U,
        class: "dp__action_row"
      }, [ve.$slots["action-row"] ? lt(ve.$slots, "action-row", Ja(ja({
        key: 0
      }, {
        internalModelValue: ve.internalModelValue,
        disabled: V.value,
        selectDate: () => ve.$emit("select-date"),
        closePicker: () => ve.$emit("close-picker")
      }))) : (be(), Ne(vt, {
        key: 1
      }, [se(o).showPreview ? (be(), Ne("div", {
        key: 0,
        class: "dp__selection_preview",
        title: Ee.value,
        style: pr(I.value)
      }, [ve.$slots["action-preview"] && z.value ? lt(ve.$slots, "action-preview", {
        key: 0,
        value: ve.internalModelValue
      }) : Ke("", !0), !ve.$slots["action-preview"] && z.value ? (be(), Ne(vt, {
        key: 1
      }, [$t(st(Ee.value), 1)], 64)) : Ke("", !0)], 12, LP)) : Ke("", !0), ce("div", {
        ref_key: "actionBtnContainer",
        ref: N,
        class: "dp__action_buttons",
        "data-dp-element": "action-row"
      }, [ve.$slots["action-buttons"] ? lt(ve.$slots, "action-buttons", {
        key: 0,
        value: ve.internalModelValue
      }) : Ke("", !0), ve.$slots["action-buttons"] ? Ke("", !0) : (be(), Ne(vt, {
        key: 1
      }, [!se(m).enabled && se(o).showCancel ? (be(), Ne("button", {
        key: 0,
        ref_key: "cancelButtonRef",
        ref: D,
        type: "button",
        class: "dp__action_button dp__action_cancel",
        onClick: me[0] || (me[0] = Ae => ve.$emit("close-picker")),
        onKeydown: me[1] || (me[1] = Ae => se(Cr)(Ae, () => ve.$emit("close-picker")))
      }, st(ve.cancelText), 545)) : Ke("", !0), se(o).showNow ? (be(), Ne("button", {
        key: 1,
        type: "button",
        class: "dp__action_button dp__action_cancel",
        onClick: me[2] || (me[2] = Ae => ve.$emit("select-now")),
        onKeydown: me[3] || (me[3] = Ae => se(Cr)(Ae, () => ve.$emit("select-now")))
      }, st(ve.nowButtonLabel), 33)) : Ke("", !0), se(o).showSelect ? (be(), Ne("button", {
        key: 2,
        ref_key: "selectButtonRef",
        ref: B,
        type: "button",
        class: "dp__action_button dp__action_select",
        disabled: V.value,
        "data-test": "select-button",
        onKeydown: me[4] || (me[4] = Ae => se(Cr)(Ae, () => ye())),
        onClick: ye
      }, st(ve.selectText), 41, OP)) : Ke("", !0)], 64))], 512)], 64))], 512))
    }
  }),
  IP = ["role", "aria-label", "tabindex"],
  RP = {
    class: "dp__selection_grid_header"
  },
  DP = ["aria-selected", "aria-disabled", "data-test", "onClick", "onKeydown", "onMouseover"],
  NP = ["aria-label"],
  Ol = Ot({
    __name: "SelectionOverlay",
    props: {
      items: {},
      type: {},
      isLast: {
        type: Boolean
      },
      arrowNavigation: {
        type: Boolean
      },
      skipButtonRef: {
        type: Boolean
      },
      headerRefs: {},
      hideNavigation: {},
      escClose: {
        type: Boolean
      },
      useRelative: {
        type: Boolean
      },
      height: {},
      textInput: {
        type: [Boolean, Object]
      },
      config: {},
      noOverlayFocus: {
        type: Boolean
      },
      focusValue: {},
      menuWrapRef: {},
      ariaLabels: {},
      overlayLabel: {}
    },
    emits: ["selected", "toggle", "reset-flow", "hover-value"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const {
        setSelectionGrid: i,
        buildMultiLevelMatrix: o,
        setMonthPicker: l
      } = Ri(), h = a, p = e, {
        defaultedAriaLabels: m,
        defaultedTextInput: k,
        defaultedConfig: w
      } = _a(p), {
        hideNavigationButtons: S
      } = Su(), A = _e(!1), E = _e(null), M = _e(null), D = _e([]), B = _e(), z = _e(null), I = _e(0), N = _e(null);
      Nb(() => {
        E.value = null
      }), Dt(() => {
        Jt().then(() => fe()), p.noOverlayFocus || W(), U(!0)
      }), Ha(() => U(!1));
      const U = he => {
          var ke;
          p.arrowNavigation && ((ke = p.headerRefs) != null && ke.length ? l(he) : i(he))
        },
        W = () => {
          var he;
          const ke = Wa(M);
          ke && (k.value.enabled || (E.value ? (he = E.value) == null || he.focus({
            preventScroll: !0
          }) : ke.focus({
            preventScroll: !0
          })), A.value = ke.clientHeight < ke.scrollHeight)
        },
        X = Oe(() => ({
          dp__overlay: !0,
          "dp--overlay-absolute": !p.useRelative,
          "dp--overlay-relative": p.useRelative
        })),
        V = Oe(() => p.useRelative ? {
          height: `${p.height}px`,
          width: "260px"
        } : void 0),
        ne = Oe(() => ({
          dp__overlay_col: !0
        })),
        Z = Oe(() => ({
          dp__btn: !0,
          dp__button: !0,
          dp__overlay_action: !0,
          dp__over_action_scroll: A.value,
          dp__button_bottom: p.isLast
        })),
        ie = Oe(() => {
          var he, ke;
          return {
            dp__overlay_container: !0,
            dp__container_flex: ((he = p.items) == null ? void 0 : he.length) <= 6,
            dp__container_block: ((ke = p.items) == null ? void 0 : ke.length) > 6
          }
        });
      Xt(() => p.items, () => fe(!1), {
        deep: !0
      });
      const fe = (he = !0) => {
          Jt().then(() => {
            const ke = Wa(E),
              re = Wa(M),
              Se = Wa(z),
              Be = Wa(N),
              J = Se ? Se.getBoundingClientRect().height : 0;
            re && (re.getBoundingClientRect().height ? I.value = re.getBoundingClientRect().height - J : I.value = w.value.modeHeight - J), ke && Be && he && (Be.scrollTop = ke.offsetTop - Be.offsetTop - (I.value / 2 - ke.getBoundingClientRect().height) - J)
          })
        },
        le = he => {
          he.disabled || h("selected", he.value)
        },
        Ee = () => {
          h("toggle"), h("reset-flow")
        },
        ye = () => {
          p.escClose && Ee()
        },
        ve = (he, ke, re, Se) => {
          he && ((ke.active || ke.value === p.focusValue) && (E.value = he), p.arrowNavigation && (Array.isArray(D.value[re]) ? D.value[re][Se] = he : D.value[re] = [he], me()))
        },
        me = () => {
          var he, ke;
          const re = (he = p.headerRefs) != null && he.length ? [p.headerRefs].concat(D.value) : D.value.concat([p.skipButtonRef ? [] : [z.value]]);
          o(Za(re), (ke = p.headerRefs) != null && ke.length ? "monthPicker" : "selectionGrid")
        },
        Ae = he => {
          p.arrowNavigation || _i(he, w.value, !0)
        },
        He = he => {
          B.value = he, h("hover-value", he)
        },
        De = () => {
          if (Ee(), !p.isLast) {
            const he = Eh(p.menuWrapRef ?? null, "action-row");
            if (he) {
              const ke = My(he);
              ke == null || ke.focus()
            }
          }
        },
        Ye = he => {
          switch (he.key) {
            case ba.esc:
              return ye();
            case ba.arrowLeft:
              return Ae(he);
            case ba.arrowRight:
              return Ae(he);
            case ba.arrowUp:
              return Ae(he);
            case ba.arrowDown:
              return Ae(he);
            default:
              return
          }
        },
        Je = he => {
          if (he.key === ba.enter) return Ee();
          if (he.key === ba.tab) return De()
        };
      return t({
        focusGrid: W
      }), (he, ke) => {
        var re;
        return be(), Ne("div", {
          ref_key: "gridWrapRef",
          ref: M,
          class: ut(X.value),
          style: pr(V.value),
          role: he.useRelative ? void 0 : "dialog",
          "aria-label": he.overlayLabel,
          tabindex: he.useRelative ? void 0 : "0",
          onKeydown: Ye,
          onClick: ke[0] || (ke[0] = qn(() => {}, ["prevent"]))
        }, [ce("div", {
          ref_key: "containerRef",
          ref: N,
          class: ut(ie.value),
          style: pr({
            "--dp-overlay-height": `${I.value}px`
          }),
          role: "grid"
        }, [ce("div", RP, [lt(he.$slots, "header")]), he.$slots.overlay ? lt(he.$slots, "overlay", {
          key: 0
        }) : (be(!0), Ne(vt, {
          key: 1
        }, la(he.items, (Se, Be) => (be(), Ne("div", {
          key: Be,
          class: ut(["dp__overlay_row", {
            dp__flex_row: he.items.length >= 3
          }]),
          role: "row"
        }, [(be(!0), Ne(vt, null, la(Se, (J, Re) => (be(), Ne("div", {
          key: J.value,
          ref_for: !0,
          ref: Xe => ve(Xe, J, Be, Re),
          role: "gridcell",
          class: ut(ne.value),
          "aria-selected": J.active || void 0,
          "aria-disabled": J.disabled || void 0,
          tabindex: "0",
          "data-test": J.text,
          onClick: qn(Xe => le(J), ["prevent"]),
          onKeydown: Xe => se(Cr)(Xe, () => le(J), !0),
          onMouseover: Xe => He(J.value)
        }, [ce("div", {
          class: ut(J.className)
        }, [he.$slots.item ? lt(he.$slots, "item", {
          key: 0,
          item: J
        }) : Ke("", !0), he.$slots.item ? Ke("", !0) : (be(), Ne(vt, {
          key: 1
        }, [$t(st(J.text), 1)], 64))], 2)], 42, DP))), 128))], 2))), 128))], 6), he.$slots["button-icon"] ? Vs((be(), Ne("button", {
          key: 0,
          ref_key: "toggleButton",
          ref: z,
          type: "button",
          "aria-label": (re = se(m)) == null ? void 0 : re.toggleOverlay,
          class: ut(Z.value),
          tabindex: "0",
          onClick: Ee,
          onKeydown: Je
        }, [lt(he.$slots, "button-icon")], 42, NP)), [
          [pc, !se(S)(he.hideNavigation, he.type)]
        ]) : Ke("", !0)], 46, IP)
      }
    }
  }),
  ku = Ot({
    __name: "InstanceWrap",
    props: {
      multiCalendars: {},
      stretch: {
        type: Boolean
      },
      collapse: {
        type: Boolean
      }
    },
    setup(e) {
      const t = e,
        a = Oe(() => t.multiCalendars > 0 ? [...Array(t.multiCalendars).keys()] : [0]),
        i = Oe(() => ({
          dp__instance_calendar: t.multiCalendars > 0
        }));
      return (o, l) => (be(), Ne("div", {
        class: ut({
          dp__menu_inner: !o.stretch,
          "dp--menu--inner-stretched": o.stretch,
          dp__flex_display: o.multiCalendars > 0,
          "dp--flex-display-collapsed": o.collapse
        })
      }, [(be(!0), Ne(vt, null, la(a.value, (h, p) => (be(), Ne("div", {
        key: h,
        class: ut(i.value)
      }, [lt(o.$slots, "default", {
        instance: h,
        index: p
      })], 2))), 128))], 2))
    }
  }),
  FP = ["data-dp-element", "aria-label", "aria-disabled"],
  tl = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "ArrowBtn",
    props: {
      ariaLabel: {},
      elName: {},
      disabled: {
        type: Boolean
      }
    },
    emits: ["activate", "set-ref"],
    setup(e, {
      emit: t
    }) {
      const a = t,
        i = _e(null);
      return Dt(() => a("set-ref", i)), (o, l) => (be(), Ne("button", {
        ref_key: "elRef",
        ref: i,
        type: "button",
        "data-dp-element": o.elName,
        class: "dp__btn dp--arrow-btn-nav",
        tabindex: "0",
        "aria-label": o.ariaLabel,
        "aria-disabled": o.disabled || void 0,
        onClick: l[0] || (l[0] = h => o.$emit("activate")),
        onKeydown: l[1] || (l[1] = h => se(Cr)(h, () => o.$emit("activate"), !0))
      }, [ce("span", {
        class: ut(["dp__inner_nav", {
          dp__inner_nav_disabled: o.disabled
        }])
      }, [lt(o.$slots, "default")], 2)], 40, FP))
    }
  }),
  $P = ["aria-label", "data-test"],
  Xy = Ot({
    __name: "YearModePicker",
    props: {
      ...bn,
      showYearPicker: {
        type: Boolean,
        default: !1
      },
      items: {
        type: Array,
        default: () => []
      },
      instance: {
        type: Number,
        default: 0
      },
      year: {
        type: Number,
        default: 0
      },
      isDisabled: {
        type: Function,
        default: () => !1
      }
    },
    emits: ["toggle-year-picker", "year-select", "handle-year"],
    setup(e, {
      emit: t
    }) {
      const a = t,
        i = e,
        {
          showRightIcon: o,
          showLeftIcon: l
        } = Su(),
        {
          defaultedConfig: h,
          defaultedMultiCalendars: p,
          defaultedAriaLabels: m,
          defaultedTransitions: k,
          defaultedUI: w
        } = _a(i),
        {
          showTransition: S,
          transitionName: A
        } = Ml(k),
        E = _e(!1),
        M = (z = !1, I) => {
          E.value = !E.value, a("toggle-year-picker", {
            flow: z,
            show: I
          })
        },
        D = z => {
          E.value = !1, a("year-select", z)
        },
        B = (z = !1) => {
          a("handle-year", z)
        };
      return (z, I) => {
        var N, U, W, X, V;
        return be(), Ne(vt, null, [ce("div", {
          class: ut(["dp--year-mode-picker", {
            "dp--hidden-el": E.value
          }])
        }, [se(l)(se(p), e.instance) ? (be(), yt(tl, {
          key: 0,
          ref: "mpPrevIconRef",
          "aria-label": (N = se(m)) == null ? void 0 : N.prevYear,
          disabled: e.isDisabled(!1),
          class: ut((U = se(w)) == null ? void 0 : U.navBtnPrev),
          onActivate: I[0] || (I[0] = ne => B(!1))
        }, {
          default: Qe(() => [z.$slots["arrow-left"] ? lt(z.$slots, "arrow-left", {
            key: 0
          }) : Ke("", !0), z.$slots["arrow-left"] ? Ke("", !0) : (be(), yt(se(Bf), {
            key: 1
          }))]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : Ke("", !0), ce("button", {
          ref: "mpYearButtonRef",
          class: "dp__btn dp--year-select",
          type: "button",
          "aria-label": `${e.year}-${(W=se(m))==null?void 0:W.openYearsOverlay}`,
          "data-test": `year-mode-btn-${e.instance}`,
          onClick: I[1] || (I[1] = () => M(!1)),
          onKeydown: I[2] || (I[2] = L_(() => M(!1), ["enter"]))
        }, [z.$slots.year ? lt(z.$slots, "year", {
          key: 0,
          year: e.year
        }) : Ke("", !0), z.$slots.year ? Ke("", !0) : (be(), Ne(vt, {
          key: 1
        }, [$t(st(e.year), 1)], 64))], 40, $P), se(o)(se(p), e.instance) ? (be(), yt(tl, {
          key: 1,
          ref: "mpNextIconRef",
          "aria-label": (X = se(m)) == null ? void 0 : X.nextYear,
          disabled: e.isDisabled(!0),
          class: ut((V = se(w)) == null ? void 0 : V.navBtnNext),
          onActivate: I[3] || (I[3] = ne => B(!0))
        }, {
          default: Qe(() => [z.$slots["arrow-right"] ? lt(z.$slots, "arrow-right", {
            key: 0
          }) : Ke("", !0), z.$slots["arrow-right"] ? Ke("", !0) : (be(), yt(se(Hf), {
            key: 1
          }))]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : Ke("", !0)], 2), Ze(In, {
          name: se(A)(e.showYearPicker),
          css: se(S)
        }, {
          default: Qe(() => {
            var ne, Z;
            return [e.showYearPicker ? (be(), yt(Ol, {
              key: 0,
              items: e.items,
              "text-input": z.textInput,
              "esc-close": z.escClose,
              config: z.config,
              "is-last": z.autoApply && !se(h).keepActionRow,
              "hide-navigation": z.hideNavigation,
              "aria-labels": z.ariaLabels,
              "overlay-label": (Z = (ne = se(m)) == null ? void 0 : ne.yearPicker) == null ? void 0 : Z.call(ne, !0),
              type: "year",
              onToggle: M,
              onSelected: I[4] || (I[4] = ie => D(ie))
            }, mr({
              "button-icon": Qe(() => [z.$slots["calendar-icon"] ? lt(z.$slots, "calendar-icon", {
                key: 0
              }) : Ke("", !0), z.$slots["calendar-icon"] ? Ke("", !0) : (be(), yt(se(mo), {
                key: 1
              }))]),
              _: 2
            }, [z.$slots["year-overlay-value"] ? {
              name: "item",
              fn: Qe(({
                item: ie
              }) => [lt(z.$slots, "year-overlay-value", {
                text: ie.text,
                value: ie.value
              })]),
              key: "0"
            } : void 0]), 1032, ["items", "text-input", "esc-close", "config", "is-last", "hide-navigation", "aria-labels", "overlay-label"])) : Ke("", !0)]
          }),
          _: 3
        }, 8, ["name", "css"])], 64)
      }
    }
  }),
  qf = (e, t, a) => {
    if (t.value && Array.isArray(t.value))
      if (t.value.some(i => Vt(e, i))) {
        const i = t.value.filter(o => !Vt(o, e));
        t.value = i.length ? i : null
      } else(a && +a > t.value.length || !a) && t.value.push(e);
    else t.value = [e]
  },
  Kf = (e, t, a) => {
    let i = e.value ? e.value.slice() : [];
    return i.length === 2 && i[1] !== null && (i = []), i.length ? Pa(t, i[0]) ? (i.unshift(t), a("range-start", i[0]), a("range-start", i[1])) : (i[1] = t, a("range-end", t)) : (i = [t], a("range-start", t)), i
  },
  _u = (e, t, a, i) => {
    e && (e[0] && e[1] && a && t("auto-apply"), e[0] && !e[1] && i && a && t("auto-apply"))
  },
  Wy = e => {
    Array.isArray(e.value) && e.value.length <= 2 && e.range ? e.modelValue.value = e.value.map(t => $r(at(t), e.timezone)) : Array.isArray(e.value) || (e.modelValue.value = $r(at(e.value), e.timezone))
  },
  Vy = (e, t, a, i) => Array.isArray(t.value) && (t.value.length === 2 || t.value.length === 1 && i.value.partialRange) ? i.value.fixedStart && (Ia(e, t.value[0]) || Vt(e, t.value[0])) ? [t.value[0], e] : i.value.fixedEnd && (Pa(e, t.value[1]) || Vt(e, t.value[1])) ? [e, t.value[1]] : (a("invalid-fixed-range", e), t.value) : [],
  jy = ({
    multiCalendars: e,
    range: t,
    highlight: a,
    propDates: i,
    calendars: o,
    modelValue: l,
    props: h,
    filters: p,
    year: m,
    month: k,
    emit: w
  }) => {
    const S = Oe(() => Vf(h.yearRange, h.locale, h.reverseYears)),
      A = _e([!1]),
      E = Oe(() => (ie, fe) => {
        const le = da(sn(new Date), {
            month: k.value(ie),
            year: m.value(ie)
          }),
          Ee = fe ? gy(le) : gl(le);
        return $y(Ee, i.value.maxDate, i.value.minDate, h.preventMinMaxNavigation, fe)
      }),
      M = () => Array.isArray(l.value) && e.value.solo && l.value[1],
      D = () => {
        for (let ie = 0; ie < e.value.count; ie++)
          if (ie === 0) o.value[ie] = o.value[0];
          else if (ie === e.value.count - 1 && M()) o.value[ie] = {
          month: zt(l.value[1]),
          year: Tt(l.value[1])
        };
        else {
          const fe = da(at(), o.value[ie - 1]);
          o.value[ie] = {
            month: zt(fe),
            year: Tt(If(fe, 1))
          }
        }
      },
      B = ie => {
        if (!ie) return D();
        const fe = da(at(), o.value[ie]);
        return o.value[0].year = Tt(Ey(fe, e.value.count - 1)), D()
      },
      z = (ie, fe) => {
        const le = KC(fe, ie);
        return t.value.showLastInRange && le > 1 ? fe : ie
      },
      I = ie => h.focusStartDate || e.value.solo ? ie[0] : ie[1] ? z(ie[0], ie[1]) : ie[0],
      N = () => {
        if (l.value) {
          const ie = Array.isArray(l.value) ? I(l.value) : l.value;
          o.value[0] = {
            month: zt(ie),
            year: Tt(ie)
          }
        }
      },
      U = () => {
        N(), e.value.count && D()
      };
    Xt(l, (ie, fe) => {
      h.isTextInputDate && JSON.stringify(ie ?? {}) !== JSON.stringify(fe ?? {}) && U()
    }), Dt(() => {
      U()
    });
    const W = (ie, fe) => {
        o.value[fe].year = ie, w("update-month-year", {
          instance: fe,
          year: ie,
          month: o.value[fe].month
        }), e.value.count && !e.value.solo && B(fe)
      },
      X = Oe(() => ie => ao(S.value, fe => {
        var le;
        const Ee = m.value(ie) === fe.value,
          ye = vl(fe.value, ro(i.value.minDate), ro(i.value.maxDate)) || ((le = p.value.years) == null ? void 0 : le.includes(m.value(ie))),
          ve = Gf(a.value, fe.value);
        return {
          active: Ee,
          disabled: ye,
          highlighted: ve
        }
      })),
      V = (ie, fe) => {
        W(ie, fe), Z(fe)
      },
      ne = (ie, fe = !1) => {
        if (!E.value(ie, fe)) {
          const le = fe ? m.value(ie) + 1 : m.value(ie) - 1;
          W(le, ie)
        }
      },
      Z = (ie, fe = !1, le) => {
        fe || w("reset-flow"), le !== void 0 ? A.value[ie] = le : A.value[ie] = !A.value[ie], A.value[ie] ? w("overlay-toggle", {
          open: !0,
          overlay: hr.year
        }) : (w("overlay-closed"), w("overlay-toggle", {
          open: !1,
          overlay: hr.year
        }))
      };
    return {
      isDisabled: E,
      groupedYears: X,
      showYearPicker: A,
      selectYear: W,
      toggleYearPicker: Z,
      handleYearSelect: V,
      handleYear: ne
    }
  },
  BP = (e, t) => {
    const {
      defaultedMultiCalendars: a,
      defaultedAriaLabels: i,
      defaultedTransitions: o,
      defaultedConfig: l,
      defaultedRange: h,
      defaultedHighlight: p,
      propDates: m,
      defaultedTz: k,
      defaultedFilters: w,
      defaultedMultiDates: S
    } = _a(e), A = () => {
      e.isTextInputDate && U(Tt(at(e.startDate)), 0)
    }, {
      modelValue: E,
      year: M,
      month: D,
      calendars: B
    } = Il(e, t, A), z = Oe(() => Ly(e.formatLocale, e.locale, e.monthNameFormat)), I = _e(null), {
      checkMinMaxRange: N
    } = Di(e), {
      selectYear: U,
      groupedYears: W,
      showYearPicker: X,
      toggleYearPicker: V,
      handleYearSelect: ne,
      handleYear: Z,
      isDisabled: ie
    } = jy({
      modelValue: E,
      multiCalendars: a,
      range: h,
      highlight: p,
      calendars: B,
      year: M,
      propDates: m,
      month: D,
      filters: w,
      props: e,
      emit: t
    });
    Dt(() => {
      e.startDate && (E.value && e.focusStartDate || !E.value) && U(Tt(at(e.startDate)), 0)
    });
    const fe = re => re ? {
        month: zt(re),
        year: Tt(re)
      } : {
        month: null,
        year: null
      },
      le = () => E.value ? Array.isArray(E.value) ? E.value.map(re => fe(re)) : fe(E.value) : fe(),
      Ee = (re, Se) => {
        const Be = B.value[re],
          J = le();
        return Array.isArray(J) ? J.some(Re => Re.year === (Be == null ? void 0 : Be.year) && Re.month === Se) : (Be == null ? void 0 : Be.year) === J.year && Se === J.month
      },
      ye = (re, Se, Be) => {
        var J, Re;
        const Xe = le();
        return Array.isArray(Xe) ? M.value(Se) === ((J = Xe[Be]) == null ? void 0 : J.year) && re === ((Re = Xe[Be]) == null ? void 0 : Re.month) : !1
      },
      ve = (re, Se) => {
        if (h.value.enabled) {
          const Be = le();
          if (Array.isArray(E.value) && Array.isArray(Be)) {
            const J = ye(re, Se, 0) || ye(re, Se, 1),
              Re = jn(sn(at()), re, M.value(Se));
            return xu(E.value, I.value, Re) && !J
          }
          return !1
        }
        return !1
      },
      me = Oe(() => re => ao(z.value, Se => {
        var Be;
        const J = Ee(re, Se.value),
          Re = vl(Se.value, Ry(M.value(re), m.value.minDate), Dy(M.value(re), m.value.maxDate)) || uP(m.value.disabledDates, M.value(re)).includes(Se.value) || ((Be = w.value.months) == null ? void 0 : Be.includes(Se.value)),
          Xe = ve(Se.value, re),
          nt = Hy(p.value, Se.value, M.value(re));
        return {
          active: J,
          disabled: Re,
          isBetween: Xe,
          highlighted: nt
        }
      })),
      Ae = (re, Se) => jn(sn(at()), re, M.value(Se)),
      He = (re, Se) => {
        const Be = E.value ? E.value : sn(new Date);
        E.value = jn(Be, re, M.value(Se)), t("auto-apply"), t("update-flow-step")
      },
      De = (re, Se) => {
        const Be = Ae(re, Se);
        h.value.fixedEnd || h.value.fixedStart ? E.value = Vy(Be, E, t, h) : E.value ? N(Be, E.value) && (E.value = Kf(E, Ae(re, Se), t)) : E.value = [Ae(re, Se)], Jt().then(() => {
          _u(E.value, t, e.autoApply, e.modelAuto)
        })
      },
      Ye = (re, Se) => {
        qf(Ae(re, Se), E, S.value.limit), t("auto-apply", !0)
      },
      Je = (re, Se) => (B.value[Se].month = re, ke(Se, B.value[Se].year, re), S.value.enabled ? Ye(re, Se) : h.value.enabled ? De(re, Se) : He(re, Se)),
      he = (re, Se) => {
        U(re, Se), ke(Se, re, null)
      },
      ke = (re, Se, Be) => {
        let J = Be;
        if (!J && J !== 0) {
          const Re = le();
          J = Array.isArray(Re) ? Re[re].month : Re.month
        }
        t("update-month-year", {
          instance: re,
          year: Se,
          month: J
        })
      };
    return {
      groupedMonths: me,
      groupedYears: W,
      year: M,
      isDisabled: ie,
      defaultedMultiCalendars: a,
      defaultedAriaLabels: i,
      defaultedTransitions: o,
      defaultedConfig: l,
      showYearPicker: X,
      modelValue: E,
      presetDate: (re, Se) => {
        Wy({
          value: re,
          modelValue: E,
          range: h.value.enabled,
          timezone: Se ? void 0 : k.value.timezone
        }), t("auto-apply")
      },
      setHoverDate: (re, Se) => {
        I.value = Ae(re, Se)
      },
      selectMonth: Je,
      selectYear: he,
      toggleYearPicker: V,
      handleYearSelect: ne,
      handleYear: Z,
      getModelMonthYear: le
    }
  },
  HP = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "MonthPicker",
    props: {
      ...bn
    },
    emits: ["update:internal-model-value", "overlay-closed", "reset-flow", "range-start", "range-end", "auto-apply", "update-month-year", "update-flow-step", "mount", "invalid-fixed-range", "overlay-toggle"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = vs(),
        l = Ur(o, "yearMode"),
        h = e;
      Dt(() => {
        h.shadow || i("mount", null)
      });
      const {
        groupedMonths: p,
        groupedYears: m,
        year: k,
        isDisabled: w,
        defaultedMultiCalendars: S,
        defaultedConfig: A,
        showYearPicker: E,
        modelValue: M,
        presetDate: D,
        setHoverDate: B,
        selectMonth: z,
        selectYear: I,
        toggleYearPicker: N,
        handleYearSelect: U,
        handleYear: W,
        getModelMonthYear: X
      } = BP(h, i);
      return t({
        getSidebarProps: () => ({
          modelValue: M,
          year: k,
          getModelMonthYear: X,
          selectMonth: z,
          selectYear: I,
          handleYear: W
        }),
        presetDate: D,
        toggleYearPicker: V => N(0, V)
      }), (V, ne) => (be(), yt(ku, {
        "multi-calendars": se(S).count,
        collapse: V.collapse,
        stretch: ""
      }, {
        default: Qe(({
          instance: Z
        }) => [V.$slots["top-extra"] ? lt(V.$slots, "top-extra", {
          key: 0,
          value: V.internalModelValue
        }) : Ke("", !0), V.$slots["month-year"] ? lt(V.$slots, "month-year", Ja(ja({
          key: 1
        }, {
          year: se(k),
          months: se(p)(Z),
          years: se(m)(Z),
          selectMonth: se(z),
          selectYear: se(I),
          instance: Z
        }))) : (be(), yt(Ol, {
          key: 2,
          items: se(p)(Z),
          "arrow-navigation": V.arrowNavigation,
          "is-last": V.autoApply && !se(A).keepActionRow,
          "esc-close": V.escClose,
          height: se(A).modeHeight,
          config: V.config,
          "no-overlay-focus": !!(V.noOverlayFocus || V.textInput),
          "use-relative": "",
          type: "month",
          onSelected: ie => se(z)(ie, Z),
          onHoverValue: ie => se(B)(ie, Z)
        }, mr({
          header: Qe(() => [Ze(Xy, ja(V.$props, {
            items: se(m)(Z),
            instance: Z,
            "show-year-picker": se(E)[Z],
            year: se(k)(Z),
            "is-disabled": ie => se(w)(Z, ie),
            onHandleYear: ie => se(W)(Z, ie),
            onYearSelect: ie => se(U)(ie, Z),
            onToggleYearPicker: ie => se(N)(Z, ie == null ? void 0 : ie.flow, ie == null ? void 0 : ie.show)
          }), mr({
            _: 2
          }, [la(se(l), (ie, fe) => ({
            name: ie,
            fn: Qe(le => [lt(V.$slots, ie, Ja(Ar(le)))])
          }))]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])]),
          _: 2
        }, [V.$slots["month-overlay-value"] ? {
          name: "item",
          fn: Qe(({
            item: ie
          }) => [lt(V.$slots, "month-overlay-value", {
            text: ie.text,
            value: ie.value
          })]),
          key: "0"
        } : void 0]), 1032, ["items", "arrow-navigation", "is-last", "esc-close", "height", "config", "no-overlay-focus", "onSelected", "onHoverValue"]))]),
        _: 3
      }, 8, ["multi-calendars", "collapse"]))
    }
  }),
  YP = (e, t) => {
    const a = () => {
        e.isTextInputDate && (w.value = Tt(at(e.startDate)))
      },
      {
        modelValue: i
      } = Il(e, t, a),
      o = _e(null),
      {
        defaultedHighlight: l,
        defaultedMultiDates: h,
        defaultedFilters: p,
        defaultedRange: m,
        propDates: k
      } = _a(e),
      w = _e();
    Dt(() => {
      e.startDate && (i.value && e.focusStartDate || !i.value) && (w.value = Tt(at(e.startDate)))
    });
    const S = D => Array.isArray(i.value) ? i.value.some(B => Tt(B) === D) : i.value ? Tt(i.value) === D : !1,
      A = D => m.value.enabled && Array.isArray(i.value) ? xu(i.value, o.value, M(D)) : !1,
      E = Oe(() => ao(Vf(e.yearRange, e.locale, e.reverseYears), D => {
        const B = S(D.value),
          z = vl(D.value, ro(k.value.minDate), ro(k.value.maxDate)) || p.value.years.includes(D.value),
          I = A(D.value) && !B,
          N = Gf(l.value, D.value);
        return {
          active: B,
          disabled: z,
          isBetween: I,
          highlighted: N
        }
      })),
      M = D => Pn(sn(gl(new Date)), D);
    return {
      groupedYears: E,
      modelValue: i,
      focusYear: w,
      setHoverValue: D => {
        o.value = Pn(sn(new Date), D)
      },
      selectYear: D => {
        var B;
        if (t("update-month-year", {
            instance: 0,
            year: D
          }), h.value.enabled) return i.value ? Array.isArray(i.value) && (((B = i.value) == null ? void 0 : B.map(z => Tt(z))).includes(D) ? i.value = i.value.filter(z => Tt(z) !== D) : i.value.push(Pn(Pr(at()), D))) : i.value = [Pn(Pr(gl(at())), D)], t("auto-apply", !0);
        m.value.enabled ? (i.value = Kf(i, M(D), t), Jt().then(() => {
          _u(i.value, t, e.autoApply, e.modelAuto)
        })) : (i.value = M(D), t("auto-apply"))
      }
    }
  },
  zP = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "YearPicker",
    props: {
      ...bn
    },
    emits: ["update:internal-model-value", "reset-flow", "range-start", "range-end", "auto-apply", "update-month-year"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        {
          groupedYears: l,
          modelValue: h,
          focusYear: p,
          selectYear: m,
          setHoverValue: k
        } = YP(o, i),
        {
          defaultedConfig: w
        } = _a(o);
      return t({
        getSidebarProps: () => ({
          modelValue: h,
          selectYear: m
        })
      }), (S, A) => (be(), Ne("div", null, [S.$slots["top-extra"] ? lt(S.$slots, "top-extra", {
        key: 0,
        value: S.internalModelValue
      }) : Ke("", !0), S.$slots["month-year"] ? lt(S.$slots, "month-year", Ja(ja({
        key: 1
      }, {
        years: se(l),
        selectYear: se(m)
      }))) : (be(), yt(Ol, {
        key: 2,
        items: se(l),
        "is-last": S.autoApply && !se(w).keepActionRow,
        height: se(w).modeHeight,
        config: S.config,
        "no-overlay-focus": !!(S.noOverlayFocus || S.textInput),
        "focus-value": se(p),
        type: "year",
        "use-relative": "",
        onSelected: se(m),
        onHoverValue: se(k)
      }, mr({
        _: 2
      }, [S.$slots["year-overlay-value"] ? {
        name: "item",
        fn: Qe(({
          item: E
        }) => [lt(S.$slots, "year-overlay-value", {
          text: E.text,
          value: E.value
        })]),
        key: "0"
      } : void 0]), 1032, ["items", "is-last", "height", "config", "no-overlay-focus", "focus-value", "onSelected", "onHoverValue"]))]))
    }
  }),
  XP = {
    key: 0,
    class: "dp__time_input"
  },
  WP = ["data-test", "aria-label", "onKeydown", "onClick", "onMousedown"],
  VP = ce("span", {
    class: "dp__tp_inline_btn_bar dp__tp_btn_in_l"
  }, null, -1),
  jP = ce("span", {
    class: "dp__tp_inline_btn_bar dp__tp_btn_in_r"
  }, null, -1),
  UP = ["aria-label", "disabled", "data-test", "onKeydown", "onClick"],
  GP = ["data-test", "aria-label", "onKeydown", "onClick", "onMousedown"],
  qP = ce("span", {
    class: "dp__tp_inline_btn_bar dp__tp_btn_in_l"
  }, null, -1),
  KP = ce("span", {
    class: "dp__tp_inline_btn_bar dp__tp_btn_in_r"
  }, null, -1),
  ZP = {
    key: 0
  },
  QP = ["aria-label"],
  JP = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "TimeInput",
    props: {
      hours: {
        type: Number,
        default: 0
      },
      minutes: {
        type: Number,
        default: 0
      },
      seconds: {
        type: Number,
        default: 0
      },
      closeTimePickerBtn: {
        type: Object,
        default: null
      },
      order: {
        type: Number,
        default: 0
      },
      disabledTimesConfig: {
        type: Function,
        default: null
      },
      validateTime: {
        type: Function,
        default: () => !1
      },
      ...bn
    },
    emits: ["set-hours", "set-minutes", "update:hours", "update:minutes", "update:seconds", "reset-flow", "mounted", "overlay-closed", "overlay-opened", "am-pm-change"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        {
          setTimePickerElements: l,
          setTimePickerBackRef: h
        } = Ri(),
        {
          defaultedAriaLabels: p,
          defaultedTransitions: m,
          defaultedFilters: k,
          defaultedConfig: w,
          defaultedRange: S
        } = _a(o),
        {
          transitionName: A,
          showTransition: E
        } = Ml(m),
        M = qr({
          hours: !1,
          minutes: !1,
          seconds: !1
        }),
        D = _e("AM"),
        B = _e(null),
        z = _e([]),
        I = _e(),
        N = _e(!1);
      Dt(() => {
        i("mounted")
      });
      const U = F => da(new Date, {
          hours: F.hours,
          minutes: F.minutes,
          seconds: o.enableSeconds ? F.seconds : 0,
          milliseconds: 0
        }),
        W = Oe(() => F => Ae(F, o[F]) || V(F, o[F])),
        X = Oe(() => ({
          hours: o.hours,
          minutes: o.minutes,
          seconds: o.seconds
        })),
        V = (F, j) => S.value.enabled && !S.value.disableTimeRangeValidation ? !o.validateTime(F, j) : !1,
        ne = (F, j) => {
          if (S.value.enabled && !S.value.disableTimeRangeValidation) {
            const oe = j ? +o[`${F}Increment`] : - +o[`${F}Increment`],
              de = o[F] + oe;
            return !o.validateTime(F, de)
          }
          return !1
        },
        Z = Oe(() => F => !he(+o[F] + +o[`${F}Increment`], F) || ne(F, !0)),
        ie = Oe(() => F => !he(+o[F] - +o[`${F}Increment`], F) || ne(F, !1)),
        fe = (F, j) => ly(da(at(), F), j),
        le = (F, j) => VE(da(at(), F), j),
        Ee = Oe(() => ({
          dp__time_col: !0,
          dp__time_col_block: !o.timePickerInline,
          dp__time_col_reg_block: !o.enableSeconds && o.is24 && !o.timePickerInline,
          dp__time_col_reg_inline: !o.enableSeconds && o.is24 && o.timePickerInline,
          dp__time_col_reg_with_button: !o.enableSeconds && !o.is24,
          dp__time_col_sec: o.enableSeconds && o.is24,
          dp__time_col_sec_with_button: o.enableSeconds && !o.is24
        })),
        ye = Oe(() => {
          const F = [{
            type: "hours"
          }];
          return o.enableMinutes && F.push({
            type: "",
            separator: !0
          }, {
            type: "minutes"
          }), o.enableSeconds && F.push({
            type: "",
            separator: !0
          }, {
            type: "seconds"
          }), F
        }),
        ve = Oe(() => ye.value.filter(F => !F.separator)),
        me = Oe(() => F => {
          if (F === "hours") {
            const j = Re(+o.hours);
            return {
              text: j < 10 ? `0${j}` : `${j}`,
              value: j
            }
          }
          return {
            text: o[F] < 10 ? `0${o[F]}` : `${o[F]}`,
            value: o[F]
          }
        }),
        Ae = (F, j) => {
          var oe;
          if (!o.disabledTimesConfig) return !1;
          const de = o.disabledTimesConfig(o.order, F === "hours" ? j : void 0);
          return de[F] ? !!((oe = de[F]) != null && oe.includes(j)) : !0
        },
        He = (F, j) => j !== "hours" || D.value === "AM" ? F : F + 12,
        De = F => {
          const j = o.is24 ? 24 : 12,
            oe = F === "hours" ? j : 60,
            de = +o[`${F}GridIncrement`],
            Ie = F === "hours" && !o.is24 ? de : 0,
            ue = [];
          for (let Le = Ie; Le < oe; Le += de) ue.push({
            value: o.is24 ? Le : He(Le, F),
            text: Le < 10 ? `0${Le}` : `${Le}`
          });
          return F === "hours" && !o.is24 && ue.unshift({
            value: D.value === "PM" ? 12 : 0,
            text: "12"
          }), ao(ue, Le => ({
            active: !1,
            disabled: k.value.times[F].includes(Le.value) || !he(Le.value, F) || Ae(F, Le.value) || V(F, Le.value)
          }))
        },
        Ye = F => F >= 0 ? F : 59,
        Je = F => F >= 0 ? F : 23,
        he = (F, j) => {
          const oe = o.minTime ? U(sd(o.minTime)) : null,
            de = o.maxTime ? U(sd(o.maxTime)) : null,
            Ie = U(sd(X.value, j, j === "minutes" || j === "seconds" ? Ye(F) : Je(F)));
          return oe && de ? (ml(Ie, de) || Hs(Ie, de)) && (eo(Ie, oe) || Hs(Ie, oe)) : oe ? eo(Ie, oe) || Hs(Ie, oe) : de ? ml(Ie, de) || Hs(Ie, de) : !0
        },
        ke = F => o[`no${F[0].toUpperCase()+F.slice(1)}Overlay`],
        re = F => {
          ke(F) || (M[F] = !M[F], M[F] ? (N.value = !0, i("overlay-opened", F)) : (N.value = !1, i("overlay-closed", F)))
        },
        Se = F => F === "hours" ? Kn : F === "minutes" ? Ti : Js,
        Be = () => {
          I.value && clearTimeout(I.value)
        },
        J = (F, j = !0, oe) => {
          const de = j ? fe : le,
            Ie = j ? +o[`${F}Increment`] : - +o[`${F}Increment`];
          he(+o[F] + Ie, F) && i(`update:${F}`, Se(F)(de({
            [F]: +o[F]
          }, {
            [F]: +o[`${F}Increment`]
          }))), !(oe != null && oe.keyboard) && w.value.timeArrowHoldThreshold && (I.value = setTimeout(() => {
            J(F, j)
          }, w.value.timeArrowHoldThreshold))
        },
        Re = F => o.is24 ? F : (F >= 12 ? D.value = "PM" : D.value = "AM", ZE(F)),
        Xe = () => {
          D.value === "PM" ? (D.value = "AM", i("update:hours", o.hours - 12)) : (D.value = "PM", i("update:hours", o.hours + 12)), i("am-pm-change", D.value)
        },
        nt = F => {
          M[F] = !0
        },
        Pe = (F, j, oe) => {
          if (F && o.arrowNavigation) {
            Array.isArray(z.value[j]) ? z.value[j][oe] = F : z.value[j] = [F];
            const de = z.value.reduce((Ie, ue) => ue.map((Le, K) => [...Ie[K] || [], ue[K]]), []);
            h(o.closeTimePickerBtn), B.value && (de[1] = de[1].concat(B.value)), l(de, o.order)
          }
        },
        We = (F, j) => (re(F), i(`update:${F}`, j));
      return t({
        openChildCmp: nt
      }), (F, j) => {
        var oe;
        return F.disabled ? Ke("", !0) : (be(), Ne("div", XP, [(be(!0), Ne(vt, null, la(ye.value, (de, Ie) => {
          var ue, Le, K;
          return be(), Ne("div", {
            key: Ie,
            class: ut(Ee.value)
          }, [de.separator ? (be(), Ne(vt, {
            key: 0
          }, [N.value ? Ke("", !0) : (be(), Ne(vt, {
            key: 0
          }, [$t(":")], 64))], 64)) : (be(), Ne(vt, {
            key: 1
          }, [ce("button", {
            ref_for: !0,
            ref: ae => Pe(ae, Ie, 0),
            type: "button",
            class: ut({
              dp__btn: !0,
              dp__inc_dec_button: !F.timePickerInline,
              dp__inc_dec_button_inline: F.timePickerInline,
              dp__tp_inline_btn_top: F.timePickerInline,
              dp__inc_dec_button_disabled: Z.value(de.type),
              "dp--hidden-el": N.value
            }),
            "data-test": `${de.type}-time-inc-btn-${o.order}`,
            "aria-label": (ue = se(p)) == null ? void 0 : ue.incrementValue(de.type),
            tabindex: "0",
            onKeydown: ae => se(Cr)(ae, () => J(de.type, !0, {
              keyboard: !0
            }), !0),
            onClick: ae => se(w).timeArrowHoldThreshold ? void 0 : J(de.type, !0),
            onMousedown: ae => se(w).timeArrowHoldThreshold ? J(de.type, !0) : void 0,
            onMouseup: Be
          }, [o.timePickerInline ? (be(), Ne(vt, {
            key: 1
          }, [F.$slots["tp-inline-arrow-up"] ? lt(F.$slots, "tp-inline-arrow-up", {
            key: 0
          }) : (be(), Ne(vt, {
            key: 1
          }, [VP, jP], 64))], 64)) : (be(), Ne(vt, {
            key: 0
          }, [F.$slots["arrow-up"] ? lt(F.$slots, "arrow-up", {
            key: 0
          }) : Ke("", !0), F.$slots["arrow-up"] ? Ke("", !0) : (be(), yt(se(zf), {
            key: 1
          }))], 64))], 42, WP), ce("button", {
            ref_for: !0,
            ref: ae => Pe(ae, Ie, 1),
            type: "button",
            "aria-label": `${me.value(de.type).text}-${(Le=se(p))==null?void 0:Le.openTpOverlay(de.type)}`,
            class: ut({
              dp__time_display: !0,
              dp__time_display_block: !F.timePickerInline,
              dp__time_display_inline: F.timePickerInline,
              "dp--time-invalid": W.value(de.type),
              "dp--time-overlay-btn": !W.value(de.type),
              "dp--hidden-el": N.value
            }),
            disabled: ke(de.type),
            tabindex: "0",
            "data-test": `${de.type}-toggle-overlay-btn-${o.order}`,
            onKeydown: ae => se(Cr)(ae, () => re(de.type), !0),
            onClick: ae => re(de.type)
          }, [F.$slots[de.type] ? lt(F.$slots, de.type, {
            key: 0,
            text: me.value(de.type).text,
            value: me.value(de.type).value
          }) : Ke("", !0), F.$slots[de.type] ? Ke("", !0) : (be(), Ne(vt, {
            key: 1
          }, [$t(st(me.value(de.type).text), 1)], 64))], 42, UP), ce("button", {
            ref_for: !0,
            ref: ae => Pe(ae, Ie, 2),
            type: "button",
            class: ut({
              dp__btn: !0,
              dp__inc_dec_button: !F.timePickerInline,
              dp__inc_dec_button_inline: F.timePickerInline,
              dp__tp_inline_btn_bottom: F.timePickerInline,
              dp__inc_dec_button_disabled: ie.value(de.type),
              "dp--hidden-el": N.value
            }),
            "data-test": `${de.type}-time-dec-btn-${o.order}`,
            "aria-label": (K = se(p)) == null ? void 0 : K.decrementValue(de.type),
            tabindex: "0",
            onKeydown: ae => se(Cr)(ae, () => J(de.type, !1, {
              keyboard: !0
            }), !0),
            onClick: ae => se(w).timeArrowHoldThreshold ? void 0 : J(de.type, !1),
            onMousedown: ae => se(w).timeArrowHoldThreshold ? J(de.type, !1) : void 0,
            onMouseup: Be
          }, [o.timePickerInline ? (be(), Ne(vt, {
            key: 1
          }, [F.$slots["tp-inline-arrow-down"] ? lt(F.$slots, "tp-inline-arrow-down", {
            key: 0
          }) : (be(), Ne(vt, {
            key: 1
          }, [qP, KP], 64))], 64)) : (be(), Ne(vt, {
            key: 0
          }, [F.$slots["arrow-down"] ? lt(F.$slots, "arrow-down", {
            key: 0
          }) : Ke("", !0), F.$slots["arrow-down"] ? Ke("", !0) : (be(), yt(se(Xf), {
            key: 1
          }))], 64))], 42, GP)], 64))], 2)
        }), 128)), F.is24 ? Ke("", !0) : (be(), Ne("div", ZP, [F.$slots["am-pm-button"] ? lt(F.$slots, "am-pm-button", {
          key: 0,
          toggle: Xe,
          value: D.value
        }) : Ke("", !0), F.$slots["am-pm-button"] ? Ke("", !0) : (be(), Ne("button", {
          key: 1,
          ref_key: "amPmButton",
          ref: B,
          type: "button",
          class: "dp__pm_am_button",
          role: "button",
          "aria-label": (oe = se(p)) == null ? void 0 : oe.amPmButton,
          tabindex: "0",
          onClick: Xe,
          onKeydown: j[0] || (j[0] = de => se(Cr)(de, () => Xe(), !0))
        }, st(D.value), 41, QP))])), (be(!0), Ne(vt, null, la(ve.value, (de, Ie) => (be(), yt(In, {
          key: Ie,
          name: se(A)(M[de.type]),
          css: se(E)
        }, {
          default: Qe(() => {
            var ue, Le;
            return [M[de.type] ? (be(), yt(Ol, {
              key: 0,
              items: De(de.type),
              "is-last": F.autoApply && !se(w).keepActionRow,
              "esc-close": F.escClose,
              type: de.type,
              "text-input": F.textInput,
              config: F.config,
              "arrow-navigation": F.arrowNavigation,
              "aria-labels": F.ariaLabels,
              "overlay-label": (Le = (ue = se(p)).timeOverlay) == null ? void 0 : Le.call(ue, de.type),
              onSelected: K => We(de.type, K),
              onToggle: K => re(de.type),
              onResetFlow: j[1] || (j[1] = K => F.$emit("reset-flow"))
            }, mr({
              "button-icon": Qe(() => [F.$slots["clock-icon"] ? lt(F.$slots, "clock-icon", {
                key: 0
              }) : Ke("", !0), F.$slots["clock-icon"] ? Ke("", !0) : (be(), yt(Al(F.timePickerInline ? se(mo) : se(Yf)), {
                key: 1
              }))]),
              _: 2
            }, [F.$slots[`${de.type}-overlay-value`] ? {
              name: "item",
              fn: Qe(({
                item: K
              }) => [lt(F.$slots, `${de.type}-overlay-value`, {
                text: K.text,
                value: K.value
              })]),
              key: "0"
            } : void 0, F.$slots[`${de.type}-overlay-header`] ? {
              name: "header",
              fn: Qe(() => [lt(F.$slots, `${de.type}-overlay-header`, {
                toggle: () => re(de.type)
              })]),
              key: "1"
            } : void 0]), 1032, ["items", "is-last", "esc-close", "type", "text-input", "config", "arrow-navigation", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : Ke("", !0)]
          }),
          _: 2
        }, 1032, ["name", "css"]))), 128))]))
      }
    }
  }),
  eL = {
    class: "dp--tp-wrap"
  },
  tL = ["aria-label", "tabindex"],
  aL = ["role", "aria-label", "tabindex"],
  rL = ["aria-label"],
  Uy = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "TimePicker",
    props: {
      hours: {
        type: [Number, Array],
        default: 0
      },
      minutes: {
        type: [Number, Array],
        default: 0
      },
      seconds: {
        type: [Number, Array],
        default: 0
      },
      disabledTimesConfig: {
        type: Function,
        default: null
      },
      validateTime: {
        type: Function,
        default: () => !1
      },
      ...bn
    },
    emits: ["update:hours", "update:minutes", "update:seconds", "mount", "reset-flow", "overlay-opened", "overlay-closed", "am-pm-change"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        {
          buildMatrix: l,
          setTimePicker: h
        } = Ri(),
        p = vs(),
        {
          defaultedTransitions: m,
          defaultedAriaLabels: k,
          defaultedTextInput: w,
          defaultedConfig: S,
          defaultedRange: A
        } = _a(o),
        {
          transitionName: E,
          showTransition: M
        } = Ml(m),
        {
          hideNavigationButtons: D
        } = Su(),
        B = _e(null),
        z = _e(null),
        I = _e([]),
        N = _e(null),
        U = _e(!1);
      Dt(() => {
        i("mount"), !o.timePicker && o.arrowNavigation ? l([Wa(B.value)], "time") : h(!0, o.timePicker)
      });
      const W = Oe(() => A.value.enabled && o.modelAuto ? Oy(o.internalModelValue) : !0),
        X = _e(!1),
        V = De => ({
          hours: Array.isArray(o.hours) ? o.hours[De] : o.hours,
          minutes: Array.isArray(o.minutes) ? o.minutes[De] : o.minutes,
          seconds: Array.isArray(o.seconds) ? o.seconds[De] : o.seconds
        }),
        ne = Oe(() => {
          const De = [];
          if (A.value.enabled)
            for (let Ye = 0; Ye < 2; Ye++) De.push(V(Ye));
          else De.push(V(0));
          return De
        }),
        Z = (De, Ye = !1, Je = "") => {
          Ye || i("reset-flow"), X.value = De, i(De ? "overlay-opened" : "overlay-closed", hr.time), o.arrowNavigation && h(De), Jt(() => {
            Je !== "" && I.value[0] && I.value[0].openChildCmp(Je)
          })
        },
        ie = Oe(() => ({
          dp__btn: !0,
          dp__button: !0,
          dp__button_bottom: o.autoApply && !S.value.keepActionRow
        })),
        fe = Ur(p, "timePicker"),
        le = (De, Ye, Je) => A.value.enabled ? Ye === 0 ? [De, ne.value[1][Je]] : [ne.value[0][Je], De] : De,
        Ee = De => {
          i("update:hours", De)
        },
        ye = De => {
          i("update:minutes", De)
        },
        ve = De => {
          i("update:seconds", De)
        },
        me = () => {
          if (N.value && !w.value.enabled && !o.noOverlayFocus) {
            const De = My(N.value);
            De && De.focus({
              preventScroll: !0
            })
          }
        },
        Ae = De => {
          U.value = !1, i("overlay-closed", De)
        },
        He = De => {
          U.value = !0, i("overlay-opened", De)
        };
      return t({
        toggleTimePicker: Z
      }), (De, Ye) => {
        var Je;
        return be(), Ne("div", eL, [!De.timePicker && !De.timePickerInline ? Vs((be(), Ne("button", {
          key: 0,
          ref_key: "openTimePickerBtn",
          ref: B,
          type: "button",
          class: ut({
            ...ie.value,
            "dp--hidden-el": X.value
          }),
          "aria-label": (Je = se(k)) == null ? void 0 : Je.openTimePicker,
          tabindex: De.noOverlayFocus ? void 0 : 0,
          "data-test": "open-time-picker-btn",
          onKeydown: Ye[0] || (Ye[0] = he => se(Cr)(he, () => Z(!0))),
          onClick: Ye[1] || (Ye[1] = he => Z(!0))
        }, [De.$slots["clock-icon"] ? lt(De.$slots, "clock-icon", {
          key: 0
        }) : Ke("", !0), De.$slots["clock-icon"] ? Ke("", !0) : (be(), yt(se(Yf), {
          key: 1
        }))], 42, tL)), [
          [pc, !se(D)(De.hideNavigation, "time")]
        ]) : Ke("", !0), Ze(In, {
          name: se(E)(X.value),
          css: se(M) && !De.timePickerInline
        }, {
          default: Qe(() => {
            var he, ke;
            return [X.value || De.timePicker || De.timePickerInline ? (be(), Ne("div", {
              key: 0,
              ref_key: "overlayRef",
              ref: N,
              role: De.timePickerInline ? void 0 : "dialog",
              class: ut({
                dp__overlay: !De.timePickerInline,
                "dp--overlay-absolute": !o.timePicker && !De.timePickerInline,
                "dp--overlay-relative": o.timePicker
              }),
              style: pr(De.timePicker ? {
                height: `${se(S).modeHeight}px`
              } : void 0),
              "aria-label": (he = se(k)) == null ? void 0 : he.timePicker,
              tabindex: De.timePickerInline ? void 0 : 0
            }, [ce("div", {
              class: ut(De.timePickerInline ? "dp__time_picker_inline_container" : "dp__overlay_container dp__container_flex dp__time_picker_overlay_container"),
              style: {
                display: "flex"
              }
            }, [De.$slots["time-picker-overlay"] ? lt(De.$slots, "time-picker-overlay", {
              key: 0,
              hours: e.hours,
              minutes: e.minutes,
              seconds: e.seconds,
              setHours: Ee,
              setMinutes: ye,
              setSeconds: ve
            }) : Ke("", !0), De.$slots["time-picker-overlay"] ? Ke("", !0) : (be(), Ne("div", {
              key: 1,
              class: ut(De.timePickerInline ? "dp__flex" : "dp__overlay_row dp__flex_row")
            }, [(be(!0), Ne(vt, null, la(ne.value, (re, Se) => Vs((be(), yt(JP, ja({
              key: Se,
              ref_for: !0
            }, {
              ...De.$props,
              order: Se,
              hours: re.hours,
              minutes: re.minutes,
              seconds: re.seconds,
              closeTimePickerBtn: z.value,
              disabledTimesConfig: e.disabledTimesConfig,
              disabled: Se === 0 ? se(A).fixedStart : se(A).fixedEnd
            }, {
              ref_for: !0,
              ref_key: "timeInputRefs",
              ref: I,
              "validate-time": (Be, J) => e.validateTime(Be, le(J, Se, Be)),
              "onUpdate:hours": Be => Ee(le(Be, Se, "hours")),
              "onUpdate:minutes": Be => ye(le(Be, Se, "minutes")),
              "onUpdate:seconds": Be => ve(le(Be, Se, "seconds")),
              onMounted: me,
              onOverlayClosed: Ae,
              onOverlayOpened: He,
              onAmPmChange: Ye[2] || (Ye[2] = Be => De.$emit("am-pm-change", Be))
            }), mr({
              _: 2
            }, [la(se(fe), (Be, J) => ({
              name: Be,
              fn: Qe(Re => [lt(De.$slots, Be, ja({
                ref_for: !0
              }, Re))])
            }))]), 1040, ["validate-time", "onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
              [pc, Se === 0 ? !0 : W.value]
            ])), 128))], 2)), !De.timePicker && !De.timePickerInline ? Vs((be(), Ne("button", {
              key: 2,
              ref_key: "closeTimePickerBtn",
              ref: z,
              type: "button",
              class: ut({
                ...ie.value,
                "dp--hidden-el": U.value
              }),
              "aria-label": (ke = se(k)) == null ? void 0 : ke.closeTimePicker,
              tabindex: "0",
              onKeydown: Ye[3] || (Ye[3] = re => se(Cr)(re, () => Z(!1))),
              onClick: Ye[4] || (Ye[4] = re => Z(!1))
            }, [De.$slots["calendar-icon"] ? lt(De.$slots, "calendar-icon", {
              key: 0
            }) : Ke("", !0), De.$slots["calendar-icon"] ? Ke("", !0) : (be(), yt(se(mo), {
              key: 1
            }))], 42, rL)), [
              [pc, !se(D)(De.hideNavigation, "time")]
            ]) : Ke("", !0)], 2)], 14, aL)) : Ke("", !0)]
          }),
          _: 3
        }, 8, ["name", "css"])])
      }
    }
  }),
  Gy = (e, t, a, i) => {
    const {
      defaultedRange: o
    } = _a(e), l = (N, U) => Array.isArray(t[N]) ? t[N][U] : t[N], h = N => e.enableSeconds ? Array.isArray(t.seconds) ? t.seconds[N] : t.seconds : 0, p = (N, U) => N ? U !== void 0 ? Si(N, l("hours", U), l("minutes", U), h(U)) : Si(N, t.hours, t.minutes, h()) : Ty(at(), h(U)), m = (N, U) => {
      t[N] = U
    }, k = Oe(() => e.modelAuto && o.value.enabled ? Array.isArray(a.value) ? a.value.length > 1 : !1 : o.value.enabled), w = (N, U) => {
      const W = Object.fromEntries(Object.keys(t).map(X => X === N ? [X, U] : [X, t[X]].slice()));
      if (k.value && !o.value.disableTimeRangeValidation) {
        const X = ne => a.value ? Si(a.value[ne], W.hours[ne], W.minutes[ne], W.seconds[ne]) : null,
          V = ne => Cy(a.value[ne], 0);
        return !(Vt(X(0), X(1)) && (eo(X(0), V(1)) || ml(X(1), V(0))))
      }
      return !0
    }, S = (N, U) => {
      w(N, U) && (m(N, U), i && i())
    }, A = N => {
      S("hours", N)
    }, E = N => {
      S("minutes", N)
    }, M = N => {
      S("seconds", N)
    }, D = (N, U, W, X) => {
      U && A(N), !U && !W && E(N), W && M(N), a.value && X(a.value)
    }, B = N => {
      if (N) {
        const U = Array.isArray(N),
          W = U ? [+N[0].hours, +N[1].hours] : +N.hours,
          X = U ? [+N[0].minutes, +N[1].minutes] : +N.minutes,
          V = U ? [+N[0].seconds, +N[1].seconds] : +N.seconds;
        m("hours", W), m("minutes", X), e.enableSeconds && m("seconds", V)
      }
    }, z = (N, U) => {
      const W = {
        hours: Array.isArray(t.hours) ? t.hours[N] : t.hours,
        disabledArr: []
      };
      return (U || U === 0) && (W.hours = U), Array.isArray(e.disabledTimes) && (W.disabledArr = o.value.enabled && Array.isArray(e.disabledTimes[N]) ? e.disabledTimes[N] : e.disabledTimes), W
    }, I = Oe(() => (N, U) => {
      var W;
      if (Array.isArray(e.disabledTimes)) {
        const {
          disabledArr: X,
          hours: V
        } = z(N, U), ne = X.filter(Z => +Z.hours === V);
        return ((W = ne[0]) == null ? void 0 : W.minutes) === "*" ? {
          hours: [V],
          minutes: void 0,
          seconds: void 0
        } : {
          hours: [],
          minutes: (ne == null ? void 0 : ne.map(Z => +Z.minutes)) ?? [],
          seconds: (ne == null ? void 0 : ne.map(Z => Z.seconds ? +Z.seconds : void 0)) ?? []
        }
      }
      return {
        hours: [],
        minutes: [],
        seconds: []
      }
    });
    return {
      setTime: m,
      updateHours: A,
      updateMinutes: E,
      updateSeconds: M,
      getSetDateTime: p,
      updateTimeValues: D,
      getSecondsValue: h,
      assignStartTime: B,
      validateTime: w,
      disabledTimesConfig: I
    }
  },
  nL = (e, t) => {
    const a = () => {
        e.isTextInputDate && U()
      },
      {
        modelValue: i,
        time: o
      } = Il(e, t, a),
      {
        defaultedStartTime: l,
        defaultedRange: h,
        defaultedTz: p
      } = _a(e),
      {
        updateTimeValues: m,
        getSetDateTime: k,
        setTime: w,
        assignStartTime: S,
        disabledTimesConfig: A,
        validateTime: E
      } = Gy(e, o, i, M);

    function M() {
      t("update-flow-step")
    }
    const D = X => {
        const {
          hours: V,
          minutes: ne,
          seconds: Z
        } = X;
        return {
          hours: +V,
          minutes: +ne,
          seconds: Z ? +Z : 0
        }
      },
      B = () => {
        if (e.startTime) {
          if (Array.isArray(e.startTime)) {
            const V = D(e.startTime[0]),
              ne = D(e.startTime[1]);
            return [da(at(), V), da(at(), ne)]
          }
          const X = D(e.startTime);
          return da(at(), X)
        }
        return h.value.enabled ? [null, null] : null
      },
      z = () => {
        if (h.value.enabled) {
          const [X, V] = B();
          i.value = [$r(k(X, 0), p.value.timezone), $r(k(V, 1), p.value.timezone)]
        } else i.value = $r(k(B()), p.value.timezone)
      },
      I = X => Array.isArray(X) ? [hs(at(X[0])), hs(at(X[1]))] : [hs(X ?? at())],
      N = (X, V, ne) => {
        w("hours", X), w("minutes", V), w("seconds", e.enableSeconds ? ne : 0)
      },
      U = () => {
        const [X, V] = I(i.value);
        return h.value.enabled ? N([X.hours, V.hours], [X.minutes, V.minutes], [X.seconds, V.seconds]) : N(X.hours, X.minutes, X.seconds)
      };
    Dt(() => {
      if (!e.shadow) return S(l.value), i.value ? U() : z()
    });
    const W = () => {
      Array.isArray(i.value) ? i.value = i.value.map((X, V) => X && k(X, V)) : i.value = k(i.value), t("time-update")
    };
    return {
      modelValue: i,
      time: o,
      disabledTimesConfig: A,
      updateTime: (X, V = !0, ne = !1) => {
        m(X, V, ne, W)
      },
      validateTime: E
    }
  },
  iL = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "TimePickerSolo",
    props: {
      ...bn
    },
    emits: ["update:internal-model-value", "time-update", "am-pm-change", "mount", "reset-flow", "update-flow-step", "overlay-toggle"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        l = vs(),
        h = Ur(l, "timePicker"),
        p = _e(null),
        {
          time: m,
          modelValue: k,
          disabledTimesConfig: w,
          updateTime: S,
          validateTime: A
        } = nL(o, i);
      return Dt(() => {
        o.shadow || i("mount", null)
      }), t({
        getSidebarProps: () => ({
          modelValue: k,
          time: m,
          updateTime: S
        }),
        toggleTimePicker: (E, M = !1, D = "") => {
          var B;
          (B = p.value) == null || B.toggleTimePicker(E, M, D)
        }
      }), (E, M) => (be(), yt(ku, {
        "multi-calendars": 0,
        stretch: ""
      }, {
        default: Qe(() => [Ze(Uy, ja({
          ref_key: "tpRef",
          ref: p
        }, E.$props, {
          hours: se(m).hours,
          minutes: se(m).minutes,
          seconds: se(m).seconds,
          "internal-model-value": E.internalModelValue,
          "disabled-times-config": se(w),
          "validate-time": se(A),
          "onUpdate:hours": M[0] || (M[0] = D => se(S)(D)),
          "onUpdate:minutes": M[1] || (M[1] = D => se(S)(D, !1)),
          "onUpdate:seconds": M[2] || (M[2] = D => se(S)(D, !1, !0)),
          onAmPmChange: M[3] || (M[3] = D => E.$emit("am-pm-change", D)),
          onResetFlow: M[4] || (M[4] = D => E.$emit("reset-flow")),
          onOverlayClosed: M[5] || (M[5] = D => E.$emit("overlay-toggle", {
            open: !1,
            overlay: D
          })),
          onOverlayOpened: M[6] || (M[6] = D => E.$emit("overlay-toggle", {
            open: !0,
            overlay: D
          }))
        }), mr({
          _: 2
        }, [la(se(h), (D, B) => ({
          name: D,
          fn: Qe(z => [lt(E.$slots, D, Ja(Ar(z)))])
        }))]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"])]),
        _: 3
      }))
    }
  }),
  sL = {
    class: "dp--header-wrap"
  },
  oL = {
    key: 0,
    class: "dp__month_year_wrap"
  },
  lL = {
    key: 0
  },
  cL = {
    class: "dp__month_year_wrap"
  },
  uL = ["data-dp-element", "aria-label", "data-test", "onClick", "onKeydown"],
  dL = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "DpHeader",
    props: {
      month: {
        type: Number,
        default: 0
      },
      year: {
        type: Number,
        default: 0
      },
      instance: {
        type: Number,
        default: 0
      },
      years: {
        type: Array,
        default: () => []
      },
      months: {
        type: Array,
        default: () => []
      },
      ...bn
    },
    emits: ["update-month-year", "mount", "reset-flow", "overlay-closed", "overlay-opened"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        {
          defaultedTransitions: l,
          defaultedAriaLabels: h,
          defaultedMultiCalendars: p,
          defaultedFilters: m,
          defaultedConfig: k,
          defaultedHighlight: w,
          propDates: S,
          defaultedUI: A
        } = _a(o),
        {
          transitionName: E,
          showTransition: M
        } = Ml(l),
        {
          buildMatrix: D
        } = Ri(),
        {
          handleMonthYearChange: B,
          isDisabled: z,
          updateMonthYear: I
        } = PP(o, i),
        {
          showLeftIcon: N,
          showRightIcon: U
        } = Su(),
        W = _e(!1),
        X = _e(!1),
        V = _e(!1),
        ne = _e([null, null, null, null]);
      Dt(() => {
        i("mount")
      });
      const Z = ke => ({
          get: () => o[ke],
          set: re => {
            const Se = ke === rn.month ? rn.year : rn.month;
            i("update-month-year", {
              [ke]: re,
              [Se]: o[Se]
            }), ke === rn.month ? Ae(!0) : He(!0)
          }
        }),
        ie = Oe(Z(rn.month)),
        fe = Oe(Z(rn.year)),
        le = Oe(() => ke => ({
          month: o.month,
          year: o.year,
          items: ke === rn.month ? o.months : o.years,
          instance: o.instance,
          updateMonthYear: I,
          toggle: ke === rn.month ? Ae : He
        })),
        Ee = Oe(() => o.months.find(re => re.value === o.month) || {
          text: "",
          value: 0
        }),
        ye = Oe(() => ao(o.months, ke => {
          const re = o.month === ke.value,
            Se = vl(ke.value, Ry(o.year, S.value.minDate), Dy(o.year, S.value.maxDate)) || m.value.months.includes(ke.value),
            Be = Hy(w.value, ke.value, o.year);
          return {
            active: re,
            disabled: Se,
            highlighted: Be
          }
        })),
        ve = Oe(() => ao(o.years, ke => {
          const re = o.year === ke.value,
            Se = vl(ke.value, ro(S.value.minDate), ro(S.value.maxDate)) || m.value.years.includes(ke.value),
            Be = Gf(w.value, ke.value);
          return {
            active: re,
            disabled: Se,
            highlighted: Be
          }
        })),
        me = (ke, re, Se) => {
          Se !== void 0 ? ke.value = Se : ke.value = !ke.value, ke.value ? (V.value = !0, i("overlay-opened", re)) : (V.value = !1, i("overlay-closed", re))
        },
        Ae = (ke = !1, re) => {
          De(ke), me(W, hr.month, re)
        },
        He = (ke = !1, re) => {
          De(ke), me(X, hr.year, re)
        },
        De = ke => {
          ke || i("reset-flow")
        },
        Ye = (ke, re) => {
          o.arrowNavigation && (ne.value[re] = Wa(ke), D(ne.value, "monthYear"))
        },
        Je = Oe(() => {
          var ke, re, Se, Be, J, Re;
          return [{
            type: rn.month,
            index: 1,
            toggle: Ae,
            modelValue: ie.value,
            updateModelValue: Xe => ie.value = Xe,
            text: Ee.value.text,
            showSelectionGrid: W.value,
            items: ye.value,
            ariaLabel: (ke = h.value) == null ? void 0 : ke.openMonthsOverlay,
            overlayLabel: ((Se = (re = h.value).monthPicker) == null ? void 0 : Se.call(re, !0)) ?? void 0
          }, {
            type: rn.year,
            index: 2,
            toggle: He,
            modelValue: fe.value,
            updateModelValue: Xe => fe.value = Xe,
            text: Iy(o.year, o.locale),
            showSelectionGrid: X.value,
            items: ve.value,
            ariaLabel: (Be = h.value) == null ? void 0 : Be.openYearsOverlay,
            overlayLabel: ((Re = (J = h.value).yearPicker) == null ? void 0 : Re.call(J, !0)) ?? void 0
          }]
        }),
        he = Oe(() => o.disableYearSelect ? [Je.value[0]] : o.yearFirst ? [...Je.value].reverse() : Je.value);
      return t({
        toggleMonthPicker: Ae,
        toggleYearPicker: He,
        handleMonthYearChange: B
      }), (ke, re) => {
        var Se, Be, J, Re, Xe, nt;
        return be(), Ne("div", sL, [ke.$slots["month-year"] ? (be(), Ne("div", oL, [lt(ke.$slots, "month-year", Ja(Ar({
          month: e.month,
          year: e.year,
          months: e.months,
          years: e.years,
          updateMonthYear: se(I),
          handleMonthYearChange: se(B),
          instance: e.instance
        })))])) : (be(), Ne(vt, {
          key: 1
        }, [ke.$slots["top-extra"] ? (be(), Ne("div", lL, [lt(ke.$slots, "top-extra", {
          value: ke.internalModelValue
        })])) : Ke("", !0), ce("div", cL, [se(N)(se(p), e.instance) && !ke.vertical ? (be(), yt(tl, {
          key: 0,
          "aria-label": (Se = se(h)) == null ? void 0 : Se.prevMonth,
          disabled: se(z)(!1),
          class: ut((Be = se(A)) == null ? void 0 : Be.navBtnPrev),
          "el-name": "action-prev",
          onActivate: re[0] || (re[0] = Pe => se(B)(!1, !0)),
          onSetRef: re[1] || (re[1] = Pe => Ye(Pe, 0))
        }, {
          default: Qe(() => [ke.$slots["arrow-left"] ? lt(ke.$slots, "arrow-left", {
            key: 0
          }) : Ke("", !0), ke.$slots["arrow-left"] ? Ke("", !0) : (be(), yt(se(Bf), {
            key: 1
          }))]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : Ke("", !0), ce("div", {
          class: ut(["dp__month_year_wrap", {
            dp__year_disable_select: ke.disableYearSelect
          }])
        }, [(be(!0), Ne(vt, null, la(he.value, (Pe, We) => (be(), Ne(vt, {
          key: Pe.type
        }, [ce("button", {
          ref_for: !0,
          ref: F => Ye(F, We + 1),
          type: "button",
          "data-dp-element": `overlay-${Pe.type}`,
          class: ut(["dp__btn dp__month_year_select", {
            "dp--hidden-el": V.value
          }]),
          "aria-label": `${Pe.text}-${Pe.ariaLabel}`,
          "data-test": `${Pe.type}-toggle-overlay-${e.instance}`,
          onClick: Pe.toggle,
          onKeydown: F => se(Cr)(F, () => Pe.toggle(), !0)
        }, [ke.$slots[Pe.type] ? lt(ke.$slots, Pe.type, {
          key: 0,
          text: Pe.text,
          value: o[Pe.type]
        }) : Ke("", !0), ke.$slots[Pe.type] ? Ke("", !0) : (be(), Ne(vt, {
          key: 1
        }, [$t(st(Pe.text), 1)], 64))], 42, uL), Ze(In, {
          name: se(E)(Pe.showSelectionGrid),
          css: se(M)
        }, {
          default: Qe(() => [Pe.showSelectionGrid ? (be(), yt(Ol, {
            key: 0,
            items: Pe.items,
            "arrow-navigation": ke.arrowNavigation,
            "hide-navigation": ke.hideNavigation,
            "is-last": ke.autoApply && !se(k).keepActionRow,
            "skip-button-ref": !1,
            config: ke.config,
            type: Pe.type,
            "header-refs": [],
            "esc-close": ke.escClose,
            "menu-wrap-ref": ke.menuWrapRef,
            "text-input": ke.textInput,
            "aria-labels": ke.ariaLabels,
            "overlay-label": Pe.overlayLabel,
            onSelected: Pe.updateModelValue,
            onToggle: Pe.toggle
          }, mr({
            "button-icon": Qe(() => [ke.$slots["calendar-icon"] ? lt(ke.$slots, "calendar-icon", {
              key: 0
            }) : Ke("", !0), ke.$slots["calendar-icon"] ? Ke("", !0) : (be(), yt(se(mo), {
              key: 1
            }))]),
            _: 2
          }, [ke.$slots[`${Pe.type}-overlay-value`] ? {
            name: "item",
            fn: Qe(({
              item: F
            }) => [lt(ke.$slots, `${Pe.type}-overlay-value`, {
              text: F.text,
              value: F.value
            })]),
            key: "0"
          } : void 0, ke.$slots[`${Pe.type}-overlay`] ? {
            name: "overlay",
            fn: Qe(() => [lt(ke.$slots, `${Pe.type}-overlay`, ja({
              ref_for: !0
            }, le.value(Pe.type)))]),
            key: "1"
          } : void 0, ke.$slots[`${Pe.type}-overlay-header`] ? {
            name: "header",
            fn: Qe(() => [lt(ke.$slots, `${Pe.type}-overlay-header`, {
              toggle: Pe.toggle
            })]),
            key: "2"
          } : void 0]), 1032, ["items", "arrow-navigation", "hide-navigation", "is-last", "config", "type", "esc-close", "menu-wrap-ref", "text-input", "aria-labels", "overlay-label", "onSelected", "onToggle"])) : Ke("", !0)]),
          _: 2
        }, 1032, ["name", "css"])], 64))), 128))], 2), se(N)(se(p), e.instance) && ke.vertical ? (be(), yt(tl, {
          key: 1,
          "aria-label": (J = se(h)) == null ? void 0 : J.prevMonth,
          "el-name": "action-prev",
          disabled: se(z)(!1),
          class: ut((Re = se(A)) == null ? void 0 : Re.navBtnPrev),
          onActivate: re[2] || (re[2] = Pe => se(B)(!1, !0))
        }, {
          default: Qe(() => [ke.$slots["arrow-up"] ? lt(ke.$slots, "arrow-up", {
            key: 0
          }) : Ke("", !0), ke.$slots["arrow-up"] ? Ke("", !0) : (be(), yt(se(zf), {
            key: 1
          }))]),
          _: 3
        }, 8, ["aria-label", "disabled", "class"])) : Ke("", !0), se(U)(se(p), e.instance) ? (be(), yt(tl, {
          key: 2,
          ref: "rightIcon",
          "el-name": "action-next",
          disabled: se(z)(!0),
          "aria-label": (Xe = se(h)) == null ? void 0 : Xe.nextMonth,
          class: ut((nt = se(A)) == null ? void 0 : nt.navBtnNext),
          onActivate: re[3] || (re[3] = Pe => se(B)(!0, !0)),
          onSetRef: re[4] || (re[4] = Pe => Ye(Pe, ke.disableYearSelect ? 2 : 3))
        }, {
          default: Qe(() => [ke.$slots[ke.vertical ? "arrow-down" : "arrow-right"] ? lt(ke.$slots, ke.vertical ? "arrow-down" : "arrow-right", {
            key: 0
          }) : Ke("", !0), ke.$slots[ke.vertical ? "arrow-down" : "arrow-right"] ? Ke("", !0) : (be(), yt(Al(ke.vertical ? se(Xf) : se(Hf)), {
            key: 1
          }))]),
          _: 3
        }, 8, ["disabled", "aria-label", "class"])) : Ke("", !0)])], 64))])
      }
    }
  }),
  hL = {
    class: "dp__calendar_header",
    role: "row"
  },
  fL = {
    key: 0,
    class: "dp__calendar_header_item",
    role: "gridcell"
  },
  pL = ["aria-label"],
  gL = ce("div", {
    class: "dp__calendar_header_separator"
  }, null, -1),
  mL = {
    key: 0,
    class: "dp__calendar_item dp__week_num",
    role: "gridcell"
  },
  vL = {
    class: "dp__cell_inner"
  },
  bL = ["id", "aria-pressed", "aria-disabled", "aria-label", "data-test", "onClick", "onTouchend", "onKeydown", "onMouseenter", "onMouseleave", "onMousedown"],
  yL = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "DpCalendar",
    props: {
      mappedDates: {
        type: Array,
        default: () => []
      },
      instance: {
        type: Number,
        default: 0
      },
      month: {
        type: Number,
        default: 0
      },
      year: {
        type: Number,
        default: 0
      },
      ...bn
    },
    emits: ["select-date", "set-hover-date", "handle-scroll", "mount", "handle-swipe", "handle-space", "tooltip-open", "tooltip-close"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        {
          buildMultiLevelMatrix: l
        } = Ri(),
        {
          defaultedTransitions: h,
          defaultedConfig: p,
          defaultedAriaLabels: m,
          defaultedMultiCalendars: k,
          defaultedWeekNumbers: w,
          defaultedMultiDates: S,
          defaultedUI: A
        } = _a(o),
        E = _e(null),
        M = _e({
          bottom: "",
          left: "",
          transform: ""
        }),
        D = _e([]),
        B = _e(null),
        z = _e(!0),
        I = _e(""),
        N = _e({
          startX: 0,
          endX: 0,
          startY: 0,
          endY: 0
        }),
        U = _e([]),
        W = _e({
          left: "50%"
        }),
        X = _e(!1),
        V = Oe(() => o.calendar ? o.calendar(o.mappedDates) : o.mappedDates),
        ne = Oe(() => o.dayNames ? Array.isArray(o.dayNames) ? o.dayNames : o.dayNames(o.locale, +o.weekStart) : KE(o.formatLocale, o.locale, +o.weekStart));
      Dt(() => {
        i("mount", {
          cmp: "calendar",
          refs: D
        }), p.value.noSwipe || B.value && (B.value.addEventListener("touchstart", Ye, {
          passive: !1
        }), B.value.addEventListener("touchend", Je, {
          passive: !1
        }), B.value.addEventListener("touchmove", he, {
          passive: !1
        })), o.monthChangeOnScroll && B.value && B.value.addEventListener("wheel", Se, {
          passive: !1
        })
      });
      const Z = Pe => Pe ? o.vertical ? "vNext" : "next" : o.vertical ? "vPrevious" : "previous",
        ie = (Pe, We) => {
          if (o.transitions) {
            const F = Pr(jn(at(), o.month, o.year));
            I.value = Ia(Pr(jn(at(), Pe, We)), F) ? h.value[Z(!0)] : h.value[Z(!1)], z.value = !1, Jt(() => {
              z.value = !0
            })
          }
        },
        fe = Oe(() => ({
          ...A.value.calendar ?? {}
        })),
        le = Oe(() => Pe => {
          const We = QE(Pe);
          return {
            dp__marker_dot: We.type === "dot",
            dp__marker_line: We.type === "line"
          }
        }),
        Ee = Oe(() => Pe => Vt(Pe, E.value)),
        ye = Oe(() => ({
          dp__calendar: !0,
          dp__calendar_next: k.value.count > 0 && o.instance !== 0
        })),
        ve = Oe(() => Pe => o.hideOffsetDates ? Pe.current : !0),
        me = async (Pe, We) => {
          const {
            width: F,
            height: j
          } = Pe.getBoundingClientRect();
          E.value = We.value;
          let oe = {
              left: `${F/2}px`
            },
            de = -50;
          if (await Jt(), U.value[0]) {
            const {
              left: Ie,
              width: ue
            } = U.value[0].getBoundingClientRect();
            Ie < 0 && (oe = {
              left: "0"
            }, de = 0, W.value.left = `${F/2}px`), window.innerWidth < Ie + ue && (oe = {
              right: "0"
            }, de = 0, W.value.left = `${ue-F/2}px`)
          }
          M.value = {
            bottom: `${j}px`,
            ...oe,
            transform: `translateX(${de}%)`
          }
        }, Ae = async (Pe, We, F) => {
          var j, oe, de;
          const Ie = Wa(D.value[We][F]);
          Ie && ((j = Pe.marker) != null && j.customPosition && (de = (oe = Pe.marker) == null ? void 0 : oe.tooltip) != null && de.length ? M.value = Pe.marker.customPosition(Ie) : await me(Ie, Pe), i("tooltip-open", Pe.marker))
        }, He = async (Pe, We, F) => {
          var j, oe;
          if (X.value && S.value.enabled && S.value.dragSelect) return i("select-date", Pe);
          i("set-hover-date", Pe), (oe = (j = Pe.marker) == null ? void 0 : j.tooltip) != null && oe.length && await Ae(Pe, We, F)
        }, De = Pe => {
          E.value && (E.value = null, M.value = JSON.parse(JSON.stringify({
            bottom: "",
            left: "",
            transform: ""
          })), i("tooltip-close", Pe.marker))
        }, Ye = Pe => {
          N.value.startX = Pe.changedTouches[0].screenX, N.value.startY = Pe.changedTouches[0].screenY
        }, Je = Pe => {
          N.value.endX = Pe.changedTouches[0].screenX, N.value.endY = Pe.changedTouches[0].screenY, ke()
        }, he = Pe => {
          o.vertical && !o.inline && Pe.preventDefault()
        }, ke = () => {
          const Pe = o.vertical ? "Y" : "X";
          Math.abs(N.value[`start${Pe}`] - N.value[`end${Pe}`]) > 10 && i("handle-swipe", N.value[`start${Pe}`] > N.value[`end${Pe}`] ? "right" : "left")
        }, re = (Pe, We, F) => {
          Pe && (Array.isArray(D.value[We]) ? D.value[We][F] = Pe : D.value[We] = [Pe]), o.arrowNavigation && l(D.value, "calendar")
        }, Se = Pe => {
          o.monthChangeOnScroll && (Pe.preventDefault(), i("handle-scroll", Pe))
        }, Be = Pe => w.value.type === "local" ? Nf(Pe.value, {
          weekStartsOn: +o.weekStart
        }) : w.value.type === "iso" ? Rf(Pe.value) : typeof w.value.type == "function" ? w.value.type(Pe.value) : "", J = Pe => {
          const We = Pe[0];
          return w.value.hideOnOffsetDates ? Pe.some(F => F.current) ? Be(We) : "" : Be(We)
        }, Re = (Pe, We, F = !0) => {
          F && rP() || S.value.enabled || (_i(Pe, p.value), i("select-date", We))
        }, Xe = Pe => {
          _i(Pe, p.value)
        }, nt = Pe => {
          S.value.enabled && S.value.dragSelect ? (X.value = !0, i("select-date", Pe)) : S.value.enabled && i("select-date", Pe)
        };
      return t({
        triggerTransition: ie
      }), (Pe, We) => (be(), Ne("div", {
        class: ut(ye.value)
      }, [ce("div", {
        ref_key: "calendarWrapRef",
        ref: B,
        class: ut(fe.value),
        role: "grid"
      }, [ce("div", hL, [Pe.weekNumbers ? (be(), Ne("div", fL, st(Pe.weekNumName), 1)) : Ke("", !0), (be(!0), Ne(vt, null, la(ne.value, (F, j) => {
        var oe, de;
        return be(), Ne("div", {
          key: j,
          class: "dp__calendar_header_item",
          role: "gridcell",
          "data-test": "calendar-header",
          "aria-label": (de = (oe = se(m)) == null ? void 0 : oe.weekDay) == null ? void 0 : de.call(oe, j)
        }, [Pe.$slots["calendar-header"] ? lt(Pe.$slots, "calendar-header", {
          key: 0,
          day: F,
          index: j
        }) : Ke("", !0), Pe.$slots["calendar-header"] ? Ke("", !0) : (be(), Ne(vt, {
          key: 1
        }, [$t(st(F), 1)], 64))], 8, pL)
      }), 128))]), gL, Ze(In, {
        name: I.value,
        css: !!Pe.transitions
      }, {
        default: Qe(() => [z.value ? (be(), Ne("div", {
          key: 0,
          class: "dp__calendar",
          role: "rowgroup",
          onMouseleave: We[1] || (We[1] = F => X.value = !1)
        }, [(be(!0), Ne(vt, null, la(V.value, (F, j) => (be(), Ne("div", {
          key: j,
          class: "dp__calendar_row",
          role: "row"
        }, [Pe.weekNumbers ? (be(), Ne("div", mL, [ce("div", vL, st(J(F.days)), 1)])) : Ke("", !0), (be(!0), Ne(vt, null, la(F.days, (oe, de) => {
          var Ie, ue, Le;
          return be(), Ne("div", {
            id: se(Yy)(oe.value),
            ref_for: !0,
            ref: K => re(K, j, de),
            key: de + j,
            role: "gridcell",
            class: "dp__calendar_item",
            "aria-pressed": (oe.classData.dp__active_date || oe.classData.dp__range_start || oe.classData.dp__range_start) ?? void 0,
            "aria-disabled": oe.classData.dp__cell_disabled || void 0,
            "aria-label": (ue = (Ie = se(m)) == null ? void 0 : Ie.day) == null ? void 0 : ue.call(Ie, oe),
            tabindex: "0",
            "data-test": oe.value,
            onClick: qn(K => Re(K, oe), ["prevent"]),
            onTouchend: K => Re(K, oe, !1),
            onKeydown: K => se(Cr)(K, () => Pe.$emit("select-date", oe)),
            onMouseenter: K => He(oe, j, de),
            onMouseleave: K => De(oe),
            onMousedown: K => nt(oe),
            onMouseup: We[0] || (We[0] = K => X.value = !1)
          }, [ce("div", {
            class: ut(["dp__cell_inner", oe.classData])
          }, [Pe.$slots.day && ve.value(oe) ? lt(Pe.$slots, "day", {
            key: 0,
            day: +oe.text,
            date: oe.value
          }) : Ke("", !0), Pe.$slots.day ? Ke("", !0) : (be(), Ne(vt, {
            key: 1
          }, [$t(st(oe.text), 1)], 64)), oe.marker && ve.value(oe) ? (be(), Ne(vt, {
            key: 2
          }, [Pe.$slots.marker ? lt(Pe.$slots, "marker", {
            key: 0,
            marker: oe.marker,
            day: +oe.text,
            date: oe.value
          }) : (be(), Ne("div", {
            key: 1,
            class: ut(le.value(oe.marker)),
            style: pr(oe.marker.color ? {
              backgroundColor: oe.marker.color
            } : {})
          }, null, 6))], 64)) : Ke("", !0), Ee.value(oe.value) ? (be(), Ne("div", {
            key: 3,
            ref_for: !0,
            ref_key: "activeTooltip",
            ref: U,
            class: "dp__marker_tooltip",
            style: pr(M.value)
          }, [(Le = oe.marker) != null && Le.tooltip ? (be(), Ne("div", {
            key: 0,
            class: "dp__tooltip_content",
            onClick: Xe
          }, [(be(!0), Ne(vt, null, la(oe.marker.tooltip, (K, ae) => (be(), Ne("div", {
            key: ae,
            class: "dp__tooltip_text"
          }, [Pe.$slots["marker-tooltip"] ? lt(Pe.$slots, "marker-tooltip", {
            key: 0,
            tooltip: K,
            day: oe.value
          }) : Ke("", !0), Pe.$slots["marker-tooltip"] ? Ke("", !0) : (be(), Ne(vt, {
            key: 1
          }, [ce("div", {
            class: "dp__tooltip_mark",
            style: pr(K.color ? {
              backgroundColor: K.color
            } : {})
          }, null, 4), ce("div", null, st(K.text), 1)], 64))]))), 128)), ce("div", {
            class: "dp__arrow_bottom_tp",
            style: pr(W.value)
          }, null, 4)])) : Ke("", !0)], 4)) : Ke("", !0)], 2)], 40, bL)
        }), 128))]))), 128))], 32)) : Ke("", !0)]),
        _: 3
      }, 8, ["name", "css"])], 2)], 2))
    }
  }),
  dm = e => Array.isArray(e),
  xL = (e, t, a, i) => {
    const o = _e([]),
      l = _e(new Date),
      h = _e(),
      p = () => Ye(e.isTextInputDate),
      {
        modelValue: m,
        calendars: k,
        time: w,
        today: S
      } = Il(e, t, p),
      {
        defaultedMultiCalendars: A,
        defaultedStartTime: E,
        defaultedRange: M,
        defaultedConfig: D,
        defaultedTz: B,
        propDates: z,
        defaultedMultiDates: I
      } = _a(e),
      {
        validateMonthYearInRange: N,
        isDisabled: U,
        isDateRangeAllowed: W,
        checkMinMaxRange: X
      } = Di(e),
      {
        updateTimeValues: V,
        getSetDateTime: ne,
        setTime: Z,
        assignStartTime: ie,
        validateTime: fe,
        disabledTimesConfig: le
      } = Gy(e, w, m, i),
      Ee = Oe(() => Me => k.value[Me] ? k.value[Me].month : 0),
      ye = Oe(() => Me => k.value[Me] ? k.value[Me].year : 0),
      ve = Me => !D.value.keepViewOnOffsetClick || Me ? !0 : !h.value,
      me = (Me, rt, ze, et = !1) => {
        var ct, ca;
        ve(et) && (k.value[Me] || (k.value[Me] = {
          month: 0,
          year: 0
        }), k.value[Me].month = sm(rt) ? (ct = k.value[Me]) == null ? void 0 : ct.month : rt, k.value[Me].year = sm(ze) ? (ca = k.value[Me]) == null ? void 0 : ca.year : ze)
      },
      Ae = () => {
        e.autoApply && t("select-date")
      };
    Dt(() => {
      e.shadow || (m.value || (Pe(), E.value && ie(E.value)), Ye(!0), e.focusStartDate && e.startDate && Pe())
    });
    const He = Oe(() => {
        var Me;
        return (Me = e.flow) != null && Me.length && !e.partialFlow ? e.flowStep === e.flow.length : !0
      }),
      De = () => {
        e.autoApply && He.value && t("auto-apply", e.partialFlow ? e.flowStep !== e.flow.length : !1)
      },
      Ye = (Me = !1) => {
        if (m.value) return Array.isArray(m.value) ? (o.value = m.value, J(Me)) : ke(m.value, Me);
        if (A.value.count && Me && !e.startDate) return he(at(), Me)
      },
      Je = () => Array.isArray(m.value) && M.value.enabled ? zt(m.value[0]) === zt(m.value[1] ?? m.value[0]) : !1,
      he = (Me = new Date, rt = !1) => {
        if ((!A.value.count || !A.value.static || rt) && me(0, zt(Me), Tt(Me)), A.value.count && (!A.value.solo || !m.value || Je()))
          for (let ze = 1; ze < A.value.count; ze++) {
            const et = da(at(), {
                month: Ee.value(ze - 1),
                year: ye.value(ze - 1)
              }),
              ct = ly(et, {
                months: 1
              });
            k.value[ze] = {
              month: zt(ct),
              year: Tt(ct)
            }
          }
      },
      ke = (Me, rt) => {
        he(Me), Z("hours", Kn(Me)), Z("minutes", Ti(Me)), Z("seconds", Js(Me)), A.value.count && rt && nt()
      },
      re = Me => {
        if (A.value.count) {
          if (A.value.solo) return 0;
          const rt = zt(Me[0]),
            ze = zt(Me[1]);
          return Math.abs(ze - rt) < A.value.count ? 0 : 1
        }
        return 1
      },
      Se = (Me, rt) => {
        Me[1] && M.value.showLastInRange ? he(Me[re(Me)], rt) : he(Me[0], rt);
        const ze = (et, ct) => [et(Me[0]), Me[1] ? et(Me[1]) : w[ct][1]];
        Z("hours", ze(Kn, "hours")), Z("minutes", ze(Ti, "minutes")), Z("seconds", ze(Js, "seconds"))
      },
      Be = (Me, rt) => {
        if ((M.value.enabled || e.weekPicker) && !I.value.enabled) return Se(Me, rt);
        if (I.value.enabled && rt) {
          const ze = Me[Me.length - 1];
          return ke(ze, rt)
        }
      },
      J = Me => {
        const rt = m.value;
        Be(rt, Me), A.value.count && A.value.solo && nt()
      },
      Re = (Me, rt) => {
        const ze = da(at(), {
            month: Ee.value(rt),
            year: ye.value(rt)
          }),
          et = Me < 0 ? cn(ze, 1) : to(ze, 1);
        N(zt(et), Tt(et), Me < 0, e.preventMinMaxNavigation) && (me(rt, zt(et), Tt(et)), t("update-month-year", {
          instance: rt,
          month: zt(et),
          year: Tt(et)
        }), A.value.count && !A.value.solo && Xe(rt), a())
      },
      Xe = Me => {
        for (let rt = Me - 1; rt >= 0; rt--) {
          const ze = to(da(at(), {
            month: Ee.value(rt + 1),
            year: ye.value(rt + 1)
          }), 1);
          me(rt, zt(ze), Tt(ze))
        }
        for (let rt = Me + 1; rt <= A.value.count - 1; rt++) {
          const ze = cn(da(at(), {
            month: Ee.value(rt - 1),
            year: ye.value(rt - 1)
          }), 1);
          me(rt, zt(ze), Tt(ze))
        }
      },
      nt = () => {
        if (Array.isArray(m.value) && m.value.length === 2) {
          const Me = at(at(m.value[1] ? m.value[1] : cn(m.value[0], 1))),
            [rt, ze] = [zt(m.value[0]), Tt(m.value[0])],
            [et, ct] = [zt(m.value[1]), Tt(m.value[1])];
          (rt !== et || rt === et && ze !== ct) && A.value.solo && me(1, zt(Me), Tt(Me))
        } else m.value && !Array.isArray(m.value) && (me(0, zt(m.value), Tt(m.value)), he(at()))
      },
      Pe = () => {
        e.startDate && (me(0, zt(at(e.startDate)), Tt(at(e.startDate))), A.value.count && Xe(0))
      },
      We = (Me, rt) => {
        if (e.monthChangeOnScroll) {
          const ze = new Date().getTime() - l.value.getTime(),
            et = Math.abs(Me.deltaY);
          let ct = 500;
          et > 1 && (ct = 100), et > 100 && (ct = 0), ze > ct && (l.value = new Date, Re(e.monthChangeOnScroll !== "inverse" ? -Me.deltaY : Me.deltaY, rt))
        }
      },
      F = (Me, rt, ze = !1) => {
        e.monthChangeOnArrows && e.vertical === ze && j(Me, rt)
      },
      j = (Me, rt) => {
        Re(Me === "right" ? -1 : 1, rt)
      },
      oe = Me => {
        if (z.value.markers) return Fc(Me.value, z.value.markers)
      },
      de = (Me, rt) => {
        switch (e.sixWeeks === !0 ? "append" : e.sixWeeks) {
          case "prepend":
            return [!0, !1];
          case "center":
            return [Me == 0, !0];
          case "fair":
            return [Me == 0 || rt > Me, !0];
          case "append":
            return [!1, !1];
          default:
            return [!1, !1]
        }
      },
      Ie = (Me, rt, ze, et) => {
        if (e.sixWeeks && Me.length < 6) {
          const ct = 6 - Me.length,
            ca = (rt.getDay() + 7 - et) % 7,
            Oa = 6 - (ze.getDay() + 7 - et) % 7,
            [nr, zr] = de(ca, Oa);
          for (let Lr = 1; Lr <= ct; Lr++)
            if (zr ? !!(Lr % 2) == nr : nr) {
              const lr = Me[0].days[0],
                Or = ue(nn(lr.value, -7), zt(rt));
              Me.unshift({
                days: Or
              })
            } else {
              const lr = Me[Me.length - 1],
                Or = lr.days[lr.days.length - 1],
                Jn = ue(nn(Or.value, 1), zt(rt));
              Me.push({
                days: Jn
              })
            }
        }
        return Me
      },
      ue = (Me, rt) => {
        const ze = at(Me),
          et = [];
        for (let ct = 0; ct < 7; ct++) {
          const ca = nn(ze, ct),
            Oa = zt(ca) !== rt;
          et.push({
            text: e.hideOffsetDates && Oa ? "" : ca.getDate(),
            value: ca,
            current: !Oa,
            classData: {}
          })
        }
        return et
      },
      Le = (Me, rt) => {
        const ze = [],
          et = new Date(rt, Me),
          ct = new Date(rt, Me + 1, 0),
          ca = e.weekStart,
          Oa = pn(et, {
            weekStartsOn: ca
          }),
          nr = zr => {
            const Lr = ue(zr, Me);
            if (ze.push({
                days: Lr
              }), !ze[ze.length - 1].days.some(lr => Vt(Pr(lr.value), Pr(ct)))) {
              const lr = nn(zr, 7);
              nr(lr)
            }
          };
        return nr(Oa), Ie(ze, et, ct, ca)
      },
      K = Me => {
        const rt = Si(at(Me.value), w.hours, w.minutes, $e());
        t("date-update", rt), I.value.enabled ? qf(rt, m, I.value.limit) : m.value = rt, i(), Jt().then(() => {
          De()
        })
      },
      ae = Me => M.value.noDisabledRange ? Ny(o.value[0], Me).some(rt => U(rt)) : !1,
      xe = () => {
        o.value = m.value ? m.value.slice() : [], o.value.length === 2 && !(M.value.fixedStart || M.value.fixedEnd) && (o.value = [])
      },
      Ce = (Me, rt) => {
        const ze = [at(Me.value), nn(at(Me.value), +M.value.autoRange)];
        W(ze) ? (rt && tt(Me.value), o.value = ze) : t("invalid-date", Me.value)
      },
      tt = Me => {
        const rt = zt(at(Me)),
          ze = Tt(at(Me));
        if (me(0, rt, ze), A.value.count > 0)
          for (let et = 1; et < A.value.count; et++) {
            const ct = sP(da(at(Me), {
              year: ye.value(et - 1),
              month: Ee.value(et - 1)
            }));
            me(et, ct.month, ct.year)
          }
      },
      qe = Me => {
        if (ae(Me.value) || !X(Me.value, m.value, M.value.fixedStart ? 0 : 1)) return t("invalid-date", Me.value);
        o.value = Vy(at(Me.value), m, t, M)
      },
      Te = (Me, rt) => {
        if (xe(), M.value.autoRange) return Ce(Me, rt);
        if (M.value.fixedStart || M.value.fixedEnd) return qe(Me);
        o.value[0] ? X(at(Me.value), m.value) && !ae(Me.value) ? Pa(at(Me.value), at(o.value[0])) ? (o.value.unshift(at(Me.value)), t("range-end", o.value[0])) : (o.value[1] = at(Me.value), t("range-end", o.value[1])) : (e.autoApply && t("auto-apply-invalid", Me.value), t("invalid-date", Me.value)) : (o.value[0] = at(Me.value), t("range-start", o.value[0]))
      },
      $e = (Me = !0) => e.enableSeconds ? Array.isArray(w.seconds) ? Me ? w.seconds[0] : w.seconds[1] : w.seconds : 0,
      ft = Me => {
        o.value[Me] = Si(o.value[Me], w.hours[Me], w.minutes[Me], $e(Me !== 1))
      },
      gt = () => {
        var Me, rt;
        o.value[0] && o.value[1] && +((Me = o.value) == null ? void 0 : Me[0]) > +((rt = o.value) == null ? void 0 : rt[1]) && (o.value.reverse(), t("range-start", o.value[0]), t("range-end", o.value[1]))
      },
      Ct = () => {
        o.value.length && (o.value[0] && !o.value[1] ? ft(0) : (ft(0), ft(1), i()), gt(), m.value = o.value.slice(), _u(o.value, t, e.autoApply, e.modelAuto))
      },
      ia = (Me, rt = !1) => {
        if (U(Me.value) || !Me.current && e.hideOffsetDates) return t("invalid-date", Me.value);
        if (h.value = JSON.parse(JSON.stringify(Me)), !M.value.enabled) return K(Me);
        dm(w.hours) && dm(w.minutes) && !I.value.enabled && (Te(Me, rt), Ct())
      },
      xa = (Me, rt) => {
        var ze;
        me(Me, rt.month, rt.year, !0), A.value.count && !A.value.solo && Xe(Me), t("update-month-year", {
          instance: Me,
          month: rt.month,
          year: rt.year
        }), a(A.value.solo ? Me : void 0);
        const et = (ze = e.flow) != null && ze.length ? e.flow[e.flowStep] : void 0;
        !rt.fromNav && (et === hr.month || et === hr.year) && i()
      },
      yr = (Me, rt) => {
        Wy({
          value: Me,
          modelValue: m,
          range: M.value.enabled,
          timezone: rt ? void 0 : B.value.timezone
        }), Ae(), e.multiCalendars && Jt().then(() => Ye(!0))
      },
      qa = () => {
        const Me = Wf(at(), B.value);
        M.value.enabled ? m.value && Array.isArray(m.value) && m.value[0] ? m.value = Pa(Me, m.value[0]) ? [Me, m.value[0]] : [m.value[0], Me] : m.value = [Me] : m.value = Me, Ae()
      },
      xr = () => {
        if (Array.isArray(m.value))
          if (I.value.enabled) {
            const Me = wa();
            m.value[m.value.length - 1] = ne(Me)
          } else m.value = m.value.map((Me, rt) => Me && ne(Me, rt));
        else m.value = ne(m.value);
        t("time-update")
      },
      wa = () => Array.isArray(m.value) && m.value.length ? m.value[m.value.length - 1] : null;
    return {
      calendars: k,
      modelValue: m,
      month: Ee,
      year: ye,
      time: w,
      disabledTimesConfig: le,
      today: S,
      validateTime: fe,
      getCalendarDays: Le,
      getMarker: oe,
      handleScroll: We,
      handleSwipe: j,
      handleArrow: F,
      selectDate: ia,
      updateMonthYear: xa,
      presetDate: yr,
      selectCurrentDate: qa,
      updateTime: (Me, rt = !0, ze = !1) => {
        V(Me, rt, ze, xr)
      },
      assignMonthAndYear: he
    }
  },
  wL = {
    key: 0
  },
  kL = Ot({
    __name: "DatePicker",
    props: {
      ...bn
    },
    emits: ["tooltip-open", "tooltip-close", "mount", "update:internal-model-value", "update-flow-step", "reset-flow", "auto-apply", "focus-menu", "select-date", "range-start", "range-end", "invalid-fixed-range", "time-update", "am-pm-change", "time-picker-open", "time-picker-close", "recalculate-position", "update-month-year", "auto-apply-invalid", "date-update", "invalid-date", "overlay-toggle"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        {
          calendars: l,
          month: h,
          year: p,
          modelValue: m,
          time: k,
          disabledTimesConfig: w,
          today: S,
          validateTime: A,
          getCalendarDays: E,
          getMarker: M,
          handleArrow: D,
          handleScroll: B,
          handleSwipe: z,
          selectDate: I,
          updateMonthYear: N,
          presetDate: U,
          selectCurrentDate: W,
          updateTime: X,
          assignMonthAndYear: V
        } = xL(o, i, Je, he),
        ne = vs(),
        {
          setHoverDate: Z,
          getDayClassData: ie,
          clearHoverDate: fe
        } = BL(m, o),
        {
          defaultedMultiCalendars: le
        } = _a(o),
        Ee = _e([]),
        ye = _e([]),
        ve = _e(null),
        me = Ur(ne, "calendar"),
        Ae = Ur(ne, "monthYear"),
        He = Ur(ne, "timePicker"),
        De = We => {
          o.shadow || i("mount", We)
        };
      Xt(l, () => {
        o.shadow || setTimeout(() => {
          i("recalculate-position")
        }, 0)
      }, {
        deep: !0
      }), Xt(le, (We, F) => {
        We.count - F.count > 0 && V()
      }, {
        deep: !0
      });
      const Ye = Oe(() => We => E(h.value(We), p.value(We)).map(F => ({
        ...F,
        days: F.days.map(j => (j.marker = M(j), j.classData = ie(j), j))
      })));

      function Je(We) {
        var F;
        We || We === 0 ? (F = ye.value[We]) == null || F.triggerTransition(h.value(We), p.value(We)) : ye.value.forEach((j, oe) => j.triggerTransition(h.value(oe), p.value(oe)))
      }

      function he() {
        i("update-flow-step")
      }
      const ke = (We, F = !1) => {
          I(We, F), o.spaceConfirm && i("select-date")
        },
        re = (We, F, j = 0) => {
          var oe;
          (oe = Ee.value[j]) == null || oe.toggleMonthPicker(We, F)
        },
        Se = (We, F, j = 0) => {
          var oe;
          (oe = Ee.value[j]) == null || oe.toggleYearPicker(We, F)
        },
        Be = (We, F, j) => {
          var oe;
          (oe = ve.value) == null || oe.toggleTimePicker(We, F, j)
        },
        J = (We, F) => {
          var j;
          if (!o.range) {
            const oe = m.value ? m.value : S,
              de = F ? new Date(F) : oe,
              Ie = We ? pn(de, {
                weekStartsOn: 1
              }) : my(de, {
                weekStartsOn: 1
              });
            I({
              value: Ie,
              current: zt(de) === h.value(0),
              text: "",
              classData: {}
            }), (j = document.getElementById(Yy(Ie))) == null || j.focus()
          }
        },
        Re = We => {
          var F;
          (F = Ee.value[0]) == null || F.handleMonthYearChange(We, !0)
        },
        Xe = We => {
          N(0, {
            month: h.value(0),
            year: p.value(0) + (We ? 1 : -1),
            fromNav: !0
          })
        },
        nt = (We, F) => {
          We === hr.time && i(`time-picker-${F?"open":"close"}`), i("overlay-toggle", {
            open: F,
            overlay: We
          })
        },
        Pe = We => {
          i("overlay-toggle", {
            open: !1,
            overlay: We
          }), i("focus-menu")
        };
      return t({
        clearHoverDate: fe,
        presetDate: U,
        selectCurrentDate: W,
        toggleMonthPicker: re,
        toggleYearPicker: Se,
        toggleTimePicker: Be,
        handleArrow: D,
        updateMonthYear: N,
        getSidebarProps: () => ({
          modelValue: m,
          month: h,
          year: p,
          time: k,
          updateTime: X,
          updateMonthYear: N,
          selectDate: I,
          presetDate: U
        }),
        changeMonth: Re,
        changeYear: Xe,
        selectWeekDate: J
      }), (We, F) => (be(), Ne(vt, null, [Ze(ku, {
        "multi-calendars": se(le).count,
        collapse: We.collapse
      }, {
        default: Qe(({
          instance: j,
          index: oe
        }) => [We.disableMonthYearSelect ? Ke("", !0) : (be(), yt(dL, ja({
          key: 0,
          ref: de => {
            de && (Ee.value[oe] = de)
          },
          months: se(Ly)(We.formatLocale, We.locale, We.monthNameFormat),
          years: se(Vf)(We.yearRange, We.locale, We.reverseYears),
          month: se(h)(j),
          year: se(p)(j),
          instance: j
        }, We.$props, {
          onMount: F[0] || (F[0] = de => De(se(ds).header)),
          onResetFlow: F[1] || (F[1] = de => We.$emit("reset-flow")),
          onUpdateMonthYear: de => se(N)(j, de),
          onOverlayClosed: Pe,
          onOverlayOpened: F[2] || (F[2] = de => We.$emit("overlay-toggle", {
            open: !0,
            overlay: de
          }))
        }), mr({
          _: 2
        }, [la(se(Ae), (de, Ie) => ({
          name: de,
          fn: Qe(ue => [lt(We.$slots, de, Ja(Ar(ue)))])
        }))]), 1040, ["months", "years", "month", "year", "instance", "onUpdateMonthYear"])), Ze(yL, ja({
          ref: de => {
            de && (ye.value[oe] = de)
          },
          "mapped-dates": Ye.value(j),
          month: se(h)(j),
          year: se(p)(j),
          instance: j
        }, We.$props, {
          onSelectDate: de => se(I)(de, j !== 1),
          onHandleSpace: de => ke(de, j !== 1),
          onSetHoverDate: F[3] || (F[3] = de => se(Z)(de)),
          onHandleScroll: de => se(B)(de, j),
          onHandleSwipe: de => se(z)(de, j),
          onMount: F[4] || (F[4] = de => De(se(ds).calendar)),
          onResetFlow: F[5] || (F[5] = de => We.$emit("reset-flow")),
          onTooltipOpen: F[6] || (F[6] = de => We.$emit("tooltip-open", de)),
          onTooltipClose: F[7] || (F[7] = de => We.$emit("tooltip-close", de))
        }), mr({
          _: 2
        }, [la(se(me), (de, Ie) => ({
          name: de,
          fn: Qe(ue => [lt(We.$slots, de, Ja(Ar({
            ...ue
          })))])
        }))]), 1040, ["mapped-dates", "month", "year", "instance", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])]),
        _: 3
      }, 8, ["multi-calendars", "collapse"]), We.enableTimePicker ? (be(), Ne("div", wL, [We.$slots["time-picker"] ? lt(We.$slots, "time-picker", Ja(ja({
        key: 0
      }, {
        time: se(k),
        updateTime: se(X)
      }))) : (be(), yt(Uy, ja({
        key: 1,
        ref_key: "timePickerRef",
        ref: ve
      }, We.$props, {
        hours: se(k).hours,
        minutes: se(k).minutes,
        seconds: se(k).seconds,
        "internal-model-value": We.internalModelValue,
        "disabled-times-config": se(w),
        "validate-time": se(A),
        onMount: F[8] || (F[8] = j => De(se(ds).timePicker)),
        "onUpdate:hours": F[9] || (F[9] = j => se(X)(j)),
        "onUpdate:minutes": F[10] || (F[10] = j => se(X)(j, !1)),
        "onUpdate:seconds": F[11] || (F[11] = j => se(X)(j, !1, !0)),
        onResetFlow: F[12] || (F[12] = j => We.$emit("reset-flow")),
        onOverlayClosed: F[13] || (F[13] = j => nt(j, !1)),
        onOverlayOpened: F[14] || (F[14] = j => nt(j, !0)),
        onAmPmChange: F[15] || (F[15] = j => We.$emit("am-pm-change", j))
      }), mr({
        _: 2
      }, [la(se(He), (j, oe) => ({
        name: j,
        fn: Qe(de => [lt(We.$slots, j, Ja(Ar(de)))])
      }))]), 1040, ["hours", "minutes", "seconds", "internal-model-value", "disabled-times-config", "validate-time"]))])) : Ke("", !0)], 64))
    }
  }),
  _L = (e, t) => {
    const a = _e(),
      {
        defaultedMultiCalendars: i,
        defaultedConfig: o,
        defaultedHighlight: l,
        defaultedRange: h,
        propDates: p,
        defaultedFilters: m,
        defaultedMultiDates: k
      } = _a(e),
      {
        modelValue: w,
        year: S,
        month: A,
        calendars: E
      } = Il(e, t),
      {
        isDisabled: M
      } = Di(e),
      {
        selectYear: D,
        groupedYears: B,
        showYearPicker: z,
        isDisabled: I,
        toggleYearPicker: N,
        handleYearSelect: U,
        handleYear: W
      } = jy({
        modelValue: w,
        multiCalendars: i,
        range: h,
        highlight: l,
        calendars: E,
        propDates: p,
        month: A,
        year: S,
        filters: m,
        props: e,
        emit: t
      }),
      X = (ve, me) => [ve, me].map(Ae => On(Ae, "MMMM", {
        locale: e.formatLocale
      })).join("-"),
      V = Oe(() => ve => w.value ? Array.isArray(w.value) ? w.value.some(me => rm(ve, me)) : rm(w.value, ve) : !1),
      ne = ve => {
        if (h.value.enabled) {
          if (Array.isArray(w.value)) {
            const me = Vt(ve, w.value[0]) || Vt(ve, w.value[1]);
            return xu(w.value, a.value, ve) && !me
          }
          return !1
        }
        return !1
      },
      Z = (ve, me) => ve.quarter === Zg(me) && ve.year === Tt(me),
      ie = ve => typeof l.value == "function" ? l.value({
        quarter: Zg(ve),
        year: Tt(ve)
      }) : !!l.value.quarters.find(me => Z(me, ve)),
      fe = Oe(() => ve => {
        const me = da(new Date, {
          year: S.value(ve)
        });
        return ZC({
          start: gl(me),
          end: gy(me)
        }).map(Ae => {
          const He = ss(Ae),
            De = Qg(Ae),
            Ye = M(Ae),
            Je = ne(He),
            he = ie(He);
          return {
            text: X(He, De),
            value: He,
            active: V.value(He),
            highlighted: he,
            disabled: Ye,
            isBetween: Je
          }
        })
      }),
      le = ve => {
        qf(ve, w, k.value.limit), t("auto-apply", !0)
      },
      Ee = ve => {
        w.value = Kf(w, ve, t), _u(w.value, t, e.autoApply, e.modelAuto)
      },
      ye = ve => {
        w.value = ve, t("auto-apply")
      };
    return {
      defaultedConfig: o,
      defaultedMultiCalendars: i,
      groupedYears: B,
      year: S,
      isDisabled: I,
      quarters: fe,
      showYearPicker: z,
      modelValue: w,
      setHoverDate: ve => {
        a.value = ve
      },
      selectYear: D,
      selectQuarter: (ve, me, Ae) => {
        if (!Ae) return E.value[me].month = zt(Qg(ve)), k.value.enabled ? le(ve) : h.value.enabled ? Ee(ve) : ye(ve)
      },
      toggleYearPicker: N,
      handleYearSelect: U,
      handleYear: W
    }
  },
  SL = {
    class: "dp--quarter-items"
  },
  AL = ["data-test", "disabled", "onClick", "onMouseover"],
  CL = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "QuarterPicker",
    props: {
      ...bn
    },
    emits: ["update:internal-model-value", "reset-flow", "overlay-closed", "auto-apply", "range-start", "range-end", "overlay-toggle", "update-month-year"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        l = vs(),
        h = Ur(l, "yearMode"),
        {
          defaultedMultiCalendars: p,
          defaultedConfig: m,
          groupedYears: k,
          year: w,
          isDisabled: S,
          quarters: A,
          modelValue: E,
          showYearPicker: M,
          setHoverDate: D,
          selectQuarter: B,
          toggleYearPicker: z,
          handleYearSelect: I,
          handleYear: N
        } = _L(o, i);
      return t({
        getSidebarProps: () => ({
          modelValue: E,
          year: w,
          selectQuarter: B,
          handleYearSelect: I,
          handleYear: N
        })
      }), (U, W) => (be(), yt(ku, {
        "multi-calendars": se(p).count,
        collapse: U.collapse,
        stretch: ""
      }, {
        default: Qe(({
          instance: X
        }) => [ce("div", {
          class: "dp-quarter-picker-wrap",
          style: pr({
            minHeight: `${se(m).modeHeight}px`
          })
        }, [U.$slots["top-extra"] ? lt(U.$slots, "top-extra", {
          key: 0,
          value: U.internalModelValue
        }) : Ke("", !0), ce("div", null, [Ze(Xy, ja(U.$props, {
          items: se(k)(X),
          instance: X,
          "show-year-picker": se(M)[X],
          year: se(w)(X),
          "is-disabled": V => se(S)(X, V),
          onHandleYear: V => se(N)(X, V),
          onYearSelect: V => se(I)(V, X),
          onToggleYearPicker: V => se(z)(X, V == null ? void 0 : V.flow, V == null ? void 0 : V.show)
        }), mr({
          _: 2
        }, [la(se(h), (V, ne) => ({
          name: V,
          fn: Qe(Z => [lt(U.$slots, V, Ja(Ar(Z)))])
        }))]), 1040, ["items", "instance", "show-year-picker", "year", "is-disabled", "onHandleYear", "onYearSelect", "onToggleYearPicker"])]), ce("div", SL, [(be(!0), Ne(vt, null, la(se(A)(X), (V, ne) => (be(), Ne("div", {
          key: ne
        }, [ce("button", {
          type: "button",
          class: ut(["dp--qr-btn", {
            "dp--qr-btn-active": V.active,
            "dp--qr-btn-between": V.isBetween,
            "dp--qr-btn-disabled": V.disabled,
            "dp--highlighted": V.highlighted
          }]),
          "data-test": V.value,
          disabled: V.disabled,
          onClick: Z => se(B)(V.value, X, V.disabled),
          onMouseover: Z => se(D)(V.value)
        }, [U.$slots.quarter ? lt(U.$slots, "quarter", {
          key: 0,
          value: V.value,
          text: V.text
        }) : (be(), Ne(vt, {
          key: 1
        }, [$t(st(V.text), 1)], 64))], 42, AL)]))), 128))])], 4)]),
        _: 3
      }, 8, ["multi-calendars", "collapse"]))
    }
  }),
  TL = ["id", "tabindex", "role", "aria-label"],
  EL = {
    key: 0,
    class: "dp--menu-load-container"
  },
  PL = ce("span", {
    class: "dp--menu-loader"
  }, null, -1),
  LL = [PL],
  OL = {
    key: 1,
    class: "dp--menu-header"
  },
  ML = {
    key: 0,
    class: "dp__sidebar_left"
  },
  IL = ["data-test", "onClick", "onKeydown"],
  RL = {
    key: 2,
    class: "dp__sidebar_right"
  },
  DL = {
    key: 3,
    class: "dp__action_extra"
  },
  hm = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "DatepickerMenu",
    props: {
      ...wu,
      shadow: {
        type: Boolean,
        default: !1
      },
      openOnTop: {
        type: Boolean,
        default: !1
      },
      internalModelValue: {
        type: [Date, Array],
        default: null
      },
      noOverlayFocus: {
        type: Boolean,
        default: !1
      },
      collapse: {
        type: Boolean,
        default: !1
      },
      getInputRect: {
        type: Function,
        default: () => ({})
      },
      isTextInputDate: {
        type: Boolean,
        default: !1
      }
    },
    emits: ["close-picker", "select-date", "auto-apply", "time-update", "flow-step", "update-month-year", "invalid-select", "update:internal-model-value", "recalculate-position", "invalid-fixed-range", "tooltip-open", "tooltip-close", "time-picker-open", "time-picker-close", "am-pm-change", "range-start", "range-end", "auto-apply-invalid", "date-update", "invalid-date", "overlay-toggle"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        l = _e(null),
        h = Oe(() => {
          const {
            openOnTop: ue,
            ...Le
          } = o;
          return {
            ...Le,
            flowStep: Z.value,
            collapse: o.collapse,
            noOverlayFocus: o.noOverlayFocus,
            menuWrapRef: l.value
          }
        }),
        {
          setMenuFocused: p,
          setShiftKey: m,
          control: k
        } = zy(),
        w = vs(),
        {
          defaultedTextInput: S,
          defaultedInline: A,
          defaultedConfig: E,
          defaultedUI: M
        } = _a(o),
        D = _e(null),
        B = _e(0),
        z = _e(null),
        I = _e(!1),
        N = _e(null);
      Dt(() => {
        if (!o.shadow) {
          I.value = !0, U(), window.addEventListener("resize", U);
          const ue = Wa(l);
          if (ue && !S.value.enabled && !A.value.enabled && (p(!0), me()), ue) {
            const Le = K => {
              E.value.allowPreventDefault && K.preventDefault(), _i(K, E.value, !0)
            };
            ue.addEventListener("pointerdown", Le), ue.addEventListener("mousedown", Le)
          }
        }
      }), Ha(() => {
        window.removeEventListener("resize", U)
      });
      const U = () => {
          const ue = Wa(z);
          ue && (B.value = ue.getBoundingClientRect().width)
        },
        {
          arrowRight: W,
          arrowLeft: X,
          arrowDown: V,
          arrowUp: ne
        } = Ri(),
        {
          flowStep: Z,
          updateFlowStep: ie,
          childMount: fe,
          resetFlow: le,
          handleFlow: Ee
        } = HL(o, i, N),
        ye = Oe(() => o.monthPicker ? HP : o.yearPicker ? zP : o.timePicker ? iL : o.quarterPicker ? CL : kL),
        ve = Oe(() => {
          var ue;
          if (E.value.arrowLeft) return E.value.arrowLeft;
          const Le = (ue = l.value) == null ? void 0 : ue.getBoundingClientRect(),
            K = o.getInputRect();
          return (K == null ? void 0 : K.width) < (B == null ? void 0 : B.value) && (K == null ? void 0 : K.left) <= ((Le == null ? void 0 : Le.left) ?? 0) ? `${(K==null?void 0:K.width)/2}px` : (K == null ? void 0 : K.right) >= ((Le == null ? void 0 : Le.right) ?? 0) && (K == null ? void 0 : K.width) < (B == null ? void 0 : B.value) ? `${(B==null?void 0:B.value)-(K==null?void 0:K.width)/2}px` : "50%"
        }),
        me = () => {
          const ue = Wa(l);
          ue && ue.focus({
            preventScroll: !0
          })
        },
        Ae = Oe(() => {
          var ue;
          return ((ue = N.value) == null ? void 0 : ue.getSidebarProps()) || {}
        }),
        He = () => {
          o.openOnTop && i("recalculate-position")
        },
        De = Ur(w, "action"),
        Ye = Oe(() => o.monthPicker || o.yearPicker ? Ur(w, "monthYear") : o.timePicker ? Ur(w, "timePicker") : Ur(w, "shared")),
        Je = Oe(() => o.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"),
        he = Oe(() => ({
          dp__menu_disabled: o.disabled,
          dp__menu_readonly: o.readonly,
          "dp-menu-loading": o.loading
        })),
        ke = Oe(() => ({
          dp__menu: !0,
          dp__menu_index: !A.value.enabled,
          dp__relative: A.value.enabled,
          ...M.value.menu ?? {}
        })),
        re = ue => {
          _i(ue, E.value, !0)
        },
        Se = () => {
          o.escClose && i("close-picker")
        },
        Be = ue => {
          if (o.arrowNavigation) {
            if (ue === _r.up) return ne();
            if (ue === _r.down) return V();
            if (ue === _r.left) return X();
            if (ue === _r.right) return W()
          } else ue === _r.left || ue === _r.up ? Pe("handleArrow", _r.left, 0, ue === _r.up) : Pe("handleArrow", _r.right, 0, ue === _r.down)
        },
        J = ue => {
          m(ue.shiftKey), !o.disableMonthYearSelect && ue.code === ba.tab && ue.target.classList.contains("dp__menu") && k.value.shiftKeyInMenu && (ue.preventDefault(), _i(ue, E.value, !0), i("close-picker"))
        },
        Re = () => {
          me(), i("time-picker-close")
        },
        Xe = ue => {
          var Le, K, ae;
          (Le = N.value) == null || Le.toggleTimePicker(!1, !1), (K = N.value) == null || K.toggleMonthPicker(!1, !1, ue), (ae = N.value) == null || ae.toggleYearPicker(!1, !1, ue)
        },
        nt = (ue, Le = 0) => {
          var K, ae, xe;
          return ue === "month" ? (K = N.value) == null ? void 0 : K.toggleMonthPicker(!1, !0, Le) : ue === "year" ? (ae = N.value) == null ? void 0 : ae.toggleYearPicker(!1, !0, Le) : ue === "time" ? (xe = N.value) == null ? void 0 : xe.toggleTimePicker(!0, !1) : Xe(Le)
        },
        Pe = (ue, ...Le) => {
          var K, ae;
          (K = N.value) != null && K[ue] && ((ae = N.value) == null || ae[ue](...Le))
        },
        We = () => {
          Pe("selectCurrentDate")
        },
        F = (ue, Le) => {
          Pe("presetDate", ue, Le)
        },
        j = () => {
          Pe("clearHoverDate")
        },
        oe = (ue, Le) => {
          Pe("updateMonthYear", ue, Le)
        },
        de = (ue, Le) => {
          ue.preventDefault(), Be(Le)
        },
        Ie = ue => {
          var Le, K, ae;
          if (J(ue), ue.key === ba.home || ue.key === ba.end) return Pe("selectWeekDate", ue.key === ba.home, ue.target.getAttribute("id"));
          switch ((ue.key === ba.pageUp || ue.key === ba.pageDown) && (ue.shiftKey ? (Pe("changeYear", ue.key === ba.pageUp), (Le = Eh(l.value, "overlay-year")) == null || Le.focus()) : (Pe("changeMonth", ue.key === ba.pageUp), (K = Eh(l.value, ue.key === ba.pageUp ? "action-prev" : "action-next")) == null || K.focus()), ue.target.getAttribute("id") && ((ae = l.value) == null || ae.focus({
              preventScroll: !0
            }))), ue.key) {
            case ba.esc:
              return Se();
            case ba.arrowLeft:
              return de(ue, _r.left);
            case ba.arrowRight:
              return de(ue, _r.right);
            case ba.arrowUp:
              return de(ue, _r.up);
            case ba.arrowDown:
              return de(ue, _r.down);
            default:
              return
          }
        };
      return t({
        updateMonthYear: oe,
        switchView: nt,
        handleFlow: Ee
      }), (ue, Le) => {
        var K, ae, xe;
        return be(), Ne("div", {
          id: ue.uid ? `dp-menu-${ue.uid}` : void 0,
          ref_key: "dpMenuRef",
          ref: l,
          tabindex: se(A).enabled ? void 0 : "0",
          role: se(A).enabled ? void 0 : "dialog",
          "aria-label": (K = ue.ariaLabels) == null ? void 0 : K.menu,
          class: ut(ke.value),
          style: pr({
            "--dp-arrow-left": ve.value
          }),
          onMouseleave: j,
          onClick: re,
          onKeydown: Ie
        }, [(ue.disabled || ue.readonly) && se(A).enabled || ue.loading ? (be(), Ne("div", {
          key: 0,
          class: ut(he.value)
        }, [ue.loading ? (be(), Ne("div", EL, LL)) : Ke("", !0)], 2)) : Ke("", !0), ue.$slots["menu-header"] ? (be(), Ne("div", OL, [lt(ue.$slots, "menu-header")])) : Ke("", !0), !se(A).enabled && !ue.teleportCenter ? (be(), Ne("div", {
          key: 2,
          class: ut(Je.value)
        }, null, 2)) : Ke("", !0), ce("div", {
          ref_key: "innerMenuRef",
          ref: z,
          class: ut({
            dp__menu_content_wrapper: ((ae = ue.presetDates) == null ? void 0 : ae.length) || !!ue.$slots["left-sidebar"] || !!ue.$slots["right-sidebar"],
            "dp--menu-content-wrapper-collapsed": e.collapse && (((xe = ue.presetDates) == null ? void 0 : xe.length) || !!ue.$slots["left-sidebar"] || !!ue.$slots["right-sidebar"])
          }),
          style: pr({
            "--dp-menu-width": `${B.value}px`
          })
        }, [ue.$slots["left-sidebar"] ? (be(), Ne("div", ML, [lt(ue.$slots, "left-sidebar", Ja(Ar(Ae.value)))])) : Ke("", !0), ue.presetDates.length ? (be(), Ne("div", {
          key: 1,
          class: ut({
            "dp--preset-dates-collapsed": e.collapse,
            "dp--preset-dates": !0
          })
        }, [(be(!0), Ne(vt, null, la(ue.presetDates, (Ce, tt) => (be(), Ne(vt, {
          key: tt
        }, [Ce.slot ? lt(ue.$slots, Ce.slot, {
          key: 0,
          presetDate: F,
          label: Ce.label,
          value: Ce.value
        }) : (be(), Ne("button", {
          key: 1,
          type: "button",
          style: pr(Ce.style || {}),
          class: ut(["dp__btn dp--preset-range", {
            "dp--preset-range-collapsed": e.collapse
          }]),
          "data-test": Ce.testId ?? void 0,
          onClick: qn(qe => F(Ce.value, Ce.noTz), ["prevent"]),
          onKeydown: qe => se(Cr)(qe, () => F(Ce.value, Ce.noTz), !0)
        }, st(Ce.label), 47, IL))], 64))), 128))], 2)) : Ke("", !0), ce("div", {
          ref_key: "calendarWrapperRef",
          ref: D,
          class: "dp__instance_calendar",
          role: "document"
        }, [(be(), yt(Al(ye.value), ja({
          ref_key: "dynCmpRef",
          ref: N
        }, h.value, {
          "flow-step": se(Z),
          onMount: se(fe),
          onUpdateFlowStep: se(ie),
          onResetFlow: se(le),
          onFocusMenu: me,
          onSelectDate: Le[0] || (Le[0] = Ce => ue.$emit("select-date")),
          onDateUpdate: Le[1] || (Le[1] = Ce => ue.$emit("date-update", Ce)),
          onTooltipOpen: Le[2] || (Le[2] = Ce => ue.$emit("tooltip-open", Ce)),
          onTooltipClose: Le[3] || (Le[3] = Ce => ue.$emit("tooltip-close", Ce)),
          onAutoApply: Le[4] || (Le[4] = Ce => ue.$emit("auto-apply", Ce)),
          onRangeStart: Le[5] || (Le[5] = Ce => ue.$emit("range-start", Ce)),
          onRangeEnd: Le[6] || (Le[6] = Ce => ue.$emit("range-end", Ce)),
          onInvalidFixedRange: Le[7] || (Le[7] = Ce => ue.$emit("invalid-fixed-range", Ce)),
          onTimeUpdate: Le[8] || (Le[8] = Ce => ue.$emit("time-update")),
          onAmPmChange: Le[9] || (Le[9] = Ce => ue.$emit("am-pm-change", Ce)),
          onTimePickerOpen: Le[10] || (Le[10] = Ce => ue.$emit("time-picker-open", Ce)),
          onTimePickerClose: Re,
          onRecalculatePosition: He,
          onUpdateMonthYear: Le[11] || (Le[11] = Ce => ue.$emit("update-month-year", Ce)),
          onAutoApplyInvalid: Le[12] || (Le[12] = Ce => ue.$emit("auto-apply-invalid", Ce)),
          onInvalidDate: Le[13] || (Le[13] = Ce => ue.$emit("invalid-date", Ce)),
          onOverlayToggle: Le[14] || (Le[14] = Ce => ue.$emit("overlay-toggle", Ce)),
          "onUpdate:internalModelValue": Le[15] || (Le[15] = Ce => ue.$emit("update:internal-model-value", Ce))
        }), mr({
          _: 2
        }, [la(Ye.value, (Ce, tt) => ({
          name: Ce,
          fn: Qe(qe => [lt(ue.$slots, Ce, Ja(Ar({
            ...qe
          })))])
        }))]), 1040, ["flow-step", "onMount", "onUpdateFlowStep", "onResetFlow"]))], 512), ue.$slots["right-sidebar"] ? (be(), Ne("div", RL, [lt(ue.$slots, "right-sidebar", Ja(Ar(Ae.value)))])) : Ke("", !0), ue.$slots["action-extra"] ? (be(), Ne("div", DL, [ue.$slots["action-extra"] ? lt(ue.$slots, "action-extra", {
          key: 0,
          selectCurrentDate: We
        }) : Ke("", !0)])) : Ke("", !0)], 6), !ue.autoApply || se(E).keepActionRow ? (be(), yt(MP, ja({
          key: 3,
          "menu-mount": I.value
        }, h.value, {
          "calendar-width": B.value,
          onClosePicker: Le[16] || (Le[16] = Ce => ue.$emit("close-picker")),
          onSelectDate: Le[17] || (Le[17] = Ce => ue.$emit("select-date")),
          onInvalidSelect: Le[18] || (Le[18] = Ce => ue.$emit("invalid-select")),
          onSelectNow: We
        }), mr({
          _: 2
        }, [la(se(De), (Ce, tt) => ({
          name: Ce,
          fn: Qe(qe => [lt(ue.$slots, Ce, Ja(Ar({
            ...qe
          })))])
        }))]), 1040, ["menu-mount", "calendar-width"])) : Ke("", !0)], 46, TL)
      }
    }
  });
var Ns = (e => (e.center = "center", e.left = "left", e.right = "right", e))(Ns || {});
const NL = ({
    menuRef: e,
    menuRefInner: t,
    inputRef: a,
    pickerWrapperRef: i,
    inline: o,
    emit: l,
    props: h,
    slots: p
  }) => {
    const {
      defaultedConfig: m
    } = _a(h), k = _e({}), w = _e(!1), S = _e({
      top: "0",
      left: "0"
    }), A = _e(!1), E = ol(h, "teleportCenter");
    Xt(E, () => {
      S.value = JSON.parse(JSON.stringify({})), W()
    });
    const M = me => {
        if (h.teleport) {
          const Ae = me.getBoundingClientRect();
          return {
            left: Ae.left + window.scrollX,
            top: Ae.top + window.scrollY
          }
        }
        return {
          top: 0,
          left: 0
        }
      },
      D = (me, Ae) => {
        S.value.left = `${me+Ae-k.value.width}px`
      },
      B = me => {
        S.value.left = `${me}px`
      },
      z = (me, Ae) => {
        h.position === Ns.left && B(me), h.position === Ns.right && D(me, Ae), h.position === Ns.center && (S.value.left = `${me+Ae/2-k.value.width/2}px`)
      },
      I = me => {
        const {
          width: Ae,
          height: He
        } = me.getBoundingClientRect(), {
          top: De,
          left: Ye
        } = h.altPosition ? h.altPosition(me) : M(me);
        return {
          top: +De,
          left: +Ye,
          width: Ae,
          height: He
        }
      },
      N = () => {
        S.value.left = "50%", S.value.top = "50%", S.value.transform = "translate(-50%, -50%)", S.value.position = "fixed", delete S.value.opacity
      },
      U = () => {
        const me = Wa(a),
          {
            top: Ae,
            left: He,
            transform: De
          } = h.altPosition(me);
        S.value = {
          top: `${Ae}px`,
          left: `${He}px`,
          transform: De ?? ""
        }
      },
      W = (me = !0) => {
        var Ae;
        if (!o.value.enabled) {
          if (E.value) return N();
          if (h.altPosition !== null) return U();
          if (me) {
            const He = h.teleport ? (Ae = t.value) == null ? void 0 : Ae.$el : e.value;
            He && (k.value = He.getBoundingClientRect()), l("recalculate-position")
          }
          return le()
        }
      },
      X = ({
        inputEl: me,
        left: Ae,
        width: He
      }) => {
        window.screen.width > 768 && !w.value && z(Ae, He), Z(me)
      },
      V = me => {
        const {
          top: Ae,
          left: He,
          height: De,
          width: Ye
        } = I(me);
        S.value.top = `${De+Ae+ +h.offset}px`, A.value = !1, w.value || (S.value.left = `${He+Ye/2-k.value.width/2}px`), X({
          inputEl: me,
          left: He,
          width: Ye
        })
      },
      ne = me => {
        const {
          top: Ae,
          left: He,
          width: De
        } = I(me);
        S.value.top = `${Ae-+h.offset-k.value.height}px`, A.value = !0, X({
          inputEl: me,
          left: He,
          width: De
        })
      },
      Z = me => {
        if (h.autoPosition) {
          const {
            left: Ae,
            width: He
          } = I(me), {
            left: De,
            right: Ye
          } = k.value;
          if (!w.value) {
            if (Math.abs(De) !== Math.abs(Ye)) {
              if (De <= 0) return w.value = !0, B(Ae);
              if (Ye >= document.documentElement.clientWidth) return w.value = !0, D(Ae, He)
            }
            return z(Ae, He)
          }
        }
      },
      ie = () => {
        const me = Wa(a);
        if (me) {
          const {
            height: Ae
          } = k.value, {
            top: He,
            height: De
          } = me.getBoundingClientRect(), Ye = window.innerHeight - He - De, Je = He;
          return Ae <= Ye ? Ji.bottom : Ae > Ye && Ae <= Je ? Ji.top : Ye >= Je ? Ji.bottom : Ji.top
        }
        return Ji.bottom
      },
      fe = me => ie() === Ji.bottom ? V(me) : ne(me),
      le = () => {
        const me = Wa(a);
        if (me) return h.autoPosition ? fe(me) : V(me)
      },
      Ee = function (me) {
        if (me) {
          const Ae = me.scrollHeight > me.clientHeight,
            He = window.getComputedStyle(me).overflowY.indexOf("hidden") !== -1;
          return Ae && !He
        }
        return !0
      },
      ye = function (me) {
        return !me || me === document.body || me.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? window : Ee(me) ? me : ye(me.assignedSlot && m.value.shadowDom ? me.assignedSlot.parentNode : me.parentNode)
      },
      ve = me => {
        if (me) switch (h.position) {
          case Ns.left:
            return {
              left: 0, transform: "translateX(0)"
            };
          case Ns.right:
            return {
              left: `${me.width}px`, transform: "translateX(-100%)"
            };
          default:
            return {
              left: `${me.width/2}px`, transform: "translateX(-50%)"
            }
        }
        return {}
      };
    return {
      openOnTop: A,
      menuStyle: S,
      xCorrect: w,
      setMenuPosition: W,
      getScrollableParent: ye,
      shadowRender: (me, Ae) => {
        var He, De, Ye;
        const Je = document.createElement("div"),
          he = (He = Wa(a)) == null ? void 0 : He.getBoundingClientRect();
        Je.setAttribute("id", "dp--temp-container");
        const ke = (De = i.value) != null && De.clientWidth ? i.value : document.body;
        ke.append(Je);
        const re = ve(he),
          Se = m.value.shadowDom ? Object.keys(p).filter(J => ["right-sidebar", "left-sidebar", "top-extra", "action-extra"].includes(J)) : Object.keys(p),
          Be = oa(me, {
            ...Ae,
            shadow: !0,
            style: {
              opacity: 0,
              position: "absolute",
              ...re
            }
          }, Object.fromEntries(Se.map(J => [J, p[J]])));
        pg(Be, Je), k.value = (Ye = Be.el) == null ? void 0 : Ye.getBoundingClientRect(), pg(null, Je), ke.removeChild(Je)
      }
    }
  },
  ui = [{
    name: "clock-icon",
    use: ["time", "calendar", "shared"]
  }, {
    name: "arrow-left",
    use: ["month-year", "calendar", "shared", "year-mode"]
  }, {
    name: "arrow-right",
    use: ["month-year", "calendar", "shared", "year-mode"]
  }, {
    name: "arrow-up",
    use: ["time", "calendar", "month-year", "shared"]
  }, {
    name: "arrow-down",
    use: ["time", "calendar", "month-year", "shared"]
  }, {
    name: "calendar-icon",
    use: ["month-year", "time", "calendar", "shared", "year-mode"]
  }, {
    name: "day",
    use: ["calendar", "shared"]
  }, {
    name: "month-overlay-value",
    use: ["calendar", "month-year", "shared"]
  }, {
    name: "year-overlay-value",
    use: ["calendar", "month-year", "shared", "year-mode"]
  }, {
    name: "year-overlay",
    use: ["month-year", "shared"]
  }, {
    name: "month-overlay",
    use: ["month-year", "shared"]
  }, {
    name: "month-overlay-header",
    use: ["month-year", "shared"]
  }, {
    name: "year-overlay-header",
    use: ["month-year", "shared"]
  }, {
    name: "hours-overlay-value",
    use: ["calendar", "time", "shared"]
  }, {
    name: "hours-overlay-header",
    use: ["calendar", "time", "shared"]
  }, {
    name: "minutes-overlay-value",
    use: ["calendar", "time", "shared"]
  }, {
    name: "minutes-overlay-header",
    use: ["calendar", "time", "shared"]
  }, {
    name: "seconds-overlay-value",
    use: ["calendar", "time", "shared"]
  }, {
    name: "seconds-overlay-header",
    use: ["calendar", "time", "shared"]
  }, {
    name: "hours",
    use: ["calendar", "time", "shared"]
  }, {
    name: "minutes",
    use: ["calendar", "time", "shared"]
  }, {
    name: "month",
    use: ["calendar", "month-year", "shared"]
  }, {
    name: "year",
    use: ["calendar", "month-year", "shared", "year-mode"]
  }, {
    name: "action-buttons",
    use: ["action"]
  }, {
    name: "action-preview",
    use: ["action"]
  }, {
    name: "calendar-header",
    use: ["calendar", "shared"]
  }, {
    name: "marker-tooltip",
    use: ["calendar", "shared"]
  }, {
    name: "action-extra",
    use: ["menu"]
  }, {
    name: "time-picker-overlay",
    use: ["calendar", "time", "shared"]
  }, {
    name: "am-pm-button",
    use: ["calendar", "time", "shared"]
  }, {
    name: "left-sidebar",
    use: ["menu"]
  }, {
    name: "right-sidebar",
    use: ["menu"]
  }, {
    name: "month-year",
    use: ["month-year", "shared"]
  }, {
    name: "time-picker",
    use: ["menu", "shared"]
  }, {
    name: "action-row",
    use: ["action"]
  }, {
    name: "marker",
    use: ["calendar", "shared"]
  }, {
    name: "quarter",
    use: ["shared"]
  }, {
    name: "top-extra",
    use: ["shared", "month-year"]
  }, {
    name: "tp-inline-arrow-up",
    use: ["shared", "time"]
  }, {
    name: "tp-inline-arrow-down",
    use: ["shared", "time"]
  }, {
    name: "menu-header",
    use: ["menu"]
  }],
  FL = [{
    name: "trigger"
  }, {
    name: "input-icon"
  }, {
    name: "clear-icon"
  }, {
    name: "dp-input"
  }],
  $L = {
    all: () => ui,
    monthYear: () => ui.filter(e => e.use.includes("month-year")),
    input: () => FL,
    timePicker: () => ui.filter(e => e.use.includes("time")),
    action: () => ui.filter(e => e.use.includes("action")),
    calendar: () => ui.filter(e => e.use.includes("calendar")),
    menu: () => ui.filter(e => e.use.includes("menu")),
    shared: () => ui.filter(e => e.use.includes("shared")),
    yearMode: () => ui.filter(e => e.use.includes("year-mode"))
  },
  Ur = (e, t, a) => {
    const i = [];
    return $L[t]().forEach(o => {
      e[o.name] && i.push(o.name)
    }), a != null && a.length && a.forEach(o => {
      o.slot && i.push(o.slot)
    }), i
  },
  Ml = e => {
    const t = Oe(() => i => e.value ? i ? e.value.open : e.value.close : ""),
      a = Oe(() => i => e.value ? i ? e.value.menuAppearTop : e.value.menuAppearBottom : "");
    return {
      transitionName: t,
      showTransition: !!e.value,
      menuTransition: a
    }
  },
  Il = (e, t, a) => {
    const {
      defaultedRange: i,
      defaultedTz: o
    } = _a(e), l = at($r(at(), o.value.timezone)), h = _e([{
      month: zt(l),
      year: Tt(l)
    }]), p = A => {
      const E = {
        hours: Kn(l),
        minutes: Ti(l),
        seconds: 0
      };
      return i.value.enabled ? [E[A], E[A]] : E[A]
    }, m = qr({
      hours: p("hours"),
      minutes: p("minutes"),
      seconds: p("seconds")
    });
    Xt(i, (A, E) => {
      A.enabled !== E.enabled && (m.hours = p("hours"), m.minutes = p("minutes"), m.seconds = p("seconds"))
    }, {
      deep: !0
    });
    const k = Oe({
        get: () => e.internalModelValue,
        set: A => {
          !e.readonly && !e.disabled && t("update:internal-model-value", A)
        }
      }),
      w = Oe(() => A => h.value[A] ? h.value[A].month : 0),
      S = Oe(() => A => h.value[A] ? h.value[A].year : 0);
    return Xt(k, (A, E) => {
      a && JSON.stringify(A ?? {}) !== JSON.stringify(E ?? {}) && a()
    }, {
      deep: !0
    }), {
      calendars: h,
      time: m,
      modelValue: k,
      month: w,
      year: S,
      today: l
    }
  },
  BL = (e, t) => {
    const {
      defaultedMultiCalendars: a,
      defaultedMultiDates: i,
      defaultedUI: o,
      defaultedHighlight: l,
      defaultedTz: h,
      propDates: p,
      defaultedRange: m
    } = _a(t), {
      isDisabled: k
    } = Di(t), w = _e(null), S = _e($r(new Date, h.value.timezone)), A = re => {
      !re.current && t.hideOffsetDates || (w.value = re.value)
    }, E = () => {
      w.value = null
    }, M = re => Array.isArray(e.value) && m.value.enabled && e.value[0] && w.value ? re ? Ia(w.value, e.value[0]) : Pa(w.value, e.value[0]) : !0, D = (re, Se) => {
      const Be = () => e.value ? Se ? e.value[0] || null : e.value[1] : null,
        J = e.value && Array.isArray(e.value) ? Be() : null;
      return Vt(at(re.value), J)
    }, B = re => {
      const Se = Array.isArray(e.value) ? e.value[0] : null;
      return re ? !Pa(w.value ?? null, Se) : !0
    }, z = (re, Se = !0) => (m.value.enabled || t.weekPicker) && Array.isArray(e.value) && e.value.length === 2 ? t.hideOffsetDates && !re.current ? !1 : Vt(at(re.value), e.value[Se ? 0 : 1]) : m.value.enabled ? D(re, Se) && B(Se) || Vt(re.value, Array.isArray(e.value) ? e.value[0] : null) && M(Se) : !1, I = (re, Se) => {
      if (Array.isArray(e.value) && e.value[0] && e.value.length === 1) {
        const Be = Vt(re.value, w.value);
        return Se ? Ia(e.value[0], re.value) && Be : Pa(e.value[0], re.value) && Be
      }
      return !1
    }, N = re => !e.value || t.hideOffsetDates && !re.current ? !1 : m.value.enabled ? t.modelAuto && Array.isArray(e.value) ? Vt(re.value, e.value[0] ? e.value[0] : S.value) : !1 : i.value.enabled && Array.isArray(e.value) ? e.value.some(Se => Vt(Se, re.value)) : Vt(re.value, e.value ? e.value : S.value), U = re => {
      if (m.value.autoRange || t.weekPicker) {
        if (w.value) {
          if (t.hideOffsetDates && !re.current) return !1;
          const Se = nn(w.value, +m.value.autoRange),
            Be = Xn(at(w.value), t.weekStart);
          return t.weekPicker ? Vt(Be[1], at(re.value)) : Vt(Se, at(re.value))
        }
        return !1
      }
      return !1
    }, W = re => {
      if (m.value.autoRange || t.weekPicker) {
        if (w.value) {
          const Se = nn(w.value, +m.value.autoRange);
          if (t.hideOffsetDates && !re.current) return !1;
          const Be = Xn(at(w.value), t.weekStart);
          return t.weekPicker ? Ia(re.value, Be[0]) && Pa(re.value, Be[1]) : Ia(re.value, w.value) && Pa(re.value, Se)
        }
        return !1
      }
      return !1
    }, X = re => {
      if (m.value.autoRange || t.weekPicker) {
        if (w.value) {
          if (t.hideOffsetDates && !re.current) return !1;
          const Se = Xn(at(w.value), t.weekStart);
          return t.weekPicker ? Vt(Se[0], re.value) : Vt(w.value, re.value)
        }
        return !1
      }
      return !1
    }, V = re => xu(e.value, w.value, re.value), ne = () => t.modelAuto && Array.isArray(t.internalModelValue) ? !!t.internalModelValue[0] : !1, Z = () => t.modelAuto ? Oy(t.internalModelValue) : !0, ie = re => {
      if (t.weekPicker) return !1;
      const Se = m.value.enabled ? !z(re) && !z(re, !1) : !0;
      return !k(re.value) && !N(re) && !(!re.current && t.hideOffsetDates) && Se
    }, fe = re => m.value.enabled ? t.modelAuto ? ne() && N(re) : !1 : N(re), le = re => l.value ? aP(re.value, p.value.highlight) : !1, Ee = re => {
      const Se = k(re.value);
      return Se && (typeof l.value == "function" ? !l.value(re.value, Se) : !l.value.options.highlightDisabled)
    }, ye = re => {
      var Se;
      return typeof l.value == "function" ? l.value(re.value) : (Se = l.value.weekdays) == null ? void 0 : Se.includes(re.value.getDay())
    }, ve = re => (m.value.enabled || t.weekPicker) && (!(a.value.count > 0) || re.current) && Z() && !(!re.current && t.hideOffsetDates) && !N(re) ? V(re) : !1, me = re => {
      const {
        isRangeStart: Se,
        isRangeEnd: Be
      } = Ye(re), J = m.value.enabled ? Se || Be : !1;
      return {
        dp__cell_offset: !re.current,
        dp__pointer: !t.disabled && !(!re.current && t.hideOffsetDates) && !k(re.value),
        dp__cell_disabled: k(re.value),
        dp__cell_highlight: !Ee(re) && (le(re) || ye(re)) && !fe(re) && !J && !X(re) && !(ve(re) && t.weekPicker) && !Be,
        dp__cell_highlight_active: !Ee(re) && (le(re) || ye(re)) && fe(re),
        dp__today: !t.noToday && Vt(re.value, S.value) && re.current,
        "dp--past": Pa(re.value, S.value),
        "dp--future": Ia(re.value, S.value)
      }
    }, Ae = re => ({
      dp__active_date: fe(re),
      dp__date_hover: ie(re)
    }), He = re => {
      if (e.value && !Array.isArray(e.value)) {
        const Se = Xn(e.value, t.weekStart);
        return {
          ...he(re),
          dp__range_start: Vt(Se[0], re.value),
          dp__range_end: Vt(Se[1], re.value),
          dp__range_between_week: Ia(re.value, Se[0]) && Pa(re.value, Se[1])
        }
      }
      return {
        ...he(re)
      }
    }, De = re => {
      if (e.value && Array.isArray(e.value)) {
        const Se = Xn(e.value[0], t.weekStart),
          Be = e.value[1] ? Xn(e.value[1], t.weekStart) : [];
        return {
          ...he(re),
          dp__range_start: Vt(Se[0], re.value) || Vt(Be[0], re.value),
          dp__range_end: Vt(Se[1], re.value) || Vt(Be[1], re.value),
          dp__range_between_week: Ia(re.value, Se[0]) && Pa(re.value, Se[1]) || Ia(re.value, Be[0]) && Pa(re.value, Be[1]),
          dp__range_between: Ia(re.value, Se[1]) && Pa(re.value, Be[0])
        }
      }
      return {
        ...he(re)
      }
    }, Ye = re => {
      const Se = a.value.count > 0 ? re.current && z(re) && Z() : z(re) && Z(),
        Be = a.value.count > 0 ? re.current && z(re, !1) && Z() : z(re, !1) && Z();
      return {
        isRangeStart: Se,
        isRangeEnd: Be
      }
    }, Je = re => {
      const {
        isRangeStart: Se,
        isRangeEnd: Be
      } = Ye(re);
      return {
        dp__range_start: Se,
        dp__range_end: Be,
        dp__range_between: ve(re),
        dp__date_hover: Vt(re.value, w.value) && !Se && !Be && !t.weekPicker,
        dp__date_hover_start: I(re, !0),
        dp__date_hover_end: I(re, !1)
      }
    }, he = re => ({
      ...Je(re),
      dp__cell_auto_range: W(re),
      dp__cell_auto_range_start: X(re),
      dp__cell_auto_range_end: U(re)
    }), ke = re => m.value.enabled ? m.value.autoRange ? he(re) : t.modelAuto ? {
      ...Ae(re),
      ...Je(re)
    } : t.weekPicker ? De(re) : Je(re) : t.weekPicker ? He(re) : Ae(re);
    return {
      setHoverDate: A,
      clearHoverDate: E,
      getDayClassData: re => t.hideOffsetDates && !re.current ? {} : {
        ...me(re),
        ...ke(re),
        [t.dayClass ? t.dayClass(re.value, t.internalModelValue) : ""]: !0,
        ...o.value.calendarCell ?? {}
      }
    }
  },
  Di = e => {
    const {
      defaultedFilters: t,
      defaultedRange: a,
      propDates: i,
      defaultedMultiDates: o
    } = _a(e), l = ye => i.value.disabledDates ? typeof i.value.disabledDates == "function" ? i.value.disabledDates(at(ye)) : !!Fc(ye, i.value.disabledDates) : !1, h = ye => i.value.maxDate ? e.yearPicker ? Tt(ye) > Tt(i.value.maxDate) : Ia(ye, i.value.maxDate) : !1, p = ye => i.value.minDate ? e.yearPicker ? Tt(ye) < Tt(i.value.minDate) : Pa(ye, i.value.minDate) : !1, m = ye => {
      const ve = h(ye),
        me = p(ye),
        Ae = l(ye),
        He = t.value.months.map(ke => +ke).includes(zt(ye)),
        De = e.disabledWeekDays.length ? e.disabledWeekDays.some(ke => +ke === WT(ye)) : !1,
        Ye = E(ye),
        Je = Tt(ye),
        he = Je < +e.yearRange[0] || Je > +e.yearRange[1];
      return !(ve || me || Ae || He || he || De || Ye)
    }, k = (ye, ve) => Pa(...bi(i.value.minDate, ye, ve)) || Vt(...bi(i.value.minDate, ye, ve)), w = (ye, ve) => Ia(...bi(i.value.maxDate, ye, ve)) || Vt(...bi(i.value.maxDate, ye, ve)), S = (ye, ve, me) => {
      let Ae = !1;
      return i.value.maxDate && me && w(ye, ve) && (Ae = !0), i.value.minDate && !me && k(ye, ve) && (Ae = !0), Ae
    }, A = (ye, ve, me, Ae) => {
      let He = !1;
      return Ae ? i.value.minDate && i.value.maxDate ? He = S(ye, ve, me) : (i.value.minDate && k(ye, ve) || i.value.maxDate && w(ye, ve)) && (He = !0) : He = !0, He
    }, E = ye => Array.isArray(i.value.allowedDates) && !i.value.allowedDates.length ? !0 : i.value.allowedDates ? !Fc(ye, i.value.allowedDates) : !1, M = ye => !m(ye), D = ye => a.value.noDisabledRange ? !py({
      start: ye[0],
      end: ye[1]
    }).some(ve => M(ve)) : !0, B = ye => {
      if (ye) {
        const ve = Tt(ye);
        return ve >= +e.yearRange[0] && ve <= e.yearRange[1]
      }
      return !0
    }, z = (ye, ve) => !!(Array.isArray(ye) && ye[ve] && (a.value.maxRange || a.value.minRange) && B(ye[ve])), I = (ye, ve, me = 0) => {
      if (z(ve, me) && B(ye)) {
        const Ae = hy(ye, ve[me]),
          He = Ny(ve[me], ye),
          De = He.length === 1 ? 0 : He.filter(Je => M(Je)).length,
          Ye = Math.abs(Ae) - (a.value.minMaxRawRange ? 0 : De);
        if (a.value.minRange && a.value.maxRange) return Ye >= +a.value.minRange && Ye <= +a.value.maxRange;
        if (a.value.minRange) return Ye >= +a.value.minRange;
        if (a.value.maxRange) return Ye <= +a.value.maxRange
      }
      return !0
    }, N = () => !e.enableTimePicker || e.monthPicker || e.yearPicker || e.ignoreTimeValidation, U = ye => Array.isArray(ye) ? [ye[0] ? cd(ye[0]) : null, ye[1] ? cd(ye[1]) : null] : cd(ye), W = (ye, ve, me) => ye.find(Ae => +Ae.hours === Kn(ve) && Ae.minutes === "*" ? !0 : +Ae.minutes === Ti(ve) && +Ae.hours === Kn(ve)) && me, X = (ye, ve, me) => {
      const [Ae, He] = ye, [De, Ye] = ve;
      return !W(Ae, De, me) && !W(He, Ye, me) && me
    }, V = (ye, ve) => {
      const me = Array.isArray(ve) ? ve : [ve];
      return Array.isArray(e.disabledTimes) ? Array.isArray(e.disabledTimes[0]) ? X(e.disabledTimes, me, ye) : !me.some(Ae => W(e.disabledTimes, Ae, ye)) : ye
    }, ne = (ye, ve) => {
      const me = Array.isArray(ve) ? [hs(ve[0]), ve[1] ? hs(ve[1]) : void 0] : hs(ve),
        Ae = !e.disabledTimes(me);
      return ye && Ae
    }, Z = (ye, ve) => e.disabledTimes ? Array.isArray(e.disabledTimes) ? V(ve, ye) : ne(ve, ye) : ve, ie = ye => {
      let ve = !0;
      if (!ye || N()) return !0;
      const me = !i.value.minDate && !i.value.maxDate ? U(ye) : ye;
      return (e.maxTime || i.value.maxDate) && (ve = lm(e.maxTime, i.value.maxDate, "max", Za(me), ve)), (e.minTime || i.value.minDate) && (ve = lm(e.minTime, i.value.minDate, "min", Za(me), ve)), Z(ye, ve)
    }, fe = ye => {
      if (!e.monthPicker) return !0;
      let ve = !0;
      const me = at(sn(ye));
      if (i.value.minDate && i.value.maxDate) {
        const Ae = at(sn(i.value.minDate)),
          He = at(sn(i.value.maxDate));
        return Ia(me, Ae) && Pa(me, He) || Vt(me, Ae) || Vt(me, He)
      }
      if (i.value.minDate) {
        const Ae = at(sn(i.value.minDate));
        ve = Ia(me, Ae) || Vt(me, Ae)
      }
      if (i.value.maxDate) {
        const Ae = at(sn(i.value.maxDate));
        ve = Pa(me, Ae) || Vt(me, Ae)
      }
      return ve
    }, le = Oe(() => ye => !e.enableTimePicker || e.ignoreTimeValidation ? !0 : ie(ye)), Ee = Oe(() => ye => e.monthPicker ? Array.isArray(ye) && (a.value.enabled || o.value.enabled) ? !ye.filter(ve => !fe(ve)).length : fe(ye) : !0);
    return {
      isDisabled: M,
      validateDate: m,
      validateMonthYearInRange: A,
      isDateRangeAllowed: D,
      checkMinMaxRange: I,
      isValidTime: ie,
      isTimeValid: le,
      isMonthValid: Ee
    }
  },
  Su = () => {
    const e = Oe(() => (i, o) => i == null ? void 0 : i.includes(o)),
      t = Oe(() => (i, o) => i.count ? i.solo ? !0 : o === 0 : !0),
      a = Oe(() => (i, o) => i.count ? i.solo ? !0 : o === i.count - 1 : !0);
    return {
      hideNavigationButtons: e,
      showLeftIcon: t,
      showRightIcon: a
    }
  },
  HL = (e, t, a) => {
    const i = _e(0),
      o = qr({
        [ds.timePicker]: !e.enableTimePicker || e.timePicker || e.monthPicker,
        [ds.calendar]: !1,
        [ds.header]: !1
      }),
      l = Oe(() => e.monthPicker || e.timePicker),
      h = S => {
        var A;
        if ((A = e.flow) != null && A.length) {
          if (!S && l.value) return w();
          o[S] = !0, Object.keys(o).filter(E => !o[E]).length || w()
        }
      },
      p = () => {
        var S, A;
        (S = e.flow) != null && S.length && i.value !== -1 && (i.value += 1, t("flow-step", i.value), w()), ((A = e.flow) == null ? void 0 : A.length) === i.value && Jt().then(() => m())
      },
      m = () => {
        i.value = -1
      },
      k = (S, A, ...E) => {
        var M, D;
        e.flow[i.value] === S && a.value && ((D = (M = a.value)[A]) == null || D.call(M, ...E))
      },
      w = (S = 0) => {
        S && (i.value += S), k(hr.month, "toggleMonthPicker", !0), k(hr.year, "toggleYearPicker", !0), k(hr.calendar, "toggleTimePicker", !1, !0), k(hr.time, "toggleTimePicker", !0, !0);
        const A = e.flow[i.value];
        (A === hr.hours || A === hr.minutes || A === hr.seconds) && k(A, "toggleTimePicker", !0, !0, A)
      };
    return {
      childMount: h,
      updateFlowStep: p,
      resetFlow: m,
      handleFlow: w,
      flowStep: i
    }
  },
  YL = {
    key: 1,
    class: "dp__input_wrap"
  },
  zL = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "aria-disabled", "aria-invalid"],
  XL = {
    key: 2,
    class: "dp--clear-btn"
  },
  WL = ["aria-label"],
  VL = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "DatepickerInput",
    props: {
      isMenuOpen: {
        type: Boolean,
        default: !1
      },
      inputValue: {
        type: String,
        default: ""
      },
      ...wu
    },
    emits: ["clear", "open", "update:input-value", "set-input-date", "close", "select-date", "set-empty-date", "toggle", "focus-prev", "focus", "blur", "real-blur", "text-input"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        {
          defaultedTextInput: l,
          defaultedAriaLabels: h,
          defaultedInline: p,
          defaultedConfig: m,
          defaultedRange: k,
          defaultedMultiDates: w,
          defaultedUI: S,
          getDefaultPattern: A,
          getDefaultStartTime: E
        } = _a(o),
        {
          checkMinMaxRange: M
        } = Di(o),
        D = _e(),
        B = _e(null),
        z = _e(!1),
        I = _e(!1),
        N = _e(!1),
        U = _e(null),
        W = Oe(() => ({
          dp__pointer: !o.disabled && !o.readonly && !l.value.enabled,
          dp__disabled: o.disabled,
          dp__input_readonly: !l.value.enabled,
          dp__input: !0,
          dp__input_icon_pad: !o.hideInputIcon,
          dp__input_valid: typeof o.state == "boolean" ? o.state : !1,
          dp__input_invalid: typeof o.state == "boolean" ? !o.state : !1,
          dp__input_focus: z.value || o.isMenuOpen,
          dp__input_reg: !l.value.enabled,
          ...S.value.input ?? {}
        })),
        X = () => {
          i("set-input-date", null), o.clearable && o.autoApply && (i("set-empty-date"), D.value = null)
        },
        V = he => {
          const ke = E();
          return nP(he, l.value.format ?? A(), ke ?? Fy({}, o.enableSeconds), o.inputValue, N.value, o.formatLocale)
        },
        ne = he => {
          const {
            rangeSeparator: ke
          } = l.value, [re, Se] = he.split(`${ke}`);
          if (re) {
            const Be = V(re.trim()),
              J = Se ? V(Se.trim()) : null;
            if (eo(Be, J)) return;
            const Re = Be && J ? [Be, J] : [Be];
            M(J, Re, 0) && (D.value = Be ? Re : null)
          }
        },
        Z = () => {
          N.value = !0
        },
        ie = he => {
          if (k.value.enabled) ne(he);
          else if (w.value.enabled) {
            const ke = he.split(";");
            D.value = ke.map(re => V(re.trim())).filter(re => re)
          } else D.value = V(he)
        },
        fe = he => {
          var ke;
          const re = typeof he == "string" ? he : (ke = he.target) == null ? void 0 : ke.value;
          re !== "" ? (l.value.openMenu && !o.isMenuOpen && i("open"), ie(re), i("set-input-date", D.value)) : X(), N.value = !1, i("update:input-value", re), i("text-input", he, D.value)
        },
        le = he => {
          l.value.enabled ? (ie(he.target.value), l.value.enterSubmit && Ph(D.value) && o.inputValue !== "" ? (i("set-input-date", D.value, !0), D.value = null) : l.value.enterSubmit && o.inputValue === "" && (D.value = null, i("clear"))) : ve(he)
        },
        Ee = (he, ke) => {
          var re;
          if (U.value && ke && !I.value) return he.preventDefault(), I.value = !0, (re = U.value) == null ? void 0 : re.focus();
          l.value.enabled && l.value.tabSubmit && ie(he.target.value), l.value.tabSubmit && Ph(D.value) && o.inputValue !== "" ? (i("set-input-date", D.value, !0, !0), D.value = null) : l.value.tabSubmit && o.inputValue === "" && (D.value = null, i("clear", !0))
        },
        ye = () => {
          z.value = !0, i("focus"), Jt().then(() => {
            var he;
            l.value.enabled && l.value.selectOnFocus && ((he = B.value) == null || he.select())
          })
        },
        ve = he => {
          if (he.preventDefault(), _i(he, m.value, !0), l.value.enabled && l.value.openMenu && !p.value.input) {
            if (l.value.openMenu === "open" && !o.isMenuOpen) return i("open");
            if (l.value.openMenu === "toggle") return i("toggle")
          } else l.value.enabled || i("toggle")
        },
        me = () => {
          i("real-blur"), z.value = !1, (!o.isMenuOpen || p.value.enabled && p.value.input) && i("blur"), o.autoApply && l.value.enabled && D.value && !o.isMenuOpen && (i("set-input-date", D.value), i("select-date"), D.value = null)
        },
        Ae = he => {
          _i(he, m.value, !0), i("clear")
        },
        He = (he, ke) => {
          if (he.key === "Tab" && Ee(he, ke), he.key === "Enter" && le(he), !l.value.enabled) {
            if (he.code === "Tab") return;
            he.preventDefault()
          }
        },
        De = () => {
          var he;
          (he = B.value) == null || he.focus({
            preventScroll: !0
          })
        },
        Ye = he => {
          D.value = he
        },
        Je = he => {
          he.key === ba.tab && (I.value = !1, Ee(he))
        };
      return t({
        focusInput: De,
        setParsedDate: Ye
      }), (he, ke) => {
        var re, Se;
        return be(), Ne("div", {
          onClick: ve
        }, [he.$slots.trigger && !he.$slots["dp-input"] && !se(p).enabled ? lt(he.$slots, "trigger", {
          key: 0
        }) : Ke("", !0), !he.$slots.trigger && (!se(p).enabled || se(p).input) ? (be(), Ne("div", YL, [he.$slots["dp-input"] && !he.$slots.trigger && (!se(p).enabled || se(p).enabled && se(p).input) ? lt(he.$slots, "dp-input", {
          key: 0,
          value: e.inputValue,
          isMenuOpen: e.isMenuOpen,
          onInput: fe,
          onEnter: le,
          onTab: Ee,
          onClear: Ae,
          onBlur: me,
          onKeypress: He,
          onPaste: Z,
          onFocus: ye,
          openMenu: () => he.$emit("open"),
          closeMenu: () => he.$emit("close"),
          toggleMenu: () => he.$emit("toggle")
        }) : Ke("", !0), he.$slots["dp-input"] ? Ke("", !0) : (be(), Ne("input", {
          key: 1,
          id: he.uid ? `dp-input-${he.uid}` : void 0,
          ref_key: "inputRef",
          ref: B,
          "data-test": "dp-input",
          name: he.name,
          class: ut(W.value),
          inputmode: se(l).enabled ? "text" : "none",
          placeholder: he.placeholder,
          disabled: he.disabled,
          readonly: he.readonly,
          required: he.required,
          value: e.inputValue,
          autocomplete: he.autocomplete,
          "aria-disabled": he.disabled || void 0,
          "aria-invalid": he.state === !1 ? !0 : void 0,
          onInput: fe,
          onBlur: me,
          onFocus: ye,
          onKeypress: He,
          onKeydown: ke[0] || (ke[0] = Be => He(Be, !0)),
          onPaste: Z
        }, null, 42, zL)), ce("div", {
          onClick: ke[3] || (ke[3] = Be => i("toggle"))
        }, [he.$slots["input-icon"] && !he.hideInputIcon ? (be(), Ne("span", {
          key: 0,
          class: "dp__input_icon",
          onClick: ke[1] || (ke[1] = Be => i("toggle"))
        }, [lt(he.$slots, "input-icon")])) : Ke("", !0), !he.$slots["input-icon"] && !he.hideInputIcon && !he.$slots["dp-input"] ? (be(), yt(se(mo), {
          key: 1,
          "aria-label": (re = se(h)) == null ? void 0 : re.calendarIcon,
          class: "dp__input_icon dp__input_icons",
          onClick: ke[2] || (ke[2] = Be => i("toggle"))
        }, null, 8, ["aria-label"])) : Ke("", !0)]), he.$slots["clear-icon"] && e.inputValue && he.clearable && !he.disabled && !he.readonly ? (be(), Ne("span", XL, [lt(he.$slots, "clear-icon", {
          clear: Ae
        })])) : Ke("", !0), he.clearable && !he.$slots["clear-icon"] && e.inputValue && !he.disabled && !he.readonly ? (be(), Ne("button", {
          key: 3,
          ref_key: "clearBtnRef",
          ref: U,
          "aria-label": (Se = se(h)) == null ? void 0 : Se.clearInput,
          class: "dp--clear-btn",
          type: "button",
          onBlur: ke[4] || (ke[4] = Be => I.value = !1),
          onKeydown: ke[5] || (ke[5] = Be => se(Cr)(Be, () => Ae(Be), !0, Je)),
          onClick: ke[6] || (ke[6] = qn(Be => Ae(Be), ["prevent"]))
        }, [Ze(se(Py), {
          class: "dp__input_icons",
          "data-test": "clear-icon"
        })], 40, WL)) : Ke("", !0)])) : Ke("", !0)])
      }
    }
  }),
  jL = typeof window < "u" ? window : void 0,
  gd = () => {},
  UL = e => nb() ? (Sw(e), !0) : !1,
  GL = (e, t, a, i) => {
    if (!e) return gd;
    let o = gd;
    const l = Xt(() => se(e), p => {
        o(), p && (p.addEventListener(t, a, i), o = () => {
          p.removeEventListener(t, a, i), o = gd
        })
      }, {
        immediate: !0,
        flush: "post"
      }),
      h = () => {
        l(), o()
      };
    return UL(h), h
  },
  qL = (e, t, a, i = {}) => {
    const {
      window: o = jL,
      event: l = "pointerdown"
    } = i;
    return o ? GL(o, l, h => {
      const p = Wa(e),
        m = Wa(t);
      !p || !m || p === h.target || h.composedPath().includes(p) || h.composedPath().includes(m) || a(h)
    }, {
      passive: !0
    }) : void 0
  },
  KL = Ot({
    compatConfig: {
      MODE: 3
    },
    __name: "VueDatePicker",
    props: {
      ...wu
    },
    emits: ["update:model-value", "update:model-timezone-value", "text-submit", "closed", "cleared", "open", "focus", "blur", "internal-model-change", "recalculate-position", "flow-step", "update-month-year", "invalid-select", "invalid-fixed-range", "tooltip-open", "tooltip-close", "time-picker-open", "time-picker-close", "am-pm-change", "range-start", "range-end", "date-update", "invalid-date", "overlay-toggle", "text-input"],
    setup(e, {
      expose: t,
      emit: a
    }) {
      const i = a,
        o = e,
        l = vs(),
        h = _e(!1),
        p = ol(o, "modelValue"),
        m = ol(o, "timezone"),
        k = _e(null),
        w = _e(null),
        S = _e(null),
        A = _e(!1),
        E = _e(null),
        M = _e(!1),
        D = _e(!1),
        B = _e(!1),
        z = _e(!1),
        {
          setMenuFocused: I,
          setShiftKey: N
        } = zy(),
        {
          clearArrowNav: U
        } = Ri(),
        {
          validateDate: W,
          isValidTime: X
        } = Di(o),
        {
          defaultedTransitions: V,
          defaultedTextInput: ne,
          defaultedInline: Z,
          defaultedConfig: ie,
          defaultedRange: fe,
          defaultedMultiDates: le
        } = _a(o),
        {
          menuTransition: Ee,
          showTransition: ye
        } = Ml(V);
      Dt(() => {
        Se(o.modelValue), Jt().then(() => {
          if (!Z.value.enabled) {
            const ze = Je(E.value);
            ze == null || ze.addEventListener("scroll", oe), window == null || window.addEventListener("resize", de)
          }
        }), Z.value.enabled && (h.value = !0), window == null || window.addEventListener("keyup", Ie), window == null || window.addEventListener("keydown", ue)
      }), Ha(() => {
        if (!Z.value.enabled) {
          const ze = Je(E.value);
          ze == null || ze.removeEventListener("scroll", oe), window == null || window.removeEventListener("resize", de)
        }
        window == null || window.removeEventListener("keyup", Ie), window == null || window.removeEventListener("keydown", ue)
      });
      const ve = Ur(l, "all", o.presetDates),
        me = Ur(l, "input");
      Xt([p, m], () => {
        Se(p.value)
      }, {
        deep: !0
      });
      const {
        openOnTop: Ae,
        menuStyle: He,
        xCorrect: De,
        setMenuPosition: Ye,
        getScrollableParent: Je,
        shadowRender: he
      } = NL({
        menuRef: k,
        menuRefInner: w,
        inputRef: S,
        pickerWrapperRef: E,
        inline: Z,
        emit: i,
        props: o,
        slots: l
      }), {
        inputValue: ke,
        internalModelValue: re,
        parseExternalModelValue: Se,
        emitModelValue: Be,
        formatInputValue: J,
        checkBeforeEmit: Re
      } = EP(i, o, A), Xe = Oe(() => ({
        dp__main: !0,
        dp__theme_dark: o.dark,
        dp__theme_light: !o.dark,
        dp__flex_display: Z.value.enabled,
        "dp--flex-display-collapsed": B.value,
        dp__flex_display_with_input: Z.value.input
      })), nt = Oe(() => o.dark ? "dp__theme_dark" : "dp__theme_light"), Pe = Oe(() => o.teleport ? {
        to: typeof o.teleport == "boolean" ? "body" : o.teleport,
        disabled: !o.teleport || Z.value.enabled
      } : {}), We = Oe(() => ({
        class: "dp__outer_menu_wrap"
      })), F = Oe(() => Z.value.enabled && (o.timePicker || o.monthPicker || o.yearPicker || o.quarterPicker)), j = () => {
        var ze, et;
        return (et = (ze = S.value) == null ? void 0 : ze.$el) == null ? void 0 : et.getBoundingClientRect()
      }, oe = () => {
        h.value && (ie.value.closeOnScroll ? $e() : Ye())
      }, de = () => {
        var ze;
        h.value && Ye();
        const et = (ze = w.value) == null ? void 0 : ze.$el.getBoundingClientRect().width;
        B.value = document.body.offsetWidth <= et
      }, Ie = ze => {
        ze.key === "Tab" && !Z.value.enabled && !o.teleport && ie.value.tabOutClosesMenu && (E.value.contains(document.activeElement) || $e()), D.value = ze.shiftKey
      }, ue = ze => {
        D.value = ze.shiftKey
      }, Le = () => {
        !o.disabled && !o.readonly && (he(hm, o), Ye(!1), h.value = !0, h.value && i("open"), h.value || Te(), Se(o.modelValue))
      }, K = () => {
        var ze;
        ke.value = "", Te(), (ze = S.value) == null || ze.setParsedDate(null), i("update:model-value", null), i("update:model-timezone-value", null), i("cleared"), ie.value.closeOnClearValue && $e()
      }, ae = () => {
        const ze = re.value;
        return !ze || !Array.isArray(ze) && W(ze) ? !0 : Array.isArray(ze) ? le.value.enabled || ze.length === 2 && W(ze[0]) && W(ze[1]) ? !0 : fe.value.partialRange && !o.timePicker ? W(ze[0]) : !1 : !1
      }, xe = () => {
        Re() && ae() ? (Be(), $e()) : i("invalid-select", re.value)
      }, Ce = ze => {
        tt(), Be(), ie.value.closeOnAutoApply && !ze && $e()
      }, tt = () => {
        S.value && ne.value.enabled && S.value.setParsedDate(re.value)
      }, qe = (ze = !1) => {
        o.autoApply && X(re.value) && ae() && (fe.value.enabled && Array.isArray(re.value) ? (fe.value.partialRange || re.value.length === 2) && Ce(ze) : Ce(ze))
      }, Te = () => {
        ne.value.enabled || (re.value = null)
      }, $e = () => {
        Z.value.enabled || (h.value && (h.value = !1, De.value = !1, I(!1), N(!1), U(), i("closed"), ke.value && Se(p.value)), Te(), i("blur"))
      }, ft = (ze, et, ct = !1) => {
        if (!ze) {
          re.value = null;
          return
        }
        const ca = Array.isArray(ze) ? !ze.some(nr => !W(nr)) : W(ze),
          Oa = X(ze);
        ca && Oa && (z.value = !0, re.value = ze, et && (M.value = ct, xe(), i("text-submit")), Jt().then(() => {
          z.value = !1
        }))
      }, gt = () => {
        o.autoApply && X(re.value) && Be(), tt()
      }, Ct = () => h.value ? $e() : Le(), ia = ze => {
        re.value = ze
      }, xa = () => {
        ne.value.enabled && (A.value = !0, J()), i("focus")
      }, yr = () => {
        if (ne.value.enabled && (A.value = !1, Se(o.modelValue), M.value)) {
          const ze = tP(E.value, D.value);
          ze == null || ze.focus()
        }
        i("blur")
      }, qa = ze => {
        w.value && w.value.updateMonthYear(0, {
          month: im(ze.month),
          year: im(ze.year)
        })
      }, xr = ze => {
        Se(ze ?? o.modelValue)
      }, wa = (ze, et) => {
        var ct;
        (ct = w.value) == null || ct.switchView(ze, et)
      }, Me = ze => ie.value.onClickOutside ? ie.value.onClickOutside(ze) : $e(), rt = (ze = 0) => {
        var et;
        (et = w.value) == null || et.handleFlow(ze)
      };
      return qL(k, S, () => Me(ae)), t({
        closeMenu: $e,
        selectDate: xe,
        clearValue: K,
        openMenu: Le,
        onScroll: oe,
        formatInputValue: J,
        updateInternalModelValue: ia,
        setMonthYear: qa,
        parseModel: xr,
        switchView: wa,
        toggleMenu: Ct,
        handleFlow: rt,
        dpWrapMenuRef: k
      }), (ze, et) => (be(), Ne("div", {
        ref_key: "pickerWrapperRef",
        ref: E,
        class: ut(Xe.value),
        "data-datepicker-instance": ""
      }, [Ze(VL, ja({
        ref_key: "inputRef",
        ref: S,
        "input-value": se(ke),
        "onUpdate:inputValue": et[0] || (et[0] = ct => Fa(ke) ? ke.value = ct : null),
        "is-menu-open": h.value
      }, ze.$props, {
        onClear: K,
        onOpen: Le,
        onSetInputDate: ft,
        onSetEmptyDate: se(Be),
        onSelectDate: xe,
        onToggle: Ct,
        onClose: $e,
        onFocus: xa,
        onBlur: yr,
        onRealBlur: et[1] || (et[1] = ct => A.value = !1),
        onTextInput: et[2] || (et[2] = ct => ze.$emit("text-input", ct))
      }), mr({
        _: 2
      }, [la(se(me), (ct, ca) => ({
        name: ct,
        fn: Qe(Oa => [lt(ze.$slots, ct, Ja(Ar(Oa)))])
      }))]), 1040, ["input-value", "is-menu-open", "onSetEmptyDate"]), (be(), yt(Al(ze.teleport ? xf : "div"), Ja(Ar(Pe.value)), {
        default: Qe(() => [Ze(In, {
          name: se(Ee)(se(Ae)),
          css: se(ye) && !se(Z).enabled
        }, {
          default: Qe(() => [h.value ? (be(), Ne("div", ja({
            key: 0,
            ref_key: "dpWrapMenuRef",
            ref: k
          }, We.value, {
            class: {
              "dp--menu-wrapper": !se(Z).enabled
            },
            style: se(Z).enabled ? void 0 : se(He)
          }), [Ze(hm, ja({
            ref_key: "dpMenuRef",
            ref: w
          }, ze.$props, {
            "internal-model-value": se(re),
            "onUpdate:internalModelValue": et[3] || (et[3] = ct => Fa(re) ? re.value = ct : null),
            class: {
              [nt.value]: !0,
              "dp--menu-wrapper": ze.teleport
            },
            "open-on-top": se(Ae),
            "no-overlay-focus": F.value,
            collapse: B.value,
            "get-input-rect": j,
            "is-text-input-date": z.value,
            onClosePicker: $e,
            onSelectDate: xe,
            onAutoApply: qe,
            onTimeUpdate: gt,
            onFlowStep: et[4] || (et[4] = ct => ze.$emit("flow-step", ct)),
            onUpdateMonthYear: et[5] || (et[5] = ct => ze.$emit("update-month-year", ct)),
            onInvalidSelect: et[6] || (et[6] = ct => ze.$emit("invalid-select", se(re))),
            onAutoApplyInvalid: et[7] || (et[7] = ct => ze.$emit("invalid-select", ct)),
            onInvalidFixedRange: et[8] || (et[8] = ct => ze.$emit("invalid-fixed-range", ct)),
            onRecalculatePosition: se(Ye),
            onTooltipOpen: et[9] || (et[9] = ct => ze.$emit("tooltip-open", ct)),
            onTooltipClose: et[10] || (et[10] = ct => ze.$emit("tooltip-close", ct)),
            onTimePickerOpen: et[11] || (et[11] = ct => ze.$emit("time-picker-open", ct)),
            onTimePickerClose: et[12] || (et[12] = ct => ze.$emit("time-picker-close", ct)),
            onAmPmChange: et[13] || (et[13] = ct => ze.$emit("am-pm-change", ct)),
            onRangeStart: et[14] || (et[14] = ct => ze.$emit("range-start", ct)),
            onRangeEnd: et[15] || (et[15] = ct => ze.$emit("range-end", ct)),
            onDateUpdate: et[16] || (et[16] = ct => ze.$emit("date-update", ct)),
            onInvalidDate: et[17] || (et[17] = ct => ze.$emit("invalid-date", ct)),
            onOverlayToggle: et[18] || (et[18] = ct => ze.$emit("overlay-toggle", ct))
          }), mr({
            _: 2
          }, [la(se(ve), (ct, ca) => ({
            name: ct,
            fn: Qe(Oa => [lt(ze.$slots, ct, Ja(Ar({
              ...Oa
            })))])
          }))]), 1040, ["internal-model-value", "class", "open-on-top", "no-overlay-focus", "collapse", "is-text-input-date", "onRecalculatePosition"])], 16)) : Ke("", !0)]),
          _: 3
        }, 8, ["name", "css"])]),
        _: 3
      }, 16))], 2))
    }
  }),
  Zf = (() => {
    const e = KL;
    return e.install = t => {
      t.component("Vue3DatePicker", e)
    }, e
  })(),
  ZL = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: Zf
  }, Symbol.toStringTag, {
    value: "Module"
  }));
Object.entries(ZL).forEach(([e, t]) => {
  e !== "default" && (Zf[e] = t)
});
const Us = (e, t = 0, a = 1) => Jf(ep(t, e), a),
  Qf = e => {
    e._clipped = !1, e._unclipped = e.slice(0);
    for (let t = 0; t <= 3; t++) t < 3 ? ((e[t] < 0 || e[t] > 255) && (e._clipped = !0), e[t] = Us(e[t], 0, 255)) : t === 3 && (e[t] = Us(e[t], 0, 1));
    return e
  },
  qy = {};
for (let e of ["Boolean", "Number", "String", "Function", "Array", "Date", "RegExp", "Undefined", "Null"]) qy[`[object ${e}]`] = e.toLowerCase();

function Ht(e) {
  return qy[Object.prototype.toString.call(e)] || "object"
}
const Yt = (e, t = null) => e.length >= 3 ? Array.prototype.slice.call(e) : Ht(e[0]) == "object" && t ? t.split("").filter(a => e[0][a] !== void 0).map(a => e[0][a]) : e[0],
  Au = e => {
    if (e.length < 2) return null;
    const t = e.length - 1;
    return Ht(e[t]) == "string" ? e[t].toLowerCase() : null
  },
  {
    PI: Cu,
    min: Jf,
    max: ep
  } = Math,
  Wn = Cu * 2,
  md = Cu / 3,
  QL = Cu / 180,
  JL = 180 / Cu,
  Rt = {
    format: {},
    autodetect: []
  };
class ot {
  constructor(...t) {
    const a = this;
    if (Ht(t[0]) === "object" && t[0].constructor && t[0].constructor === this.constructor) return t[0];
    let i = Au(t),
      o = !1;
    if (!i) {
      o = !0, Rt.sorted || (Rt.autodetect = Rt.autodetect.sort((l, h) => h.p - l.p), Rt.sorted = !0);
      for (let l of Rt.autodetect)
        if (i = l.test(...t), i) break
    }
    if (Rt.format[i]) {
      const l = Rt.format[i].apply(null, o ? t : t.slice(0, -1));
      a._rgb = Qf(l)
    } else throw new Error("unknown format: " + t);
    a._rgb.length === 3 && a._rgb.push(1)
  }
  toString() {
    return Ht(this.hex) == "function" ? this.hex() : `[${this._rgb.join(",")}]`
  }
}
const eO = "2.6.0",
  Ft = (...e) => new Ft.Color(...e);
Ft.Color = ot;
Ft.version = eO;
const tO = (...e) => {
    e = Yt(e, "cmyk");
    const [t, a, i, o] = e, l = e.length > 4 ? e[4] : 1;
    return o === 1 ? [0, 0, 0, l] : [t >= 1 ? 0 : 255 * (1 - t) * (1 - o), a >= 1 ? 0 : 255 * (1 - a) * (1 - o), i >= 1 ? 0 : 255 * (1 - i) * (1 - o), l]
  },
  {
    max: fm
  } = Math,
  aO = (...e) => {
    let [t, a, i] = Yt(e, "rgb");
    t = t / 255, a = a / 255, i = i / 255;
    const o = 1 - fm(t, fm(a, i)),
      l = o < 1 ? 1 / (1 - o) : 0,
      h = (1 - t - o) * l,
      p = (1 - a - o) * l,
      m = (1 - i - o) * l;
    return [h, p, m, o]
  };
ot.prototype.cmyk = function () {
  return aO(this._rgb)
};
Ft.cmyk = (...e) => new ot(...e, "cmyk");
Rt.format.cmyk = tO;
Rt.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = Yt(e, "cmyk"), Ht(e) === "array" && e.length === 4) return "cmyk"
  }
});
const vd = e => Math.round(e * 100) / 100,
  rO = (...e) => {
    const t = Yt(e, "hsla");
    let a = Au(e) || "lsa";
    return t[0] = vd(t[0] || 0), t[1] = vd(t[1] * 100) + "%", t[2] = vd(t[2] * 100) + "%", a === "hsla" || t.length > 3 && t[3] < 1 ? (t[3] = t.length > 3 ? t[3] : 1, a = "hsla") : t.length = 3, `${a}(${t.join(",")})`
  },
  Ky = (...e) => {
    e = Yt(e, "rgba");
    let [t, a, i] = e;
    t /= 255, a /= 255, i /= 255;
    const o = Jf(t, a, i),
      l = ep(t, a, i),
      h = (l + o) / 2;
    let p, m;
    return l === o ? (p = 0, m = Number.NaN) : p = h < .5 ? (l - o) / (l + o) : (l - o) / (2 - l - o), t == l ? m = (a - i) / (l - o) : a == l ? m = 2 + (i - t) / (l - o) : i == l && (m = 4 + (t - a) / (l - o)), m *= 60, m < 0 && (m += 360), e.length > 3 && e[3] !== void 0 ? [m, p, h, e[3]] : [m, p, h]
  },
  {
    round: bd
  } = Math,
  nO = (...e) => {
    const t = Yt(e, "rgba");
    let a = Au(e) || "rgb";
    return a.substr(0, 3) == "hsl" ? rO(Ky(t), a) : (t[0] = bd(t[0]), t[1] = bd(t[1]), t[2] = bd(t[2]), (a === "rgba" || t.length > 3 && t[3] < 1) && (t[3] = t.length > 3 ? t[3] : 1, a = "rgba"), `${a}(${t.slice(0,a==="rgb"?3:4).join(",")})`)
  },
  {
    round: yd
  } = Math,
  Lh = (...e) => {
    e = Yt(e, "hsl");
    const [t, a, i] = e;
    let o, l, h;
    if (a === 0) o = l = h = i * 255;
    else {
      const p = [0, 0, 0],
        m = [0, 0, 0],
        k = i < .5 ? i * (1 + a) : i + a - i * a,
        w = 2 * i - k,
        S = t / 360;
      p[0] = S + 1 / 3, p[1] = S, p[2] = S - 1 / 3;
      for (let A = 0; A < 3; A++) p[A] < 0 && (p[A] += 1), p[A] > 1 && (p[A] -= 1), 6 * p[A] < 1 ? m[A] = w + (k - w) * 6 * p[A] : 2 * p[A] < 1 ? m[A] = k : 3 * p[A] < 2 ? m[A] = w + (k - w) * (2 / 3 - p[A]) * 6 : m[A] = w;
      [o, l, h] = [yd(m[0] * 255), yd(m[1] * 255), yd(m[2] * 255)]
    }
    return e.length > 3 ? [o, l, h, e[3]] : [o, l, h, 1]
  },
  Zy = /^rgb\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*\)$/,
  Qy = /^rgba\(\s*(-?\d+),\s*(-?\d+)\s*,\s*(-?\d+)\s*,\s*([01]|[01]?\.\d+)\)$/,
  Jy = /^rgb\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/,
  ex = /^rgba\(\s*(-?\d+(?:\.\d+)?)%,\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/,
  tx = /^hsl\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*\)$/,
  ax = /^hsla\(\s*(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)%\s*,\s*(-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)$/,
  {
    round: pm
  } = Math,
  tp = e => {
    e = e.toLowerCase().trim();
    let t;
    if (Rt.format.named) try {
      return Rt.format.named(e)
    } catch {}
    if (t = e.match(Zy)) {
      const a = t.slice(1, 4);
      for (let i = 0; i < 3; i++) a[i] = +a[i];
      return a[3] = 1, a
    }
    if (t = e.match(Qy)) {
      const a = t.slice(1, 5);
      for (let i = 0; i < 4; i++) a[i] = +a[i];
      return a
    }
    if (t = e.match(Jy)) {
      const a = t.slice(1, 4);
      for (let i = 0; i < 3; i++) a[i] = pm(a[i] * 2.55);
      return a[3] = 1, a
    }
    if (t = e.match(ex)) {
      const a = t.slice(1, 5);
      for (let i = 0; i < 3; i++) a[i] = pm(a[i] * 2.55);
      return a[3] = +a[3], a
    }
    if (t = e.match(tx)) {
      const a = t.slice(1, 4);
      a[1] *= .01, a[2] *= .01;
      const i = Lh(a);
      return i[3] = 1, i
    }
    if (t = e.match(ax)) {
      const a = t.slice(1, 4);
      a[1] *= .01, a[2] *= .01;
      const i = Lh(a);
      return i[3] = +t[4], i
    }
  };
tp.test = e => Zy.test(e) || Qy.test(e) || Jy.test(e) || ex.test(e) || tx.test(e) || ax.test(e);
ot.prototype.css = function (e) {
  return nO(this._rgb, e)
};
Ft.css = (...e) => new ot(...e, "css");
Rt.format.css = tp;
Rt.autodetect.push({
  p: 5,
  test: (e, ...t) => {
    if (!t.length && Ht(e) === "string" && tp.test(e)) return "css"
  }
});
Rt.format.gl = (...e) => {
  const t = Yt(e, "rgba");
  return t[0] *= 255, t[1] *= 255, t[2] *= 255, t
};
Ft.gl = (...e) => new ot(...e, "gl");
ot.prototype.gl = function () {
  const e = this._rgb;
  return [e[0] / 255, e[1] / 255, e[2] / 255, e[3]]
};
const {
  floor: iO
} = Math, sO = (...e) => {
  e = Yt(e, "hcg");
  let [t, a, i] = e, o, l, h;
  i = i * 255;
  const p = a * 255;
  if (a === 0) o = l = h = i;
  else {
    t === 360 && (t = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 60;
    const m = iO(t),
      k = t - m,
      w = i * (1 - a),
      S = w + p * (1 - k),
      A = w + p * k,
      E = w + p;
    switch (m) {
      case 0:
        [o, l, h] = [E, A, w];
        break;
      case 1:
        [o, l, h] = [S, E, w];
        break;
      case 2:
        [o, l, h] = [w, E, A];
        break;
      case 3:
        [o, l, h] = [w, S, E];
        break;
      case 4:
        [o, l, h] = [A, w, E];
        break;
      case 5:
        [o, l, h] = [E, w, S];
        break
    }
  }
  return [o, l, h, e.length > 3 ? e[3] : 1]
}, oO = (...e) => {
  const [t, a, i] = Yt(e, "rgb"), o = Jf(t, a, i), l = ep(t, a, i), h = l - o, p = h * 100 / 255, m = o / (255 - h) * 100;
  let k;
  return h === 0 ? k = Number.NaN : (t === l && (k = (a - i) / h), a === l && (k = 2 + (i - t) / h), i === l && (k = 4 + (t - a) / h), k *= 60, k < 0 && (k += 360)), [k, p, m]
};
ot.prototype.hcg = function () {
  return oO(this._rgb)
};
Ft.hcg = (...e) => new ot(...e, "hcg");
Rt.format.hcg = sO;
Rt.autodetect.push({
  p: 1,
  test: (...e) => {
    if (e = Yt(e, "hcg"), Ht(e) === "array" && e.length === 3) return "hcg"
  }
});
const lO = /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/,
  cO = /^#?([A-Fa-f0-9]{8}|[A-Fa-f0-9]{4})$/,
  rx = e => {
    if (e.match(lO)) {
      (e.length === 4 || e.length === 7) && (e = e.substr(1)), e.length === 3 && (e = e.split(""), e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]);
      const t = parseInt(e, 16),
        a = t >> 16,
        i = t >> 8 & 255,
        o = t & 255;
      return [a, i, o, 1]
    }
    if (e.match(cO)) {
      (e.length === 5 || e.length === 9) && (e = e.substr(1)), e.length === 4 && (e = e.split(""), e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]);
      const t = parseInt(e, 16),
        a = t >> 24 & 255,
        i = t >> 16 & 255,
        o = t >> 8 & 255,
        l = Math.round((t & 255) / 255 * 100) / 100;
      return [a, i, o, l]
    }
    throw new Error(`unknown hex color: ${e}`)
  },
  {
    round: ec
  } = Math,
  nx = (...e) => {
    let [t, a, i, o] = Yt(e, "rgba"), l = Au(e) || "auto";
    o === void 0 && (o = 1), l === "auto" && (l = o < 1 ? "rgba" : "rgb"), t = ec(t), a = ec(a), i = ec(i);
    let p = "000000" + (t << 16 | a << 8 | i).toString(16);
    p = p.substr(p.length - 6);
    let m = "0" + ec(o * 255).toString(16);
    switch (m = m.substr(m.length - 2), l.toLowerCase()) {
      case "rgba":
        return `#${p}${m}`;
      case "argb":
        return `#${m}${p}`;
      default:
        return `#${p}`
    }
  };
ot.prototype.hex = function (e) {
  return nx(this._rgb, e)
};
Ft.hex = (...e) => new ot(...e, "hex");
Rt.format.hex = rx;
Rt.autodetect.push({
  p: 4,
  test: (e, ...t) => {
    if (!t.length && Ht(e) === "string" && [3, 4, 5, 6, 7, 8, 9].indexOf(e.length) >= 0) return "hex"
  }
});
const {
  cos: Ps
} = Math, uO = (...e) => {
  e = Yt(e, "hsi");
  let [t, a, i] = e, o, l, h;
  return isNaN(t) && (t = 0), isNaN(a) && (a = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 360, t < 1 / 3 ? (h = (1 - a) / 3, o = (1 + a * Ps(Wn * t) / Ps(md - Wn * t)) / 3, l = 1 - (h + o)) : t < 2 / 3 ? (t -= 1 / 3, o = (1 - a) / 3, l = (1 + a * Ps(Wn * t) / Ps(md - Wn * t)) / 3, h = 1 - (o + l)) : (t -= 2 / 3, l = (1 - a) / 3, h = (1 + a * Ps(Wn * t) / Ps(md - Wn * t)) / 3, o = 1 - (l + h)), o = Us(i * o * 3), l = Us(i * l * 3), h = Us(i * h * 3), [o * 255, l * 255, h * 255, e.length > 3 ? e[3] : 1]
}, {
  min: dO,
  sqrt: hO,
  acos: fO
} = Math, pO = (...e) => {
  let [t, a, i] = Yt(e, "rgb");
  t /= 255, a /= 255, i /= 255;
  let o;
  const l = dO(t, a, i),
    h = (t + a + i) / 3,
    p = h > 0 ? 1 - l / h : 0;
  return p === 0 ? o = NaN : (o = (t - a + (t - i)) / 2, o /= hO((t - a) * (t - a) + (t - i) * (a - i)), o = fO(o), i > a && (o = Wn - o), o /= Wn), [o * 360, p, h]
};
ot.prototype.hsi = function () {
  return pO(this._rgb)
};
Ft.hsi = (...e) => new ot(...e, "hsi");
Rt.format.hsi = uO;
Rt.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = Yt(e, "hsi"), Ht(e) === "array" && e.length === 3) return "hsi"
  }
});
ot.prototype.hsl = function () {
  return Ky(this._rgb)
};
Ft.hsl = (...e) => new ot(...e, "hsl");
Rt.format.hsl = Lh;
Rt.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = Yt(e, "hsl"), Ht(e) === "array" && e.length === 3) return "hsl"
  }
});
const {
  floor: gO
} = Math, mO = (...e) => {
  e = Yt(e, "hsv");
  let [t, a, i] = e, o, l, h;
  if (i *= 255, a === 0) o = l = h = i;
  else {
    t === 360 && (t = 0), t > 360 && (t -= 360), t < 0 && (t += 360), t /= 60;
    const p = gO(t),
      m = t - p,
      k = i * (1 - a),
      w = i * (1 - a * m),
      S = i * (1 - a * (1 - m));
    switch (p) {
      case 0:
        [o, l, h] = [i, S, k];
        break;
      case 1:
        [o, l, h] = [w, i, k];
        break;
      case 2:
        [o, l, h] = [k, i, S];
        break;
      case 3:
        [o, l, h] = [k, w, i];
        break;
      case 4:
        [o, l, h] = [S, k, i];
        break;
      case 5:
        [o, l, h] = [i, k, w];
        break
    }
  }
  return [o, l, h, e.length > 3 ? e[3] : 1]
}, {
  min: vO,
  max: bO
} = Math, yO = (...e) => {
  e = Yt(e, "rgb");
  let [t, a, i] = e;
  const o = vO(t, a, i),
    l = bO(t, a, i),
    h = l - o;
  let p, m, k;
  return k = l / 255, l === 0 ? (p = Number.NaN, m = 0) : (m = h / l, t === l && (p = (a - i) / h), a === l && (p = 2 + (i - t) / h), i === l && (p = 4 + (t - a) / h), p *= 60, p < 0 && (p += 360)), [p, m, k]
};
ot.prototype.hsv = function () {
  return yO(this._rgb)
};
Ft.hsv = (...e) => new ot(...e, "hsv");
Rt.format.hsv = mO;
Rt.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = Yt(e, "hsv"), Ht(e) === "array" && e.length === 3) return "hsv"
  }
});
const Br = {
    Kn: 18,
    Xn: .95047,
    Yn: 1,
    Zn: 1.08883,
    t0: .137931034,
    t1: .206896552,
    t2: .12841855,
    t3: .008856452
  },
  {
    pow: xO
  } = Math,
  ix = (...e) => {
    e = Yt(e, "lab");
    const [t, a, i] = e;
    let o, l, h, p, m, k;
    return l = (t + 16) / 116, o = isNaN(a) ? l : l + a / 500, h = isNaN(i) ? l : l - i / 200, l = Br.Yn * wd(l), o = Br.Xn * wd(o), h = Br.Zn * wd(h), p = xd(3.2404542 * o - 1.5371385 * l - .4985314 * h), m = xd(-.969266 * o + 1.8760108 * l + .041556 * h), k = xd(.0556434 * o - .2040259 * l + 1.0572252 * h), [p, m, k, e.length > 3 ? e[3] : 1]
  },
  xd = e => 255 * (e <= .00304 ? 12.92 * e : 1.055 * xO(e, 1 / 2.4) - .055),
  wd = e => e > Br.t1 ? e * e * e : Br.t2 * (e - Br.t0),
  {
    pow: sx
  } = Math,
  ox = (...e) => {
    const [t, a, i] = Yt(e, "rgb"), [o, l, h] = wO(t, a, i), p = 116 * l - 16;
    return [p < 0 ? 0 : p, 500 * (o - l), 200 * (l - h)]
  },
  kd = e => (e /= 255) <= .04045 ? e / 12.92 : sx((e + .055) / 1.055, 2.4),
  _d = e => e > Br.t3 ? sx(e, 1 / 3) : e / Br.t2 + Br.t0,
  wO = (e, t, a) => {
    e = kd(e), t = kd(t), a = kd(a);
    const i = _d((.4124564 * e + .3575761 * t + .1804375 * a) / Br.Xn),
      o = _d((.2126729 * e + .7151522 * t + .072175 * a) / Br.Yn),
      l = _d((.0193339 * e + .119192 * t + .9503041 * a) / Br.Zn);
    return [i, o, l]
  };
ot.prototype.lab = function () {
  return ox(this._rgb)
};
Ft.lab = (...e) => new ot(...e, "lab");
Rt.format.lab = ix;
Rt.autodetect.push({
  p: 2,
  test: (...e) => {
    if (e = Yt(e, "lab"), Ht(e) === "array" && e.length === 3) return "lab"
  }
});
const {
  sin: kO,
  cos: _O
} = Math, lx = (...e) => {
  let [t, a, i] = Yt(e, "lch");
  return isNaN(i) && (i = 0), i = i * QL, [t, _O(i) * a, kO(i) * a]
}, cx = (...e) => {
  e = Yt(e, "lch");
  const [t, a, i] = e, [o, l, h] = lx(t, a, i), [p, m, k] = ix(o, l, h);
  return [p, m, k, e.length > 3 ? e[3] : 1]
}, SO = (...e) => {
  const t = Yt(e, "hcl").reverse();
  return cx(...t)
}, {
  sqrt: AO,
  atan2: CO,
  round: TO
} = Math, ux = (...e) => {
  const [t, a, i] = Yt(e, "lab"), o = AO(a * a + i * i);
  let l = (CO(i, a) * JL + 360) % 360;
  return TO(o * 1e4) === 0 && (l = Number.NaN), [t, o, l]
}, dx = (...e) => {
  const [t, a, i] = Yt(e, "rgb"), [o, l, h] = ox(t, a, i);
  return ux(o, l, h)
};
ot.prototype.lch = function () {
  return dx(this._rgb)
};
ot.prototype.hcl = function () {
  return dx(this._rgb).reverse()
};
Ft.lch = (...e) => new ot(...e, "lch");
Ft.hcl = (...e) => new ot(...e, "hcl");
Rt.format.lch = cx;
Rt.format.hcl = SO;
["lch", "hcl"].forEach(e => Rt.autodetect.push({
  p: 2,
  test: (...t) => {
    if (t = Yt(t, e), Ht(t) === "array" && t.length === 3) return e
  }
}));
const no = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  laserlemon: "#ffff54",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrod: "#fafad2",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  maroon2: "#7f0000",
  maroon3: "#b03060",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  purple2: "#7f007f",
  purple3: "#a020f0",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
ot.prototype.name = function () {
  const e = nx(this._rgb, "rgb");
  for (let t of Object.keys(no))
    if (no[t] === e) return t.toLowerCase();
  return e
};
Rt.format.named = e => {
  if (e = e.toLowerCase(), no[e]) return rx(no[e]);
  throw new Error("unknown color name: " + e)
};
Rt.autodetect.push({
  p: 5,
  test: (e, ...t) => {
    if (!t.length && Ht(e) === "string" && no[e.toLowerCase()]) return "named"
  }
});
const EO = e => {
    if (Ht(e) == "number" && e >= 0 && e <= 16777215) {
      const t = e >> 16,
        a = e >> 8 & 255,
        i = e & 255;
      return [t, a, i, 1]
    }
    throw new Error("unknown num color: " + e)
  },
  PO = (...e) => {
    const [t, a, i] = Yt(e, "rgb");
    return (t << 16) + (a << 8) + i
  };
ot.prototype.num = function () {
  return PO(this._rgb)
};
Ft.num = (...e) => new ot(...e, "num");
Rt.format.num = EO;
Rt.autodetect.push({
  p: 5,
  test: (...e) => {
    if (e.length === 1 && Ht(e[0]) === "number" && e[0] >= 0 && e[0] <= 16777215) return "num"
  }
});
const {
  round: hx
} = Math;
ot.prototype.rgb = function (e = !0) {
  return e === !1 ? this._rgb.slice(0, 3) : this._rgb.slice(0, 3).map(hx)
};
ot.prototype.rgba = function (e = !0) {
  return this._rgb.slice(0, 4).map((t, a) => a < 3 ? e === !1 ? t : hx(t) : t)
};
Ft.rgb = (...e) => new ot(...e, "rgb");
Rt.format.rgb = (...e) => {
  const t = Yt(e, "rgba");
  return t[3] === void 0 && (t[3] = 1), t
};
Rt.autodetect.push({
  p: 3,
  test: (...e) => {
    if (e = Yt(e, "rgba"), Ht(e) === "array" && (e.length === 3 || e.length === 4 && Ht(e[3]) == "number" && e[3] >= 0 && e[3] <= 1)) return "rgb"
  }
});
const {
  log: tc
} = Math, fx = e => {
  const t = e / 100;
  let a, i, o;
  return t < 66 ? (a = 255, i = t < 6 ? 0 : -155.25485562709179 - .44596950469579133 * (i = t - 2) + 104.49216199393888 * tc(i), o = t < 20 ? 0 : -254.76935184120902 + .8274096064007395 * (o = t - 10) + 115.67994401066147 * tc(o)) : (a = 351.97690566805693 + .114206453784165 * (a = t - 55) - 40.25366309332127 * tc(a), i = 325.4494125711974 + .07943456536662342 * (i = t - 50) - 28.0852963507957 * tc(i), o = 255), [a, i, o, 1]
}, {
  round: LO
} = Math, OO = (...e) => {
  const t = Yt(e, "rgb"),
    a = t[0],
    i = t[2];
  let o = 1e3,
    l = 4e4;
  const h = .4;
  let p;
  for (; l - o > h;) {
    p = (l + o) * .5;
    const m = fx(p);
    m[2] / m[0] >= i / a ? l = p : o = p
  }
  return LO(p)
};
ot.prototype.temp = ot.prototype.kelvin = ot.prototype.temperature = function () {
  return OO(this._rgb)
};
Ft.temp = Ft.kelvin = Ft.temperature = (...e) => new ot(...e, "temp");
Rt.format.temp = Rt.format.kelvin = Rt.format.temperature = fx;
const {
  pow: bc,
  sign: MO
} = Math, px = (...e) => {
  e = Yt(e, "lab");
  const [t, a, i] = e, o = bc(t + .3963377774 * a + .2158037573 * i, 3), l = bc(t - .1055613458 * a - .0638541728 * i, 3), h = bc(t - .0894841775 * a - 1.291485548 * i, 3);
  return [255 * Sd(4.0767416621 * o - 3.3077115913 * l + .2309699292 * h), 255 * Sd(-1.2684380046 * o + 2.6097574011 * l - .3413193965 * h), 255 * Sd(-.0041960863 * o - .7034186147 * l + 1.707614701 * h), e.length > 3 ? e[3] : 1]
};

function Sd(e) {
  const t = Math.abs(e);
  return t > .0031308 ? (MO(e) || 1) * (1.055 * bc(t, 1 / 2.4) - .055) : e * 12.92
}
const {
  cbrt: Ad,
  pow: IO,
  sign: RO
} = Math, gx = (...e) => {
  const [t, a, i] = Yt(e, "rgb"), [o, l, h] = [Cd(t / 255), Cd(a / 255), Cd(i / 255)], p = Ad(.4122214708 * o + .5363325363 * l + .0514459929 * h), m = Ad(.2119034982 * o + .6806995451 * l + .1073969566 * h), k = Ad(.0883024619 * o + .2817188376 * l + .6299787005 * h);
  return [.2104542553 * p + .793617785 * m - .0040720468 * k, 1.9779984951 * p - 2.428592205 * m + .4505937099 * k, .0259040371 * p + .7827717662 * m - .808675766 * k]
};

function Cd(e) {
  const t = Math.abs(e);
  return t < .04045 ? e / 12.92 : (RO(e) || 1) * IO((t + .055) / 1.055, 2.4)
}
ot.prototype.oklab = function () {
  return gx(this._rgb)
};
Ft.oklab = (...e) => new ot(...e, "oklab");
Rt.format.oklab = px;
Rt.autodetect.push({
  p: 3,
  test: (...e) => {
    if (e = Yt(e, "oklab"), Ht(e) === "array" && e.length === 3) return "oklab"
  }
});
const DO = (...e) => {
    e = Yt(e, "lch");
    const [t, a, i] = e, [o, l, h] = lx(t, a, i), [p, m, k] = px(o, l, h);
    return [p, m, k, e.length > 3 ? e[3] : 1]
  },
  NO = (...e) => {
    const [t, a, i] = Yt(e, "rgb"), [o, l, h] = gx(t, a, i);
    return ux(o, l, h)
  };
ot.prototype.oklch = function () {
  return NO(this._rgb)
};
Ft.oklch = (...e) => new ot(...e, "oklch");
Rt.format.oklch = DO;
Rt.autodetect.push({
  p: 3,
  test: (...e) => {
    if (e = Yt(e, "oklch"), Ht(e) === "array" && e.length === 3) return "oklch"
  }
});
ot.prototype.alpha = function (e, t = !1) {
  return e !== void 0 && Ht(e) === "number" ? t ? (this._rgb[3] = e, this) : new ot([this._rgb[0], this._rgb[1], this._rgb[2], e], "rgb") : this._rgb[3]
};
ot.prototype.clipped = function () {
  return this._rgb._clipped || !1
};
ot.prototype.darken = function (e = 1) {
  const t = this,
    a = t.lab();
  return a[0] -= Br.Kn * e, new ot(a, "lab").alpha(t.alpha(), !0)
};
ot.prototype.brighten = function (e = 1) {
  return this.darken(-e)
};
ot.prototype.darker = ot.prototype.darken;
ot.prototype.brighter = ot.prototype.brighten;
ot.prototype.get = function (e) {
  const [t, a] = e.split("."), i = this[t]();
  if (a) {
    const o = t.indexOf(a) - (t.substr(0, 2) === "ok" ? 2 : 0);
    if (o > -1) return i[o];
    throw new Error(`unknown channel ${a} in mode ${t}`)
  } else return i
};
const {
  pow: FO
} = Math, $O = 1e-7, BO = 20;
ot.prototype.luminance = function (e, t = "rgb") {
  if (e !== void 0 && Ht(e) === "number") {
    if (e === 0) return new ot([0, 0, 0, this._rgb[3]], "rgb");
    if (e === 1) return new ot([255, 255, 255, this._rgb[3]], "rgb");
    let a = this.luminance(),
      i = BO;
    const o = (h, p) => {
        const m = h.interpolate(p, .5, t),
          k = m.luminance();
        return Math.abs(e - k) < $O || !i-- ? m : k > e ? o(h, m) : o(m, p)
      },
      l = (a > e ? o(new ot([0, 0, 0]), this) : o(this, new ot([255, 255, 255]))).rgb();
    return new ot([...l, this._rgb[3]])
  }
  return HO(...this._rgb.slice(0, 3))
};
const HO = (e, t, a) => (e = Td(e), t = Td(t), a = Td(a), .2126 * e + .7152 * t + .0722 * a),
  Td = e => (e /= 255, e <= .03928 ? e / 12.92 : FO((e + .055) / 1.055, 2.4)),
  gr = {},
  bl = (e, t, a = .5, ...i) => {
    let o = i[0] || "lrgb";
    if (!gr[o] && !i.length && (o = Object.keys(gr)[0]), !gr[o]) throw new Error(`interpolation mode ${o} is not defined`);
    return Ht(e) !== "object" && (e = new ot(e)), Ht(t) !== "object" && (t = new ot(t)), gr[o](e, t, a).alpha(e.alpha() + a * (t.alpha() - e.alpha()))
  };
ot.prototype.mix = ot.prototype.interpolate = function (e, t = .5, ...a) {
  return bl(this, e, t, ...a)
};
ot.prototype.premultiply = function (e = !1) {
  const t = this._rgb,
    a = t[3];
  return e ? (this._rgb = [t[0] * a, t[1] * a, t[2] * a, a], this) : new ot([t[0] * a, t[1] * a, t[2] * a, a], "rgb")
};
ot.prototype.saturate = function (e = 1) {
  const t = this,
    a = t.lch();
  return a[1] += Br.Kn * e, a[1] < 0 && (a[1] = 0), new ot(a, "lch").alpha(t.alpha(), !0)
};
ot.prototype.desaturate = function (e = 1) {
  return this.saturate(-e)
};
ot.prototype.set = function (e, t, a = !1) {
  const [i, o] = e.split("."), l = this[i]();
  if (o) {
    const h = i.indexOf(o) - (i.substr(0, 2) === "ok" ? 2 : 0);
    if (h > -1) {
      if (Ht(t) == "string") switch (t.charAt(0)) {
          case "+":
            l[h] += +t;
            break;
          case "-":
            l[h] += +t;
            break;
          case "*":
            l[h] *= +t.substr(1);
            break;
          case "/":
            l[h] /= +t.substr(1);
            break;
          default:
            l[h] = +t
        } else if (Ht(t) === "number") l[h] = t;
        else throw new Error("unsupported value for Color.set");
      const p = new ot(l, i);
      return a ? (this._rgb = p._rgb, this) : p
    }
    throw new Error(`unknown channel ${o} in mode ${i}`)
  } else return l
};
ot.prototype.tint = function (e = .5, ...t) {
  return bl(this, "white", e, ...t)
};
ot.prototype.shade = function (e = .5, ...t) {
  return bl(this, "black", e, ...t)
};
const YO = (e, t, a) => {
  const i = e._rgb,
    o = t._rgb;
  return new ot(i[0] + a * (o[0] - i[0]), i[1] + a * (o[1] - i[1]), i[2] + a * (o[2] - i[2]), "rgb")
};
gr.rgb = YO;
const {
  sqrt: Ed,
  pow: Ls
} = Math, zO = (e, t, a) => {
  const [i, o, l] = e._rgb, [h, p, m] = t._rgb;
  return new ot(Ed(Ls(i, 2) * (1 - a) + Ls(h, 2) * a), Ed(Ls(o, 2) * (1 - a) + Ls(p, 2) * a), Ed(Ls(l, 2) * (1 - a) + Ls(m, 2) * a), "rgb")
};
gr.lrgb = zO;
const XO = (e, t, a) => {
  const i = e.lab(),
    o = t.lab();
  return new ot(i[0] + a * (o[0] - i[0]), i[1] + a * (o[1] - i[1]), i[2] + a * (o[2] - i[2]), "lab")
};
gr.lab = XO;
const vo = (e, t, a, i) => {
    let o, l;
    i === "hsl" ? (o = e.hsl(), l = t.hsl()) : i === "hsv" ? (o = e.hsv(), l = t.hsv()) : i === "hcg" ? (o = e.hcg(), l = t.hcg()) : i === "hsi" ? (o = e.hsi(), l = t.hsi()) : i === "lch" || i === "hcl" ? (i = "hcl", o = e.hcl(), l = t.hcl()) : i === "oklch" && (o = e.oklch().reverse(), l = t.oklch().reverse());
    let h, p, m, k, w, S;
    (i.substr(0, 1) === "h" || i === "oklch") && ([h, m, w] = o, [p, k, S] = l);
    let A, E, M, D;
    return !isNaN(h) && !isNaN(p) ? (p > h && p - h > 180 ? D = p - (h + 360) : p < h && h - p > 180 ? D = p + 360 - h : D = p - h, E = h + a * D) : isNaN(h) ? isNaN(p) ? E = Number.NaN : (E = p, (w == 1 || w == 0) && i != "hsv" && (A = k)) : (E = h, (S == 1 || S == 0) && i != "hsv" && (A = m)), A === void 0 && (A = m + a * (k - m)), M = w + a * (S - w), i === "oklch" ? new ot([M, A, E], i) : new ot([E, A, M], i)
  },
  mx = (e, t, a) => vo(e, t, a, "lch");
gr.lch = mx;
gr.hcl = mx;
const WO = (e, t, a) => {
  const i = e.num(),
    o = t.num();
  return new ot(i + a * (o - i), "num")
};
gr.num = WO;
const VO = (e, t, a) => vo(e, t, a, "hcg");
gr.hcg = VO;
const jO = (e, t, a) => vo(e, t, a, "hsi");
gr.hsi = jO;
const UO = (e, t, a) => vo(e, t, a, "hsl");
gr.hsl = UO;
const GO = (e, t, a) => vo(e, t, a, "hsv");
gr.hsv = GO;
const qO = (e, t, a) => {
  const i = e.oklab(),
    o = t.oklab();
  return new ot(i[0] + a * (o[0] - i[0]), i[1] + a * (o[1] - i[1]), i[2] + a * (o[2] - i[2]), "oklab")
};
gr.oklab = qO;
const KO = (e, t, a) => vo(e, t, a, "oklch");
gr.oklch = KO;
const {
  pow: Pd,
  sqrt: Ld,
  PI: Od,
  cos: gm,
  sin: mm,
  atan2: ZO
} = Math, QO = (e, t = "lrgb", a = null) => {
  const i = e.length;
  a || (a = Array.from(new Array(i)).map(() => 1));
  const o = i / a.reduce(function (S, A) {
    return S + A
  });
  if (a.forEach((S, A) => {
      a[A] *= o
    }), e = e.map(S => new ot(S)), t === "lrgb") return JO(e, a);
  const l = e.shift(),
    h = l.get(t),
    p = [];
  let m = 0,
    k = 0;
  for (let S = 0; S < h.length; S++)
    if (h[S] = (h[S] || 0) * a[0], p.push(isNaN(h[S]) ? 0 : a[0]), t.charAt(S) === "h" && !isNaN(h[S])) {
      const A = h[S] / 180 * Od;
      m += gm(A) * a[0], k += mm(A) * a[0]
    } let w = l.alpha() * a[0];
  e.forEach((S, A) => {
    const E = S.get(t);
    w += S.alpha() * a[A + 1];
    for (let M = 0; M < h.length; M++)
      if (!isNaN(E[M]))
        if (p[M] += a[A + 1], t.charAt(M) === "h") {
          const D = E[M] / 180 * Od;
          m += gm(D) * a[A + 1], k += mm(D) * a[A + 1]
        } else h[M] += E[M] * a[A + 1]
  });
  for (let S = 0; S < h.length; S++)
    if (t.charAt(S) === "h") {
      let A = ZO(k / p[S], m / p[S]) / Od * 180;
      for (; A < 0;) A += 360;
      for (; A >= 360;) A -= 360;
      h[S] = A
    } else h[S] = h[S] / p[S];
  return w /= i, new ot(h, t).alpha(w > .99999 ? 1 : w, !0)
}, JO = (e, t) => {
  const a = e.length,
    i = [0, 0, 0, 0];
  for (let o = 0; o < e.length; o++) {
    const l = e[o],
      h = t[o] / a,
      p = l._rgb;
    i[0] += Pd(p[0], 2) * h, i[1] += Pd(p[1], 2) * h, i[2] += Pd(p[2], 2) * h, i[3] += p[3] * h
  }
  return i[0] = Ld(i[0]), i[1] = Ld(i[1]), i[2] = Ld(i[2]), i[3] > .9999999 && (i[3] = 1), new ot(Qf(i))
}, {
  pow: eM
} = Math;

function $c(e) {
  let t = "rgb",
    a = Ft("#ccc"),
    i = 0,
    o = [0, 1],
    l = [],
    h = [0, 0],
    p = !1,
    m = [],
    k = !1,
    w = 0,
    S = 1,
    A = !1,
    E = {},
    M = !0,
    D = 1;
  const B = function (V) {
      if (V = V || ["#fff", "#000"], V && Ht(V) === "string" && Ft.brewer && Ft.brewer[V.toLowerCase()] && (V = Ft.brewer[V.toLowerCase()]), Ht(V) === "array") {
        V.length === 1 && (V = [V[0], V[0]]), V = V.slice(0);
        for (let ne = 0; ne < V.length; ne++) V[ne] = Ft(V[ne]);
        l.length = 0;
        for (let ne = 0; ne < V.length; ne++) l.push(ne / (V.length - 1))
      }
      return W(), m = V
    },
    z = function (V) {
      if (p != null) {
        const ne = p.length - 1;
        let Z = 0;
        for (; Z < ne && V >= p[Z];) Z++;
        return Z - 1
      }
      return 0
    };
  let I = V => V,
    N = V => V;
  const U = function (V, ne) {
    let Z, ie;
    if (ne == null && (ne = !1), isNaN(V) || V === null) return a;
    ne ? ie = V : p && p.length > 2 ? ie = z(V) / (p.length - 2) : S !== w ? ie = (V - w) / (S - w) : ie = 1, ie = N(ie), ne || (ie = I(ie)), D !== 1 && (ie = eM(ie, D)), ie = h[0] + ie * (1 - h[0] - h[1]), ie = Us(ie, 0, 1);
    const fe = Math.floor(ie * 1e4);
    if (M && E[fe]) Z = E[fe];
    else {
      if (Ht(m) === "array")
        for (let le = 0; le < l.length; le++) {
          const Ee = l[le];
          if (ie <= Ee) {
            Z = m[le];
            break
          }
          if (ie >= Ee && le === l.length - 1) {
            Z = m[le];
            break
          }
          if (ie > Ee && ie < l[le + 1]) {
            ie = (ie - Ee) / (l[le + 1] - Ee), Z = Ft.interpolate(m[le], m[le + 1], ie, t);
            break
          }
        } else Ht(m) === "function" && (Z = m(ie));
      M && (E[fe] = Z)
    }
    return Z
  };
  var W = () => E = {};
  B(e);
  const X = function (V) {
    const ne = Ft(U(V));
    return k && ne[k] ? ne[k]() : ne
  };
  return X.classes = function (V) {
    if (V != null) {
      if (Ht(V) === "array") p = V, o = [V[0], V[V.length - 1]];
      else {
        const ne = Ft.analyze(o);
        V === 0 ? p = [ne.min, ne.max] : p = Ft.limits(ne, "e", V)
      }
      return X
    }
    return p
  }, X.domain = function (V) {
    if (!arguments.length) return o;
    w = V[0], S = V[V.length - 1], l = [];
    const ne = m.length;
    if (V.length === ne && w !== S)
      for (let Z of Array.from(V)) l.push((Z - w) / (S - w));
    else {
      for (let Z = 0; Z < ne; Z++) l.push(Z / (ne - 1));
      if (V.length > 2) {
        const Z = V.map((fe, le) => le / (V.length - 1)),
          ie = V.map(fe => (fe - w) / (S - w));
        ie.every((fe, le) => Z[le] === fe) || (N = fe => {
          if (fe <= 0 || fe >= 1) return fe;
          let le = 0;
          for (; fe >= ie[le + 1];) le++;
          const Ee = (fe - ie[le]) / (ie[le + 1] - ie[le]);
          return Z[le] + Ee * (Z[le + 1] - Z[le])
        })
      }
    }
    return o = [w, S], X
  }, X.mode = function (V) {
    return arguments.length ? (t = V, W(), X) : t
  }, X.range = function (V, ne) {
    return B(V), X
  }, X.out = function (V) {
    return k = V, X
  }, X.spread = function (V) {
    return arguments.length ? (i = V, X) : i
  }, X.correctLightness = function (V) {
    return V == null && (V = !0), A = V, W(), A ? I = function (ne) {
      const Z = U(0, !0).lab()[0],
        ie = U(1, !0).lab()[0],
        fe = Z > ie;
      let le = U(ne, !0).lab()[0];
      const Ee = Z + (ie - Z) * ne;
      let ye = le - Ee,
        ve = 0,
        me = 1,
        Ae = 20;
      for (; Math.abs(ye) > .01 && Ae-- > 0;)(function () {
        return fe && (ye *= -1), ye < 0 ? (ve = ne, ne += (me - ne) * .5) : (me = ne, ne += (ve - ne) * .5), le = U(ne, !0).lab()[0], ye = le - Ee
      })();
      return ne
    } : I = ne => ne, X
  }, X.padding = function (V) {
    return V != null ? (Ht(V) === "number" && (V = [V, V]), h = V, X) : h
  }, X.colors = function (V, ne) {
    arguments.length < 2 && (ne = "hex");
    let Z = [];
    if (arguments.length === 0) Z = m.slice(0);
    else if (V === 1) Z = [X(.5)];
    else if (V > 1) {
      const ie = o[0],
        fe = o[1] - ie;
      Z = tM(0, V).map(le => X(ie + le / (V - 1) * fe))
    } else {
      e = [];
      let ie = [];
      if (p && p.length > 2)
        for (let fe = 1, le = p.length, Ee = 1 <= le; Ee ? fe < le : fe > le; Ee ? fe++ : fe--) ie.push((p[fe - 1] + p[fe]) * .5);
      else ie = o;
      Z = ie.map(fe => X(fe))
    }
    return Ft[ne] && (Z = Z.map(ie => ie[ne]())), Z
  }, X.cache = function (V) {
    return V != null ? (M = V, X) : M
  }, X.gamma = function (V) {
    return V != null ? (D = V, X) : D
  }, X.nodata = function (V) {
    return V != null ? (a = Ft(V), X) : a
  }, X
}

function tM(e, t, a) {
  let i = [],
    o = e < t,
    l = t;
  for (let h = e; o ? h < l : h > l; o ? h++ : h--) i.push(h);
  return i
}
const aM = function (e) {
    let t = [1, 1];
    for (let a = 1; a < e; a++) {
      let i = [1];
      for (let o = 1; o <= t.length; o++) i[o] = (t[o] || 0) + t[o - 1];
      t = i
    }
    return t
  },
  rM = function (e) {
    let t, a, i, o;
    if (e = e.map(l => new ot(l)), e.length === 2)[a, i] = e.map(l => l.lab()), t = function (l) {
      const h = [0, 1, 2].map(p => a[p] + l * (i[p] - a[p]));
      return new ot(h, "lab")
    };
    else if (e.length === 3)[a, i, o] = e.map(l => l.lab()), t = function (l) {
      const h = [0, 1, 2].map(p => (1 - l) * (1 - l) * a[p] + 2 * (1 - l) * l * i[p] + l * l * o[p]);
      return new ot(h, "lab")
    };
    else if (e.length === 4) {
      let l;
      [a, i, o, l] = e.map(h => h.lab()), t = function (h) {
        const p = [0, 1, 2].map(m => (1 - h) * (1 - h) * (1 - h) * a[m] + 3 * (1 - h) * (1 - h) * h * i[m] + 3 * (1 - h) * h * h * o[m] + h * h * h * l[m]);
        return new ot(p, "lab")
      }
    } else if (e.length >= 5) {
      let l, h, p;
      l = e.map(m => m.lab()), p = e.length - 1, h = aM(p), t = function (m) {
        const k = 1 - m,
          w = [0, 1, 2].map(S => l.reduce((A, E, M) => A + h[M] * k ** (p - M) * m ** M * E[S], 0));
        return new ot(w, "lab")
      }
    } else throw new RangeError("No point in running bezier with only one color.");
    return t
  },
  nM = e => {
    const t = rM(e);
    return t.scale = () => $c(t), t
  },
  gn = (e, t, a) => {
    if (!gn[a]) throw new Error("unknown blend mode " + a);
    return gn[a](e, t)
  },
  Ni = e => (t, a) => {
    const i = Ft(a).rgb(),
      o = Ft(t).rgb();
    return Ft.rgb(e(i, o))
  },
  Fi = e => (t, a) => {
    const i = [];
    return i[0] = e(t[0], a[0]), i[1] = e(t[1], a[1]), i[2] = e(t[2], a[2]), i
  },
  iM = e => e,
  sM = (e, t) => e * t / 255,
  oM = (e, t) => e > t ? t : e,
  lM = (e, t) => e > t ? e : t,
  cM = (e, t) => 255 * (1 - (1 - e / 255) * (1 - t / 255)),
  uM = (e, t) => t < 128 ? 2 * e * t / 255 : 255 * (1 - 2 * (1 - e / 255) * (1 - t / 255)),
  dM = (e, t) => 255 * (1 - (1 - t / 255) / (e / 255)),
  hM = (e, t) => e === 255 ? 255 : (e = 255 * (t / 255) / (1 - e / 255), e > 255 ? 255 : e);
gn.normal = Ni(Fi(iM));
gn.multiply = Ni(Fi(sM));
gn.screen = Ni(Fi(cM));
gn.overlay = Ni(Fi(uM));
gn.darken = Ni(Fi(oM));
gn.lighten = Ni(Fi(lM));
gn.dodge = Ni(Fi(hM));
gn.burn = Ni(Fi(dM));
const {
  pow: fM,
  sin: pM,
  cos: gM
} = Math;

function mM(e = 300, t = -1.5, a = 1, i = 1, o = [0, 1]) {
  let l = 0,
    h;
  Ht(o) === "array" ? h = o[1] - o[0] : (h = 0, o = [o, o]);
  const p = function (m) {
    const k = Wn * ((e + 120) / 360 + t * m),
      w = fM(o[0] + h * m, i),
      A = (l !== 0 ? a[0] + m * l : a) * w * (1 - w) / 2,
      E = gM(k),
      M = pM(k),
      D = w + A * (-.14861 * E + 1.78277 * M),
      B = w + A * (-.29227 * E - .90649 * M),
      z = w + A * (1.97294 * E);
    return Ft(Qf([D * 255, B * 255, z * 255, 1]))
  };
  return p.start = function (m) {
    return m == null ? e : (e = m, p)
  }, p.rotations = function (m) {
    return m == null ? t : (t = m, p)
  }, p.gamma = function (m) {
    return m == null ? i : (i = m, p)
  }, p.hue = function (m) {
    return m == null ? a : (a = m, Ht(a) === "array" ? (l = a[1] - a[0], l === 0 && (a = a[1])) : l = 0, p)
  }, p.lightness = function (m) {
    return m == null ? o : (Ht(m) === "array" ? (o = m, h = m[1] - m[0]) : (o = [m, m], h = 0), p)
  }, p.scale = () => Ft.scale(p), p.hue(a), p
}
const vM = "0123456789abcdef",
  {
    floor: bM,
    random: yM
  } = Math,
  xM = () => {
    let e = "#";
    for (let t = 0; t < 6; t++) e += vM.charAt(bM(yM() * 16));
    return new ot(e, "hex")
  },
  {
    log: vm,
    pow: wM,
    floor: kM,
    abs: _M
  } = Math;

function vx(e, t = null) {
  const a = {
    min: Number.MAX_VALUE,
    max: Number.MAX_VALUE * -1,
    sum: 0,
    values: [],
    count: 0
  };
  return Ht(e) === "object" && (e = Object.values(e)), e.forEach(i => {
    t && Ht(i) === "object" && (i = i[t]), i != null && !isNaN(i) && (a.values.push(i), a.sum += i, i < a.min && (a.min = i), i > a.max && (a.max = i), a.count += 1)
  }), a.domain = [a.min, a.max], a.limits = (i, o) => bx(a, i, o), a
}

function bx(e, t = "equal", a = 7) {
  Ht(e) == "array" && (e = vx(e));
  const {
    min: i,
    max: o
  } = e, l = e.values.sort((p, m) => p - m);
  if (a === 1) return [i, o];
  const h = [];
  if (t.substr(0, 1) === "c" && (h.push(i), h.push(o)), t.substr(0, 1) === "e") {
    h.push(i);
    for (let p = 1; p < a; p++) h.push(i + p / a * (o - i));
    h.push(o)
  } else if (t.substr(0, 1) === "l") {
    if (i <= 0) throw new Error("Logarithmic scales are only possible for values > 0");
    const p = Math.LOG10E * vm(i),
      m = Math.LOG10E * vm(o);
    h.push(i);
    for (let k = 1; k < a; k++) h.push(wM(10, p + k / a * (m - p)));
    h.push(o)
  } else if (t.substr(0, 1) === "q") {
    h.push(i);
    for (let p = 1; p < a; p++) {
      const m = (l.length - 1) * p / a,
        k = kM(m);
      if (k === m) h.push(l[k]);
      else {
        const w = m - k;
        h.push(l[k] * (1 - w) + l[k + 1] * w)
      }
    }
    h.push(o)
  } else if (t.substr(0, 1) === "k") {
    let p;
    const m = l.length,
      k = new Array(m),
      w = new Array(a);
    let S = !0,
      A = 0,
      E = null;
    E = [], E.push(i);
    for (let B = 1; B < a; B++) E.push(i + B / a * (o - i));
    for (E.push(o); S;) {
      for (let z = 0; z < a; z++) w[z] = 0;
      for (let z = 0; z < m; z++) {
        const I = l[z];
        let N = Number.MAX_VALUE,
          U;
        for (let W = 0; W < a; W++) {
          const X = _M(E[W] - I);
          X < N && (N = X, U = W), w[U]++, k[z] = U
        }
      }
      const B = new Array(a);
      for (let z = 0; z < a; z++) B[z] = null;
      for (let z = 0; z < m; z++) p = k[z], B[p] === null ? B[p] = l[z] : B[p] += l[z];
      for (let z = 0; z < a; z++) B[z] *= 1 / w[z];
      S = !1;
      for (let z = 0; z < a; z++)
        if (B[z] !== E[z]) {
          S = !0;
          break
        } E = B, A++, A > 200 && (S = !1)
    }
    const M = {};
    for (let B = 0; B < a; B++) M[B] = [];
    for (let B = 0; B < m; B++) p = k[B], M[p].push(l[B]);
    let D = [];
    for (let B = 0; B < a; B++) D.push(M[B][0]), D.push(M[B][M[B].length - 1]);
    D = D.sort((B, z) => B - z), h.push(D[0]);
    for (let B = 1; B < D.length; B += 2) {
      const z = D[B];
      !isNaN(z) && h.indexOf(z) === -1 && h.push(z)
    }
  }
  return h
}
const SM = (e, t) => {
    e = new ot(e), t = new ot(t);
    const a = e.luminance(),
      i = t.luminance();
    return a > i ? (a + .05) / (i + .05) : (i + .05) / (a + .05)
  },
  {
    sqrt: $n,
    pow: Ba,
    min: AM,
    max: CM,
    atan2: bm,
    abs: ym,
    cos: ac,
    sin: xm,
    exp: TM,
    PI: wm
  } = Math;

function EM(e, t, a = 1, i = 1, o = 1) {
  var l = function (ke) {
      return 360 * ke / (2 * wm)
    },
    h = function (ke) {
      return 2 * wm * ke / 360
    };
  e = new ot(e), t = new ot(t);
  const [p, m, k] = Array.from(e.lab()), [w, S, A] = Array.from(t.lab()), E = (p + w) / 2, M = $n(Ba(m, 2) + Ba(k, 2)), D = $n(Ba(S, 2) + Ba(A, 2)), B = (M + D) / 2, z = .5 * (1 - $n(Ba(B, 7) / (Ba(B, 7) + Ba(25, 7)))), I = m * (1 + z), N = S * (1 + z), U = $n(Ba(I, 2) + Ba(k, 2)), W = $n(Ba(N, 2) + Ba(A, 2)), X = (U + W) / 2, V = l(bm(k, I)), ne = l(bm(A, N)), Z = V >= 0 ? V : V + 360, ie = ne >= 0 ? ne : ne + 360, fe = ym(Z - ie) > 180 ? (Z + ie + 360) / 2 : (Z + ie) / 2, le = 1 - .17 * ac(h(fe - 30)) + .24 * ac(h(2 * fe)) + .32 * ac(h(3 * fe + 6)) - .2 * ac(h(4 * fe - 63));
  let Ee = ie - Z;
  Ee = ym(Ee) <= 180 ? Ee : ie <= Z ? Ee + 360 : Ee - 360, Ee = 2 * $n(U * W) * xm(h(Ee) / 2);
  const ye = w - p,
    ve = W - U,
    me = 1 + .015 * Ba(E - 50, 2) / $n(20 + Ba(E - 50, 2)),
    Ae = 1 + .045 * X,
    He = 1 + .015 * X * le,
    De = 30 * TM(-Ba((fe - 275) / 25, 2)),
    Je = -(2 * $n(Ba(X, 7) / (Ba(X, 7) + Ba(25, 7)))) * xm(2 * h(De)),
    he = $n(Ba(ye / (a * me), 2) + Ba(ve / (i * Ae), 2) + Ba(Ee / (o * He), 2) + Je * (ve / (i * Ae)) * (Ee / (o * He)));
  return CM(0, AM(100, he))
}

function PM(e, t, a = "lab") {
  e = new ot(e), t = new ot(t);
  const i = e.get(a),
    o = t.get(a);
  let l = 0;
  for (let h in i) {
    const p = (i[h] || 0) - (o[h] || 0);
    l += p * p
  }
  return Math.sqrt(l)
}
const LM = (...e) => {
    try {
      return new ot(...e), !0
    } catch {
      return !1
    }
  },
  OM = {
    cool() {
      return $c([Ft.hsl(180, 1, .9), Ft.hsl(250, .7, .4)])
    },
    hot() {
      return $c(["#000", "#f00", "#ff0", "#fff"]).mode("rgb")
    }
  },
  yc = {
    OrRd: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"],
    PuBu: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"],
    BuPu: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"],
    Oranges: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"],
    BuGn: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"],
    YlOrBr: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"],
    YlGn: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"],
    Reds: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"],
    RdPu: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"],
    Greens: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"],
    YlGnBu: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"],
    Purples: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"],
    GnBu: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"],
    Greys: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"],
    YlOrRd: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"],
    PuRd: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"],
    Blues: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"],
    PuBuGn: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"],
    Viridis: ["#440154", "#482777", "#3f4a8a", "#31678e", "#26838f", "#1f9d8a", "#6cce5a", "#b6de2b", "#fee825"],
    Spectral: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
    RdYlGn: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
    RdBu: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
    PiYG: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
    PRGn: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
    RdYlBu: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
    BrBG: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
    RdGy: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
    PuOr: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
    Set2: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"],
    Accent: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"],
    Set1: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"],
    Set3: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"],
    Dark2: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"],
    Paired: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"],
    Pastel2: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"],
    Pastel1: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
  };
for (let e of Object.keys(yc)) yc[e.toLowerCase()] = yc[e];
Object.assign(Ft, {
  average: QO,
  bezier: nM,
  blend: gn,
  cubehelix: mM,
  mix: bl,
  interpolate: bl,
  random: xM,
  scale: $c,
  analyze: vx,
  contrast: SM,
  deltaE: EM,
  distance: PM,
  limits: bx,
  valid: LM,
  scales: OM,
  input: Rt,
  colors: no,
  brewer: yc
});
const MM = {
    key: 0,
    class: "h-full flex items-center justify-center"
  },
  IM = {
    key: 1,
    class: "bg-white md:bg-inherit p-4 md:p-8 rounded-[5px] text-[#000] h-full overflow-y-auto"
  },
  RM = {
    class: "flex justify-between mt-3 md:mt-0"
  },
  DM = {
    class: "md:block hidden text-xl mb-1"
  },
  NM = {
    class: "mb-6 flex items-center leading-6"
  },
  FM = {
    key: 0,
    class: "mt-1 font-semibold md:font-normal text-xl"
  },
  $M = {
    key: 1,
    class: "mt-1 font-semibold md:font-normal text-xl"
  },
  BM = {
    class: "relative flex items-center",
    style: {
      width: "30%"
    }
  },
  HM = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    class: "h-6 w-6",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, [ce("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M12 4v16m8-8H4"
  })], -1),
  YM = [HM],
  zM = {
    class: "md:flex space-x-2 md:space-x-2 mt-4 md:mt-0 mb-8 text-xl md:text-sm hidden"
  },
  XM = {
    class: "grid grid-cols-2 md:grid-cols-4 gap-x-4 gap-y-2 md:space-y-0"
  },
  WM = {
    class: "flex justify-between items-center"
  },
  VM = {
    class: "text-slate-600"
  },
  jM = {
    class: "text-xl text-gray-600"
  },
  UM = ce("div", {
    class: "flex"
  }, [ce("span", {
    class: "bg-secondary/10 p-3 rounded-full self-start"
  }, [ce("svg", {
    class: "text-secondary",
    xmlns: "http://www.w3.org/2000/svg",
    width: "36",
    height: "36",
    viewBox: "0 0 24 24"
  }, [ce("g", {
    fill: "none",
    stroke: "currentColor",
    "stroke-width": "1.5"
  }, [ce("path", {
    d: "M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"
  }), ce("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    d: "m7 14l2.293-2.293a1 1 0 0 1 1.414 0l1.586 1.586a1 1 0 0 0 1.414 0L17 10m0 0v2.5m0-2.5h-2.5"
  })])])])], -1),
  GM = {
    class: "md:grid md:grid-cols-2 gap-x-4 mt-8"
  },
  qM = {
    class: "text-xl mb-4"
  },
  KM = {
    class: "text-xl mb-4"
  },
  ZM = {
    class: "md:grid md:grid-cols-2 gap-x-4 mt-8"
  },
  QM = {
    class: "text-xl mb-4 flex justify-between items-center"
  },
  JM = {
    class: "text-xl mb-4"
  },
  eI = {
    class: "md:grid md:grid-cols-1 gap-x-4 mt-8"
  },
  tI = {
    class: "text-xl mb-4"
  },
  Md = {
    __name: "Dashboard",
    setup(e) {
      const t = _e(JSON.parse(localStorage.getItem("user")));
      _e(!1);
      const a = _e(!0),
        i = _e([]),
        o = _e([]),
        l = _e([]),
        h = _e([]),
        p = _e([]),
        m = _e([]),
        k = _e(!0),
        w = _e([]),
        S = _e([]),
        A = _e(null);
      Dt(async () => {
        try {
          console.log("Dashboard component mounted");
          const Z = await Qt.get("http://localhost:3000/api/earliest-start-date"),
            ie = new Date(Z.data.startDate),
            fe = new Date;
          A.value = [ie, fe], E()
        } catch (Z) {
          console.error("Error fetching the earliest start date:", Z)
        }
      });
      async function E() {
        try {
          console.log("fetchDashboardData called");
          const Z = {};
          if (A.value && A.value.length === 2) {
            const De = new Date(A.value[0]),
              Ye = new Date(A.value[1]);
            if (!isNaN(De) && !isNaN(Ye)) Z.startDate = De.toISOString(), Z.endDate = Ye.toISOString();
            else {
              console.error("Invalid date range selected");
              return
            }
          } else {
            const De = await Qt.get("http://localhost:3000/api/dashboard-data-initial-dates");
            Z.startDate = De.data.startDate, Z.endDate = new Date().toISOString()
          }
          console.log("Request params:", Z);
          const [ie, fe] = await Promise.all([Qt.get("http://localhost:3000/api/dashboard-data", {
            params: Z
          }), Qt.get("http://localhost:3000/api/user-actions-heatmap", {
            params: Z
          })]);
          console.log("Dashboard data:", ie.data), console.log("Heatmap data:", fe.data);
          const le = ie.data,
            Ee = fe.data.heatMapData,
            ye = fe.data.maxCount,
            ve = fe.data.minCount;
          i.value = [{
            title: "API Calls",
            value: le.apiCalls
          }, {
            title: "Total Subjects",
            value: le.totalSubjects
          }, {
            title: "Total States",
            value: le.totalStates
          }, {
            title: "Total Classes",
            value: le.totalClasses
          }, {
            title: "Active Users",
            value: le.activeUsers
          }, {
            title: "Avg Ret Users",
            value: le.totalRevenue
          }, {
            title: "Subscribers",
            value: le.openTickets
          }, {
            title: "Total SMS",
            value: le.totalMessages
          }];
          const me = le.usersByAge.map(De => De._id),
            Ae = le.usersByAge.map(De => De.count);
          V.value.xaxis.categories = me, p.value = [{
            name: "Users",
            data: Ae
          }], o.value = le.usersByClass.map(De => De.count), U.value.labels = le.usersByClass.map(De => De._id), l.value = [{
            name: "Users",
            data: le.usersByGender.map(De => De.count)
          }];
          const He = le.usersByState.sort((De, Ye) => Ye.count - De.count);
          w.value = He.slice(0, 4), S.value = He.slice(-4), B(w.value), m.value = Ee.map(De => ({
            name: De.name,
            data: De.data.map((Ye, Je) => ({
              x: `${Je}:00`,
              y: Ye
            }))
          })), ne.value.plotOptions.heatmap.colorScale.ranges = D(ve, ye, 5)
        } catch (Z) {
          console.error("Error fetching dashboard data:", Z)
        } finally {
          a.value = !1
        }
      }

      function M() {
        a.value = !0, E()
      }

      function D(Z, ie, fe) {
        const le = Ft.scale(["#00A100", "#FF0000"]).domain([Z, ie]),
          Ee = (ie - Z) / fe,
          ye = [];
        for (let ve = 0; ve < fe; ve++) {
          const me = Z + ve * Ee,
            Ae = me + Ee;
          ye.push({
            from: Math.floor(me),
            to: Math.floor(Ae),
            color: le(me).hex(),
            name: `Activity ${Math.floor(me)} - ${Math.floor(Ae)}`
          })
        }
        return ye
      }

      function B(Z) {
        X.value.xaxis.categories = Z.map(ie => ie._id), h.value = [{
          name: "States",
          data: Z.map(ie => ie.count)
        }]
      }

      function z() {
        k.value = !k.value;
        const Z = k.value ? w.value : S.value;
        B(Z)
      }

      function I(Z) {
        A.value = Z, M()
      }

      function N(Z) {
        return new Intl.NumberFormat().format(Z)
      }
      const U = _e({
          chart: {
            type: "pie"
          },
          labels: [],
          legend: {
            position: "bottom"
          }
        }),
        W = _e({
          chart: {
            type: "bar"
          },
          xaxis: {
            categories: ["Male", "Female"]
          },
          plotOptions: {
            bar: {
              horizontal: !1,
              columnWidth: "50%"
            }
          }
        }),
        X = _e({
          chart: {
            type: "bar"
          },
          xaxis: {
            categories: []
          },
          plotOptions: {
            bar: {
              horizontal: !0,
              columnWidth: "50%"
            }
          }
        }),
        V = _e({
          chart: {
            type: "bar"
          },
          xaxis: {
            categories: []
          },
          plotOptions: {
            bar: {
              horizontal: !1,
              columnWidth: "70%"
            }
          }
        }),
        ne = _e({
          chart: {
            type: "heatmap"
          },
          plotOptions: {
            heatmap: {
              shadeIntensity: .5,
              radius: 0,
              useFillColorAsStroke: !0,
              colorScale: {
                ranges: []
              }
            }
          },
          dataLabels: {
            enabled: !1
          }
        });
      return (Z, ie) => {
        const fe = Mn("router-link"),
          le = Mn("apexchart");
        return be(), yt(yu, null, {
          default: Qe(() => [a.value ? (be(), Ne("div", MM, [Ze(FC)])) : t.value ? (be(), Ne("div", IM, [ce("div", RM, [ce("div", null, [ce("h2", DM, st(Z.$t("Dashboard")), 1), ce("p", NM, [t.value && t.value.first_name ? (be(), Ne("span", FM, st(`Welcome back, ${t.value.first_name}`) + " 👋 ", 1)) : (be(), Ne("span", $M, " Welcome back, Gideon 👋 "))])]), ce("div", BM, [Ze(se(Zf), {
            modelValue: A.value,
            "onUpdate:modelValue": ie[0] || (ie[0] = Ee => A.value = Ee),
            range: "",
            "onUpdate:model": I
          }, null, 8, ["modelValue"]), ce("button", {
            onClick: M,
            class: "ml-2 text-gray-500 hover:text-gray-700"
          }, YM)])]), ce("div", zM, [Ze(fe, {
            to: "/admin/organizations/create",
            class: "bg-primary py-2 px-3 rounded-lg text-white text-center"
          }, {
            default: Qe(() => [$t(st(Z.$t("Add School")), 1)]),
            _: 1
          }), Ze(fe, {
            to: "/admin/users/create",
            class: "bg-primary py-2 px-3 rounded-lg text-white text-center"
          }, {
            default: Qe(() => [$t(st(Z.$t("Add User")), 1)]),
            _: 1
          })]), ce("div", XM, [(be(!0), Ne(vt, null, la(i.value, Ee => (be(), Ne("div", {
            class: "bg-slate-100 md:bg-white col-span-1 rounded-lg p-3",
            key: Ee.title
          }, [ce("div", WM, [ce("div", null, [ce("h2", VM, st(Ee.title), 1), ce("h1", jM, st(N(Ee.value)), 1)]), UM])]))), 128))]), ce("div", GM, [ce("div", null, [ce("h2", qM, st(Z.$t("Users by Class")), 1), Ze(le, {
            type: "pie",
            height: "350",
            options: U.value,
            series: o.value
          }, null, 8, ["options", "series"])]), ce("div", null, [ce("h2", KM, st(Z.$t("Users by Gender")), 1), Ze(le, {
            type: "bar",
            height: "350",
            options: W.value,
            series: l.value
          }, null, 8, ["options", "series"])])]), ce("div", ZM, [ce("div", null, [ce("h2", QM, [$t(st(Z.$t("Users by State")) + " ", 1), ce("button", {
            onClick: z,
            class: "bg-primary py-2 px-3 rounded-lg text-white text-center"
          }, st(k.value.value ? Z.$t("Show Least 4") : Z.$t("Show Top 4")), 1)]), Ze(le, {
            type: "bar",
            height: "350",
            options: X.value,
            series: h.value
          }, null, 8, ["options", "series"])]), ce("div", null, [ce("h2", JM, st(Z.$t("Users by Age")), 1), Ze(le, {
            type: "bar",
            height: "350",
            options: V.value,
            series: p.value
          }, null, 8, ["options", "series"])])]), ce("div", eI, [ce("div", null, [ce("h2", tI, st(Z.$t("User Activity Heatmap")), 1), Ze(le, {
            type: "heatmap",
            height: "350",
            options: ne.value,
            series: m.value
          }, null, 8, ["options", "series"])])])])) : Ke("", !0)]),
          _: 1
        })
      }
    }
  };
var Tr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function Tu(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}

function aI(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var a = function i() {
      return this instanceof i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
    };
    a.prototype = t.prototype
  } else a = {};
  return Object.defineProperty(a, "__esModule", {
    value: !0
  }), Object.keys(e).forEach(function (i) {
    var o = Object.getOwnPropertyDescriptor(e, i);
    Object.defineProperty(a, i, o.get ? o : {
      enumerable: !0,
      get: function () {
        return e[i]
      }
    })
  }), a
}
var rI = function (t) {
  return nI(t) && !iI(t)
};

function nI(e) {
  return !!e && typeof e == "object"
}

function iI(e) {
  var t = Object.prototype.toString.call(e);
  return t === "[object RegExp]" || t === "[object Date]" || lI(e)
}
var sI = typeof Symbol == "function" && Symbol.for,
  oI = sI ? Symbol.for("react.element") : 60103;

function lI(e) {
  return e.$$typeof === oI
}

function cI(e) {
  return Array.isArray(e) ? [] : {}
}

function yl(e, t) {
  return t.clone !== !1 && t.isMergeableObject(e) ? io(cI(e), e, t) : e
}

function uI(e, t, a) {
  return e.concat(t).map(function (i) {
    return yl(i, a)
  })
}

function dI(e, t) {
  if (!t.customMerge) return io;
  var a = t.customMerge(e);
  return typeof a == "function" ? a : io
}

function hI(e) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(e).filter(function (t) {
    return Object.propertyIsEnumerable.call(e, t)
  }) : []
}

function km(e) {
  return Object.keys(e).concat(hI(e))
}

function yx(e, t) {
  try {
    return t in e
  } catch {
    return !1
  }
}

function fI(e, t) {
  return yx(e, t) && !(Object.hasOwnProperty.call(e, t) && Object.propertyIsEnumerable.call(e, t))
}

function pI(e, t, a) {
  var i = {};
  return a.isMergeableObject(e) && km(e).forEach(function (o) {
    i[o] = yl(e[o], a)
  }), km(t).forEach(function (o) {
    fI(e, o) || (yx(e, o) && a.isMergeableObject(t[o]) ? i[o] = dI(o, a)(e[o], t[o], a) : i[o] = yl(t[o], a))
  }), i
}

function io(e, t, a) {
  a = a || {}, a.arrayMerge = a.arrayMerge || uI, a.isMergeableObject = a.isMergeableObject || rI, a.cloneUnlessOtherwiseSpecified = yl;
  var i = Array.isArray(t),
    o = Array.isArray(e),
    l = i === o;
  return l ? i ? a.arrayMerge(e, t, a) : pI(e, t, a) : yl(t, a)
}
io.all = function (t, a) {
  if (!Array.isArray(t)) throw new Error("first argument should be an array");
  return t.reduce(function (i, o) {
    return io(i, o, a)
  }, {})
};
var gI = io,
  mI = gI;
const vI = Tu(mI);
var bI = Error,
  yI = EvalError,
  xI = RangeError,
  wI = ReferenceError,
  xx = SyntaxError,
  Rl = TypeError,
  kI = URIError,
  _I = function () {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
    if (typeof Symbol.iterator == "symbol") return !0;
    var t = {},
      a = Symbol("test"),
      i = Object(a);
    if (typeof a == "string" || Object.prototype.toString.call(a) !== "[object Symbol]" || Object.prototype.toString.call(i) !== "[object Symbol]") return !1;
    var o = 42;
    t[a] = o;
    for (a in t) return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0) return !1;
    var l = Object.getOwnPropertySymbols(t);
    if (l.length !== 1 || l[0] !== a || !Object.prototype.propertyIsEnumerable.call(t, a)) return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var h = Object.getOwnPropertyDescriptor(t, a);
      if (h.value !== o || h.enumerable !== !0) return !1
    }
    return !0
  },
  _m = typeof Symbol < "u" && Symbol,
  SI = _I,
  AI = function () {
    return typeof _m != "function" || typeof Symbol != "function" || typeof _m("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : SI()
  },
  Id = {
    __proto__: null,
    foo: {}
  },
  CI = Object,
  TI = function () {
    return {
      __proto__: Id
    }.foo === Id.foo && !(Id instanceof CI)
  },
  EI = "Function.prototype.bind called on incompatible ",
  PI = Object.prototype.toString,
  LI = Math.max,
  OI = "[object Function]",
  Sm = function (t, a) {
    for (var i = [], o = 0; o < t.length; o += 1) i[o] = t[o];
    for (var l = 0; l < a.length; l += 1) i[l + t.length] = a[l];
    return i
  },
  MI = function (t, a) {
    for (var i = [], o = a, l = 0; o < t.length; o += 1, l += 1) i[l] = t[o];
    return i
  },
  II = function (e, t) {
    for (var a = "", i = 0; i < e.length; i += 1) a += e[i], i + 1 < e.length && (a += t);
    return a
  },
  RI = function (t) {
    var a = this;
    if (typeof a != "function" || PI.apply(a) !== OI) throw new TypeError(EI + a);
    for (var i = MI(arguments, 1), o, l = function () {
        if (this instanceof o) {
          var w = a.apply(this, Sm(i, arguments));
          return Object(w) === w ? w : this
        }
        return a.apply(t, Sm(i, arguments))
      }, h = LI(0, a.length - i.length), p = [], m = 0; m < h; m++) p[m] = "$" + m;
    if (o = Function("binder", "return function (" + II(p, ",") + "){ return binder.apply(this,arguments); }")(l), a.prototype) {
      var k = function () {};
      k.prototype = a.prototype, o.prototype = new k, k.prototype = null
    }
    return o
  },
  DI = RI,
  ap = Function.prototype.bind || DI,
  NI = Function.prototype.call,
  FI = Object.prototype.hasOwnProperty,
  $I = ap,
  BI = $I.call(NI, FI),
  Wt, HI = bI,
  YI = yI,
  zI = xI,
  XI = wI,
  so = xx,
  Gs = Rl,
  WI = kI,
  wx = Function,
  Rd = function (e) {
    try {
      return wx('"use strict"; return (' + e + ").constructor;")()
    } catch {}
  },
  fs = Object.getOwnPropertyDescriptor;
if (fs) try {
  fs({}, "")
} catch {
  fs = null
}
var Dd = function () {
    throw new Gs
  },
  VI = fs ? function () {
    try {
      return arguments.callee, Dd
    } catch {
      try {
        return fs(arguments, "callee").get
      } catch {
        return Dd
      }
    }
  }() : Dd,
  Os = AI(),
  jI = TI(),
  Qa = Object.getPrototypeOf || (jI ? function (e) {
    return e.__proto__
  } : null),
  Fs = {},
  UI = typeof Uint8Array > "u" || !Qa ? Wt : Qa(Uint8Array),
  ps = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? Wt : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Wt : ArrayBuffer,
    "%ArrayIteratorPrototype%": Os && Qa ? Qa([][Symbol.iterator]()) : Wt,
    "%AsyncFromSyncIteratorPrototype%": Wt,
    "%AsyncFunction%": Fs,
    "%AsyncGenerator%": Fs,
    "%AsyncGeneratorFunction%": Fs,
    "%AsyncIteratorPrototype%": Fs,
    "%Atomics%": typeof Atomics > "u" ? Wt : Atomics,
    "%BigInt%": typeof BigInt > "u" ? Wt : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? Wt : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? Wt : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? Wt : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": HI,
    "%eval%": eval,
    "%EvalError%": YI,
    "%Float32Array%": typeof Float32Array > "u" ? Wt : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? Wt : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Wt : FinalizationRegistry,
    "%Function%": wx,
    "%GeneratorFunction%": Fs,
    "%Int8Array%": typeof Int8Array > "u" ? Wt : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? Wt : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? Wt : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": Os && Qa ? Qa(Qa([][Symbol.iterator]())) : Wt,
    "%JSON%": typeof JSON == "object" ? JSON : Wt,
    "%Map%": typeof Map > "u" ? Wt : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !Os || !Qa ? Wt : Qa(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? Wt : Promise,
    "%Proxy%": typeof Proxy > "u" ? Wt : Proxy,
    "%RangeError%": zI,
    "%ReferenceError%": XI,
    "%Reflect%": typeof Reflect > "u" ? Wt : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? Wt : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !Os || !Qa ? Wt : Qa(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Wt : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": Os && Qa ? Qa("" [Symbol.iterator]()) : Wt,
    "%Symbol%": Os ? Symbol : Wt,
    "%SyntaxError%": so,
    "%ThrowTypeError%": VI,
    "%TypedArray%": UI,
    "%TypeError%": Gs,
    "%Uint8Array%": typeof Uint8Array > "u" ? Wt : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Wt : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? Wt : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? Wt : Uint32Array,
    "%URIError%": WI,
    "%WeakMap%": typeof WeakMap > "u" ? Wt : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? Wt : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? Wt : WeakSet
  };
if (Qa) try {
  null.error
} catch (e) {
  var GI = Qa(Qa(e));
  ps["%Error.prototype%"] = GI
}
var qI = function e(t) {
    var a;
    if (t === "%AsyncFunction%") a = Rd("async function () {}");
    else if (t === "%GeneratorFunction%") a = Rd("function* () {}");
    else if (t === "%AsyncGeneratorFunction%") a = Rd("async function* () {}");
    else if (t === "%AsyncGenerator%") {
      var i = e("%AsyncGeneratorFunction%");
      i && (a = i.prototype)
    } else if (t === "%AsyncIteratorPrototype%") {
      var o = e("%AsyncGenerator%");
      o && Qa && (a = Qa(o.prototype))
    }
    return ps[t] = a, a
  },
  Am = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  },
  Dl = ap,
  Bc = BI,
  KI = Dl.call(Function.call, Array.prototype.concat),
  ZI = Dl.call(Function.apply, Array.prototype.splice),
  Cm = Dl.call(Function.call, String.prototype.replace),
  Hc = Dl.call(Function.call, String.prototype.slice),
  QI = Dl.call(Function.call, RegExp.prototype.exec),
  JI = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
  eR = /\\(\\)?/g,
  tR = function (t) {
    var a = Hc(t, 0, 1),
      i = Hc(t, -1);
    if (a === "%" && i !== "%") throw new so("invalid intrinsic syntax, expected closing `%`");
    if (i === "%" && a !== "%") throw new so("invalid intrinsic syntax, expected opening `%`");
    var o = [];
    return Cm(t, JI, function (l, h, p, m) {
      o[o.length] = p ? Cm(m, eR, "$1") : h || l
    }), o
  },
  aR = function (t, a) {
    var i = t,
      o;
    if (Bc(Am, i) && (o = Am[i], i = "%" + o[0] + "%"), Bc(ps, i)) {
      var l = ps[i];
      if (l === Fs && (l = qI(i)), typeof l > "u" && !a) throw new Gs("intrinsic " + t + " exists, but is not available. Please file an issue!");
      return {
        alias: o,
        name: i,
        value: l
      }
    }
    throw new so("intrinsic " + t + " does not exist!")
  },
  bo = function (t, a) {
    if (typeof t != "string" || t.length === 0) throw new Gs("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof a != "boolean") throw new Gs('"allowMissing" argument must be a boolean');
    if (QI(/^%?[^%]*%?$/, t) === null) throw new so("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var i = tR(t),
      o = i.length > 0 ? i[0] : "",
      l = aR("%" + o + "%", a),
      h = l.name,
      p = l.value,
      m = !1,
      k = l.alias;
    k && (o = k[0], ZI(i, KI([0, 1], k)));
    for (var w = 1, S = !0; w < i.length; w += 1) {
      var A = i[w],
        E = Hc(A, 0, 1),
        M = Hc(A, -1);
      if ((E === '"' || E === "'" || E === "`" || M === '"' || M === "'" || M === "`") && E !== M) throw new so("property names with quotes must have matching quotes");
      if ((A === "constructor" || !S) && (m = !0), o += "." + A, h = "%" + o + "%", Bc(ps, h)) p = ps[h];
      else if (p != null) {
        if (!(A in p)) {
          if (!a) throw new Gs("base intrinsic for " + t + " exists, but the property is not available.");
          return
        }
        if (fs && w + 1 >= i.length) {
          var D = fs(p, A);
          S = !!D, S && "get" in D && !("originalValue" in D.get) ? p = D.get : p = p[A]
        } else S = Bc(p, A), p = p[A];
        S && !m && (ps[h] = p)
      }
    }
    return p
  },
  kx = {
    exports: {}
  },
  Nd, Tm;

function rp() {
  if (Tm) return Nd;
  Tm = 1;
  var e = bo,
    t = e("%Object.defineProperty%", !0) || !1;
  if (t) try {
    t({}, "a", {
      value: 1
    })
  } catch {
    t = !1
  }
  return Nd = t, Nd
}
var rR = bo,
  xc = rR("%Object.getOwnPropertyDescriptor%", !0);
if (xc) try {
  xc([], "length")
} catch {
  xc = null
}
var _x = xc,
  Em = rp(),
  nR = xx,
  Ms = Rl,
  Pm = _x,
  iR = function (t, a, i) {
    if (!t || typeof t != "object" && typeof t != "function") throw new Ms("`obj` must be an object or a function`");
    if (typeof a != "string" && typeof a != "symbol") throw new Ms("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null) throw new Ms("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null) throw new Ms("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null) throw new Ms("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean") throw new Ms("`loose`, if provided, must be a boolean");
    var o = arguments.length > 3 ? arguments[3] : null,
      l = arguments.length > 4 ? arguments[4] : null,
      h = arguments.length > 5 ? arguments[5] : null,
      p = arguments.length > 6 ? arguments[6] : !1,
      m = !!Pm && Pm(t, a);
    if (Em) Em(t, a, {
      configurable: h === null && m ? m.configurable : !h,
      enumerable: o === null && m ? m.enumerable : !o,
      value: i,
      writable: l === null && m ? m.writable : !l
    });
    else if (p || !o && !l && !h) t[a] = i;
    else throw new nR("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
  },
  Oh = rp(),
  Sx = function () {
    return !!Oh
  };
Sx.hasArrayLengthDefineBug = function () {
  if (!Oh) return null;
  try {
    return Oh([], "length", {
      value: 1
    }).length !== 1
  } catch {
    return !0
  }
};
var sR = Sx,
  oR = bo,
  Lm = iR,
  lR = sR(),
  Om = _x,
  Mm = Rl,
  cR = oR("%Math.floor%"),
  uR = function (t, a) {
    if (typeof t != "function") throw new Mm("`fn` is not a function");
    if (typeof a != "number" || a < 0 || a > 4294967295 || cR(a) !== a) throw new Mm("`length` must be a positive 32-bit integer");
    var i = arguments.length > 2 && !!arguments[2],
      o = !0,
      l = !0;
    if ("length" in t && Om) {
      var h = Om(t, "length");
      h && !h.configurable && (o = !1), h && !h.writable && (l = !1)
    }
    return (o || l || !i) && (lR ? Lm(t, "length", a, !0, !0) : Lm(t, "length", a)), t
  };
(function (e) {
  var t = ap,
    a = bo,
    i = uR,
    o = Rl,
    l = a("%Function.prototype.apply%"),
    h = a("%Function.prototype.call%"),
    p = a("%Reflect.apply%", !0) || t.call(h, l),
    m = rp(),
    k = a("%Math.max%");
  e.exports = function (A) {
    if (typeof A != "function") throw new o("a function is required");
    var E = p(t, h, arguments);
    return i(E, 1 + k(0, A.length - (arguments.length - 1)), !0)
  };
  var w = function () {
    return p(t, l, arguments)
  };
  m ? m(e.exports, "apply", {
    value: w
  }) : e.exports.apply = w
})(kx);
var dR = kx.exports,
  Ax = bo,
  Cx = dR,
  hR = Cx(Ax("String.prototype.indexOf")),
  fR = function (t, a) {
    var i = Ax(t, !!a);
    return typeof i == "function" && hR(t, ".prototype.") > -1 ? Cx(i) : i
  };
const pR = {},
  gR = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: pR
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  mR = aI(gR);
var np = typeof Map == "function" && Map.prototype,
  Fd = Object.getOwnPropertyDescriptor && np ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
  Yc = np && Fd && typeof Fd.get == "function" ? Fd.get : null,
  Im = np && Map.prototype.forEach,
  ip = typeof Set == "function" && Set.prototype,
  $d = Object.getOwnPropertyDescriptor && ip ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
  zc = ip && $d && typeof $d.get == "function" ? $d.get : null,
  Rm = ip && Set.prototype.forEach,
  vR = typeof WeakMap == "function" && WeakMap.prototype,
  al = vR ? WeakMap.prototype.has : null,
  bR = typeof WeakSet == "function" && WeakSet.prototype,
  rl = bR ? WeakSet.prototype.has : null,
  yR = typeof WeakRef == "function" && WeakRef.prototype,
  Dm = yR ? WeakRef.prototype.deref : null,
  xR = Boolean.prototype.valueOf,
  wR = Object.prototype.toString,
  kR = Function.prototype.toString,
  _R = String.prototype.match,
  sp = String.prototype.slice,
  yi = String.prototype.replace,
  SR = String.prototype.toUpperCase,
  Nm = String.prototype.toLowerCase,
  Tx = RegExp.prototype.test,
  Fm = Array.prototype.concat,
  Sn = Array.prototype.join,
  AR = Array.prototype.slice,
  $m = Math.floor,
  Mh = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
  Bd = Object.getOwnPropertySymbols,
  Ih = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
  oo = typeof Symbol == "function" && typeof Symbol.iterator == "object",
  br = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === oo || !0) ? Symbol.toStringTag : null,
  Ex = Object.prototype.propertyIsEnumerable,
  Bm = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function (e) {
    return e.__proto__
  } : null);

function Hm(e, t) {
  if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || Tx.call(/e/, t)) return t;
  var a = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof e == "number") {
    var i = e < 0 ? -$m(-e) : $m(e);
    if (i !== e) {
      var o = String(i),
        l = sp.call(t, o.length + 1);
      return yi.call(o, a, "$&_") + "." + yi.call(yi.call(l, /([0-9]{3})/g, "$&_"), /_$/, "")
    }
  }
  return yi.call(t, a, "$&_")
}
var Rh = mR,
  Ym = Rh.custom,
  zm = Lx(Ym) ? Ym : null,
  CR = function e(t, a, i, o) {
    var l = a || {};
    if (mi(l, "quoteStyle") && l.quoteStyle !== "single" && l.quoteStyle !== "double") throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (mi(l, "maxStringLength") && (typeof l.maxStringLength == "number" ? l.maxStringLength < 0 && l.maxStringLength !== 1 / 0 : l.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var h = mi(l, "customInspect") ? l.customInspect : !0;
    if (typeof h != "boolean" && h !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (mi(l, "indent") && l.indent !== null && l.indent !== "	" && !(parseInt(l.indent, 10) === l.indent && l.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (mi(l, "numericSeparator") && typeof l.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var p = l.numericSeparator;
    if (typeof t > "u") return "undefined";
    if (t === null) return "null";
    if (typeof t == "boolean") return t ? "true" : "false";
    if (typeof t == "string") return Mx(t, l);
    if (typeof t == "number") {
      if (t === 0) return 1 / 0 / t > 0 ? "0" : "-0";
      var m = String(t);
      return p ? Hm(t, m) : m
    }
    if (typeof t == "bigint") {
      var k = String(t) + "n";
      return p ? Hm(t, k) : k
    }
    var w = typeof l.depth > "u" ? 5 : l.depth;
    if (typeof i > "u" && (i = 0), i >= w && w > 0 && typeof t == "object") return Dh(t) ? "[Array]" : "[Object]";
    var S = WR(l, i);
    if (typeof o > "u") o = [];
    else if (Ox(o, t) >= 0) return "[Circular]";

    function A(Ee, ye, ve) {
      if (ye && (o = AR.call(o), o.push(ye)), ve) {
        var me = {
          depth: l.depth
        };
        return mi(l, "quoteStyle") && (me.quoteStyle = l.quoteStyle), e(Ee, me, i + 1, o)
      }
      return e(Ee, l, i + 1, o)
    }
    if (typeof t == "function" && !Xm(t)) {
      var E = DR(t),
        M = rc(t, A);
      return "[Function" + (E ? ": " + E : " (anonymous)") + "]" + (M.length > 0 ? " { " + Sn.call(M, ", ") + " }" : "")
    }
    if (Lx(t)) {
      var D = oo ? yi.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : Ih.call(t);
      return typeof t == "object" && !oo ? No(D) : D
    }
    if (YR(t)) {
      for (var B = "<" + Nm.call(String(t.nodeName)), z = t.attributes || [], I = 0; I < z.length; I++) B += " " + z[I].name + "=" + Px(TR(z[I].value), "double", l);
      return B += ">", t.childNodes && t.childNodes.length && (B += "..."), B += "</" + Nm.call(String(t.nodeName)) + ">", B
    }
    if (Dh(t)) {
      if (t.length === 0) return "[]";
      var N = rc(t, A);
      return S && !XR(N) ? "[" + Nh(N, S) + "]" : "[ " + Sn.call(N, ", ") + " ]"
    }
    if (PR(t)) {
      var U = rc(t, A);
      return !("cause" in Error.prototype) && "cause" in t && !Ex.call(t, "cause") ? "{ [" + String(t) + "] " + Sn.call(Fm.call("[cause]: " + A(t.cause), U), ", ") + " }" : U.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + Sn.call(U, ", ") + " }"
    }
    if (typeof t == "object" && h) {
      if (zm && typeof t[zm] == "function" && Rh) return Rh(t, {
        depth: w - i
      });
      if (h !== "symbol" && typeof t.inspect == "function") return t.inspect()
    }
    if (NR(t)) {
      var W = [];
      return Im && Im.call(t, function (Ee, ye) {
        W.push(A(ye, t, !0) + " => " + A(Ee, t))
      }), Wm("Map", Yc.call(t), W, S)
    }
    if (BR(t)) {
      var X = [];
      return Rm && Rm.call(t, function (Ee) {
        X.push(A(Ee, t))
      }), Wm("Set", zc.call(t), X, S)
    }
    if (FR(t)) return Hd("WeakMap");
    if (HR(t)) return Hd("WeakSet");
    if ($R(t)) return Hd("WeakRef");
    if (OR(t)) return No(A(Number(t)));
    if (IR(t)) return No(A(Mh.call(t)));
    if (MR(t)) return No(xR.call(t));
    if (LR(t)) return No(A(String(t)));
    if (typeof window < "u" && t === window) return "{ [object Window] }";
    if (typeof globalThis < "u" && t === globalThis || typeof Tr < "u" && t === Tr) return "{ [object globalThis] }";
    if (!ER(t) && !Xm(t)) {
      var V = rc(t, A),
        ne = Bm ? Bm(t) === Object.prototype : t instanceof Object || t.constructor === Object,
        Z = t instanceof Object ? "" : "null prototype",
        ie = !ne && br && Object(t) === t && br in t ? sp.call($i(t), 8, -1) : Z ? "Object" : "",
        fe = ne || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "",
        le = fe + (ie || Z ? "[" + Sn.call(Fm.call([], ie || [], Z || []), ": ") + "] " : "");
      return V.length === 0 ? le + "{}" : S ? le + "{" + Nh(V, S) + "}" : le + "{ " + Sn.call(V, ", ") + " }"
    }
    return String(t)
  };

function Px(e, t, a) {
  var i = (a.quoteStyle || t) === "double" ? '"' : "'";
  return i + e + i
}

function TR(e) {
  return yi.call(String(e), /"/g, "&quot;")
}

function Dh(e) {
  return $i(e) === "[object Array]" && (!br || !(typeof e == "object" && br in e))
}

function ER(e) {
  return $i(e) === "[object Date]" && (!br || !(typeof e == "object" && br in e))
}

function Xm(e) {
  return $i(e) === "[object RegExp]" && (!br || !(typeof e == "object" && br in e))
}

function PR(e) {
  return $i(e) === "[object Error]" && (!br || !(typeof e == "object" && br in e))
}

function LR(e) {
  return $i(e) === "[object String]" && (!br || !(typeof e == "object" && br in e))
}

function OR(e) {
  return $i(e) === "[object Number]" && (!br || !(typeof e == "object" && br in e))
}

function MR(e) {
  return $i(e) === "[object Boolean]" && (!br || !(typeof e == "object" && br in e))
}

function Lx(e) {
  if (oo) return e && typeof e == "object" && e instanceof Symbol;
  if (typeof e == "symbol") return !0;
  if (!e || typeof e != "object" || !Ih) return !1;
  try {
    return Ih.call(e), !0
  } catch {}
  return !1
}

function IR(e) {
  if (!e || typeof e != "object" || !Mh) return !1;
  try {
    return Mh.call(e), !0
  } catch {}
  return !1
}
var RR = Object.prototype.hasOwnProperty || function (e) {
  return e in this
};

function mi(e, t) {
  return RR.call(e, t)
}

function $i(e) {
  return wR.call(e)
}

function DR(e) {
  if (e.name) return e.name;
  var t = _R.call(kR.call(e), /^function\s*([\w$]+)/);
  return t ? t[1] : null
}

function Ox(e, t) {
  if (e.indexOf) return e.indexOf(t);
  for (var a = 0, i = e.length; a < i; a++)
    if (e[a] === t) return a;
  return -1
}

function NR(e) {
  if (!Yc || !e || typeof e != "object") return !1;
  try {
    Yc.call(e);
    try {
      zc.call(e)
    } catch {
      return !0
    }
    return e instanceof Map
  } catch {}
  return !1
}

function FR(e) {
  if (!al || !e || typeof e != "object") return !1;
  try {
    al.call(e, al);
    try {
      rl.call(e, rl)
    } catch {
      return !0
    }
    return e instanceof WeakMap
  } catch {}
  return !1
}

function $R(e) {
  if (!Dm || !e || typeof e != "object") return !1;
  try {
    return Dm.call(e), !0
  } catch {}
  return !1
}

function BR(e) {
  if (!zc || !e || typeof e != "object") return !1;
  try {
    zc.call(e);
    try {
      Yc.call(e)
    } catch {
      return !0
    }
    return e instanceof Set
  } catch {}
  return !1
}

function HR(e) {
  if (!rl || !e || typeof e != "object") return !1;
  try {
    rl.call(e, rl);
    try {
      al.call(e, al)
    } catch {
      return !0
    }
    return e instanceof WeakSet
  } catch {}
  return !1
}

function YR(e) {
  return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function"
}

function Mx(e, t) {
  if (e.length > t.maxStringLength) {
    var a = e.length - t.maxStringLength,
      i = "... " + a + " more character" + (a > 1 ? "s" : "");
    return Mx(sp.call(e, 0, t.maxStringLength), t) + i
  }
  var o = yi.call(yi.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, zR);
  return Px(o, "single", t)
}

function zR(e) {
  var t = e.charCodeAt(0),
    a = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    } [t];
  return a ? "\\" + a : "\\x" + (t < 16 ? "0" : "") + SR.call(t.toString(16))
}

function No(e) {
  return "Object(" + e + ")"
}

function Hd(e) {
  return e + " { ? }"
}

function Wm(e, t, a, i) {
  var o = i ? Nh(a, i) : Sn.call(a, ", ");
  return e + " (" + t + ") {" + o + "}"
}

function XR(e) {
  for (var t = 0; t < e.length; t++)
    if (Ox(e[t], `
`) >= 0) return !1;
  return !0
}

function WR(e, t) {
  var a;
  if (e.indent === "	") a = "	";
  else if (typeof e.indent == "number" && e.indent > 0) a = Sn.call(Array(e.indent + 1), " ");
  else return null;
  return {
    base: a,
    prev: Sn.call(Array(t + 1), a)
  }
}

function Nh(e, t) {
  if (e.length === 0) return "";
  var a = `
` + t.prev + t.base;
  return a + Sn.call(e, "," + a) + `
` + t.prev
}

function rc(e, t) {
  var a = Dh(e),
    i = [];
  if (a) {
    i.length = e.length;
    for (var o = 0; o < e.length; o++) i[o] = mi(e, o) ? t(e[o], e) : ""
  }
  var l = typeof Bd == "function" ? Bd(e) : [],
    h;
  if (oo) {
    h = {};
    for (var p = 0; p < l.length; p++) h["$" + l[p]] = l[p]
  }
  for (var m in e) mi(e, m) && (a && String(Number(m)) === m && m < e.length || oo && h["$" + m] instanceof Symbol || (Tx.call(/[^\w$]/, m) ? i.push(t(m, e) + ": " + t(e[m], e)) : i.push(m + ": " + t(e[m], e))));
  if (typeof Bd == "function")
    for (var k = 0; k < l.length; k++) Ex.call(e, l[k]) && i.push("[" + t(l[k]) + "]: " + t(e[l[k]], e));
  return i
}
var Ix = bo,
  yo = fR,
  VR = CR,
  jR = Rl,
  nc = Ix("%WeakMap%", !0),
  ic = Ix("%Map%", !0),
  UR = yo("WeakMap.prototype.get", !0),
  GR = yo("WeakMap.prototype.set", !0),
  qR = yo("WeakMap.prototype.has", !0),
  KR = yo("Map.prototype.get", !0),
  ZR = yo("Map.prototype.set", !0),
  QR = yo("Map.prototype.has", !0),
  op = function (e, t) {
    for (var a = e, i;
      (i = a.next) !== null; a = i)
      if (i.key === t) return a.next = i.next, i.next = e.next, e.next = i, i
  },
  JR = function (e, t) {
    var a = op(e, t);
    return a && a.value
  },
  e3 = function (e, t, a) {
    var i = op(e, t);
    i ? i.value = a : e.next = {
      key: t,
      next: e.next,
      value: a
    }
  },
  t3 = function (e, t) {
    return !!op(e, t)
  },
  a3 = function () {
    var t, a, i, o = {
      assert: function (l) {
        if (!o.has(l)) throw new jR("Side channel does not contain " + VR(l))
      },
      get: function (l) {
        if (nc && l && (typeof l == "object" || typeof l == "function")) {
          if (t) return UR(t, l)
        } else if (ic) {
          if (a) return KR(a, l)
        } else if (i) return JR(i, l)
      },
      has: function (l) {
        if (nc && l && (typeof l == "object" || typeof l == "function")) {
          if (t) return qR(t, l)
        } else if (ic) {
          if (a) return QR(a, l)
        } else if (i) return t3(i, l);
        return !1
      },
      set: function (l, h) {
        nc && l && (typeof l == "object" || typeof l == "function") ? (t || (t = new nc), GR(t, l, h)) : ic ? (a || (a = new ic), ZR(a, l, h)) : (i || (i = {
          key: {},
          next: null
        }), e3(i, l, h))
      }
    };
    return o
  },
  r3 = String.prototype.replace,
  n3 = /%20/g,
  Yd = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  },
  lp = {
    default: Yd.RFC3986,
    formatters: {
      RFC1738: function (e) {
        return r3.call(e, n3, "+")
      },
      RFC3986: function (e) {
        return String(e)
      }
    },
    RFC1738: Yd.RFC1738,
    RFC3986: Yd.RFC3986
  },
  i3 = lp,
  zd = Object.prototype.hasOwnProperty,
  rs = Array.isArray,
  wn = function () {
    for (var e = [], t = 0; t < 256; ++t) e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return e
  }(),
  s3 = function (t) {
    for (; t.length > 1;) {
      var a = t.pop(),
        i = a.obj[a.prop];
      if (rs(i)) {
        for (var o = [], l = 0; l < i.length; ++l) typeof i[l] < "u" && o.push(i[l]);
        a.obj[a.prop] = o
      }
    }
  },
  Rx = function (t, a) {
    for (var i = a && a.plainObjects ? Object.create(null) : {}, o = 0; o < t.length; ++o) typeof t[o] < "u" && (i[o] = t[o]);
    return i
  },
  o3 = function e(t, a, i) {
    if (!a) return t;
    if (typeof a != "object") {
      if (rs(t)) t.push(a);
      else if (t && typeof t == "object")(i && (i.plainObjects || i.allowPrototypes) || !zd.call(Object.prototype, a)) && (t[a] = !0);
      else return [t, a];
      return t
    }
    if (!t || typeof t != "object") return [t].concat(a);
    var o = t;
    return rs(t) && !rs(a) && (o = Rx(t, i)), rs(t) && rs(a) ? (a.forEach(function (l, h) {
      if (zd.call(t, h)) {
        var p = t[h];
        p && typeof p == "object" && l && typeof l == "object" ? t[h] = e(p, l, i) : t.push(l)
      } else t[h] = l
    }), t) : Object.keys(a).reduce(function (l, h) {
      var p = a[h];
      return zd.call(l, h) ? l[h] = e(l[h], p, i) : l[h] = p, l
    }, o)
  },
  l3 = function (t, a) {
    return Object.keys(a).reduce(function (i, o) {
      return i[o] = a[o], i
    }, t)
  },
  c3 = function (e, t, a) {
    var i = e.replace(/\+/g, " ");
    if (a === "iso-8859-1") return i.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(i)
    } catch {
      return i
    }
  },
  Xd = 1024,
  u3 = function (t, a, i, o, l) {
    if (t.length === 0) return t;
    var h = t;
    if (typeof t == "symbol" ? h = Symbol.prototype.toString.call(t) : typeof t != "string" && (h = String(t)), i === "iso-8859-1") return escape(h).replace(/%u[0-9a-f]{4}/gi, function (E) {
      return "%26%23" + parseInt(E.slice(2), 16) + "%3B"
    });
    for (var p = "", m = 0; m < h.length; m += Xd) {
      for (var k = h.length >= Xd ? h.slice(m, m + Xd) : h, w = [], S = 0; S < k.length; ++S) {
        var A = k.charCodeAt(S);
        if (A === 45 || A === 46 || A === 95 || A === 126 || A >= 48 && A <= 57 || A >= 65 && A <= 90 || A >= 97 && A <= 122 || l === i3.RFC1738 && (A === 40 || A === 41)) {
          w[w.length] = k.charAt(S);
          continue
        }
        if (A < 128) {
          w[w.length] = wn[A];
          continue
        }
        if (A < 2048) {
          w[w.length] = wn[192 | A >> 6] + wn[128 | A & 63];
          continue
        }
        if (A < 55296 || A >= 57344) {
          w[w.length] = wn[224 | A >> 12] + wn[128 | A >> 6 & 63] + wn[128 | A & 63];
          continue
        }
        S += 1, A = 65536 + ((A & 1023) << 10 | k.charCodeAt(S) & 1023), w[w.length] = wn[240 | A >> 18] + wn[128 | A >> 12 & 63] + wn[128 | A >> 6 & 63] + wn[128 | A & 63]
      }
      p += w.join("")
    }
    return p
  },
  d3 = function (t) {
    for (var a = [{
        obj: {
          o: t
        },
        prop: "o"
      }], i = [], o = 0; o < a.length; ++o)
      for (var l = a[o], h = l.obj[l.prop], p = Object.keys(h), m = 0; m < p.length; ++m) {
        var k = p[m],
          w = h[k];
        typeof w == "object" && w !== null && i.indexOf(w) === -1 && (a.push({
          obj: h,
          prop: k
        }), i.push(w))
      }
    return s3(a), t
  },
  h3 = function (t) {
    return Object.prototype.toString.call(t) === "[object RegExp]"
  },
  f3 = function (t) {
    return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
  },
  p3 = function (t, a) {
    return [].concat(t, a)
  },
  g3 = function (t, a) {
    if (rs(t)) {
      for (var i = [], o = 0; o < t.length; o += 1) i.push(a(t[o]));
      return i
    }
    return a(t)
  },
  Dx = {
    arrayToObject: Rx,
    assign: l3,
    combine: p3,
    compact: d3,
    decode: c3,
    encode: u3,
    isBuffer: f3,
    isRegExp: h3,
    maybeMap: g3,
    merge: o3
  },
  Nx = a3,
  wc = Dx,
  nl = lp,
  m3 = Object.prototype.hasOwnProperty,
  Fx = {
    brackets: function (t) {
      return t + "[]"
    },
    comma: "comma",
    indices: function (t, a) {
      return t + "[" + a + "]"
    },
    repeat: function (t) {
      return t
    }
  },
  kn = Array.isArray,
  v3 = Array.prototype.push,
  $x = function (e, t) {
    v3.apply(e, kn(t) ? t : [t])
  },
  b3 = Date.prototype.toISOString,
  Vm = nl.default,
  Xa = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: wc.encode,
    encodeValuesOnly: !1,
    format: Vm,
    formatter: nl.formatters[Vm],
    indices: !1,
    serializeDate: function (t) {
      return b3.call(t)
    },
    skipNulls: !1,
    strictNullHandling: !1
  },
  y3 = function (t) {
    return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint"
  },
  Wd = {},
  x3 = function e(t, a, i, o, l, h, p, m, k, w, S, A, E, M, D, B, z, I) {
    for (var N = t, U = I, W = 0, X = !1;
      (U = U.get(Wd)) !== void 0 && !X;) {
      var V = U.get(t);
      if (W += 1, typeof V < "u") {
        if (V === W) throw new RangeError("Cyclic object value");
        X = !0
      }
      typeof U.get(Wd) > "u" && (W = 0)
    }
    if (typeof w == "function" ? N = w(a, N) : N instanceof Date ? N = E(N) : i === "comma" && kn(N) && (N = wc.maybeMap(N, function (Ye) {
        return Ye instanceof Date ? E(Ye) : Ye
      })), N === null) {
      if (h) return k && !B ? k(a, Xa.encoder, z, "key", M) : a;
      N = ""
    }
    if (y3(N) || wc.isBuffer(N)) {
      if (k) {
        var ne = B ? a : k(a, Xa.encoder, z, "key", M);
        return [D(ne) + "=" + D(k(N, Xa.encoder, z, "value", M))]
      }
      return [D(a) + "=" + D(String(N))]
    }
    var Z = [];
    if (typeof N > "u") return Z;
    var ie;
    if (i === "comma" && kn(N)) B && k && (N = wc.maybeMap(N, k)), ie = [{
      value: N.length > 0 ? N.join(",") || null : void 0
    }];
    else if (kn(w)) ie = w;
    else {
      var fe = Object.keys(N);
      ie = S ? fe.sort(S) : fe
    }
    var le = m ? a.replace(/\./g, "%2E") : a,
      Ee = o && kn(N) && N.length === 1 ? le + "[]" : le;
    if (l && kn(N) && N.length === 0) return Ee + "[]";
    for (var ye = 0; ye < ie.length; ++ye) {
      var ve = ie[ye],
        me = typeof ve == "object" && typeof ve.value < "u" ? ve.value : N[ve];
      if (!(p && me === null)) {
        var Ae = A && m ? ve.replace(/\./g, "%2E") : ve,
          He = kn(N) ? typeof i == "function" ? i(Ee, Ae) : Ee : Ee + (A ? "." + Ae : "[" + Ae + "]");
        I.set(t, W);
        var De = Nx();
        De.set(Wd, I), $x(Z, e(me, He, i, o, l, h, p, m, i === "comma" && B && kn(N) ? null : k, w, S, A, E, M, D, B, z, De))
      }
    }
    return Z
  },
  w3 = function (t) {
    if (!t) return Xa;
    if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function") throw new TypeError("Encoder has to be a function.");
    var a = t.charset || Xa.charset;
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var i = nl.default;
    if (typeof t.format < "u") {
      if (!m3.call(nl.formatters, t.format)) throw new TypeError("Unknown format option provided.");
      i = t.format
    }
    var o = nl.formatters[i],
      l = Xa.filter;
    (typeof t.filter == "function" || kn(t.filter)) && (l = t.filter);
    var h;
    if (t.arrayFormat in Fx ? h = t.arrayFormat : "indices" in t ? h = t.indices ? "indices" : "repeat" : h = Xa.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var p = typeof t.allowDots > "u" ? t.encodeDotInKeys === !0 ? !0 : Xa.allowDots : !!t.allowDots;
    return {
      addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Xa.addQueryPrefix,
      allowDots: p,
      allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Xa.allowEmptyArrays,
      arrayFormat: h,
      charset: a,
      charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Xa.charsetSentinel,
      commaRoundTrip: t.commaRoundTrip,
      delimiter: typeof t.delimiter > "u" ? Xa.delimiter : t.delimiter,
      encode: typeof t.encode == "boolean" ? t.encode : Xa.encode,
      encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : Xa.encodeDotInKeys,
      encoder: typeof t.encoder == "function" ? t.encoder : Xa.encoder,
      encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Xa.encodeValuesOnly,
      filter: l,
      format: i,
      formatter: o,
      serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Xa.serializeDate,
      skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Xa.skipNulls,
      sort: typeof t.sort == "function" ? t.sort : null,
      strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Xa.strictNullHandling
    }
  },
  k3 = function (e, t) {
    var a = e,
      i = w3(t),
      o, l;
    typeof i.filter == "function" ? (l = i.filter, a = l("", a)) : kn(i.filter) && (l = i.filter, o = l);
    var h = [];
    if (typeof a != "object" || a === null) return "";
    var p = Fx[i.arrayFormat],
      m = p === "comma" && i.commaRoundTrip;
    o || (o = Object.keys(a)), i.sort && o.sort(i.sort);
    for (var k = Nx(), w = 0; w < o.length; ++w) {
      var S = o[w];
      i.skipNulls && a[S] === null || $x(h, x3(a[S], S, p, m, i.allowEmptyArrays, i.strictNullHandling, i.skipNulls, i.encodeDotInKeys, i.encode ? i.encoder : null, i.filter, i.sort, i.allowDots, i.serializeDate, i.format, i.formatter, i.encodeValuesOnly, i.charset, k))
    }
    var A = h.join(i.delimiter),
      E = i.addQueryPrefix === !0 ? "?" : "";
    return i.charsetSentinel && (i.charset === "iso-8859-1" ? E += "utf8=%26%2310003%3B&" : E += "utf8=%E2%9C%93&"), A.length > 0 ? E + A : ""
  },
  lo = Dx,
  Fh = Object.prototype.hasOwnProperty,
  _3 = Array.isArray,
  Ea = {
    allowDots: !1,
    allowEmptyArrays: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decodeDotInKeys: !1,
    decoder: lo.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictDepth: !1,
    strictNullHandling: !1
  },
  S3 = function (e) {
    return e.replace(/&#(\d+);/g, function (t, a) {
      return String.fromCharCode(parseInt(a, 10))
    })
  },
  Bx = function (e, t) {
    return e && typeof e == "string" && t.comma && e.indexOf(",") > -1 ? e.split(",") : e
  },
  A3 = "utf8=%26%2310003%3B",
  C3 = "utf8=%E2%9C%93",
  T3 = function (t, a) {
    var i = {
        __proto__: null
      },
      o = a.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
    o = o.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var l = a.parameterLimit === 1 / 0 ? void 0 : a.parameterLimit,
      h = o.split(a.delimiter, l),
      p = -1,
      m, k = a.charset;
    if (a.charsetSentinel)
      for (m = 0; m < h.length; ++m) h[m].indexOf("utf8=") === 0 && (h[m] === C3 ? k = "utf-8" : h[m] === A3 && (k = "iso-8859-1"), p = m, m = h.length);
    for (m = 0; m < h.length; ++m)
      if (m !== p) {
        var w = h[m],
          S = w.indexOf("]="),
          A = S === -1 ? w.indexOf("=") : S + 1,
          E, M;
        A === -1 ? (E = a.decoder(w, Ea.decoder, k, "key"), M = a.strictNullHandling ? null : "") : (E = a.decoder(w.slice(0, A), Ea.decoder, k, "key"), M = lo.maybeMap(Bx(w.slice(A + 1), a), function (B) {
          return a.decoder(B, Ea.decoder, k, "value")
        })), M && a.interpretNumericEntities && k === "iso-8859-1" && (M = S3(M)), w.indexOf("[]=") > -1 && (M = _3(M) ? [M] : M);
        var D = Fh.call(i, E);
        D && a.duplicates === "combine" ? i[E] = lo.combine(i[E], M) : (!D || a.duplicates === "last") && (i[E] = M)
      } return i
  },
  E3 = function (e, t, a, i) {
    for (var o = i ? t : Bx(t, a), l = e.length - 1; l >= 0; --l) {
      var h, p = e[l];
      if (p === "[]" && a.parseArrays) h = a.allowEmptyArrays && (o === "" || a.strictNullHandling && o === null) ? [] : [].concat(o);
      else {
        h = a.plainObjects ? Object.create(null) : {};
        var m = p.charAt(0) === "[" && p.charAt(p.length - 1) === "]" ? p.slice(1, -1) : p,
          k = a.decodeDotInKeys ? m.replace(/%2E/g, ".") : m,
          w = parseInt(k, 10);
        !a.parseArrays && k === "" ? h = {
          0: o
        } : !isNaN(w) && p !== k && String(w) === k && w >= 0 && a.parseArrays && w <= a.arrayLimit ? (h = [], h[w] = o) : k !== "__proto__" && (h[k] = o)
      }
      o = h
    }
    return o
  },
  P3 = function (t, a, i, o) {
    if (t) {
      var l = i.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
        h = /(\[[^[\]]*])/,
        p = /(\[[^[\]]*])/g,
        m = i.depth > 0 && h.exec(l),
        k = m ? l.slice(0, m.index) : l,
        w = [];
      if (k) {
        if (!i.plainObjects && Fh.call(Object.prototype, k) && !i.allowPrototypes) return;
        w.push(k)
      }
      for (var S = 0; i.depth > 0 && (m = p.exec(l)) !== null && S < i.depth;) {
        if (S += 1, !i.plainObjects && Fh.call(Object.prototype, m[1].slice(1, -1)) && !i.allowPrototypes) return;
        w.push(m[1])
      }
      if (m) {
        if (i.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + i.depth + " and strictDepth is true");
        w.push("[" + l.slice(m.index) + "]")
      }
      return E3(w, a, i, o)
    }
  },
  L3 = function (t) {
    if (!t) return Ea;
    if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof t.decodeDotInKeys < "u" && typeof t.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (t.decoder !== null && typeof t.decoder < "u" && typeof t.decoder != "function") throw new TypeError("Decoder has to be a function.");
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var a = typeof t.charset > "u" ? Ea.charset : t.charset,
      i = typeof t.duplicates > "u" ? Ea.duplicates : t.duplicates;
    if (i !== "combine" && i !== "first" && i !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
    var o = typeof t.allowDots > "u" ? t.decodeDotInKeys === !0 ? !0 : Ea.allowDots : !!t.allowDots;
    return {
      allowDots: o,
      allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Ea.allowEmptyArrays,
      allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Ea.allowPrototypes,
      allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Ea.allowSparse,
      arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Ea.arrayLimit,
      charset: a,
      charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Ea.charsetSentinel,
      comma: typeof t.comma == "boolean" ? t.comma : Ea.comma,
      decodeDotInKeys: typeof t.decodeDotInKeys == "boolean" ? t.decodeDotInKeys : Ea.decodeDotInKeys,
      decoder: typeof t.decoder == "function" ? t.decoder : Ea.decoder,
      delimiter: typeof t.delimiter == "string" || lo.isRegExp(t.delimiter) ? t.delimiter : Ea.delimiter,
      depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : Ea.depth,
      duplicates: i,
      ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
      interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Ea.interpretNumericEntities,
      parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Ea.parameterLimit,
      parseArrays: t.parseArrays !== !1,
      plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Ea.plainObjects,
      strictDepth: typeof t.strictDepth == "boolean" ? !!t.strictDepth : Ea.strictDepth,
      strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Ea.strictNullHandling
    }
  },
  O3 = function (e, t) {
    var a = L3(t);
    if (e === "" || e === null || typeof e > "u") return a.plainObjects ? Object.create(null) : {};
    for (var i = typeof e == "string" ? T3(e, a) : e, o = a.plainObjects ? Object.create(null) : {}, l = Object.keys(i), h = 0; h < l.length; ++h) {
      var p = l[h],
        m = P3(p, i[p], a, typeof e == "string");
      o = lo.merge(o, m, a)
    }
    return a.allowSparse === !0 ? o : lo.compact(o)
  },
  M3 = k3,
  I3 = O3,
  R3 = lp,
  jm = {
    formats: R3,
    parse: I3,
    stringify: M3
  },
  D3 = {
    exports: {}
  };
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */
(function (e, t) {
  (function (a, i) {
    e.exports = i()
  })(Tr, function () {
    var a = {};
    a.version = "0.2.0";
    var i = a.settings = {
      minimum: .08,
      easing: "ease",
      positionUsing: "",
      speed: 200,
      trickle: !0,
      trickleRate: .02,
      trickleSpeed: 800,
      showSpinner: !0,
      barSelector: '[role="bar"]',
      spinnerSelector: '[role="spinner"]',
      parent: "body",
      template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'
    };
    a.configure = function (M) {
        var D, B;
        for (D in M) B = M[D], B !== void 0 && M.hasOwnProperty(D) && (i[D] = B);
        return this
      }, a.status = null, a.set = function (M) {
        var D = a.isStarted();
        M = o(M, i.minimum, 1), a.status = M === 1 ? null : M;
        var B = a.render(!D),
          z = B.querySelector(i.barSelector),
          I = i.speed,
          N = i.easing;
        return B.offsetWidth, p(function (U) {
          i.positionUsing === "" && (i.positionUsing = a.getPositioningCSS()), m(z, h(M, I, N)), M === 1 ? (m(B, {
            transition: "none",
            opacity: 1
          }), B.offsetWidth, setTimeout(function () {
            m(B, {
              transition: "all " + I + "ms linear",
              opacity: 0
            }), setTimeout(function () {
              a.remove(), U()
            }, I)
          }, I)) : setTimeout(U, I)
        }), this
      }, a.isStarted = function () {
        return typeof a.status == "number"
      }, a.start = function () {
        a.status || a.set(0);
        var M = function () {
          setTimeout(function () {
            a.status && (a.trickle(), M())
          }, i.trickleSpeed)
        };
        return i.trickle && M(), this
      }, a.done = function (M) {
        return !M && !a.status ? this : a.inc(.3 + .5 * Math.random()).set(1)
      }, a.inc = function (M) {
        var D = a.status;
        return D ? (typeof M != "number" && (M = (1 - D) * o(Math.random() * D, .1, .95)), D = o(D + M, 0, .994), a.set(D)) : a.start()
      }, a.trickle = function () {
        return a.inc(Math.random() * i.trickleRate)
      },
      function () {
        var M = 0,
          D = 0;
        a.promise = function (B) {
          return !B || B.state() === "resolved" ? this : (D === 0 && a.start(), M++, D++, B.always(function () {
            D--, D === 0 ? (M = 0, a.done()) : a.set((M - D) / M)
          }), this)
        }
      }(), a.render = function (M) {
        if (a.isRendered()) return document.getElementById("nprogress");
        w(document.documentElement, "nprogress-busy");
        var D = document.createElement("div");
        D.id = "nprogress", D.innerHTML = i.template;
        var B = D.querySelector(i.barSelector),
          z = M ? "-100" : l(a.status || 0),
          I = document.querySelector(i.parent),
          N;
        return m(B, {
          transition: "all 0 linear",
          transform: "translate3d(" + z + "%,0,0)"
        }), i.showSpinner || (N = D.querySelector(i.spinnerSelector), N && E(N)), I != document.body && w(I, "nprogress-custom-parent"), I.appendChild(D), D
      }, a.remove = function () {
        S(document.documentElement, "nprogress-busy"), S(document.querySelector(i.parent), "nprogress-custom-parent");
        var M = document.getElementById("nprogress");
        M && E(M)
      }, a.isRendered = function () {
        return !!document.getElementById("nprogress")
      }, a.getPositioningCSS = function () {
        var M = document.body.style,
          D = "WebkitTransform" in M ? "Webkit" : "MozTransform" in M ? "Moz" : "msTransform" in M ? "ms" : "OTransform" in M ? "O" : "";
        return D + "Perspective" in M ? "translate3d" : D + "Transform" in M ? "translate" : "margin"
      };

    function o(M, D, B) {
      return M < D ? D : M > B ? B : M
    }

    function l(M) {
      return (-1 + M) * 100
    }

    function h(M, D, B) {
      var z;
      return i.positionUsing === "translate3d" ? z = {
        transform: "translate3d(" + l(M) + "%,0,0)"
      } : i.positionUsing === "translate" ? z = {
        transform: "translate(" + l(M) + "%,0)"
      } : z = {
        "margin-left": l(M) + "%"
      }, z.transition = "all " + D + "ms " + B, z
    }
    var p = function () {
        var M = [];

        function D() {
          var B = M.shift();
          B && B(D)
        }
        return function (B) {
          M.push(B), M.length == 1 && D()
        }
      }(),
      m = function () {
        var M = ["Webkit", "O", "Moz", "ms"],
          D = {};

        function B(U) {
          return U.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function (W, X) {
            return X.toUpperCase()
          })
        }

        function z(U) {
          var W = document.body.style;
          if (U in W) return U;
          for (var X = M.length, V = U.charAt(0).toUpperCase() + U.slice(1), ne; X--;)
            if (ne = M[X] + V, ne in W) return ne;
          return U
        }

        function I(U) {
          return U = B(U), D[U] || (D[U] = z(U))
        }

        function N(U, W, X) {
          W = I(W), U.style[W] = X
        }
        return function (U, W) {
          var X = arguments,
            V, ne;
          if (X.length == 2)
            for (V in W) ne = W[V], ne !== void 0 && W.hasOwnProperty(V) && N(U, V, ne);
          else N(U, X[1], X[2])
        }
      }();

    function k(M, D) {
      var B = typeof M == "string" ? M : A(M);
      return B.indexOf(" " + D + " ") >= 0
    }

    function w(M, D) {
      var B = A(M),
        z = B + D;
      k(B, D) || (M.className = z.substring(1))
    }

    function S(M, D) {
      var B = A(M),
        z;
      k(M, D) && (z = B.replace(" " + D + " ", " "), M.className = z.substring(1, z.length - 1))
    }

    function A(M) {
      return (" " + (M.className || "") + " ").replace(/\s+/gi, " ")
    }

    function E(M) {
      M && M.parentNode && M.parentNode.removeChild(M)
    }
    return a
  })
})(D3);

function N3(e, t) {
  let a;
  return function (...i) {
    clearTimeout(a), a = setTimeout(() => e.apply(this, i), t)
  }
}

function Qn(e, t) {
  return document.dispatchEvent(new CustomEvent(`inertia:${e}`, t))
}
var F3 = e => Qn("before", {
    cancelable: !0,
    detail: {
      visit: e
    }
  }),
  $3 = e => Qn("error", {
    detail: {
      errors: e
    }
  }),
  B3 = e => Qn("exception", {
    cancelable: !0,
    detail: {
      exception: e
    }
  }),
  Um = e => Qn("finish", {
    detail: {
      visit: e
    }
  }),
  H3 = e => Qn("invalid", {
    cancelable: !0,
    detail: {
      response: e
    }
  }),
  Fo = e => Qn("navigate", {
    detail: {
      page: e
    }
  }),
  Y3 = e => Qn("progress", {
    detail: {
      progress: e
    }
  }),
  z3 = e => Qn("start", {
    detail: {
      visit: e
    }
  }),
  X3 = e => Qn("success", {
    detail: {
      page: e
    }
  });

function $h(e) {
  return e instanceof File || e instanceof Blob || e instanceof FileList && e.length > 0 || e instanceof FormData && Array.from(e.values()).some(t => $h(t)) || typeof e == "object" && e !== null && Object.values(e).some(t => $h(t))
}

function Hx(e, t = new FormData, a = null) {
  e = e || {};
  for (let i in e) Object.prototype.hasOwnProperty.call(e, i) && zx(t, Yx(a, i), e[i]);
  return t
}

function Yx(e, t) {
  return e ? e + "[" + t + "]" : t
}

function zx(e, t, a) {
  if (Array.isArray(a)) return Array.from(a.keys()).forEach(i => zx(e, Yx(t, i.toString()), a[i]));
  if (a instanceof Date) return e.append(t, a.toISOString());
  if (a instanceof File) return e.append(t, a, a.name);
  if (a instanceof Blob) return e.append(t, a);
  if (typeof a == "boolean") return e.append(t, a ? "1" : "0");
  if (typeof a == "string") return e.append(t, a);
  if (typeof a == "number") return e.append(t, `${a}`);
  if (a == null) return e.append(t, "");
  Hx(a, e, t)
}
var W3 = {
  modal: null,
  listener: null,
  show(e) {
    typeof e == "object" && (e = `All Inertia requests must receive a valid Inertia response, however a plain JSON response was received.<hr>${JSON.stringify(e)}`);
    let t = document.createElement("html");
    t.innerHTML = e, t.querySelectorAll("a").forEach(i => i.setAttribute("target", "_top")), this.modal = document.createElement("div"), this.modal.style.position = "fixed", this.modal.style.width = "100vw", this.modal.style.height = "100vh", this.modal.style.padding = "50px", this.modal.style.boxSizing = "border-box", this.modal.style.backgroundColor = "rgba(0, 0, 0, .6)", this.modal.style.zIndex = 2e5, this.modal.addEventListener("click", () => this.hide());
    let a = document.createElement("iframe");
    if (a.style.backgroundColor = "white", a.style.borderRadius = "5px", a.style.width = "100%", a.style.height = "100%", this.modal.appendChild(a), document.body.prepend(this.modal), document.body.style.overflow = "hidden", !a.contentWindow) throw new Error("iframe not yet ready.");
    a.contentWindow.document.open(), a.contentWindow.document.write(t.outerHTML), a.contentWindow.document.close(), this.listener = this.hideOnEscape.bind(this), document.addEventListener("keydown", this.listener)
  },
  hide() {
    this.modal.outerHTML = "", this.modal = null, document.body.style.overflow = "visible", document.removeEventListener("keydown", this.listener)
  },
  hideOnEscape(e) {
    e.keyCode === 27 && this.hide()
  }
};

function Is(e) {
  return new URL(e.toString(), window.location.toString())
}

function Xx(e, t, a, i = "brackets") {
  let o = /^https?:\/\//.test(t.toString()),
    l = o || t.toString().startsWith("/"),
    h = !l && !t.toString().startsWith("#") && !t.toString().startsWith("?"),
    p = t.toString().includes("?") || e === "get" && Object.keys(a).length,
    m = t.toString().includes("#"),
    k = new URL(t.toString(), "http://localhost");
  return e === "get" && Object.keys(a).length && (k.search = jm.stringify(vI(jm.parse(k.search, {
    ignoreQueryPrefix: !0
  }), a), {
    encodeValuesOnly: !0,
    arrayFormat: i
  }), a = {}), [
    [o ? `${k.protocol}//${k.host}` : "", l ? k.pathname : "", h ? k.pathname.substring(1) : "", p ? k.search : "", m ? k.hash : ""].join(""), a
  ]
}

function $o(e) {
  return e = new URL(e.href), e.hash = "", e
}
var Gm = typeof window > "u",
  V3 = class {
    constructor() {
      this.visitId = null
    }
    init({
      initialPage: e,
      resolveComponent: t,
      swapComponent: a
    }) {
      this.page = e, this.resolveComponent = t, this.swapComponent = a, this.setNavigationType(), this.clearRememberedStateOnReload(), this.isBackForwardVisit() ? this.handleBackForwardVisit(this.page) : this.isLocationVisit() ? this.handleLocationVisit(this.page) : this.handleInitialPageVisit(this.page), this.setupEventListeners()
    }
    setNavigationType() {
      this.navigationType = window.performance && window.performance.getEntriesByType("navigation").length > 0 ? window.performance.getEntriesByType("navigation")[0].type : "navigate"
    }
    clearRememberedStateOnReload() {
      var e;
      this.navigationType === "reload" && ((e = window.history.state) != null && e.rememberedState) && delete window.history.state.rememberedState
    }
    handleInitialPageVisit(e) {
      this.page.url += window.location.hash, this.setPage(e, {
        preserveState: !0
      }).then(() => Fo(e))
    }
    setupEventListeners() {
      window.addEventListener("popstate", this.handlePopstateEvent.bind(this)), document.addEventListener("scroll", N3(this.handleScrollEvent.bind(this), 100), !0)
    }
    scrollRegions() {
      return document.querySelectorAll("[scroll-region]")
    }
    handleScrollEvent(e) {
      typeof e.target.hasAttribute == "function" && e.target.hasAttribute("scroll-region") && this.saveScrollPositions()
    }
    saveScrollPositions() {
      this.replaceState({
        ...this.page,
        scrollRegions: Array.from(this.scrollRegions()).map(e => ({
          top: e.scrollTop,
          left: e.scrollLeft
        }))
      })
    }
    resetScrollPositions() {
      window.scrollTo(0, 0), this.scrollRegions().forEach(e => {
        typeof e.scrollTo == "function" ? e.scrollTo(0, 0) : (e.scrollTop = 0, e.scrollLeft = 0)
      }), this.saveScrollPositions(), window.location.hash && setTimeout(() => {
        var e;
        return (e = document.getElementById(window.location.hash.slice(1))) == null ? void 0 : e.scrollIntoView()
      })
    }
    restoreScrollPositions() {
      this.page.scrollRegions && this.scrollRegions().forEach((e, t) => {
        let a = this.page.scrollRegions[t];
        if (a) typeof e.scrollTo == "function" ? e.scrollTo(a.left, a.top) : (e.scrollTop = a.top, e.scrollLeft = a.left);
        else return
      })
    }
    isBackForwardVisit() {
      return window.history.state && this.navigationType === "back_forward"
    }
    handleBackForwardVisit(e) {
      window.history.state.version = e.version, this.setPage(window.history.state, {
        preserveScroll: !0,
        preserveState: !0
      }).then(() => {
        this.restoreScrollPositions(), Fo(e)
      })
    }
    locationVisit(e, t) {
      try {
        let a = {
          preserveScroll: t
        };
        window.sessionStorage.setItem("inertiaLocationVisit", JSON.stringify(a)), window.location.href = e.href, $o(window.location).href === $o(e).href && window.location.reload()
      } catch {
        return !1
      }
    }
    isLocationVisit() {
      try {
        return window.sessionStorage.getItem("inertiaLocationVisit") !== null
      } catch {
        return !1
      }
    }
    handleLocationVisit(e) {
      var a, i;
      let t = JSON.parse(window.sessionStorage.getItem("inertiaLocationVisit") || "");
      window.sessionStorage.removeItem("inertiaLocationVisit"), e.url += window.location.hash, e.rememberedState = ((a = window.history.state) == null ? void 0 : a.rememberedState) ?? {}, e.scrollRegions = ((i = window.history.state) == null ? void 0 : i.scrollRegions) ?? [], this.setPage(e, {
        preserveScroll: t.preserveScroll,
        preserveState: !0
      }).then(() => {
        t.preserveScroll && this.restoreScrollPositions(), Fo(e)
      })
    }
    isLocationVisitResponse(e) {
      return !!(e && e.status === 409 && e.headers["x-inertia-location"])
    }
    isInertiaResponse(e) {
      return !!(e != null && e.headers["x-inertia"])
    }
    createVisitId() {
      return this.visitId = {}, this.visitId
    }
    cancelVisit(e, {
      cancelled: t = !1,
      interrupted: a = !1
    }) {
      e && !e.completed && !e.cancelled && !e.interrupted && (e.cancelToken.abort(), e.onCancel(), e.completed = !1, e.cancelled = t, e.interrupted = a, Um(e), e.onFinish(e))
    }
    finishVisit(e) {
      !e.cancelled && !e.interrupted && (e.completed = !0, e.cancelled = !1, e.interrupted = !1, Um(e), e.onFinish(e))
    }
    resolvePreserveOption(e, t) {
      return typeof e == "function" ? e(t) : e === "errors" ? Object.keys(t.props.errors || {}).length > 0 : e
    }
    cancel() {
      this.activeVisit && this.cancelVisit(this.activeVisit, {
        cancelled: !0
      })
    }
    visit(e, {
      method: t = "get",
      data: a = {},
      replace: i = !1,
      preserveScroll: o = !1,
      preserveState: l = !1,
      only: h = [],
      except: p = [],
      headers: m = {},
      errorBag: k = "",
      forceFormData: w = !1,
      onCancelToken: S = () => {},
      onBefore: A = () => {},
      onStart: E = () => {},
      onProgress: M = () => {},
      onFinish: D = () => {},
      onCancel: B = () => {},
      onSuccess: z = () => {},
      onError: I = () => {},
      queryStringArrayFormat: N = "brackets"
    } = {}) {
      let U = typeof e == "string" ? Is(e) : e;
      if (($h(a) || w) && !(a instanceof FormData) && (a = Hx(a)), !(a instanceof FormData)) {
        let [ne, Z] = Xx(t, U, a, N);
        U = Is(ne), a = Z
      }
      let W = {
        url: U,
        method: t,
        data: a,
        replace: i,
        preserveScroll: o,
        preserveState: l,
        only: h,
        except: p,
        headers: m,
        errorBag: k,
        forceFormData: w,
        queryStringArrayFormat: N,
        cancelled: !1,
        completed: !1,
        interrupted: !1
      };
      if (A(W) === !1 || !F3(W)) return;
      this.activeVisit && this.cancelVisit(this.activeVisit, {
        interrupted: !0
      }), this.saveScrollPositions();
      let X = this.createVisitId();
      this.activeVisit = {
        ...W,
        onCancelToken: S,
        onBefore: A,
        onStart: E,
        onProgress: M,
        onFinish: D,
        onCancel: B,
        onSuccess: z,
        onError: I,
        queryStringArrayFormat: N,
        cancelToken: new AbortController
      }, S({
        cancel: () => {
          this.activeVisit && this.cancelVisit(this.activeVisit, {
            cancelled: !0
          })
        }
      }), z3(W), E(W);
      let V = !!(h.length || p.length);
      Qt({
        method: t,
        url: $o(U).href,
        data: t === "get" ? {} : a,
        params: t === "get" ? a : {},
        signal: this.activeVisit.cancelToken.signal,
        headers: {
          ...m,
          Accept: "text/html, application/xhtml+xml",
          "X-Requested-With": "XMLHttpRequest",
          "X-Inertia": !0,
          ...V ? {
            "X-Inertia-Partial-Component": this.page.component
          } : {},
          ...h.length ? {
            "X-Inertia-Partial-Data": h.join(",")
          } : {},
          ...p.length ? {
            "X-Inertia-Partial-Except": p.join(",")
          } : {},
          ...k && k.length ? {
            "X-Inertia-Error-Bag": k
          } : {},
          ...this.page.version ? {
            "X-Inertia-Version": this.page.version
          } : {}
        },
        onUploadProgress: ne => {
          a instanceof FormData && (ne.percentage = ne.progress ? Math.round(ne.progress * 100) : 0, Y3(ne), M(ne))
        }
      }).then(ne => {
        var le;
        if (!this.isInertiaResponse(ne)) return Promise.reject({
          response: ne
        });
        let Z = ne.data;
        V && Z.component === this.page.component && (Z.props = {
          ...this.page.props,
          ...Z.props
        }), o = this.resolvePreserveOption(o, Z), l = this.resolvePreserveOption(l, Z), l && ((le = window.history.state) != null && le.rememberedState) && Z.component === this.page.component && (Z.rememberedState = window.history.state.rememberedState);
        let ie = U,
          fe = Is(Z.url);
        return ie.hash && !fe.hash && $o(ie).href === fe.href && (fe.hash = ie.hash, Z.url = fe.href), this.setPage(Z, {
          visitId: X,
          replace: i,
          preserveScroll: o,
          preserveState: l
        })
      }).then(() => {
        let ne = this.page.props.errors || {};
        if (Object.keys(ne).length > 0) {
          let Z = k ? ne[k] ? ne[k] : {} : ne;
          return $3(Z), I(Z)
        }
        return X3(this.page), z(this.page)
      }).catch(ne => {
        if (this.isInertiaResponse(ne.response)) return this.setPage(ne.response.data, {
          visitId: X
        });
        if (this.isLocationVisitResponse(ne.response)) {
          let Z = Is(ne.response.headers["x-inertia-location"]),
            ie = U;
          ie.hash && !Z.hash && $o(ie).href === Z.href && (Z.hash = ie.hash), this.locationVisit(Z, o === !0)
        } else if (ne.response) H3(ne.response) && W3.show(ne.response.data);
        else return Promise.reject(ne)
      }).then(() => {
        this.activeVisit && this.finishVisit(this.activeVisit)
      }).catch(ne => {
        if (!Qt.isCancel(ne)) {
          let Z = B3(ne);
          if (this.activeVisit && this.finishVisit(this.activeVisit), Z) return Promise.reject(ne)
        }
      })
    }
    setPage(e, {
      visitId: t = this.createVisitId(),
      replace: a = !1,
      preserveScroll: i = !1,
      preserveState: o = !1
    } = {}) {
      return Promise.resolve(this.resolveComponent(e.component)).then(l => {
        t === this.visitId && (e.scrollRegions = e.scrollRegions || [], e.rememberedState = e.rememberedState || {}, a = a || Is(e.url).href === window.location.href, a ? this.replaceState(e) : this.pushState(e), this.swapComponent({
          component: l,
          page: e,
          preserveState: o
        }).then(() => {
          i || this.resetScrollPositions(), a || Fo(e)
        }))
      })
    }
    pushState(e) {
      this.page = e, window.history.pushState(e, "", e.url)
    }
    replaceState(e) {
      this.page = e, window.history.replaceState(e, "", e.url)
    }
    handlePopstateEvent(e) {
      if (e.state !== null) {
        let t = e.state,
          a = this.createVisitId();
        Promise.resolve(this.resolveComponent(t.component)).then(i => {
          a === this.visitId && (this.page = t, this.swapComponent({
            component: i,
            page: t,
            preserveState: !1
          }).then(() => {
            this.restoreScrollPositions(), Fo(t)
          }))
        })
      } else {
        let t = Is(this.page.url);
        t.hash = window.location.hash, this.replaceState({
          ...this.page,
          url: t.href
        }), this.resetScrollPositions()
      }
    }
    get(e, t = {}, a = {}) {
      return this.visit(e, {
        ...a,
        method: "get",
        data: t
      })
    }
    reload(e = {}) {
      return this.visit(window.location.href, {
        ...e,
        preserveScroll: !0,
        preserveState: !0
      })
    }
    replace(e, t = {}) {
      return console.warn(`Inertia.replace() has been deprecated and will be removed in a future release. Please use Inertia.${t.method??"get"}() instead.`), this.visit(e, {
        preserveState: !0,
        ...t,
        replace: !0
      })
    }
    post(e, t = {}, a = {}) {
      return this.visit(e, {
        preserveState: !0,
        ...a,
        method: "post",
        data: t
      })
    }
    put(e, t = {}, a = {}) {
      return this.visit(e, {
        preserveState: !0,
        ...a,
        method: "put",
        data: t
      })
    }
    patch(e, t = {}, a = {}) {
      return this.visit(e, {
        preserveState: !0,
        ...a,
        method: "patch",
        data: t
      })
    }
    delete(e, t = {}) {
      return this.visit(e, {
        preserveState: !0,
        ...t,
        method: "delete"
      })
    }
    remember(e, t = "default") {
      var a;
      Gm || this.replaceState({
        ...this.page,
        rememberedState: {
          ...(a = this.page) == null ? void 0 : a.rememberedState,
          [t]: e
        }
      })
    }
    restore(e = "default") {
      var t, a;
      if (!Gm) return (a = (t = window.history.state) == null ? void 0 : t.rememberedState) == null ? void 0 : a[e]
    }
    on(e, t) {
      let a = i => {
        let o = t(i);
        i.cancelable && !i.defaultPrevented && o === !1 && i.preventDefault()
      };
      return document.addEventListener(`inertia:${e}`, a), () => document.removeEventListener(`inertia:${e}`, a)
    }
  };

function j3(e) {
  let t = e.currentTarget.tagName.toLowerCase() === "a";
  return !(e.target && (e == null ? void 0 : e.target).isContentEditable || e.defaultPrevented || t && e.which > 1 || t && e.altKey || t && e.ctrlKey || t && e.metaKey || t && e.shiftKey)
}
var Wo = new V3,
  Xc = {
    exports: {}
  };
Xc.exports;
(function (e, t) {
  var a = 200,
    i = "__lodash_hash_undefined__",
    o = 9007199254740991,
    l = "[object Arguments]",
    h = "[object Array]",
    p = "[object Boolean]",
    m = "[object Date]",
    k = "[object Error]",
    w = "[object Function]",
    S = "[object GeneratorFunction]",
    A = "[object Map]",
    E = "[object Number]",
    M = "[object Object]",
    D = "[object Promise]",
    B = "[object RegExp]",
    z = "[object Set]",
    I = "[object String]",
    N = "[object Symbol]",
    U = "[object WeakMap]",
    W = "[object ArrayBuffer]",
    X = "[object DataView]",
    V = "[object Float32Array]",
    ne = "[object Float64Array]",
    Z = "[object Int8Array]",
    ie = "[object Int16Array]",
    fe = "[object Int32Array]",
    le = "[object Uint8Array]",
    Ee = "[object Uint8ClampedArray]",
    ye = "[object Uint16Array]",
    ve = "[object Uint32Array]",
    me = /[\\^$.*+?()[\]{}|]/g,
    Ae = /\w*$/,
    He = /^\[object .+?Constructor\]$/,
    De = /^(?:0|[1-9]\d*)$/,
    Ye = {};
  Ye[l] = Ye[h] = Ye[W] = Ye[X] = Ye[p] = Ye[m] = Ye[V] = Ye[ne] = Ye[Z] = Ye[ie] = Ye[fe] = Ye[A] = Ye[E] = Ye[M] = Ye[B] = Ye[z] = Ye[I] = Ye[N] = Ye[le] = Ye[Ee] = Ye[ye] = Ye[ve] = !0, Ye[k] = Ye[w] = Ye[U] = !1;
  var Je = typeof Tr == "object" && Tr && Tr.Object === Object && Tr,
    he = typeof self == "object" && self && self.Object === Object && self,
    ke = Je || he || Function("return this")(),
    re = t && !t.nodeType && t,
    Se = re && !0 && e && !e.nodeType && e,
    Be = Se && Se.exports === re;

  function J(R, te) {
    return R.set(te[0], te[1]), R
  }

  function Re(R, te) {
    return R.add(te), R
  }

  function Xe(R, te) {
    for (var we = -1, Ge = R ? R.length : 0; ++we < Ge && te(R[we], we, R) !== !1;);
    return R
  }

  function nt(R, te) {
    for (var we = -1, Ge = te.length, Mt = R.length; ++we < Ge;) R[Mt + we] = te[we];
    return R
  }

  function Pe(R, te, we, Ge) {
    for (var Mt = -1, xt = R ? R.length : 0; ++Mt < xt;) we = te(we, R[Mt], Mt, R);
    return we
  }

  function We(R, te) {
    for (var we = -1, Ge = Array(R); ++we < R;) Ge[we] = te(we);
    return Ge
  }

  function F(R, te) {
    return R == null ? void 0 : R[te]
  }

  function j(R) {
    var te = !1;
    if (R != null && typeof R.toString != "function") try {
      te = !!(R + "")
    } catch {}
    return te
  }

  function oe(R) {
    var te = -1,
      we = Array(R.size);
    return R.forEach(function (Ge, Mt) {
      we[++te] = [Mt, Ge]
    }), we
  }

  function de(R, te) {
    return function (we) {
      return R(te(we))
    }
  }

  function Ie(R) {
    var te = -1,
      we = Array(R.size);
    return R.forEach(function (Ge) {
      we[++te] = Ge
    }), we
  }
  var ue = Array.prototype,
    Le = Function.prototype,
    K = Object.prototype,
    ae = ke["__core-js_shared__"],
    xe = function () {
      var R = /[^.]+$/.exec(ae && ae.keys && ae.keys.IE_PROTO || "");
      return R ? "Symbol(src)_1." + R : ""
    }(),
    Ce = Le.toString,
    tt = K.hasOwnProperty,
    qe = K.toString,
    Te = RegExp("^" + Ce.call(tt).replace(me, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
    $e = Be ? ke.Buffer : void 0,
    ft = ke.Symbol,
    gt = ke.Uint8Array,
    Ct = de(Object.getPrototypeOf, Object),
    ia = Object.create,
    xa = K.propertyIsEnumerable,
    yr = ue.splice,
    qa = Object.getOwnPropertySymbols,
    xr = $e ? $e.isBuffer : void 0,
    wa = de(Object.keys, Object),
    Me = it(ke, "DataView"),
    rt = it(ke, "Map"),
    ze = it(ke, "Promise"),
    et = it(ke, "Set"),
    ct = it(ke, "WeakMap"),
    ca = it(Object, "create"),
    Oa = ma(Me),
    nr = ma(rt),
    zr = ma(ze),
    Lr = ma(et),
    lr = ma(ct),
    Or = ft ? ft.prototype : void 0,
    Jn = Or ? Or.valueOf : void 0;

  function tn(R) {
    var te = -1,
      we = R ? R.length : 0;
    for (this.clear(); ++te < we;) {
      var Ge = R[te];
      this.set(Ge[0], Ge[1])
    }
  }

  function wo() {
    this.__data__ = ca ? ca(null) : {}
  }

  function zi(R) {
    return this.has(R) && delete this.__data__[R]
  }

  function ws(R) {
    var te = this.__data__;
    if (ca) {
      var we = te[R];
      return we === i ? void 0 : we
    }
    return tt.call(te, R) ? te[R] : void 0
  }

  function ei(R) {
    var te = this.__data__;
    return ca ? te[R] !== void 0 : tt.call(te, R)
  }

  function Dn(R, te) {
    var we = this.__data__;
    return we[R] = ca && te === void 0 ? i : te, this
  }
  tn.prototype.clear = wo, tn.prototype.delete = zi, tn.prototype.get = ws, tn.prototype.has = ei, tn.prototype.set = Dn;

  function ga(R) {
    var te = -1,
      we = R ? R.length : 0;
    for (this.clear(); ++te < we;) {
      var Ge = R[te];
      this.set(Ge[0], Ge[1])
    }
  }

  function ti() {
    this.__data__ = []
  }

  function ko(R) {
    var te = this.__data__,
      we = b(te, R);
    if (we < 0) return !1;
    var Ge = te.length - 1;
    return we == Ge ? te.pop() : yr.call(te, we, 1), !0
  }

  function _o(R) {
    var te = this.__data__,
      we = b(te, R);
    return we < 0 ? void 0 : te[we][1]
  }

  function So(R) {
    return b(this.__data__, R) > -1
  }

  function Ao(R, te) {
    var we = this.__data__,
      Ge = b(we, R);
    return Ge < 0 ? we.push([R, te]) : we[Ge][1] = te, this
  }
  ga.prototype.clear = ti, ga.prototype.delete = ko, ga.prototype.get = _o, ga.prototype.has = So, ga.prototype.set = Ao;

  function Ka(R) {
    var te = -1,
      we = R ? R.length : 0;
    for (this.clear(); ++te < we;) {
      var Ge = R[te];
      this.set(Ge[0], Ge[1])
    }
  }

  function ks() {
    this.__data__ = {
      hash: new tn,
      map: new(rt || ga),
      string: new tn
    }
  }

  function _s(R) {
    return Ve(this, R).delete(R)
  }

  function Xi(R) {
    return Ve(this, R).get(R)
  }

  function Co(R) {
    return Ve(this, R).has(R)
  }

  function Y(R, te) {
    return Ve(this, R).set(R, te), this
  }
  Ka.prototype.clear = ks, Ka.prototype.delete = _s, Ka.prototype.get = Xi, Ka.prototype.has = Co, Ka.prototype.set = Y;

  function r(R) {
    this.__data__ = new ga(R)
  }

  function n() {
    this.__data__ = new ga
  }

  function s(R) {
    return this.__data__.delete(R)
  }

  function c(R) {
    return this.__data__.get(R)
  }

  function u(R) {
    return this.__data__.has(R)
  }

  function d(R, te) {
    var we = this.__data__;
    if (we instanceof ga) {
      var Ge = we.__data__;
      if (!rt || Ge.length < a - 1) return Ge.push([R, te]), this;
      we = this.__data__ = new Ka(Ge)
    }
    return we.set(R, te), this
  }
  r.prototype.clear = n, r.prototype.delete = s, r.prototype.get = c, r.prototype.has = u, r.prototype.set = d;

  function f(R, te) {
    var we = ai(R) || Sa(R) ? We(R.length, String) : [],
      Ge = we.length,
      Mt = !!Ge;
    for (var xt in R) tt.call(R, xt) && !(Mt && (xt == "length" || qt(xt, Ge))) && we.push(xt);
    return we
  }

  function g(R, te, we) {
    var Ge = R[te];
    (!(tt.call(R, te) && Ta(Ge, we)) || we === void 0 && !(te in R)) && (R[te] = we)
  }

  function b(R, te) {
    for (var we = R.length; we--;)
      if (Ta(R[we][0], te)) return we;
    return -1
  }

  function y(R, te) {
    return R && pe(te, Eo(te), R)
  }

  function x(R, te, we, Ge, Mt, xt, Kt) {
    var Ut;
    if (Ge && (Ut = xt ? Ge(R, Mt, xt, Kt) : Ge(R)), Ut !== void 0) return Ut;
    if (!yn(R)) return R;
    var $a = ai(R);
    if ($a) {
      if (Ut = At(R), !te) return ge(R, Ut)
    } else {
      var ta = mt(R),
        cr = ta == w || ta == S;
      if (Bl(R)) return G(R, te);
      if (ta == M || ta == l || cr && !xt) {
        if (j(R)) return xt ? R : {};
        if (Ut = _t(cr ? {} : R), !te) return Fe(R, y(Ut, R))
      } else {
        if (!Ye[ta]) return xt ? R : {};
        Ut = Et(R, ta, x, te)
      }
    }
    Kt || (Kt = new r);
    var Ir = Kt.get(R);
    if (Ir) return Ir;
    if (Kt.set(R, Ut), !$a) var za = we ? Ue(R) : Eo(R);
    return Xe(za || R, function (ur, ir) {
      za && (ir = ur, ur = R[ir]), g(Ut, ir, x(ur, te, we, Ge, ir, R, Kt))
    }), Ut
  }

  function _(R) {
    return yn(R) ? ia(R) : {}
  }

  function T(R, te, we) {
    var Ge = te(R);
    return ai(R) ? Ge : nt(Ge, we(R))
  }

  function P(R) {
    return qe.call(R)
  }

  function O(R) {
    if (!yn(R) || wr(R)) return !1;
    var te = To(R) || j(R) ? Te : He;
    return te.test(ma(R))
  }

  function $(R) {
    if (!Ya(R)) return wa(R);
    var te = [];
    for (var we in Object(R)) tt.call(R, we) && we != "constructor" && te.push(we);
    return te
  }

  function G(R, te) {
    if (te) return R.slice();
    var we = new R.constructor(R.length);
    return R.copy(we), we
  }

  function Q(R) {
    var te = new R.constructor(R.byteLength);
    return new gt(te).set(new gt(R)), te
  }

  function v(R, te) {
    var we = te ? Q(R.buffer) : R.buffer;
    return new R.constructor(we, R.byteOffset, R.byteLength)
  }

  function C(R, te, we) {
    var Ge = te ? we(oe(R), !0) : oe(R);
    return Pe(Ge, J, new R.constructor)
  }

  function L(R) {
    var te = new R.constructor(R.source, Ae.exec(R));
    return te.lastIndex = R.lastIndex, te
  }

  function H(R, te, we) {
    var Ge = te ? we(Ie(R), !0) : Ie(R);
    return Pe(Ge, Re, new R.constructor)
  }

  function q(R) {
    return Jn ? Object(Jn.call(R)) : {}
  }

  function ee(R, te) {
    var we = te ? Q(R.buffer) : R.buffer;
    return new R.constructor(we, R.byteOffset, R.length)
  }

  function ge(R, te) {
    var we = -1,
      Ge = R.length;
    for (te || (te = Array(Ge)); ++we < Ge;) te[we] = R[we];
    return te
  }

  function pe(R, te, we, Ge) {
    we || (we = {});
    for (var Mt = -1, xt = te.length; ++Mt < xt;) {
      var Kt = te[Mt],
        Ut = void 0;
      g(we, Kt, Ut === void 0 ? R[Kt] : Ut)
    }
    return we
  }

  function Fe(R, te) {
    return pe(R, dt(R), te)
  }

  function Ue(R) {
    return T(R, Eo, dt)
  }

  function Ve(R, te) {
    var we = R.__data__;
    return sa(te) ? we[typeof te == "string" ? "string" : "hash"] : we.map
  }

  function it(R, te) {
    var we = F(R, te);
    return O(we) ? we : void 0
  }
  var dt = qa ? de(qa, Object) : $u,
    mt = P;
  (Me && mt(new Me(new ArrayBuffer(1))) != X || rt && mt(new rt) != A || ze && mt(ze.resolve()) != D || et && mt(new et) != z || ct && mt(new ct) != U) && (mt = function (R) {
    var te = qe.call(R),
      we = te == M ? R.constructor : void 0,
      Ge = we ? ma(we) : void 0;
    if (Ge) switch (Ge) {
      case Oa:
        return X;
      case nr:
        return A;
      case zr:
        return D;
      case Lr:
        return z;
      case lr:
        return U
    }
    return te
  });

  function At(R) {
    var te = R.length,
      we = R.constructor(te);
    return te && typeof R[0] == "string" && tt.call(R, "index") && (we.index = R.index, we.input = R.input), we
  }

  function _t(R) {
    return typeof R.constructor == "function" && !Ya(R) ? _(Ct(R)) : {}
  }

  function Et(R, te, we, Ge) {
    var Mt = R.constructor;
    switch (te) {
      case W:
        return Q(R);
      case p:
      case m:
        return new Mt(+R);
      case X:
        return v(R, Ge);
      case V:
      case ne:
      case Z:
      case ie:
      case fe:
      case le:
      case Ee:
      case ye:
      case ve:
        return ee(R, Ge);
      case A:
        return C(R, Ge, we);
      case E:
      case I:
        return new Mt(R);
      case B:
        return L(R);
      case z:
        return H(R, Ge, we);
      case N:
        return q(R)
    }
  }

  function qt(R, te) {
    return te = te ?? o, !!te && (typeof R == "number" || De.test(R)) && R > -1 && R % 1 == 0 && R < te
  }

  function sa(R) {
    var te = typeof R;
    return te == "string" || te == "number" || te == "symbol" || te == "boolean" ? R !== "__proto__" : R === null
  }

  function wr(R) {
    return !!xe && xe in R
  }

  function Ya(R) {
    var te = R && R.constructor,
      we = typeof te == "function" && te.prototype || K;
    return R === we
  }

  function ma(R) {
    if (R != null) {
      try {
        return Ce.call(R)
      } catch {}
      try {
        return R + ""
      } catch {}
    }
    return ""
  }

  function Mr(R) {
    return x(R, !0, !0)
  }

  function Ta(R, te) {
    return R === te || R !== R && te !== te
  }

  function Sa(R) {
    return Fu(R) && tt.call(R, "callee") && (!xa.call(R, "callee") || qe.call(R) == l)
  }
  var ai = Array.isArray;

  function Ss(R) {
    return R != null && Hl(R.length) && !To(R)
  }

  function Fu(R) {
    return Yl(R) && Ss(R)
  }
  var Bl = xr || Bu;

  function To(R) {
    var te = yn(R) ? qe.call(R) : "";
    return te == w || te == S
  }

  function Hl(R) {
    return typeof R == "number" && R > -1 && R % 1 == 0 && R <= o
  }

  function yn(R) {
    var te = typeof R;
    return !!R && (te == "object" || te == "function")
  }

  function Yl(R) {
    return !!R && typeof R == "object"
  }

  function Eo(R) {
    return Ss(R) ? f(R) : $(R)
  }

  function $u() {
    return []
  }

  function Bu() {
    return !1
  }
  e.exports = Mr
})(Xc, Xc.exports);
var U3 = Xc.exports;
const Bn = Tu(U3);
var Wc = {
  exports: {}
};
Wc.exports;
(function (e, t) {
  var a = 200,
    i = "__lodash_hash_undefined__",
    o = 1,
    l = 2,
    h = 9007199254740991,
    p = "[object Arguments]",
    m = "[object Array]",
    k = "[object AsyncFunction]",
    w = "[object Boolean]",
    S = "[object Date]",
    A = "[object Error]",
    E = "[object Function]",
    M = "[object GeneratorFunction]",
    D = "[object Map]",
    B = "[object Number]",
    z = "[object Null]",
    I = "[object Object]",
    N = "[object Promise]",
    U = "[object Proxy]",
    W = "[object RegExp]",
    X = "[object Set]",
    V = "[object String]",
    ne = "[object Symbol]",
    Z = "[object Undefined]",
    ie = "[object WeakMap]",
    fe = "[object ArrayBuffer]",
    le = "[object DataView]",
    Ee = "[object Float32Array]",
    ye = "[object Float64Array]",
    ve = "[object Int8Array]",
    me = "[object Int16Array]",
    Ae = "[object Int32Array]",
    He = "[object Uint8Array]",
    De = "[object Uint8ClampedArray]",
    Ye = "[object Uint16Array]",
    Je = "[object Uint32Array]",
    he = /[\\^$.*+?()[\]{}|]/g,
    ke = /^\[object .+?Constructor\]$/,
    re = /^(?:0|[1-9]\d*)$/,
    Se = {};
  Se[Ee] = Se[ye] = Se[ve] = Se[me] = Se[Ae] = Se[He] = Se[De] = Se[Ye] = Se[Je] = !0, Se[p] = Se[m] = Se[fe] = Se[w] = Se[le] = Se[S] = Se[A] = Se[E] = Se[D] = Se[B] = Se[I] = Se[W] = Se[X] = Se[V] = Se[ie] = !1;
  var Be = typeof Tr == "object" && Tr && Tr.Object === Object && Tr,
    J = typeof self == "object" && self && self.Object === Object && self,
    Re = Be || J || Function("return this")(),
    Xe = t && !t.nodeType && t,
    nt = Xe && !0 && e && !e.nodeType && e,
    Pe = nt && nt.exports === Xe,
    We = Pe && Be.process,
    F = function () {
      try {
        return We && We.binding && We.binding("util")
      } catch {}
    }(),
    j = F && F.isTypedArray;

  function oe(R, te) {
    for (var we = -1, Ge = R == null ? 0 : R.length, Mt = 0, xt = []; ++we < Ge;) {
      var Kt = R[we];
      te(Kt, we, R) && (xt[Mt++] = Kt)
    }
    return xt
  }

  function de(R, te) {
    for (var we = -1, Ge = te.length, Mt = R.length; ++we < Ge;) R[Mt + we] = te[we];
    return R
  }

  function Ie(R, te) {
    for (var we = -1, Ge = R == null ? 0 : R.length; ++we < Ge;)
      if (te(R[we], we, R)) return !0;
    return !1
  }

  function ue(R, te) {
    for (var we = -1, Ge = Array(R); ++we < R;) Ge[we] = te(we);
    return Ge
  }

  function Le(R) {
    return function (te) {
      return R(te)
    }
  }

  function K(R, te) {
    return R.has(te)
  }

  function ae(R, te) {
    return R == null ? void 0 : R[te]
  }

  function xe(R) {
    var te = -1,
      we = Array(R.size);
    return R.forEach(function (Ge, Mt) {
      we[++te] = [Mt, Ge]
    }), we
  }

  function Ce(R, te) {
    return function (we) {
      return R(te(we))
    }
  }

  function tt(R) {
    var te = -1,
      we = Array(R.size);
    return R.forEach(function (Ge) {
      we[++te] = Ge
    }), we
  }
  var qe = Array.prototype,
    Te = Function.prototype,
    $e = Object.prototype,
    ft = Re["__core-js_shared__"],
    gt = Te.toString,
    Ct = $e.hasOwnProperty,
    ia = function () {
      var R = /[^.]+$/.exec(ft && ft.keys && ft.keys.IE_PROTO || "");
      return R ? "Symbol(src)_1." + R : ""
    }(),
    xa = $e.toString,
    yr = RegExp("^" + gt.call(Ct).replace(he, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
    qa = Pe ? Re.Buffer : void 0,
    xr = Re.Symbol,
    wa = Re.Uint8Array,
    Me = $e.propertyIsEnumerable,
    rt = qe.splice,
    ze = xr ? xr.toStringTag : void 0,
    et = Object.getOwnPropertySymbols,
    ct = qa ? qa.isBuffer : void 0,
    ca = Ce(Object.keys, Object),
    Oa = dt(Re, "DataView"),
    nr = dt(Re, "Map"),
    zr = dt(Re, "Promise"),
    Lr = dt(Re, "Set"),
    lr = dt(Re, "WeakMap"),
    Or = dt(Object, "create"),
    Jn = ma(Oa),
    tn = ma(nr),
    wo = ma(zr),
    zi = ma(Lr),
    ws = ma(lr),
    ei = xr ? xr.prototype : void 0,
    Dn = ei ? ei.valueOf : void 0;

  function ga(R) {
    var te = -1,
      we = R == null ? 0 : R.length;
    for (this.clear(); ++te < we;) {
      var Ge = R[te];
      this.set(Ge[0], Ge[1])
    }
  }

  function ti() {
    this.__data__ = Or ? Or(null) : {}, this.size = 0
  }

  function ko(R) {
    var te = this.has(R) && delete this.__data__[R];
    return this.size -= te ? 1 : 0, te
  }

  function _o(R) {
    var te = this.__data__;
    if (Or) {
      var we = te[R];
      return we === i ? void 0 : we
    }
    return Ct.call(te, R) ? te[R] : void 0
  }

  function So(R) {
    var te = this.__data__;
    return Or ? te[R] !== void 0 : Ct.call(te, R)
  }

  function Ao(R, te) {
    var we = this.__data__;
    return this.size += this.has(R) ? 0 : 1, we[R] = Or && te === void 0 ? i : te, this
  }
  ga.prototype.clear = ti, ga.prototype.delete = ko, ga.prototype.get = _o, ga.prototype.has = So, ga.prototype.set = Ao;

  function Ka(R) {
    var te = -1,
      we = R == null ? 0 : R.length;
    for (this.clear(); ++te < we;) {
      var Ge = R[te];
      this.set(Ge[0], Ge[1])
    }
  }

  function ks() {
    this.__data__ = [], this.size = 0
  }

  function _s(R) {
    var te = this.__data__,
      we = G(te, R);
    if (we < 0) return !1;
    var Ge = te.length - 1;
    return we == Ge ? te.pop() : rt.call(te, we, 1), --this.size, !0
  }

  function Xi(R) {
    var te = this.__data__,
      we = G(te, R);
    return we < 0 ? void 0 : te[we][1]
  }

  function Co(R) {
    return G(this.__data__, R) > -1
  }

  function Y(R, te) {
    var we = this.__data__,
      Ge = G(we, R);
    return Ge < 0 ? (++this.size, we.push([R, te])) : we[Ge][1] = te, this
  }
  Ka.prototype.clear = ks, Ka.prototype.delete = _s, Ka.prototype.get = Xi, Ka.prototype.has = Co, Ka.prototype.set = Y;

  function r(R) {
    var te = -1,
      we = R == null ? 0 : R.length;
    for (this.clear(); ++te < we;) {
      var Ge = R[te];
      this.set(Ge[0], Ge[1])
    }
  }

  function n() {
    this.size = 0, this.__data__ = {
      hash: new ga,
      map: new(nr || Ka),
      string: new ga
    }
  }

  function s(R) {
    var te = it(this, R).delete(R);
    return this.size -= te ? 1 : 0, te
  }

  function c(R) {
    return it(this, R).get(R)
  }

  function u(R) {
    return it(this, R).has(R)
  }

  function d(R, te) {
    var we = it(this, R),
      Ge = we.size;
    return we.set(R, te), this.size += we.size == Ge ? 0 : 1, this
  }
  r.prototype.clear = n, r.prototype.delete = s, r.prototype.get = c, r.prototype.has = u, r.prototype.set = d;

  function f(R) {
    var te = -1,
      we = R == null ? 0 : R.length;
    for (this.__data__ = new r; ++te < we;) this.add(R[te])
  }

  function g(R) {
    return this.__data__.set(R, i), this
  }

  function b(R) {
    return this.__data__.has(R)
  }
  f.prototype.add = f.prototype.push = g, f.prototype.has = b;

  function y(R) {
    var te = this.__data__ = new Ka(R);
    this.size = te.size
  }

  function x() {
    this.__data__ = new Ka, this.size = 0
  }

  function _(R) {
    var te = this.__data__,
      we = te.delete(R);
    return this.size = te.size, we
  }

  function T(R) {
    return this.__data__.get(R)
  }

  function P(R) {
    return this.__data__.has(R)
  }

  function O(R, te) {
    var we = this.__data__;
    if (we instanceof Ka) {
      var Ge = we.__data__;
      if (!nr || Ge.length < a - 1) return Ge.push([R, te]), this.size = ++we.size, this;
      we = this.__data__ = new r(Ge)
    }
    return we.set(R, te), this.size = we.size, this
  }
  y.prototype.clear = x, y.prototype.delete = _, y.prototype.get = T, y.prototype.has = P, y.prototype.set = O;

  function $(R, te) {
    var we = Sa(R),
      Ge = !we && Ta(R),
      Mt = !we && !Ge && Ss(R),
      xt = !we && !Ge && !Mt && Yl(R),
      Kt = we || Ge || Mt || xt,
      Ut = Kt ? ue(R.length, String) : [],
      $a = Ut.length;
    for (var ta in R) Ct.call(R, ta) && !(Kt && (ta == "length" || Mt && (ta == "offset" || ta == "parent") || xt && (ta == "buffer" || ta == "byteLength" || ta == "byteOffset") || Et(ta, $a))) && Ut.push(ta);
    return Ut
  }

  function G(R, te) {
    for (var we = R.length; we--;)
      if (Mr(R[we][0], te)) return we;
    return -1
  }

  function Q(R, te, we) {
    var Ge = te(R);
    return Sa(R) ? Ge : de(Ge, we(R))
  }

  function v(R) {
    return R == null ? R === void 0 ? Z : z : ze && ze in Object(R) ? mt(R) : Ya(R)
  }

  function C(R) {
    return yn(R) && v(R) == p
  }

  function L(R, te, we, Ge, Mt) {
    return R === te ? !0 : R == null || te == null || !yn(R) && !yn(te) ? R !== R && te !== te : H(R, te, we, Ge, L, Mt)
  }

  function H(R, te, we, Ge, Mt, xt) {
    var Kt = Sa(R),
      Ut = Sa(te),
      $a = Kt ? m : _t(R),
      ta = Ut ? m : _t(te);
    $a = $a == p ? I : $a, ta = ta == p ? I : ta;
    var cr = $a == I,
      Ir = ta == I,
      za = $a == ta;
    if (za && Ss(R)) {
      if (!Ss(te)) return !1;
      Kt = !0, cr = !1
    }
    if (za && !cr) return xt || (xt = new y), Kt || Yl(R) ? pe(R, te, we, Ge, Mt, xt) : Fe(R, te, $a, we, Ge, Mt, xt);
    if (!(we & o)) {
      var ur = cr && Ct.call(R, "__wrapped__"),
        ir = Ir && Ct.call(te, "__wrapped__");
      if (ur || ir) {
        var ri = ur ? R.value() : R,
          Nn = ir ? te.value() : te;
        return xt || (xt = new y), Mt(ri, Nn, we, Ge, xt)
      }
    }
    return za ? (xt || (xt = new y), Ue(R, te, we, Ge, Mt, xt)) : !1
  }

  function q(R) {
    if (!Hl(R) || sa(R)) return !1;
    var te = Bl(R) ? yr : ke;
    return te.test(ma(R))
  }

  function ee(R) {
    return yn(R) && To(R.length) && !!Se[v(R)]
  }

  function ge(R) {
    if (!wr(R)) return ca(R);
    var te = [];
    for (var we in Object(R)) Ct.call(R, we) && we != "constructor" && te.push(we);
    return te
  }

  function pe(R, te, we, Ge, Mt, xt) {
    var Kt = we & o,
      Ut = R.length,
      $a = te.length;
    if (Ut != $a && !(Kt && $a > Ut)) return !1;
    var ta = xt.get(R);
    if (ta && xt.get(te)) return ta == te;
    var cr = -1,
      Ir = !0,
      za = we & l ? new f : void 0;
    for (xt.set(R, te), xt.set(te, R); ++cr < Ut;) {
      var ur = R[cr],
        ir = te[cr];
      if (Ge) var ri = Kt ? Ge(ir, ur, cr, te, R, xt) : Ge(ur, ir, cr, R, te, xt);
      if (ri !== void 0) {
        if (ri) continue;
        Ir = !1;
        break
      }
      if (za) {
        if (!Ie(te, function (Nn, Wi) {
            if (!K(za, Wi) && (ur === Nn || Mt(ur, Nn, we, Ge, xt))) return za.push(Wi)
          })) {
          Ir = !1;
          break
        }
      } else if (!(ur === ir || Mt(ur, ir, we, Ge, xt))) {
        Ir = !1;
        break
      }
    }
    return xt.delete(R), xt.delete(te), Ir
  }

  function Fe(R, te, we, Ge, Mt, xt, Kt) {
    switch (we) {
      case le:
        if (R.byteLength != te.byteLength || R.byteOffset != te.byteOffset) return !1;
        R = R.buffer, te = te.buffer;
      case fe:
        return !(R.byteLength != te.byteLength || !xt(new wa(R), new wa(te)));
      case w:
      case S:
      case B:
        return Mr(+R, +te);
      case A:
        return R.name == te.name && R.message == te.message;
      case W:
      case V:
        return R == te + "";
      case D:
        var Ut = xe;
      case X:
        var $a = Ge & o;
        if (Ut || (Ut = tt), R.size != te.size && !$a) return !1;
        var ta = Kt.get(R);
        if (ta) return ta == te;
        Ge |= l, Kt.set(R, te);
        var cr = pe(Ut(R), Ut(te), Ge, Mt, xt, Kt);
        return Kt.delete(R), cr;
      case ne:
        if (Dn) return Dn.call(R) == Dn.call(te)
    }
    return !1
  }

  function Ue(R, te, we, Ge, Mt, xt) {
    var Kt = we & o,
      Ut = Ve(R),
      $a = Ut.length,
      ta = Ve(te),
      cr = ta.length;
    if ($a != cr && !Kt) return !1;
    for (var Ir = $a; Ir--;) {
      var za = Ut[Ir];
      if (!(Kt ? za in te : Ct.call(te, za))) return !1
    }
    var ur = xt.get(R);
    if (ur && xt.get(te)) return ur == te;
    var ir = !0;
    xt.set(R, te), xt.set(te, R);
    for (var ri = Kt; ++Ir < $a;) {
      za = Ut[Ir];
      var Nn = R[za],
        Wi = te[za];
      if (Ge) var Tp = Kt ? Ge(Wi, Nn, za, te, R, xt) : Ge(Nn, Wi, za, R, te, xt);
      if (!(Tp === void 0 ? Nn === Wi || Mt(Nn, Wi, we, Ge, xt) : Tp)) {
        ir = !1;
        break
      }
      ri || (ri = za == "constructor")
    }
    if (ir && !ri) {
      var zl = R.constructor,
        Xl = te.constructor;
      zl != Xl && "constructor" in R && "constructor" in te && !(typeof zl == "function" && zl instanceof zl && typeof Xl == "function" && Xl instanceof Xl) && (ir = !1)
    }
    return xt.delete(R), xt.delete(te), ir
  }

  function Ve(R) {
    return Q(R, Eo, At)
  }

  function it(R, te) {
    var we = R.__data__;
    return qt(te) ? we[typeof te == "string" ? "string" : "hash"] : we.map
  }

  function dt(R, te) {
    var we = ae(R, te);
    return q(we) ? we : void 0
  }

  function mt(R) {
    var te = Ct.call(R, ze),
      we = R[ze];
    try {
      R[ze] = void 0;
      var Ge = !0
    } catch {}
    var Mt = xa.call(R);
    return Ge && (te ? R[ze] = we : delete R[ze]), Mt
  }
  var At = et ? function (R) {
      return R == null ? [] : (R = Object(R), oe(et(R), function (te) {
        return Me.call(R, te)
      }))
    } : $u,
    _t = v;
  (Oa && _t(new Oa(new ArrayBuffer(1))) != le || nr && _t(new nr) != D || zr && _t(zr.resolve()) != N || Lr && _t(new Lr) != X || lr && _t(new lr) != ie) && (_t = function (R) {
    var te = v(R),
      we = te == I ? R.constructor : void 0,
      Ge = we ? ma(we) : "";
    if (Ge) switch (Ge) {
      case Jn:
        return le;
      case tn:
        return D;
      case wo:
        return N;
      case zi:
        return X;
      case ws:
        return ie
    }
    return te
  });

  function Et(R, te) {
    return te = te ?? h, !!te && (typeof R == "number" || re.test(R)) && R > -1 && R % 1 == 0 && R < te
  }

  function qt(R) {
    var te = typeof R;
    return te == "string" || te == "number" || te == "symbol" || te == "boolean" ? R !== "__proto__" : R === null
  }

  function sa(R) {
    return !!ia && ia in R
  }

  function wr(R) {
    var te = R && R.constructor,
      we = typeof te == "function" && te.prototype || $e;
    return R === we
  }

  function Ya(R) {
    return xa.call(R)
  }

  function ma(R) {
    if (R != null) {
      try {
        return gt.call(R)
      } catch {}
      try {
        return R + ""
      } catch {}
    }
    return ""
  }

  function Mr(R, te) {
    return R === te || R !== R && te !== te
  }
  var Ta = C(function () {
      return arguments
    }()) ? C : function (R) {
      return yn(R) && Ct.call(R, "callee") && !Me.call(R, "callee")
    },
    Sa = Array.isArray;

  function ai(R) {
    return R != null && To(R.length) && !Bl(R)
  }
  var Ss = ct || Bu;

  function Fu(R, te) {
    return L(R, te)
  }

  function Bl(R) {
    if (!Hl(R)) return !1;
    var te = v(R);
    return te == E || te == M || te == k || te == U
  }

  function To(R) {
    return typeof R == "number" && R > -1 && R % 1 == 0 && R <= h
  }

  function Hl(R) {
    var te = typeof R;
    return R != null && (te == "object" || te == "function")
  }

  function yn(R) {
    return R != null && typeof R == "object"
  }
  var Yl = j ? Le(j) : ee;

  function Eo(R) {
    return ai(R) ? $(R) : ge(R)
  }

  function $u() {
    return []
  }

  function Bu() {
    return !1
  }
  e.exports = Fu
})(Wc, Wc.exports);
var G3 = Wc.exports;
const q3 = Tu(G3);

function K3(e, t) {
  let a = typeof e == "string" ? e : null,
    i = typeof e == "string" ? t : e,
    o = a ? Wo.restore(a) : null,
    l = Bn(typeof i == "object" ? i : i()),
    h = null,
    p = null,
    m = w => w,
    k = qr({
      ...o ? o.data : Bn(l),
      isDirty: !1,
      errors: o ? o.errors : {},
      hasErrors: !1,
      processing: !1,
      progress: null,
      wasSuccessful: !1,
      recentlySuccessful: !1,
      data() {
        return Object.keys(l).reduce((w, S) => (w[S] = this[S], w), {})
      },
      transform(w) {
        return m = w, this
      },
      defaults(w, S) {
        if (typeof i == "function") throw new Error("You cannot call `defaults()` when using a function to define your form data.");
        return typeof w > "u" ? l = this.data() : l = Object.assign({}, Bn(l), typeof w == "string" ? {
          [w]: S
        } : w), this
      },
      reset(...w) {
        let S = Bn(typeof i == "object" ? l : i()),
          A = Bn(S);
        return w.length === 0 ? (l = A, Object.assign(this, S)) : Object.keys(S).filter(E => w.includes(E)).forEach(E => {
          l[E] = A[E], this[E] = S[E]
        }), this
      },
      setError(w, S) {
        return Object.assign(this.errors, typeof w == "string" ? {
          [w]: S
        } : w), this.hasErrors = Object.keys(this.errors).length > 0, this
      },
      clearErrors(...w) {
        return this.errors = Object.keys(this.errors).reduce((S, A) => ({
          ...S,
          ...w.length > 0 && !w.includes(A) ? {
            [A]: this.errors[A]
          } : {}
        }), {}), this.hasErrors = Object.keys(this.errors).length > 0, this
      },
      submit(w, S, A = {}) {
        let E = m(this.data()),
          M = {
            ...A,
            onCancelToken: D => {
              if (h = D, A.onCancelToken) return A.onCancelToken(D)
            },
            onBefore: D => {
              if (this.wasSuccessful = !1, this.recentlySuccessful = !1, clearTimeout(p), A.onBefore) return A.onBefore(D)
            },
            onStart: D => {
              if (this.processing = !0, A.onStart) return A.onStart(D)
            },
            onProgress: D => {
              if (this.progress = D, A.onProgress) return A.onProgress(D)
            },
            onSuccess: async D => {
              this.processing = !1, this.progress = null, this.clearErrors(), this.wasSuccessful = !0, this.recentlySuccessful = !0, p = setTimeout(() => this.recentlySuccessful = !1, 2e3);
              let B = A.onSuccess ? await A.onSuccess(D) : null;
              return l = Bn(this.data()), this.isDirty = !1, B
            },
            onError: D => {
              if (this.processing = !1, this.progress = null, this.clearErrors().setError(D), A.onError) return A.onError(D)
            },
            onCancel: () => {
              if (this.processing = !1, this.progress = null, A.onCancel) return A.onCancel()
            },
            onFinish: D => {
              if (this.processing = !1, this.progress = null, h = null, A.onFinish) return A.onFinish(D)
            }
          };
        w === "delete" ? Wo.delete(S, {
          ...M,
          data: E
        }) : Wo[w](S, E, M)
      },
      get(w, S) {
        this.submit("get", w, S)
      },
      post(w, S) {
        this.submit("post", w, S)
      },
      put(w, S) {
        this.submit("put", w, S)
      },
      patch(w, S) {
        this.submit("patch", w, S)
      },
      delete(w, S) {
        this.submit("delete", w, S)
      },
      cancel() {
        h && h.cancel()
      },
      __rememberable: a === null,
      __remember() {
        return {
          data: this.data(),
          errors: this.errors
        }
      },
      __restore(w) {
        Object.assign(this, w.data), this.setError(w.errors)
      }
    });
  return Xt(k, w => {
    k.isDirty = !q3(k.data(), l), a && Wo.remember(Bn(w.__remember()), a)
  }, {
    immediate: !0,
    deep: !0
  }), k
}
_e(null);
_e(null);
Sl(null);
_e(null);
var Z3 = Ot({
    name: "Link",
    props: {
      as: {
        type: String,
        default: "a"
      },
      data: {
        type: Object,
        default: () => ({})
      },
      href: {
        type: String,
        required: !0
      },
      method: {
        type: String,
        default: "get"
      },
      replace: {
        type: Boolean,
        default: !1
      },
      preserveScroll: {
        type: Boolean,
        default: !1
      },
      preserveState: {
        type: Boolean,
        default: null
      },
      only: {
        type: Array,
        default: () => []
      },
      except: {
        type: Array,
        default: () => []
      },
      headers: {
        type: Object,
        default: () => ({})
      },
      queryStringArrayFormat: {
        type: String,
        default: "brackets"
      }
    },
    setup(e, {
      slots: t,
      attrs: a
    }) {
      return () => {
        let i = e.as.toLowerCase(),
          o = e.method.toLowerCase(),
          [l, h] = Xx(o, e.href || "", e.data, e.queryStringArrayFormat);
        return i === "a" && o !== "get" && console.warn(`Creating POST/PUT/PATCH/DELETE <a> links is discouraged as it causes "Open Link in New Tab/Window" accessibility issues.

Please specify a more appropriate element using the "as" attribute. For example:

<Link href="${l}" method="${o}" as="button">...</Link>`), oa(e.as, {
          ...a,
          ...i === "a" ? {
            href: l
          } : {},
          onClick: p => {
            j3(p) && (p.preventDefault(), Wo.visit(l, {
              data: h,
              method: o,
              replace: e.replace,
              preserveScroll: e.preserveScroll,
              preserveState: e.preserveState ?? o !== "get",
              only: e.only,
              except: e.except,
              headers: e.headers,
              onCancelToken: a.onCancelToken || (() => ({})),
              onBefore: a.onBefore || (() => ({})),
              onStart: a.onStart || (() => ({})),
              onProgress: a.onProgress || (() => ({})),
              onFinish: a.onFinish || (() => ({})),
              onCancel: a.onCancel || (() => ({})),
              onSuccess: a.onSuccess || (() => ({})),
              onError: a.onError || (() => ({}))
            }))
          }
        }, t)
      }
    }
  }),
  Wx = Z3;

function Q3(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function")
}
var Vx = Q3,
  J3 = typeof Tr == "object" && Tr && Tr.Object === Object && Tr,
  eD = J3,
  tD = eD,
  aD = typeof self == "object" && self && self.Object === Object && self,
  rD = tD || aD || Function("return this")(),
  jx = rD,
  nD = jx,
  iD = function () {
    return nD.Date.now()
  },
  sD = iD,
  oD = /\s/;

function lD(e) {
  for (var t = e.length; t-- && oD.test(e.charAt(t)););
  return t
}
var cD = lD,
  uD = cD,
  dD = /^\s+/;

function hD(e) {
  return e && e.slice(0, uD(e) + 1).replace(dD, "")
}
var fD = hD,
  pD = jx,
  gD = pD.Symbol,
  Ux = gD,
  qm = Ux,
  Gx = Object.prototype,
  mD = Gx.hasOwnProperty,
  vD = Gx.toString,
  Bo = qm ? qm.toStringTag : void 0;

function bD(e) {
  var t = mD.call(e, Bo),
    a = e[Bo];
  try {
    e[Bo] = void 0;
    var i = !0
  } catch {}
  var o = vD.call(e);
  return i && (t ? e[Bo] = a : delete e[Bo]), o
}
var yD = bD,
  xD = Object.prototype,
  wD = xD.toString;

function kD(e) {
  return wD.call(e)
}
var _D = kD,
  Km = Ux,
  SD = yD,
  AD = _D,
  CD = "[object Null]",
  TD = "[object Undefined]",
  Zm = Km ? Km.toStringTag : void 0;

function ED(e) {
  return e == null ? e === void 0 ? TD : CD : Zm && Zm in Object(e) ? SD(e) : AD(e)
}
var PD = ED;

function LD(e) {
  return e != null && typeof e == "object"
}
var OD = LD,
  MD = PD,
  ID = OD,
  RD = "[object Symbol]";

function DD(e) {
  return typeof e == "symbol" || ID(e) && MD(e) == RD
}
var ND = DD,
  FD = fD,
  Qm = Vx,
  $D = ND,
  Jm = NaN,
  BD = /^[-+]0x[0-9a-f]+$/i,
  HD = /^0b[01]+$/i,
  YD = /^0o[0-7]+$/i,
  zD = parseInt;

function XD(e) {
  if (typeof e == "number") return e;
  if ($D(e)) return Jm;
  if (Qm(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Qm(t) ? t + "" : t
  }
  if (typeof e != "string") return e === 0 ? e : +e;
  e = FD(e);
  var a = HD.test(e);
  return a || YD.test(e) ? zD(e.slice(2), a ? 2 : 8) : BD.test(e) ? Jm : +e
}
var WD = XD,
  VD = Vx,
  Vd = sD,
  ev = WD,
  jD = "Expected a function",
  UD = Math.max,
  GD = Math.min;

function qD(e, t, a) {
  var i, o, l, h, p, m, k = 0,
    w = !1,
    S = !1,
    A = !0;
  if (typeof e != "function") throw new TypeError(jD);
  t = ev(t) || 0, VD(a) && (w = !!a.leading, S = "maxWait" in a, l = S ? UD(ev(a.maxWait) || 0, t) : l, A = "trailing" in a ? !!a.trailing : A);

  function E(X) {
    var V = i,
      ne = o;
    return i = o = void 0, k = X, h = e.apply(ne, V), h
  }

  function M(X) {
    return k = X, p = setTimeout(z, t), w ? E(X) : h
  }

  function D(X) {
    var V = X - m,
      ne = X - k,
      Z = t - V;
    return S ? GD(Z, l - ne) : Z
  }

  function B(X) {
    var V = X - m,
      ne = X - k;
    return m === void 0 || V >= t || V < 0 || S && ne >= l
  }

  function z() {
    var X = Vd();
    if (B(X)) return I(X);
    p = setTimeout(z, D(X))
  }

  function I(X) {
    return p = void 0, A && i ? E(X) : (i = o = void 0, h)
  }

  function N() {
    p !== void 0 && clearTimeout(p), k = 0, i = m = o = p = void 0
  }

  function U() {
    return p === void 0 ? h : I(Vd())
  }

  function W() {
    var X = Vd(),
      V = B(X);
    if (i = arguments, o = this, m = X, V) {
      if (p === void 0) return M(m);
      if (S) return clearTimeout(p), p = setTimeout(z, t), E(m)
    }
    return p === void 0 && (p = setTimeout(z, t)), h
  }
  return W.cancel = N, W.flush = U, W
}
var KD = qD;
const qx = Tu(KD);

function ZD(e, t, a) {
  let i = _e(a == null ? void 0 : a.value),
    o = Oe(() => e.value !== void 0);
  return [Oe(() => o.value ? e.value : i.value), function (l) {
    return o.value || (i.value = l), t == null ? void 0 : t(l)
  }]
}

function cp(e) {
  typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch(t => setTimeout(() => {
    throw t
  }))
}

function Nl() {
  let e = [],
    t = {
      addEventListener(a, i, o, l) {
        return a.addEventListener(i, o, l), t.add(() => a.removeEventListener(i, o, l))
      },
      requestAnimationFrame(...a) {
        let i = requestAnimationFrame(...a);
        t.add(() => cancelAnimationFrame(i))
      },
      nextFrame(...a) {
        t.requestAnimationFrame(() => {
          t.requestAnimationFrame(...a)
        })
      },
      setTimeout(...a) {
        let i = setTimeout(...a);
        t.add(() => clearTimeout(i))
      },
      microTask(...a) {
        let i = {
          current: !0
        };
        return cp(() => {
          i.current && a[0]()
        }), t.add(() => {
          i.current = !1
        })
      },
      style(a, i, o) {
        let l = a.style.getPropertyValue(i);
        return Object.assign(a.style, {
          [i]: o
        }), this.add(() => {
          Object.assign(a.style, {
            [i]: l
          })
        })
      },
      group(a) {
        let i = Nl();
        return a(i), this.add(() => i.dispose())
      },
      add(a) {
        return e.push(a), () => {
          let i = e.indexOf(a);
          if (i >= 0)
            for (let o of e.splice(i, 1)) o()
        }
      },
      dispose() {
        for (let a of e.splice(0)) a()
      }
    };
  return t
}
let QD = Symbol("headlessui.useid"),
  JD = 0;

function Rn() {
  return fa(QD, () => `${++JD}`)()
}

function wt(e) {
  var t;
  if (e == null || e.value == null) return null;
  let a = (t = e.value.$el) != null ? t : e.value;
  return a instanceof Node ? a : null
}

function Ua(e, t, ...a) {
  if (e in t) {
    let o = t[e];
    return typeof o == "function" ? o(...a) : o
  }
  let i = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map(o=>`"${o}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(i, Ua), i
}
var eN = Object.defineProperty,
  tN = (e, t, a) => t in e ? eN(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
  }) : e[t] = a,
  tv = (e, t, a) => (tN(e, typeof t != "symbol" ? t + "" : t, a), a);
let aN = class {
    constructor() {
      tv(this, "current", this.detect()), tv(this, "currentId", 0)
    }
    set(t) {
      this.current !== t && (this.currentId = 0, this.current = t)
    }
    reset() {
      this.set(this.detect())
    }
    nextId() {
      return ++this.currentId
    }
    get isServer() {
      return this.current === "server"
    }
    get isClient() {
      return this.current === "client"
    }
    detect() {
      return typeof window > "u" || typeof document > "u" ? "server" : "client"
    }
  },
  Fl = new aN;

function Bi(e) {
  if (Fl.isServer) return null;
  if (e instanceof Node) return e.ownerDocument;
  if (e != null && e.hasOwnProperty("value")) {
    let t = wt(e);
    if (t) return t.ownerDocument
  }
  return document
}
let Bh = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(e => `${e}:not([tabindex='-1'])`).join(",");
var En = (e => (e[e.First = 1] = "First", e[e.Previous = 2] = "Previous", e[e.Next = 4] = "Next", e[e.Last = 8] = "Last", e[e.WrapAround = 16] = "WrapAround", e[e.NoScroll = 32] = "NoScroll", e))(En || {}),
  Kx = (e => (e[e.Error = 0] = "Error", e[e.Overflow = 1] = "Overflow", e[e.Success = 2] = "Success", e[e.Underflow = 3] = "Underflow", e))(Kx || {}),
  rN = (e => (e[e.Previous = -1] = "Previous", e[e.Next = 1] = "Next", e))(rN || {});

function Zx(e = document.body) {
  return e == null ? [] : Array.from(e.querySelectorAll(Bh)).sort((t, a) => Math.sign((t.tabIndex || Number.MAX_SAFE_INTEGER) - (a.tabIndex || Number.MAX_SAFE_INTEGER)))
}
var Eu = (e => (e[e.Strict = 0] = "Strict", e[e.Loose = 1] = "Loose", e))(Eu || {});

function Pu(e, t = 0) {
  var a;
  return e === ((a = Bi(e)) == null ? void 0 : a.body) ? !1 : Ua(t, {
    0() {
      return e.matches(Bh)
    },
    1() {
      let i = e;
      for (; i !== null;) {
        if (i.matches(Bh)) return !0;
        i = i.parentElement
      }
      return !1
    }
  })
}

function Qx(e) {
  let t = Bi(e);
  Jt(() => {
    t && !Pu(t.activeElement, 0) && Ai(e)
  })
}
var nN = (e => (e[e.Keyboard = 0] = "Keyboard", e[e.Mouse = 1] = "Mouse", e))(nN || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", e => {
  e.metaKey || e.altKey || e.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "")
}, !0), document.addEventListener("click", e => {
  e.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "")
}, !0));

function Ai(e) {
  e == null || e.focus({
    preventScroll: !0
  })
}
let iN = ["textarea", "input"].join(",");

function sN(e) {
  var t, a;
  return (a = (t = e == null ? void 0 : e.matches) == null ? void 0 : t.call(e, iN)) != null ? a : !1
}

function up(e, t = a => a) {
  return e.slice().sort((a, i) => {
    let o = t(a),
      l = t(i);
    if (o === null || l === null) return 0;
    let h = o.compareDocumentPosition(l);
    return h & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : h & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0
  })
}

function oN(e, t) {
  return il(Zx(), t, {
    relativeTo: e
  })
}

function il(e, t, {
  sorted: a = !0,
  relativeTo: i = null,
  skipElements: o = []
} = {}) {
  var l;
  let h = (l = Array.isArray(e) ? e.length > 0 ? e[0].ownerDocument : document : e == null ? void 0 : e.ownerDocument) != null ? l : document,
    p = Array.isArray(e) ? a ? up(e) : e : Zx(e);
  o.length > 0 && p.length > 1 && (p = p.filter(M => !o.includes(M))), i = i ?? h.activeElement;
  let m = (() => {
      if (t & 5) return 1;
      if (t & 10) return -1;
      throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
    })(),
    k = (() => {
      if (t & 1) return 0;
      if (t & 2) return Math.max(0, p.indexOf(i)) - 1;
      if (t & 4) return Math.max(0, p.indexOf(i)) + 1;
      if (t & 8) return p.length - 1;
      throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last")
    })(),
    w = t & 32 ? {
      preventScroll: !0
    } : {},
    S = 0,
    A = p.length,
    E;
  do {
    if (S >= A || S + A <= 0) return 0;
    let M = k + S;
    if (t & 16) M = (M + A) % A;
    else {
      if (M < 0) return 3;
      if (M >= A) return 1
    }
    E = p[M], E == null || E.focus(w), S += m
  } while (E !== h.activeElement);
  return t & 6 && sN(E) && E.select(), 2
}

function Jx() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0
}

function lN() {
  return /Android/gi.test(window.navigator.userAgent)
}

function cN() {
  return Jx() || lN()
}

function sc(e, t, a) {
  Fl.isServer || Er(i => {
    document.addEventListener(e, t, a), i(() => document.removeEventListener(e, t, a))
  })
}

function e1(e, t, a) {
  Fl.isServer || Er(i => {
    window.addEventListener(e, t, a), i(() => window.removeEventListener(e, t, a))
  })
}

function dp(e, t, a = Oe(() => !0)) {
  function i(l, h) {
    if (!a.value || l.defaultPrevented) return;
    let p = h(l);
    if (p === null || !p.getRootNode().contains(p)) return;
    let m = function k(w) {
      return typeof w == "function" ? k(w()) : Array.isArray(w) || w instanceof Set ? w : [w]
    }(e);
    for (let k of m) {
      if (k === null) continue;
      let w = k instanceof HTMLElement ? k : wt(k);
      if (w != null && w.contains(p) || l.composed && l.composedPath().includes(w)) return
    }
    return !Pu(p, Eu.Loose) && p.tabIndex !== -1 && l.preventDefault(), t(l, p)
  }
  let o = _e(null);
  sc("pointerdown", l => {
    var h, p;
    a.value && (o.value = ((p = (h = l.composedPath) == null ? void 0 : h.call(l)) == null ? void 0 : p[0]) || l.target)
  }, !0), sc("mousedown", l => {
    var h, p;
    a.value && (o.value = ((p = (h = l.composedPath) == null ? void 0 : h.call(l)) == null ? void 0 : p[0]) || l.target)
  }, !0), sc("click", l => {
    cN() || o.value && (i(l, () => o.value), o.value = null)
  }, !0), sc("touchend", l => i(l, () => l.target instanceof HTMLElement ? l.target : null), !0), e1("blur", l => i(l, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0)
}

function av(e, t) {
  if (e) return e;
  let a = t ?? "button";
  if (typeof a == "string" && a.toLowerCase() === "button") return "button"
}

function t1(e, t) {
  let a = _e(av(e.value.type, e.value.as));
  return Dt(() => {
    a.value = av(e.value.type, e.value.as)
  }), Er(() => {
    var i;
    a.value || wt(t) && wt(t) instanceof HTMLButtonElement && !((i = wt(t)) != null && i.hasAttribute("type")) && (a.value = "button")
  }), a
}

function rv(e) {
  return [e.screenX, e.screenY]
}

function a1() {
  let e = _e([-1, -1]);
  return {
    wasMoved(t) {
      let a = rv(t);
      return e.value[0] === a[0] && e.value[1] === a[1] ? !1 : (e.value = a, !0)
    },
    update(t) {
      e.value = rv(t)
    }
  }
}

function uN({
  container: e,
  accept: t,
  walk: a,
  enabled: i
}) {
  Er(() => {
    let o = e.value;
    if (!o || i !== void 0 && !i.value) return;
    let l = Bi(e);
    if (!l) return;
    let h = Object.assign(m => t(m), {
        acceptNode: t
      }),
      p = l.createTreeWalker(o, NodeFilter.SHOW_ELEMENT, h, !1);
    for (; p.nextNode();) a(p.currentNode)
  })
}
var Ei = (e => (e[e.None = 0] = "None", e[e.RenderStrategy = 1] = "RenderStrategy", e[e.Static = 2] = "Static", e))(Ei || {}),
  xi = (e => (e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(xi || {});

function rr({
  visible: e = !0,
  features: t = 0,
  ourProps: a,
  theirProps: i,
  ...o
}) {
  var l;
  let h = n1(i, a),
    p = Object.assign(o, {
      props: h
    });
  if (e || t & 2 && h.static) return jd(p);
  if (t & 1) {
    let m = (l = h.unmount) == null || l ? 0 : 1;
    return Ua(m, {
      0() {
        return null
      },
      1() {
        return jd({
          ...o,
          props: {
            ...h,
            hidden: !0,
            style: {
              display: "none"
            }
          }
        })
      }
    })
  }
  return jd(p)
}

function jd({
  props: e,
  attrs: t,
  slots: a,
  slot: i,
  name: o
}) {
  var l, h;
  let {
    as: p,
    ...m
  } = hp(e, ["unmount", "static"]), k = (l = a.default) == null ? void 0 : l.call(a, i), w = {};
  if (i) {
    let S = !1,
      A = [];
    for (let [E, M] of Object.entries(i)) typeof M == "boolean" && (S = !0), M === !0 && A.push(E);
    S && (w["data-headlessui-state"] = A.join(" "))
  }
  if (p === "template") {
    if (k = r1(k ?? []), Object.keys(m).length > 0 || Object.keys(t).length > 0) {
      let [S, ...A] = k ?? [];
      if (!hN(S) || A.length > 0) throw new Error(['Passing props on "template"!', "", `The current component <${o} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(m).concat(Object.keys(t)).map(D => D.trim()).filter((D, B, z) => z.indexOf(D) === B).sort((D, B) => D.localeCompare(B)).map(D => `  - ${D}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(D => `  - ${D}`).join(`
`)].join(`
`));
      let E = n1((h = S.props) != null ? h : {}, m, w),
        M = Gn(S, E, !0);
      for (let D in E) D.startsWith("on") && (M.props || (M.props = {}), M.props[D] = E[D]);
      return M
    }
    return Array.isArray(k) && k.length === 1 ? k[0] : k
  }
  return oa(p, Object.assign({}, m, w), {
    default: () => k
  })
}

function r1(e) {
  return e.flatMap(t => t.type === vt ? r1(t.children) : [t])
}

function n1(...e) {
  if (e.length === 0) return {};
  if (e.length === 1) return e[0];
  let t = {},
    a = {};
  for (let i of e)
    for (let o in i) o.startsWith("on") && typeof i[o] == "function" ? (a[o] != null || (a[o] = []), a[o].push(i[o])) : t[o] = i[o];
  if (t.disabled || t["aria-disabled"]) return Object.assign(t, Object.fromEntries(Object.keys(a).map(i => [i, void 0])));
  for (let i in a) Object.assign(t, {
    [i](o, ...l) {
      let h = a[i];
      for (let p of h) {
        if (o instanceof Event && o.defaultPrevented) return;
        p(o, ...l)
      }
    }
  });
  return t
}

function dN(e) {
  let t = Object.assign({}, e);
  for (let a in t) t[a] === void 0 && delete t[a];
  return t
}

function hp(e, t = []) {
  let a = Object.assign({}, e);
  for (let i of t) i in a && delete a[i];
  return a
}

function hN(e) {
  return e == null ? !1 : typeof e.type == "string" || typeof e.type == "object" || typeof e.type == "function"
}
var xl = (e => (e[e.None = 1] = "None", e[e.Focusable = 2] = "Focusable", e[e.Hidden = 4] = "Hidden", e))(xl || {});
let Vc = Ot({
    name: "Hidden",
    props: {
      as: {
        type: [Object, String],
        default: "div"
      },
      features: {
        type: Number,
        default: 1
      }
    },
    setup(e, {
      slots: t,
      attrs: a
    }) {
      return () => {
        var i;
        let {
          features: o,
          ...l
        } = e, h = {
          "aria-hidden": (o & 2) === 2 ? !0 : (i = l["aria-hidden"]) != null ? i : void 0,
          hidden: (o & 4) === 4 ? !0 : void 0,
          style: {
            position: "fixed",
            top: 1,
            left: 1,
            width: 1,
            height: 0,
            padding: 0,
            margin: -1,
            overflow: "hidden",
            clip: "rect(0, 0, 0, 0)",
            whiteSpace: "nowrap",
            borderWidth: "0",
            ...(o & 4) === 4 && (o & 2) !== 2 && {
              display: "none"
            }
          }
        };
        return rr({
          ourProps: h,
          theirProps: l,
          slot: {},
          attrs: a,
          slots: t,
          name: "Hidden"
        })
      }
    }
  }),
  i1 = Symbol("Context");
var Ra = (e => (e[e.Open = 1] = "Open", e[e.Closed = 2] = "Closed", e[e.Closing = 4] = "Closing", e[e.Opening = 8] = "Opening", e))(Ra || {});

function fN() {
  return $l() !== null
}

function $l() {
  return fa(i1, null)
}

function fp(e) {
  vr(i1, e)
}
var jt = (e => (e.Space = " ", e.Enter = "Enter", e.Escape = "Escape", e.Backspace = "Backspace", e.Delete = "Delete", e.ArrowLeft = "ArrowLeft", e.ArrowUp = "ArrowUp", e.ArrowRight = "ArrowRight", e.ArrowDown = "ArrowDown", e.Home = "Home", e.End = "End", e.PageUp = "PageUp", e.PageDown = "PageDown", e.Tab = "Tab", e))(jt || {});

function pN(e) {
  function t() {
    document.readyState !== "loading" && (e(), document.removeEventListener("DOMContentLoaded", t))
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", t), t())
}
let ns = [];
pN(() => {
  function e(t) {
    t.target instanceof HTMLElement && t.target !== document.body && ns[0] !== t.target && (ns.unshift(t.target), ns = ns.filter(a => a != null && a.isConnected), ns.splice(10))
  }
  window.addEventListener("click", e, {
    capture: !0
  }), window.addEventListener("mousedown", e, {
    capture: !0
  }), window.addEventListener("focus", e, {
    capture: !0
  }), document.body.addEventListener("click", e, {
    capture: !0
  }), document.body.addEventListener("mousedown", e, {
    capture: !0
  }), document.body.addEventListener("focus", e, {
    capture: !0
  })
});

function gN(e) {
  throw new Error("Unexpected object: " + e)
}
var ua = (e => (e[e.First = 0] = "First", e[e.Previous = 1] = "Previous", e[e.Next = 2] = "Next", e[e.Last = 3] = "Last", e[e.Specific = 4] = "Specific", e[e.Nothing = 5] = "Nothing", e))(ua || {});

function s1(e, t) {
  let a = t.resolveItems();
  if (a.length <= 0) return null;
  let i = t.resolveActiveIndex(),
    o = i ?? -1;
  switch (e.focus) {
    case 0: {
      for (let l = 0; l < a.length; ++l)
        if (!t.resolveDisabled(a[l], l, a)) return l;
      return i
    }
    case 1: {
      o === -1 && (o = a.length);
      for (let l = o - 1; l >= 0; --l)
        if (!t.resolveDisabled(a[l], l, a)) return l;
      return i
    }
    case 2: {
      for (let l = o + 1; l < a.length; ++l)
        if (!t.resolveDisabled(a[l], l, a)) return l;
      return i
    }
    case 3: {
      for (let l = a.length - 1; l >= 0; --l)
        if (!t.resolveDisabled(a[l], l, a)) return l;
      return i
    }
    case 4: {
      for (let l = 0; l < a.length; ++l)
        if (t.resolveId(a[l], l, a) === e.id) return l;
      return i
    }
    case 5:
      return null;
    default:
      gN(e)
  }
}

function o1(e = {}, t = null, a = []) {
  for (let [i, o] of Object.entries(e)) c1(a, l1(t, i), o);
  return a
}

function l1(e, t) {
  return e ? e + "[" + t + "]" : t
}

function c1(e, t, a) {
  if (Array.isArray(a))
    for (let [i, o] of a.entries()) c1(e, l1(t, i.toString()), o);
  else a instanceof Date ? e.push([t, a.toISOString()]) : typeof a == "boolean" ? e.push([t, a ? "1" : "0"]) : typeof a == "string" ? e.push([t, a]) : typeof a == "number" ? e.push([t, `${a}`]) : a == null ? e.push([t, ""]) : o1(a, t, e)
}

function u1(e, t, a, i) {
  Fl.isServer || Er(o => {
    e = e ?? window, e.addEventListener(t, a, i), o(() => e.removeEventListener(t, a, i))
  })
}
var Vo = (e => (e[e.Forwards = 0] = "Forwards", e[e.Backwards = 1] = "Backwards", e))(Vo || {});

function mN() {
  let e = _e(0);
  return e1("keydown", t => {
    t.key === "Tab" && (e.value = t.shiftKey ? 1 : 0)
  }), e
}

function d1(e) {
  if (!e) return new Set;
  if (typeof e == "function") return new Set(e());
  let t = new Set;
  for (let a of e.value) {
    let i = wt(a);
    i instanceof HTMLElement && t.add(i)
  }
  return t
}
var h1 = (e => (e[e.None = 1] = "None", e[e.InitialFocus = 2] = "InitialFocus", e[e.TabLock = 4] = "TabLock", e[e.FocusLock = 8] = "FocusLock", e[e.RestoreFocus = 16] = "RestoreFocus", e[e.All = 30] = "All", e))(h1 || {});
let Ho = Object.assign(Ot({
  name: "FocusTrap",
  props: {
    as: {
      type: [Object, String],
      default: "div"
    },
    initialFocus: {
      type: Object,
      default: null
    },
    features: {
      type: Number,
      default: 30
    },
    containers: {
      type: [Object, Function],
      default: _e(new Set)
    }
  },
  inheritAttrs: !1,
  setup(e, {
    attrs: t,
    slots: a,
    expose: i
  }) {
    let o = _e(null);
    i({
      el: o,
      $el: o
    });
    let l = Oe(() => Bi(o)),
      h = _e(!1);
    Dt(() => h.value = !0), Ha(() => h.value = !1), bN({
      ownerDocument: l
    }, Oe(() => h.value && !!(e.features & 16)));
    let p = yN({
      ownerDocument: l,
      container: o,
      initialFocus: Oe(() => e.initialFocus)
    }, Oe(() => h.value && !!(e.features & 2)));
    xN({
      ownerDocument: l,
      container: o,
      containers: e.containers,
      previousActiveElement: p
    }, Oe(() => h.value && !!(e.features & 8)));
    let m = mN();

    function k(E) {
      let M = wt(o);
      M && (D => D())(() => {
        Ua(m.value, {
          [Vo.Forwards]: () => {
            il(M, En.First, {
              skipElements: [E.relatedTarget]
            })
          },
          [Vo.Backwards]: () => {
            il(M, En.Last, {
              skipElements: [E.relatedTarget]
            })
          }
        })
      })
    }
    let w = _e(!1);

    function S(E) {
      E.key === "Tab" && (w.value = !0, requestAnimationFrame(() => {
        w.value = !1
      }))
    }

    function A(E) {
      if (!h.value) return;
      let M = d1(e.containers);
      wt(o) instanceof HTMLElement && M.add(wt(o));
      let D = E.relatedTarget;
      D instanceof HTMLElement && D.dataset.headlessuiFocusGuard !== "true" && (f1(M, D) || (w.value ? il(wt(o), Ua(m.value, {
        [Vo.Forwards]: () => En.Next,
        [Vo.Backwards]: () => En.Previous
      }) | En.WrapAround, {
        relativeTo: E.target
      }) : E.target instanceof HTMLElement && Ai(E.target)))
    }
    return () => {
      let E = {},
        M = {
          ref: o,
          onKeydown: S,
          onFocusout: A
        },
        {
          features: D,
          initialFocus: B,
          containers: z,
          ...I
        } = e;
      return oa(vt, [!!(D & 4) && oa(Vc, {
        as: "button",
        type: "button",
        "data-headlessui-focus-guard": !0,
        onFocus: k,
        features: xl.Focusable
      }), rr({
        ourProps: M,
        theirProps: {
          ...t,
          ...I
        },
        slot: E,
        attrs: t,
        slots: a,
        name: "FocusTrap"
      }), !!(D & 4) && oa(Vc, {
        as: "button",
        type: "button",
        "data-headlessui-focus-guard": !0,
        onFocus: k,
        features: xl.Focusable
      })])
    }
  }
}), {
  features: h1
});

function vN(e) {
  let t = _e(ns.slice());
  return Xt([e], ([a], [i]) => {
    i === !0 && a === !1 ? cp(() => {
      t.value.splice(0)
    }) : i === !1 && a === !0 && (t.value = ns.slice())
  }, {
    flush: "post"
  }), () => {
    var a;
    return (a = t.value.find(i => i != null && i.isConnected)) != null ? a : null
  }
}

function bN({
  ownerDocument: e
}, t) {
  let a = vN(t);
  Dt(() => {
    Er(() => {
      var i, o;
      t.value || ((i = e.value) == null ? void 0 : i.activeElement) === ((o = e.value) == null ? void 0 : o.body) && Ai(a())
    }, {
      flush: "post"
    })
  }), Ha(() => {
    t.value && Ai(a())
  })
}

function yN({
  ownerDocument: e,
  container: t,
  initialFocus: a
}, i) {
  let o = _e(null),
    l = _e(!1);
  return Dt(() => l.value = !0), Ha(() => l.value = !1), Dt(() => {
    Xt([t, a, i], (h, p) => {
      if (h.every((k, w) => (p == null ? void 0 : p[w]) === k) || !i.value) return;
      let m = wt(t);
      m && cp(() => {
        var k, w;
        if (!l.value) return;
        let S = wt(a),
          A = (k = e.value) == null ? void 0 : k.activeElement;
        if (S) {
          if (S === A) {
            o.value = A;
            return
          }
        } else if (m.contains(A)) {
          o.value = A;
          return
        }
        S ? Ai(S) : il(m, En.First | En.NoScroll) === Kx.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), o.value = (w = e.value) == null ? void 0 : w.activeElement
      })
    }, {
      immediate: !0,
      flush: "post"
    })
  }), o
}

function xN({
  ownerDocument: e,
  container: t,
  containers: a,
  previousActiveElement: i
}, o) {
  var l;
  u1((l = e.value) == null ? void 0 : l.defaultView, "focus", h => {
    if (!o.value) return;
    let p = d1(a);
    wt(t) instanceof HTMLElement && p.add(wt(t));
    let m = i.value;
    if (!m) return;
    let k = h.target;
    k && k instanceof HTMLElement ? f1(p, k) ? (i.value = k, Ai(k)) : (h.preventDefault(), h.stopPropagation(), Ai(m)) : Ai(i.value)
  }, !0)
}

function f1(e, t) {
  for (let a of e)
    if (a.contains(t)) return !0;
  return !1
}

function wN(e) {
  let t = Sl(e.getSnapshot());
  return Ha(e.subscribe(() => {
    t.value = e.getSnapshot()
  })), t
}

function kN(e, t) {
  let a = e(),
    i = new Set;
  return {
    getSnapshot() {
      return a
    },
    subscribe(o) {
      return i.add(o), () => i.delete(o)
    },
    dispatch(o, ...l) {
      let h = t[o].call(a, ...l);
      h && (a = h, i.forEach(p => p()))
    }
  }
}

function _N() {
  let e;
  return {
    before({
      doc: t
    }) {
      var a;
      let i = t.documentElement;
      e = ((a = t.defaultView) != null ? a : window).innerWidth - i.clientWidth
    },
    after({
      doc: t,
      d: a
    }) {
      let i = t.documentElement,
        o = i.clientWidth - i.offsetWidth,
        l = e - o;
      a.style(i, "paddingRight", `${l}px`)
    }
  }
}

function SN() {
  return Jx() ? {
    before({
      doc: e,
      d: t,
      meta: a
    }) {
      function i(o) {
        return a.containers.flatMap(l => l()).some(l => l.contains(o))
      }
      t.microTask(() => {
        var o;
        if (window.getComputedStyle(e.documentElement).scrollBehavior !== "auto") {
          let p = Nl();
          p.style(e.documentElement, "scrollBehavior", "auto"), t.add(() => t.microTask(() => p.dispose()))
        }
        let l = (o = window.scrollY) != null ? o : window.pageYOffset,
          h = null;
        t.addEventListener(e, "click", p => {
          if (p.target instanceof HTMLElement) try {
            let m = p.target.closest("a");
            if (!m) return;
            let {
              hash: k
            } = new URL(m.href), w = e.querySelector(k);
            w && !i(w) && (h = w)
          } catch {}
        }, !0), t.addEventListener(e, "touchstart", p => {
          if (p.target instanceof HTMLElement)
            if (i(p.target)) {
              let m = p.target;
              for (; m.parentElement && i(m.parentElement);) m = m.parentElement;
              t.style(m, "overscrollBehavior", "contain")
            } else t.style(p.target, "touchAction", "none")
        }), t.addEventListener(e, "touchmove", p => {
          if (p.target instanceof HTMLElement) {
            if (p.target.tagName === "INPUT") return;
            if (i(p.target)) {
              let m = p.target;
              for (; m.parentElement && m.dataset.headlessuiPortal !== "" && !(m.scrollHeight > m.clientHeight || m.scrollWidth > m.clientWidth);) m = m.parentElement;
              m.dataset.headlessuiPortal === "" && p.preventDefault()
            } else p.preventDefault()
          }
        }, {
          passive: !1
        }), t.add(() => {
          var p;
          let m = (p = window.scrollY) != null ? p : window.pageYOffset;
          l !== m && window.scrollTo(0, l), h && h.isConnected && (h.scrollIntoView({
            block: "nearest"
          }), h = null)
        })
      })
    }
  } : {}
}

function AN() {
  return {
    before({
      doc: e,
      d: t
    }) {
      t.style(e.documentElement, "overflow", "hidden")
    }
  }
}

function CN(e) {
  let t = {};
  for (let a of e) Object.assign(t, a(t));
  return t
}
let os = kN(() => new Map, {
  PUSH(e, t) {
    var a;
    let i = (a = this.get(e)) != null ? a : {
      doc: e,
      count: 0,
      d: Nl(),
      meta: new Set
    };
    return i.count++, i.meta.add(t), this.set(e, i), this
  },
  POP(e, t) {
    let a = this.get(e);
    return a && (a.count--, a.meta.delete(t)), this
  },
  SCROLL_PREVENT({
    doc: e,
    d: t,
    meta: a
  }) {
    let i = {
        doc: e,
        d: t,
        meta: CN(a)
      },
      o = [SN(), _N(), AN()];
    o.forEach(({
      before: l
    }) => l == null ? void 0 : l(i)), o.forEach(({
      after: l
    }) => l == null ? void 0 : l(i))
  },
  SCROLL_ALLOW({
    d: e
  }) {
    e.dispose()
  },
  TEARDOWN({
    doc: e
  }) {
    this.delete(e)
  }
});
os.subscribe(() => {
  let e = os.getSnapshot(),
    t = new Map;
  for (let [a] of e) t.set(a, a.documentElement.style.overflow);
  for (let a of e.values()) {
    let i = t.get(a.doc) === "hidden",
      o = a.count !== 0;
    (o && !i || !o && i) && os.dispatch(a.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", a), a.count === 0 && os.dispatch("TEARDOWN", a)
  }
});

function TN(e, t, a) {
  let i = wN(os),
    o = Oe(() => {
      let l = e.value ? i.value.get(e.value) : void 0;
      return l ? l.count > 0 : !1
    });
  return Xt([e, t], ([l, h], [p], m) => {
    if (!l || !h) return;
    os.dispatch("PUSH", l, a);
    let k = !1;
    m(() => {
      k || (os.dispatch("POP", p ?? l, a), k = !0)
    })
  }, {
    immediate: !0
  }), o
}
let Ud = new Map,
  Yo = new Map;

function nv(e, t = _e(!0)) {
  Er(a => {
    var i;
    if (!t.value) return;
    let o = wt(e);
    if (!o) return;
    a(function () {
      var h;
      if (!o) return;
      let p = (h = Yo.get(o)) != null ? h : 1;
      if (p === 1 ? Yo.delete(o) : Yo.set(o, p - 1), p !== 1) return;
      let m = Ud.get(o);
      m && (m["aria-hidden"] === null ? o.removeAttribute("aria-hidden") : o.setAttribute("aria-hidden", m["aria-hidden"]), o.inert = m.inert, Ud.delete(o))
    });
    let l = (i = Yo.get(o)) != null ? i : 0;
    Yo.set(o, l + 1), l === 0 && (Ud.set(o, {
      "aria-hidden": o.getAttribute("aria-hidden"),
      inert: o.inert
    }), o.setAttribute("aria-hidden", "true"), o.inert = !0)
  })
}

function EN({
  defaultContainers: e = [],
  portals: t,
  mainTreeNodeRef: a
} = {}) {
  let i = _e(null),
    o = Bi(i);

  function l() {
    var h, p, m;
    let k = [];
    for (let w of e) w !== null && (w instanceof HTMLElement ? k.push(w) : "value" in w && w.value instanceof HTMLElement && k.push(w.value));
    if (t != null && t.value)
      for (let w of t.value) k.push(w);
    for (let w of (h = o == null ? void 0 : o.querySelectorAll("html > *, body > *")) != null ? h : []) w !== document.body && w !== document.head && w instanceof HTMLElement && w.id !== "headlessui-portal-root" && (w.contains(wt(i)) || w.contains((m = (p = wt(i)) == null ? void 0 : p.getRootNode()) == null ? void 0 : m.host) || k.some(S => w.contains(S)) || k.push(w));
    return k
  }
  return {
    resolveContainers: l,
    contains(h) {
      return l().some(p => p.contains(h))
    },
    mainTreeNodeRef: i,
    MainTreeNode() {
      return a != null ? null : oa(Vc, {
        features: xl.Hidden,
        ref: i
      })
    }
  }
}
let p1 = Symbol("ForcePortalRootContext");

function PN() {
  return fa(p1, !1)
}
let iv = Ot({
    name: "ForcePortalRoot",
    props: {
      as: {
        type: [Object, String],
        default: "template"
      },
      force: {
        type: Boolean,
        default: !1
      }
    },
    setup(e, {
      slots: t,
      attrs: a
    }) {
      return vr(p1, e.force), () => {
        let {
          force: i,
          ...o
        } = e;
        return rr({
          theirProps: o,
          ourProps: {},
          slot: {},
          slots: t,
          attrs: a,
          name: "ForcePortalRoot"
        })
      }
    }
  }),
  g1 = Symbol("StackContext");
var Hh = (e => (e[e.Add = 0] = "Add", e[e.Remove = 1] = "Remove", e))(Hh || {});

function LN() {
  return fa(g1, () => {})
}

function ON({
  type: e,
  enabled: t,
  element: a,
  onUpdate: i
}) {
  let o = LN();

  function l(...h) {
    i == null || i(...h), o(...h)
  }
  Dt(() => {
    Xt(t, (h, p) => {
      h ? l(0, e, a) : p === !0 && l(1, e, a)
    }, {
      immediate: !0,
      flush: "sync"
    })
  }), Ha(() => {
    t.value && l(1, e, a)
  }), vr(g1, l)
}
let MN = Symbol("DescriptionContext");

function IN({
  slot: e = _e({}),
  name: t = "Description",
  props: a = {}
} = {}) {
  let i = _e([]);

  function o(l) {
    return i.value.push(l), () => {
      let h = i.value.indexOf(l);
      h !== -1 && i.value.splice(h, 1)
    }
  }
  return vr(MN, {
    register: o,
    slot: e,
    name: t,
    props: a
  }), Oe(() => i.value.length > 0 ? i.value.join(" ") : void 0)
}

function RN(e) {
  let t = Bi(e);
  if (!t) {
    if (e === null) return null;
    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${e}`)
  }
  let a = t.getElementById("headlessui-portal-root");
  if (a) return a;
  let i = t.createElement("div");
  return i.setAttribute("id", "headlessui-portal-root"), t.body.appendChild(i)
}
const Yh = new WeakMap;

function DN(e) {
  var t;
  return (t = Yh.get(e)) != null ? t : 0
}

function sv(e, t) {
  let a = t(DN(e));
  return a <= 0 ? Yh.delete(e) : Yh.set(e, a), a
}
let NN = Ot({
    name: "Portal",
    props: {
      as: {
        type: [Object, String],
        default: "div"
      }
    },
    setup(e, {
      slots: t,
      attrs: a
    }) {
      let i = _e(null),
        o = Oe(() => Bi(i)),
        l = PN(),
        h = fa(m1, null),
        p = _e(l === !0 || h == null ? RN(i.value) : h.resolveTarget());
      p.value && sv(p.value, A => A + 1);
      let m = _e(!1);
      Dt(() => {
        m.value = !0
      }), Er(() => {
        l || h != null && (p.value = h.resolveTarget())
      });
      let k = fa(zh, null),
        w = !1,
        S = hn();
      return Xt(i, () => {
        if (w || !k) return;
        let A = wt(i);
        A && (Ha(k.register(A), S), w = !0)
      }), Ha(() => {
        var A, E;
        let M = (A = o.value) == null ? void 0 : A.getElementById("headlessui-portal-root");
        !M || p.value !== M || sv(p.value, D => D - 1) || p.value.children.length > 0 || (E = p.value.parentElement) == null || E.removeChild(p.value)
      }), () => {
        if (!m.value || p.value === null) return null;
        let A = {
          ref: i,
          "data-headlessui-portal": ""
        };
        return oa(xf, {
          to: p.value
        }, rr({
          ourProps: A,
          theirProps: e,
          slot: {},
          attrs: a,
          slots: t,
          name: "Portal"
        }))
      }
    }
  }),
  zh = Symbol("PortalParentContext");

function FN() {
  let e = fa(zh, null),
    t = _e([]);

  function a(l) {
    return t.value.push(l), e && e.register(l), () => i(l)
  }

  function i(l) {
    let h = t.value.indexOf(l);
    h !== -1 && t.value.splice(h, 1), e && e.unregister(l)
  }
  let o = {
    register: a,
    unregister: i,
    portals: t
  };
  return [t, Ot({
    name: "PortalWrapper",
    setup(l, {
      slots: h
    }) {
      return vr(zh, o), () => {
        var p;
        return (p = h.default) == null ? void 0 : p.call(h)
      }
    }
  })]
}
let m1 = Symbol("PortalGroupContext"),
  $N = Ot({
    name: "PortalGroup",
    props: {
      as: {
        type: [Object, String],
        default: "template"
      },
      target: {
        type: Object,
        default: null
      }
    },
    setup(e, {
      attrs: t,
      slots: a
    }) {
      let i = qr({
        resolveTarget() {
          return e.target
        }
      });
      return vr(m1, i), () => {
        let {
          target: o,
          ...l
        } = e;
        return rr({
          theirProps: l,
          ourProps: {},
          slot: {},
          attrs: t,
          slots: a,
          name: "PortalGroup"
        })
      }
    }
  });
var BN = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(BN || {});
let Xh = Symbol("DialogContext");

function pp(e) {
  let t = fa(Xh, null);
  if (t === null) {
    let a = new Error(`<${e} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(a, pp), a
  }
  return t
}
let oc = "DC8F892D-2EBD-447C-A4C8-A03058436FF4",
  HN = Ot({
    name: "Dialog",
    inheritAttrs: !1,
    props: {
      as: {
        type: [Object, String],
        default: "div"
      },
      static: {
        type: Boolean,
        default: !1
      },
      unmount: {
        type: Boolean,
        default: !0
      },
      open: {
        type: [Boolean, String],
        default: oc
      },
      initialFocus: {
        type: Object,
        default: null
      },
      id: {
        type: String,
        default: null
      },
      role: {
        type: String,
        default: "dialog"
      }
    },
    emits: {
      close: e => !0
    },
    setup(e, {
      emit: t,
      attrs: a,
      slots: i,
      expose: o
    }) {
      var l, h;
      let p = (l = e.id) != null ? l : `headlessui-dialog-${Rn()}`,
        m = _e(!1);
      Dt(() => {
        m.value = !0
      });
      let k = !1,
        w = Oe(() => e.role === "dialog" || e.role === "alertdialog" ? e.role : (k || (k = !0, console.warn(`Invalid role [${w}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog")),
        S = _e(0),
        A = $l(),
        E = Oe(() => e.open === oc && A !== null ? (A.value & Ra.Open) === Ra.Open : e.open),
        M = _e(null),
        D = Oe(() => Bi(M));
      if (o({
          el: M,
          $el: M
        }), !(e.open !== oc || A !== null)) throw new Error("You forgot to provide an `open` prop to the `Dialog`.");
      if (typeof E.value != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${E.value===oc?void 0:e.open}`);
      let B = Oe(() => m.value && E.value ? 0 : 1),
        z = Oe(() => B.value === 0),
        I = Oe(() => S.value > 1),
        N = fa(Xh, null) !== null,
        [U, W] = FN(),
        {
          resolveContainers: X,
          mainTreeNodeRef: V,
          MainTreeNode: ne
        } = EN({
          portals: U,
          defaultContainers: [Oe(() => {
            var Je;
            return (Je = Ae.panelRef.value) != null ? Je : M.value
          })]
        }),
        Z = Oe(() => I.value ? "parent" : "leaf"),
        ie = Oe(() => A !== null ? (A.value & Ra.Closing) === Ra.Closing : !1),
        fe = Oe(() => N || ie.value ? !1 : z.value),
        le = Oe(() => {
          var Je, he, ke;
          return (ke = Array.from((he = (Je = D.value) == null ? void 0 : Je.querySelectorAll("body > *")) != null ? he : []).find(re => re.id === "headlessui-portal-root" ? !1 : re.contains(wt(V)) && re instanceof HTMLElement)) != null ? ke : null
        });
      nv(le, fe);
      let Ee = Oe(() => I.value ? !0 : z.value),
        ye = Oe(() => {
          var Je, he, ke;
          return (ke = Array.from((he = (Je = D.value) == null ? void 0 : Je.querySelectorAll("[data-headlessui-portal]")) != null ? he : []).find(re => re.contains(wt(V)) && re instanceof HTMLElement)) != null ? ke : null
        });
      nv(ye, Ee), ON({
        type: "Dialog",
        enabled: Oe(() => B.value === 0),
        element: M,
        onUpdate: (Je, he) => {
          if (he === "Dialog") return Ua(Je, {
            [Hh.Add]: () => S.value += 1,
            [Hh.Remove]: () => S.value -= 1
          })
        }
      });
      let ve = IN({
          name: "DialogDescription",
          slot: Oe(() => ({
            open: E.value
          }))
        }),
        me = _e(null),
        Ae = {
          titleId: me,
          panelRef: _e(null),
          dialogState: B,
          setTitleId(Je) {
            me.value !== Je && (me.value = Je)
          },
          close() {
            t("close", !1)
          }
        };
      vr(Xh, Ae);
      let He = Oe(() => !(!z.value || I.value));
      dp(X, (Je, he) => {
        Je.preventDefault(), Ae.close(), Jt(() => he == null ? void 0 : he.focus())
      }, He);
      let De = Oe(() => !(I.value || B.value !== 0));
      u1((h = D.value) == null ? void 0 : h.defaultView, "keydown", Je => {
        De.value && (Je.defaultPrevented || Je.key === jt.Escape && (Je.preventDefault(), Je.stopPropagation(), Ae.close()))
      });
      let Ye = Oe(() => !(ie.value || B.value !== 0 || N));
      return TN(D, Ye, Je => {
        var he;
        return {
          containers: [...(he = Je.containers) != null ? he : [], X]
        }
      }), Er(Je => {
        if (B.value !== 0) return;
        let he = wt(M);
        if (!he) return;
        let ke = new ResizeObserver(re => {
          for (let Se of re) {
            let Be = Se.target.getBoundingClientRect();
            Be.x === 0 && Be.y === 0 && Be.width === 0 && Be.height === 0 && Ae.close()
          }
        });
        ke.observe(he), Je(() => ke.disconnect())
      }), () => {
        let {
          open: Je,
          initialFocus: he,
          ...ke
        } = e, re = {
          ...a,
          ref: M,
          id: p,
          role: w.value,
          "aria-modal": B.value === 0 ? !0 : void 0,
          "aria-labelledby": me.value,
          "aria-describedby": ve.value
        }, Se = {
          open: B.value === 0
        };
        return oa(iv, {
          force: !0
        }, () => [oa(NN, () => oa($N, {
          target: M.value
        }, () => oa(iv, {
          force: !1
        }, () => oa(Ho, {
          initialFocus: he,
          containers: X,
          features: z.value ? Ua(Z.value, {
            parent: Ho.features.RestoreFocus,
            leaf: Ho.features.All & ~Ho.features.FocusLock
          }) : Ho.features.None
        }, () => oa(W, {}, () => rr({
          ourProps: re,
          theirProps: {
            ...ke,
            ...a
          },
          slot: Se,
          attrs: a,
          slots: i,
          visible: B.value === 0,
          features: Ei.RenderStrategy | Ei.Static,
          name: "Dialog"
        })))))), oa(ne)])
      }
    }
  }),
  YN = Ot({
    name: "DialogPanel",
    props: {
      as: {
        type: [Object, String],
        default: "div"
      },
      id: {
        type: String,
        default: null
      }
    },
    setup(e, {
      attrs: t,
      slots: a,
      expose: i
    }) {
      var o;
      let l = (o = e.id) != null ? o : `headlessui-dialog-panel-${Rn()}`,
        h = pp("DialogPanel");
      i({
        el: h.panelRef,
        $el: h.panelRef
      });

      function p(m) {
        m.stopPropagation()
      }
      return () => {
        let {
          ...m
        } = e, k = {
          id: l,
          ref: h.panelRef,
          onClick: p
        };
        return rr({
          ourProps: k,
          theirProps: m,
          slot: {
            open: h.dialogState.value === 0
          },
          attrs: t,
          slots: a,
          name: "DialogPanel"
        })
      }
    }
  }),
  zN = Ot({
    name: "DialogTitle",
    props: {
      as: {
        type: [Object, String],
        default: "h2"
      },
      id: {
        type: String,
        default: null
      }
    },
    setup(e, {
      attrs: t,
      slots: a
    }) {
      var i;
      let o = (i = e.id) != null ? i : `headlessui-dialog-title-${Rn()}`,
        l = pp("DialogTitle");
      return Dt(() => {
        l.setTitleId(o), Ha(() => l.setTitleId(null))
      }), () => {
        let {
          ...h
        } = e;
        return rr({
          ourProps: {
            id: o
          },
          theirProps: h,
          slot: {
            open: l.dialogState.value === 0
          },
          attrs: t,
          slots: a,
          name: "DialogTitle"
        })
      }
    }
  }),
  ov = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;

function lv(e) {
  var t, a;
  let i = (t = e.innerText) != null ? t : "",
    o = e.cloneNode(!0);
  if (!(o instanceof HTMLElement)) return i;
  let l = !1;
  for (let p of o.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) p.remove(), l = !0;
  let h = l ? (a = o.innerText) != null ? a : "" : i;
  return ov.test(h) && (h = h.replace(ov, "")), h
}

function XN(e) {
  let t = e.getAttribute("aria-label");
  if (typeof t == "string") return t.trim();
  let a = e.getAttribute("aria-labelledby");
  if (a) {
    let i = a.split(" ").map(o => {
      let l = document.getElementById(o);
      if (l) {
        let h = l.getAttribute("aria-label");
        return typeof h == "string" ? h.trim() : lv(l).trim()
      }
      return null
    }).filter(Boolean);
    if (i.length > 0) return i.join(", ")
  }
  return lv(e).trim()
}

function v1(e) {
  let t = _e(""),
    a = _e("");
  return () => {
    let i = wt(e);
    if (!i) return "";
    let o = i.innerText;
    if (t.value === o) return a.value;
    let l = XN(i).trim().toLowerCase();
    return t.value = o, a.value = l, l
  }
}

function WN(e, t) {
  return e === t
}
var VN = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(VN || {}),
  jN = (e => (e[e.Single = 0] = "Single", e[e.Multi = 1] = "Multi", e))(jN || {}),
  UN = (e => (e[e.Pointer = 0] = "Pointer", e[e.Other = 1] = "Other", e))(UN || {});

function GN(e) {
  requestAnimationFrame(() => requestAnimationFrame(e))
}
let b1 = Symbol("ListboxContext");

function Lu(e) {
  let t = fa(b1, null);
  if (t === null) {
    let a = new Error(`<${e} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(a, Lu), a
  }
  return t
}
let qN = Ot({
    name: "Listbox",
    emits: {
      "update:modelValue": e => !0
    },
    props: {
      as: {
        type: [Object, String],
        default: "template"
      },
      disabled: {
        type: [Boolean],
        default: !1
      },
      by: {
        type: [String, Function],
        default: () => WN
      },
      horizontal: {
        type: [Boolean],
        default: !1
      },
      modelValue: {
        type: [Object, String, Number, Boolean],
        default: void 0
      },
      defaultValue: {
        type: [Object, String, Number, Boolean],
        default: void 0
      },
      form: {
        type: String,
        optional: !0
      },
      name: {
        type: String,
        optional: !0
      },
      multiple: {
        type: [Boolean],
        default: !1
      }
    },
    inheritAttrs: !1,
    setup(e, {
      slots: t,
      attrs: a,
      emit: i
    }) {
      let o = _e(1),
        l = _e(null),
        h = _e(null),
        p = _e(null),
        m = _e([]),
        k = _e(""),
        w = _e(null),
        S = _e(1);

      function A(N = U => U) {
        let U = w.value !== null ? m.value[w.value] : null,
          W = up(N(m.value.slice()), V => wt(V.dataRef.domRef)),
          X = U ? W.indexOf(U) : null;
        return X === -1 && (X = null), {
          options: W,
          activeOptionIndex: X
        }
      }
      let E = Oe(() => e.multiple ? 1 : 0),
        [M, D] = ZD(Oe(() => e.modelValue), N => i("update:modelValue", N), Oe(() => e.defaultValue)),
        B = Oe(() => M.value === void 0 ? Ua(E.value, {
          1: [],
          0: void 0
        }) : M.value),
        z = {
          listboxState: o,
          value: B,
          mode: E,
          compare(N, U) {
            if (typeof e.by == "string") {
              let W = e.by;
              return (N == null ? void 0 : N[W]) === (U == null ? void 0 : U[W])
            }
            return e.by(N, U)
          },
          orientation: Oe(() => e.horizontal ? "horizontal" : "vertical"),
          labelRef: l,
          buttonRef: h,
          optionsRef: p,
          disabled: Oe(() => e.disabled),
          options: m,
          searchQuery: k,
          activeOptionIndex: w,
          activationTrigger: S,
          closeListbox() {
            e.disabled || o.value !== 1 && (o.value = 1, w.value = null)
          },
          openListbox() {
            e.disabled || o.value !== 0 && (o.value = 0)
          },
          goToOption(N, U, W) {
            if (e.disabled || o.value === 1) return;
            let X = A(),
              V = s1(N === ua.Specific ? {
                focus: ua.Specific,
                id: U
              } : {
                focus: N
              }, {
                resolveItems: () => X.options,
                resolveActiveIndex: () => X.activeOptionIndex,
                resolveId: ne => ne.id,
                resolveDisabled: ne => ne.dataRef.disabled
              });
            k.value = "", w.value = V, S.value = W ?? 1, m.value = X.options
          },
          search(N) {
            if (e.disabled || o.value === 1) return;
            let U = k.value !== "" ? 0 : 1;
            k.value += N.toLowerCase();
            let W = (w.value !== null ? m.value.slice(w.value + U).concat(m.value.slice(0, w.value + U)) : m.value).find(V => V.dataRef.textValue.startsWith(k.value) && !V.dataRef.disabled),
              X = W ? m.value.indexOf(W) : -1;
            X === -1 || X === w.value || (w.value = X, S.value = 1)
          },
          clearSearch() {
            e.disabled || o.value !== 1 && k.value !== "" && (k.value = "")
          },
          registerOption(N, U) {
            let W = A(X => [...X, {
              id: N,
              dataRef: U
            }]);
            m.value = W.options, w.value = W.activeOptionIndex
          },
          unregisterOption(N) {
            let U = A(W => {
              let X = W.findIndex(V => V.id === N);
              return X !== -1 && W.splice(X, 1), W
            });
            m.value = U.options, w.value = U.activeOptionIndex, S.value = 1
          },
          theirOnChange(N) {
            e.disabled || D(N)
          },
          select(N) {
            e.disabled || D(Ua(E.value, {
              0: () => N,
              1: () => {
                let U = It(z.value.value).slice(),
                  W = It(N),
                  X = U.findIndex(V => z.compare(W, It(V)));
                return X === -1 ? U.push(W) : U.splice(X, 1), U
              }
            }))
          }
        };
      dp([h, p], (N, U) => {
        var W;
        z.closeListbox(), Pu(U, Eu.Loose) || (N.preventDefault(), (W = wt(h)) == null || W.focus())
      }, Oe(() => o.value === 0)), vr(b1, z), fp(Oe(() => Ua(o.value, {
        0: Ra.Open,
        1: Ra.Closed
      })));
      let I = Oe(() => {
        var N;
        return (N = wt(h)) == null ? void 0 : N.closest("form")
      });
      return Dt(() => {
        Xt([I], () => {
          if (!I.value || e.defaultValue === void 0) return;

          function N() {
            z.theirOnChange(e.defaultValue)
          }
          return I.value.addEventListener("reset", N), () => {
            var U;
            (U = I.value) == null || U.removeEventListener("reset", N)
          }
        }, {
          immediate: !0
        })
      }), () => {
        let {
          name: N,
          modelValue: U,
          disabled: W,
          form: X,
          ...V
        } = e, ne = {
          open: o.value === 0,
          disabled: W,
          value: B.value
        };
        return oa(vt, [...N != null && B.value != null ? o1({
          [N]: B.value
        }).map(([Z, ie]) => oa(Vc, dN({
          features: xl.Hidden,
          key: Z,
          as: "input",
          type: "hidden",
          hidden: !0,
          readOnly: !0,
          form: X,
          disabled: W,
          name: Z,
          value: ie
        }))) : [], rr({
          ourProps: {},
          theirProps: {
            ...a,
            ...hp(V, ["defaultValue", "onUpdate:modelValue", "horizontal", "multiple", "by"])
          },
          slot: ne,
          slots: t,
          attrs: a,
          name: "Listbox"
        })])
      }
    }
  }),
  KN = Ot({
    name: "ListboxButton",
    props: {
      as: {
        type: [Object, String],
        default: "button"
      },
      id: {
        type: String,
        default: null
      }
    },
    setup(e, {
      attrs: t,
      slots: a,
      expose: i
    }) {
      var o;
      let l = (o = e.id) != null ? o : `headlessui-listbox-button-${Rn()}`,
        h = Lu("ListboxButton");
      i({
        el: h.buttonRef,
        $el: h.buttonRef
      });

      function p(S) {
        switch (S.key) {
          case jt.Space:
          case jt.Enter:
          case jt.ArrowDown:
            S.preventDefault(), h.openListbox(), Jt(() => {
              var A;
              (A = wt(h.optionsRef)) == null || A.focus({
                preventScroll: !0
              }), h.value.value || h.goToOption(ua.First)
            });
            break;
          case jt.ArrowUp:
            S.preventDefault(), h.openListbox(), Jt(() => {
              var A;
              (A = wt(h.optionsRef)) == null || A.focus({
                preventScroll: !0
              }), h.value.value || h.goToOption(ua.Last)
            });
            break
        }
      }

      function m(S) {
        switch (S.key) {
          case jt.Space:
            S.preventDefault();
            break
        }
      }

      function k(S) {
        h.disabled.value || (h.listboxState.value === 0 ? (h.closeListbox(), Jt(() => {
          var A;
          return (A = wt(h.buttonRef)) == null ? void 0 : A.focus({
            preventScroll: !0
          })
        })) : (S.preventDefault(), h.openListbox(), GN(() => {
          var A;
          return (A = wt(h.optionsRef)) == null ? void 0 : A.focus({
            preventScroll: !0
          })
        })))
      }
      let w = t1(Oe(() => ({
        as: e.as,
        type: t.type
      })), h.buttonRef);
      return () => {
        var S, A;
        let E = {
            open: h.listboxState.value === 0,
            disabled: h.disabled.value,
            value: h.value.value
          },
          {
            ...M
          } = e,
          D = {
            ref: h.buttonRef,
            id: l,
            type: w.value,
            "aria-haspopup": "listbox",
            "aria-controls": (S = wt(h.optionsRef)) == null ? void 0 : S.id,
            "aria-expanded": h.listboxState.value === 0,
            "aria-labelledby": h.labelRef.value ? [(A = wt(h.labelRef)) == null ? void 0 : A.id, l].join(" ") : void 0,
            disabled: h.disabled.value === !0 ? !0 : void 0,
            onKeydown: p,
            onKeyup: m,
            onClick: k
          };
        return rr({
          ourProps: D,
          theirProps: M,
          slot: E,
          attrs: t,
          slots: a,
          name: "ListboxButton"
        })
      }
    }
  }),
  ZN = Ot({
    name: "ListboxOptions",
    props: {
      as: {
        type: [Object, String],
        default: "ul"
      },
      static: {
        type: Boolean,
        default: !1
      },
      unmount: {
        type: Boolean,
        default: !0
      },
      id: {
        type: String,
        default: null
      }
    },
    setup(e, {
      attrs: t,
      slots: a,
      expose: i
    }) {
      var o;
      let l = (o = e.id) != null ? o : `headlessui-listbox-options-${Rn()}`,
        h = Lu("ListboxOptions"),
        p = _e(null);
      i({
        el: h.optionsRef,
        $el: h.optionsRef
      });

      function m(S) {
        switch (p.value && clearTimeout(p.value), S.key) {
          case jt.Space:
            if (h.searchQuery.value !== "") return S.preventDefault(), S.stopPropagation(), h.search(S.key);
          case jt.Enter:
            if (S.preventDefault(), S.stopPropagation(), h.activeOptionIndex.value !== null) {
              let A = h.options.value[h.activeOptionIndex.value];
              h.select(A.dataRef.value)
            }
            h.mode.value === 0 && (h.closeListbox(), Jt(() => {
              var A;
              return (A = wt(h.buttonRef)) == null ? void 0 : A.focus({
                preventScroll: !0
              })
            }));
            break;
          case Ua(h.orientation.value, {
            vertical: jt.ArrowDown,
            horizontal: jt.ArrowRight
          }):
            return S.preventDefault(), S.stopPropagation(), h.goToOption(ua.Next);
          case Ua(h.orientation.value, {
            vertical: jt.ArrowUp,
            horizontal: jt.ArrowLeft
          }):
            return S.preventDefault(), S.stopPropagation(), h.goToOption(ua.Previous);
          case jt.Home:
          case jt.PageUp:
            return S.preventDefault(), S.stopPropagation(), h.goToOption(ua.First);
          case jt.End:
          case jt.PageDown:
            return S.preventDefault(), S.stopPropagation(), h.goToOption(ua.Last);
          case jt.Escape:
            S.preventDefault(), S.stopPropagation(), h.closeListbox(), Jt(() => {
              var A;
              return (A = wt(h.buttonRef)) == null ? void 0 : A.focus({
                preventScroll: !0
              })
            });
            break;
          case jt.Tab:
            S.preventDefault(), S.stopPropagation();
            break;
          default:
            S.key.length === 1 && (h.search(S.key), p.value = setTimeout(() => h.clearSearch(), 350));
            break
        }
      }
      let k = $l(),
        w = Oe(() => k !== null ? (k.value & Ra.Open) === Ra.Open : h.listboxState.value === 0);
      return () => {
        var S, A;
        let E = {
            open: h.listboxState.value === 0
          },
          {
            ...M
          } = e,
          D = {
            "aria-activedescendant": h.activeOptionIndex.value === null || (S = h.options.value[h.activeOptionIndex.value]) == null ? void 0 : S.id,
            "aria-multiselectable": h.mode.value === 1 ? !0 : void 0,
            "aria-labelledby": (A = wt(h.buttonRef)) == null ? void 0 : A.id,
            "aria-orientation": h.orientation.value,
            id: l,
            onKeydown: m,
            role: "listbox",
            tabIndex: 0,
            ref: h.optionsRef
          };
        return rr({
          ourProps: D,
          theirProps: M,
          slot: E,
          attrs: t,
          slots: a,
          features: Ei.RenderStrategy | Ei.Static,
          visible: w.value,
          name: "ListboxOptions"
        })
      }
    }
  }),
  QN = Ot({
    name: "ListboxOption",
    props: {
      as: {
        type: [Object, String],
        default: "li"
      },
      value: {
        type: [Object, String, Number, Boolean]
      },
      disabled: {
        type: Boolean,
        default: !1
      },
      id: {
        type: String,
        default: null
      }
    },
    setup(e, {
      slots: t,
      attrs: a,
      expose: i
    }) {
      var o;
      let l = (o = e.id) != null ? o : `headlessui-listbox-option-${Rn()}`,
        h = Lu("ListboxOption"),
        p = _e(null);
      i({
        el: p,
        $el: p
      });
      let m = Oe(() => h.activeOptionIndex.value !== null ? h.options.value[h.activeOptionIndex.value].id === l : !1),
        k = Oe(() => Ua(h.mode.value, {
          0: () => h.compare(It(h.value.value), It(e.value)),
          1: () => It(h.value.value).some(N => h.compare(It(N), It(e.value)))
        })),
        w = Oe(() => Ua(h.mode.value, {
          1: () => {
            var N;
            let U = It(h.value.value);
            return ((N = h.options.value.find(W => U.some(X => h.compare(It(X), It(W.dataRef.value))))) == null ? void 0 : N.id) === l
          },
          0: () => k.value
        })),
        S = v1(p),
        A = Oe(() => ({
          disabled: e.disabled,
          value: e.value,
          get textValue() {
            return S()
          },
          domRef: p
        }));
      Dt(() => h.registerOption(l, A)), Ha(() => h.unregisterOption(l)), Dt(() => {
        Xt([h.listboxState, k], () => {
          h.listboxState.value === 0 && k.value && Ua(h.mode.value, {
            1: () => {
              w.value && h.goToOption(ua.Specific, l)
            },
            0: () => {
              h.goToOption(ua.Specific, l)
            }
          })
        }, {
          immediate: !0
        })
      }), Er(() => {
        h.listboxState.value === 0 && m.value && h.activationTrigger.value !== 0 && Jt(() => {
          var N, U;
          return (U = (N = wt(p)) == null ? void 0 : N.scrollIntoView) == null ? void 0 : U.call(N, {
            block: "nearest"
          })
        })
      });

      function E(N) {
        if (e.disabled) return N.preventDefault();
        h.select(e.value), h.mode.value === 0 && (h.closeListbox(), Jt(() => {
          var U;
          return (U = wt(h.buttonRef)) == null ? void 0 : U.focus({
            preventScroll: !0
          })
        }))
      }

      function M() {
        if (e.disabled) return h.goToOption(ua.Nothing);
        h.goToOption(ua.Specific, l)
      }
      let D = a1();

      function B(N) {
        D.update(N)
      }

      function z(N) {
        D.wasMoved(N) && (e.disabled || m.value || h.goToOption(ua.Specific, l, 0))
      }

      function I(N) {
        D.wasMoved(N) && (e.disabled || m.value && h.goToOption(ua.Nothing))
      }
      return () => {
        let {
          disabled: N
        } = e, U = {
          active: m.value,
          selected: k.value,
          disabled: N
        }, {
          value: W,
          disabled: X,
          ...V
        } = e, ne = {
          id: l,
          ref: p,
          role: "option",
          tabIndex: N === !0 ? void 0 : -1,
          "aria-disabled": N === !0 ? !0 : void 0,
          "aria-selected": k.value,
          disabled: void 0,
          onClick: E,
          onFocus: M,
          onPointerenter: B,
          onMouseenter: B,
          onPointermove: z,
          onMousemove: z,
          onPointerleave: I,
          onMouseleave: I
        };
        return rr({
          ourProps: ne,
          theirProps: V,
          slot: U,
          attrs: a,
          slots: t,
          name: "ListboxOption"
        })
      }
    }
  });
var JN = (e => (e[e.Open = 0] = "Open", e[e.Closed = 1] = "Closed", e))(JN || {}),
  e5 = (e => (e[e.Pointer = 0] = "Pointer", e[e.Other = 1] = "Other", e))(e5 || {});

function t5(e) {
  requestAnimationFrame(() => requestAnimationFrame(e))
}
let y1 = Symbol("MenuContext");

function Ou(e) {
  let t = fa(y1, null);
  if (t === null) {
    let a = new Error(`<${e} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(a, Ou), a
  }
  return t
}
let a5 = Ot({
    name: "Menu",
    props: {
      as: {
        type: [Object, String],
        default: "template"
      }
    },
    setup(e, {
      slots: t,
      attrs: a
    }) {
      let i = _e(1),
        o = _e(null),
        l = _e(null),
        h = _e([]),
        p = _e(""),
        m = _e(null),
        k = _e(1);

      function w(A = E => E) {
        let E = m.value !== null ? h.value[m.value] : null,
          M = up(A(h.value.slice()), B => wt(B.dataRef.domRef)),
          D = E ? M.indexOf(E) : null;
        return D === -1 && (D = null), {
          items: M,
          activeItemIndex: D
        }
      }
      let S = {
        menuState: i,
        buttonRef: o,
        itemsRef: l,
        items: h,
        searchQuery: p,
        activeItemIndex: m,
        activationTrigger: k,
        closeMenu: () => {
          i.value = 1, m.value = null
        },
        openMenu: () => i.value = 0,
        goToItem(A, E, M) {
          let D = w(),
            B = s1(A === ua.Specific ? {
              focus: ua.Specific,
              id: E
            } : {
              focus: A
            }, {
              resolveItems: () => D.items,
              resolveActiveIndex: () => D.activeItemIndex,
              resolveId: z => z.id,
              resolveDisabled: z => z.dataRef.disabled
            });
          p.value = "", m.value = B, k.value = M ?? 1, h.value = D.items
        },
        search(A) {
          let E = p.value !== "" ? 0 : 1;
          p.value += A.toLowerCase();
          let M = (m.value !== null ? h.value.slice(m.value + E).concat(h.value.slice(0, m.value + E)) : h.value).find(B => B.dataRef.textValue.startsWith(p.value) && !B.dataRef.disabled),
            D = M ? h.value.indexOf(M) : -1;
          D === -1 || D === m.value || (m.value = D, k.value = 1)
        },
        clearSearch() {
          p.value = ""
        },
        registerItem(A, E) {
          let M = w(D => [...D, {
            id: A,
            dataRef: E
          }]);
          h.value = M.items, m.value = M.activeItemIndex, k.value = 1
        },
        unregisterItem(A) {
          let E = w(M => {
            let D = M.findIndex(B => B.id === A);
            return D !== -1 && M.splice(D, 1), M
          });
          h.value = E.items, m.value = E.activeItemIndex, k.value = 1
        }
      };
      return dp([o, l], (A, E) => {
        var M;
        S.closeMenu(), Pu(E, Eu.Loose) || (A.preventDefault(), (M = wt(o)) == null || M.focus())
      }, Oe(() => i.value === 0)), vr(y1, S), fp(Oe(() => Ua(i.value, {
        0: Ra.Open,
        1: Ra.Closed
      }))), () => {
        let A = {
          open: i.value === 0,
          close: S.closeMenu
        };
        return rr({
          ourProps: {},
          theirProps: e,
          slot: A,
          slots: t,
          attrs: a,
          name: "Menu"
        })
      }
    }
  }),
  r5 = Ot({
    name: "MenuButton",
    props: {
      disabled: {
        type: Boolean,
        default: !1
      },
      as: {
        type: [Object, String],
        default: "button"
      },
      id: {
        type: String,
        default: null
      }
    },
    setup(e, {
      attrs: t,
      slots: a,
      expose: i
    }) {
      var o;
      let l = (o = e.id) != null ? o : `headlessui-menu-button-${Rn()}`,
        h = Ou("MenuButton");
      i({
        el: h.buttonRef,
        $el: h.buttonRef
      });

      function p(S) {
        switch (S.key) {
          case jt.Space:
          case jt.Enter:
          case jt.ArrowDown:
            S.preventDefault(), S.stopPropagation(), h.openMenu(), Jt(() => {
              var A;
              (A = wt(h.itemsRef)) == null || A.focus({
                preventScroll: !0
              }), h.goToItem(ua.First)
            });
            break;
          case jt.ArrowUp:
            S.preventDefault(), S.stopPropagation(), h.openMenu(), Jt(() => {
              var A;
              (A = wt(h.itemsRef)) == null || A.focus({
                preventScroll: !0
              }), h.goToItem(ua.Last)
            });
            break
        }
      }

      function m(S) {
        switch (S.key) {
          case jt.Space:
            S.preventDefault();
            break
        }
      }

      function k(S) {
        e.disabled || (h.menuState.value === 0 ? (h.closeMenu(), Jt(() => {
          var A;
          return (A = wt(h.buttonRef)) == null ? void 0 : A.focus({
            preventScroll: !0
          })
        })) : (S.preventDefault(), h.openMenu(), t5(() => {
          var A;
          return (A = wt(h.itemsRef)) == null ? void 0 : A.focus({
            preventScroll: !0
          })
        })))
      }
      let w = t1(Oe(() => ({
        as: e.as,
        type: t.type
      })), h.buttonRef);
      return () => {
        var S;
        let A = {
            open: h.menuState.value === 0
          },
          {
            ...E
          } = e,
          M = {
            ref: h.buttonRef,
            id: l,
            type: w.value,
            "aria-haspopup": "menu",
            "aria-controls": (S = wt(h.itemsRef)) == null ? void 0 : S.id,
            "aria-expanded": h.menuState.value === 0,
            onKeydown: p,
            onKeyup: m,
            onClick: k
          };
        return rr({
          ourProps: M,
          theirProps: E,
          slot: A,
          attrs: t,
          slots: a,
          name: "MenuButton"
        })
      }
    }
  }),
  n5 = Ot({
    name: "MenuItems",
    props: {
      as: {
        type: [Object, String],
        default: "div"
      },
      static: {
        type: Boolean,
        default: !1
      },
      unmount: {
        type: Boolean,
        default: !0
      },
      id: {
        type: String,
        default: null
      }
    },
    setup(e, {
      attrs: t,
      slots: a,
      expose: i
    }) {
      var o;
      let l = (o = e.id) != null ? o : `headlessui-menu-items-${Rn()}`,
        h = Ou("MenuItems"),
        p = _e(null);
      i({
        el: h.itemsRef,
        $el: h.itemsRef
      }), uN({
        container: Oe(() => wt(h.itemsRef)),
        enabled: Oe(() => h.menuState.value === 0),
        accept(A) {
          return A.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : A.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT
        },
        walk(A) {
          A.setAttribute("role", "none")
        }
      });

      function m(A) {
        var E;
        switch (p.value && clearTimeout(p.value), A.key) {
          case jt.Space:
            if (h.searchQuery.value !== "") return A.preventDefault(), A.stopPropagation(), h.search(A.key);
          case jt.Enter:
            if (A.preventDefault(), A.stopPropagation(), h.activeItemIndex.value !== null) {
              let M = h.items.value[h.activeItemIndex.value];
              (E = wt(M.dataRef.domRef)) == null || E.click()
            }
            h.closeMenu(), Qx(wt(h.buttonRef));
            break;
          case jt.ArrowDown:
            return A.preventDefault(), A.stopPropagation(), h.goToItem(ua.Next);
          case jt.ArrowUp:
            return A.preventDefault(), A.stopPropagation(), h.goToItem(ua.Previous);
          case jt.Home:
          case jt.PageUp:
            return A.preventDefault(), A.stopPropagation(), h.goToItem(ua.First);
          case jt.End:
          case jt.PageDown:
            return A.preventDefault(), A.stopPropagation(), h.goToItem(ua.Last);
          case jt.Escape:
            A.preventDefault(), A.stopPropagation(), h.closeMenu(), Jt(() => {
              var M;
              return (M = wt(h.buttonRef)) == null ? void 0 : M.focus({
                preventScroll: !0
              })
            });
            break;
          case jt.Tab:
            A.preventDefault(), A.stopPropagation(), h.closeMenu(), Jt(() => oN(wt(h.buttonRef), A.shiftKey ? En.Previous : En.Next));
            break;
          default:
            A.key.length === 1 && (h.search(A.key), p.value = setTimeout(() => h.clearSearch(), 350));
            break
        }
      }

      function k(A) {
        switch (A.key) {
          case jt.Space:
            A.preventDefault();
            break
        }
      }
      let w = $l(),
        S = Oe(() => w !== null ? (w.value & Ra.Open) === Ra.Open : h.menuState.value === 0);
      return () => {
        var A, E;
        let M = {
            open: h.menuState.value === 0
          },
          {
            ...D
          } = e,
          B = {
            "aria-activedescendant": h.activeItemIndex.value === null || (A = h.items.value[h.activeItemIndex.value]) == null ? void 0 : A.id,
            "aria-labelledby": (E = wt(h.buttonRef)) == null ? void 0 : E.id,
            id: l,
            onKeydown: m,
            onKeyup: k,
            role: "menu",
            tabIndex: 0,
            ref: h.itemsRef
          };
        return rr({
          ourProps: B,
          theirProps: D,
          slot: M,
          attrs: t,
          slots: a,
          features: Ei.RenderStrategy | Ei.Static,
          visible: S.value,
          name: "MenuItems"
        })
      }
    }
  }),
  i5 = Ot({
    name: "MenuItem",
    inheritAttrs: !1,
    props: {
      as: {
        type: [Object, String],
        default: "template"
      },
      disabled: {
        type: Boolean,
        default: !1
      },
      id: {
        type: String,
        default: null
      }
    },
    setup(e, {
      slots: t,
      attrs: a,
      expose: i
    }) {
      var o;
      let l = (o = e.id) != null ? o : `headlessui-menu-item-${Rn()}`,
        h = Ou("MenuItem"),
        p = _e(null);
      i({
        el: p,
        $el: p
      });
      let m = Oe(() => h.activeItemIndex.value !== null ? h.items.value[h.activeItemIndex.value].id === l : !1),
        k = v1(p),
        w = Oe(() => ({
          disabled: e.disabled,
          get textValue() {
            return k()
          },
          domRef: p
        }));
      Dt(() => h.registerItem(l, w)), Ha(() => h.unregisterItem(l)), Er(() => {
        h.menuState.value === 0 && m.value && h.activationTrigger.value !== 0 && Jt(() => {
          var z, I;
          return (I = (z = wt(p)) == null ? void 0 : z.scrollIntoView) == null ? void 0 : I.call(z, {
            block: "nearest"
          })
        })
      });

      function S(z) {
        if (e.disabled) return z.preventDefault();
        h.closeMenu(), Qx(wt(h.buttonRef))
      }

      function A() {
        if (e.disabled) return h.goToItem(ua.Nothing);
        h.goToItem(ua.Specific, l)
      }
      let E = a1();

      function M(z) {
        E.update(z)
      }

      function D(z) {
        E.wasMoved(z) && (e.disabled || m.value || h.goToItem(ua.Specific, l, 0))
      }

      function B(z) {
        E.wasMoved(z) && (e.disabled || m.value && h.goToItem(ua.Nothing))
      }
      return () => {
        let {
          disabled: z,
          ...I
        } = e, N = {
          active: m.value,
          disabled: z,
          close: h.closeMenu
        };
        return rr({
          ourProps: {
            id: l,
            ref: p,
            role: "menuitem",
            tabIndex: z === !0 ? void 0 : -1,
            "aria-disabled": z === !0 ? !0 : void 0,
            onClick: S,
            onFocus: A,
            onPointerenter: M,
            onMouseenter: M,
            onPointermove: D,
            onMousemove: D,
            onPointerleave: B,
            onMouseleave: B
          },
          theirProps: {
            ...a,
            ...I
          },
          slot: N,
          attrs: a,
          slots: t,
          name: "MenuItem"
        })
      }
    }
  });

function s5(e) {
  let t = {
    called: !1
  };
  return (...a) => {
    if (!t.called) return t.called = !0, e(...a)
  }
}

function Gd(e, ...t) {
  e && t.length > 0 && e.classList.add(...t)
}

function lc(e, ...t) {
  e && t.length > 0 && e.classList.remove(...t)
}
var Wh = (e => (e.Finished = "finished", e.Cancelled = "cancelled", e))(Wh || {});

function o5(e, t) {
  let a = Nl();
  if (!e) return a.dispose;
  let {
    transitionDuration: i,
    transitionDelay: o
  } = getComputedStyle(e), [l, h] = [i, o].map(p => {
    let [m = 0] = p.split(",").filter(Boolean).map(k => k.includes("ms") ? parseFloat(k) : parseFloat(k) * 1e3).sort((k, w) => w - k);
    return m
  });
  return l !== 0 ? a.setTimeout(() => t("finished"), l + h) : t("finished"), a.add(() => t("cancelled")), a.dispose
}

function cv(e, t, a, i, o, l) {
  let h = Nl(),
    p = l !== void 0 ? s5(l) : () => {};
  return lc(e, ...o), Gd(e, ...t, ...a), h.nextFrame(() => {
    lc(e, ...a), Gd(e, ...i), h.add(o5(e, m => (lc(e, ...i, ...t), Gd(e, ...o), p(m))))
  }), h.add(() => lc(e, ...t, ...a, ...i, ...o)), h.add(() => p("cancelled")), h.dispose
}

function qi(e = "") {
  return e.split(/\s+/).filter(t => t.length > 1)
}
let gp = Symbol("TransitionContext");
var l5 = (e => (e.Visible = "visible", e.Hidden = "hidden", e))(l5 || {});

function c5() {
  return fa(gp, null) !== null
}

function u5() {
  let e = fa(gp, null);
  if (e === null) throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
  return e
}

function d5() {
  let e = fa(mp, null);
  if (e === null) throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />.");
  return e
}
let mp = Symbol("NestingContext");

function Mu(e) {
  return "children" in e ? Mu(e.children) : e.value.filter(({
    state: t
  }) => t === "visible").length > 0
}

function x1(e) {
  let t = _e([]),
    a = _e(!1);
  Dt(() => a.value = !0), Ha(() => a.value = !1);

  function i(l, h = xi.Hidden) {
    let p = t.value.findIndex(({
      id: m
    }) => m === l);
    p !== -1 && (Ua(h, {
      [xi.Unmount]() {
        t.value.splice(p, 1)
      },
      [xi.Hidden]() {
        t.value[p].state = "hidden"
      }
    }), !Mu(t) && a.value && (e == null || e()))
  }

  function o(l) {
    let h = t.value.find(({
      id: p
    }) => p === l);
    return h ? h.state !== "visible" && (h.state = "visible") : t.value.push({
      id: l,
      state: "visible"
    }), () => i(l, xi.Unmount)
  }
  return {
    children: t,
    register: o,
    unregister: i
  }
}
let w1 = Ei.RenderStrategy,
  Vh = Ot({
    props: {
      as: {
        type: [Object, String],
        default: "div"
      },
      show: {
        type: [Boolean],
        default: null
      },
      unmount: {
        type: [Boolean],
        default: !0
      },
      appear: {
        type: [Boolean],
        default: !1
      },
      enter: {
        type: [String],
        default: ""
      },
      enterFrom: {
        type: [String],
        default: ""
      },
      enterTo: {
        type: [String],
        default: ""
      },
      entered: {
        type: [String],
        default: ""
      },
      leave: {
        type: [String],
        default: ""
      },
      leaveFrom: {
        type: [String],
        default: ""
      },
      leaveTo: {
        type: [String],
        default: ""
      }
    },
    emits: {
      beforeEnter: () => !0,
      afterEnter: () => !0,
      beforeLeave: () => !0,
      afterLeave: () => !0
    },
    setup(e, {
      emit: t,
      attrs: a,
      slots: i,
      expose: o
    }) {
      let l = _e(0);

      function h() {
        l.value |= Ra.Opening, t("beforeEnter")
      }

      function p() {
        l.value &= ~Ra.Opening, t("afterEnter")
      }

      function m() {
        l.value |= Ra.Closing, t("beforeLeave")
      }

      function k() {
        l.value &= ~Ra.Closing, t("afterLeave")
      }
      if (!c5() && fN()) return () => oa(k1, {
        ...e,
        onBeforeEnter: h,
        onAfterEnter: p,
        onBeforeLeave: m,
        onAfterLeave: k
      }, i);
      let w = _e(null),
        S = Oe(() => e.unmount ? xi.Unmount : xi.Hidden);
      o({
        el: w,
        $el: w
      });
      let {
        show: A,
        appear: E
      } = u5(), {
        register: M,
        unregister: D
      } = d5(), B = _e(A.value ? "visible" : "hidden"), z = {
        value: !0
      }, I = Rn(), N = {
        value: !1
      }, U = x1(() => {
        !N.value && B.value !== "hidden" && (B.value = "hidden", D(I), k())
      });
      Dt(() => {
        let Ee = M(I);
        Ha(Ee)
      }), Er(() => {
        if (S.value === xi.Hidden && I) {
          if (A.value && B.value !== "visible") {
            B.value = "visible";
            return
          }
          Ua(B.value, {
            hidden: () => D(I),
            visible: () => M(I)
          })
        }
      });
      let W = qi(e.enter),
        X = qi(e.enterFrom),
        V = qi(e.enterTo),
        ne = qi(e.entered),
        Z = qi(e.leave),
        ie = qi(e.leaveFrom),
        fe = qi(e.leaveTo);
      Dt(() => {
        Er(() => {
          if (B.value === "visible") {
            let Ee = wt(w);
            if (Ee instanceof Comment && Ee.data === "") throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?")
          }
        })
      });

      function le(Ee) {
        let ye = z.value && !E.value,
          ve = wt(w);
        !ve || !(ve instanceof HTMLElement) || ye || (N.value = !0, A.value && h(), A.value || m(), Ee(A.value ? cv(ve, W, X, V, ne, me => {
          N.value = !1, me === Wh.Finished && p()
        }) : cv(ve, Z, ie, fe, ne, me => {
          N.value = !1, me === Wh.Finished && (Mu(U) || (B.value = "hidden", D(I), k()))
        })))
      }
      return Dt(() => {
        Xt([A], (Ee, ye, ve) => {
          le(ve), z.value = !1
        }, {
          immediate: !0
        })
      }), vr(mp, U), fp(Oe(() => Ua(B.value, {
        visible: Ra.Open,
        hidden: Ra.Closed
      }) | l.value)), () => {
        let {
          appear: Ee,
          show: ye,
          enter: ve,
          enterFrom: me,
          enterTo: Ae,
          entered: He,
          leave: De,
          leaveFrom: Ye,
          leaveTo: Je,
          ...he
        } = e, ke = {
          ref: w
        }, re = {
          ...he,
          ...E.value && A.value && Fl.isServer ? {
            class: ut([a.class, he.class, ...W, ...X])
          } : {}
        };
        return rr({
          theirProps: re,
          ourProps: ke,
          slot: {},
          slots: i,
          attrs: a,
          features: w1,
          visible: B.value === "visible",
          name: "TransitionChild"
        })
      }
    }
  }),
  h5 = Vh,
  k1 = Ot({
    inheritAttrs: !1,
    props: {
      as: {
        type: [Object, String],
        default: "div"
      },
      show: {
        type: [Boolean],
        default: null
      },
      unmount: {
        type: [Boolean],
        default: !0
      },
      appear: {
        type: [Boolean],
        default: !1
      },
      enter: {
        type: [String],
        default: ""
      },
      enterFrom: {
        type: [String],
        default: ""
      },
      enterTo: {
        type: [String],
        default: ""
      },
      entered: {
        type: [String],
        default: ""
      },
      leave: {
        type: [String],
        default: ""
      },
      leaveFrom: {
        type: [String],
        default: ""
      },
      leaveTo: {
        type: [String],
        default: ""
      }
    },
    emits: {
      beforeEnter: () => !0,
      afterEnter: () => !0,
      beforeLeave: () => !0,
      afterLeave: () => !0
    },
    setup(e, {
      emit: t,
      attrs: a,
      slots: i
    }) {
      let o = $l(),
        l = Oe(() => e.show === null && o !== null ? (o.value & Ra.Open) === Ra.Open : e.show);
      Er(() => {
        if (![!0, !1].includes(l.value)) throw new Error('A <Transition /> is used but it is missing a `:show="true | false"` prop.')
      });
      let h = _e(l.value ? "visible" : "hidden"),
        p = x1(() => {
          h.value = "hidden"
        }),
        m = _e(!0),
        k = {
          show: l,
          appear: Oe(() => e.appear || !m.value)
        };
      return Dt(() => {
        Er(() => {
          m.value = !1, l.value ? h.value = "visible" : Mu(p) || (h.value = "hidden")
        })
      }), vr(mp, p), vr(gp, k), () => {
        let w = hp(e, ["show", "appear", "unmount", "onBeforeEnter", "onBeforeLeave", "onAfterEnter", "onAfterLeave"]),
          S = {
            unmount: e.unmount
          };
        return rr({
          ourProps: {
            ...S,
            as: "template"
          },
          theirProps: {},
          slot: {},
          slots: {
            ...i,
            default: () => [oa(h5, {
              onBeforeEnter: () => t("beforeEnter"),
              onAfterEnter: () => t("afterEnter"),
              onBeforeLeave: () => t("beforeLeave"),
              onAfterLeave: () => t("afterLeave"),
              ...a,
              ...S,
              ...w
            }, i.default)]
          },
          attrs: {},
          features: w1,
          visible: h.value === "visible",
          name: "Transition"
        })
      }
    }
  });

function f5(e, t) {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [ce("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"
  })])
}
const p5 = ce("div", {
    class: "fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"
  }, null, -1),
  g5 = {
    class: "fixed inset-0 z-10 w-screen overflow-y-auto"
  },
  m5 = {
    class: "flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0"
  },
  v5 = {
    class: "bg-white px-4 pb-4 pt-5 sm:p-6 sm:pb-4"
  },
  b5 = {
    class: "sm:flex sm:items-start"
  },
  y5 = {
    class: "mx-auto flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-full bg-red-100 sm:mx-0 sm:h-10 sm:w-10"
  },
  x5 = {
    class: "mt-3 text-center sm:ml-4 sm:mt-0 sm:text-left"
  },
  w5 = {
    class: "mt-2"
  },
  k5 = {
    class: "text-sm text-gray-500"
  },
  _5 = {
    class: "bg-gray-50 px-4 py-3 sm:flex sm:flex-row-reverse sm:px-6"
  },
  S5 = {
    key: 1,
    type: "button",
    class: "inline-flex w-full justify-center rounded-md bg-gray-400 px-3 py-2 text-sm font-semibold text-white sm:ml-3 sm:w-auto"
  },
  A5 = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "currentColor",
    d: "M12 2A10 10 0 1 0 22 12A10 10 0 0 0 12 2Zm0 18a8 8 0 1 1 8-8A8 8 0 0 1 12 20Z",
    opacity: ".5"
  }), ce("path", {
    fill: "currentColor",
    d: "M20 12h2A10 10 0 0 0 12 2V4A8 8 0 0 1 20 12Z"
  }, [ce("animateTransform", {
    attributeName: "transform",
    dur: "1s",
    from: "0 12 12",
    repeatCount: "indefinite",
    to: "360 12 12",
    type: "rotate"
  })])], -1),
  C5 = [A5],
  _1 = {
    __name: "AlertModal",
    props: {
      modelValue: Boolean,
      label: String,
      description: String
    },
    emits: ["update:modelValue", "confirm"],
    setup(e, {
      emit: t
    }) {
      const a = e,
        i = _e(!1),
        o = t;

      function l() {
        i.value = !0, setTimeout(() => {
          o("confirm"), i.value = !1
        }, 1e3)
      }

      function h() {
        o("update:modelValue", !1)
      }
      return (p, m) => (be(), yt(se(k1), {
        as: "template",
        show: e.modelValue
      }, {
        default: Qe(() => [Ze(se(HN), {
          as: "div",
          class: "relative z-10",
          onClose: m[1] || (m[1] = k => p.open = !1)
        }, {
          default: Qe(() => [Ze(se(Vh), {
            as: "template",
            enter: "ease-out duration-300",
            "enter-from": "opacity-0",
            "enter-to": "opacity-100",
            leave: "ease-in duration-200",
            "leave-from": "opacity-100",
            "leave-to": "opacity-0"
          }, {
            default: Qe(() => [p5]),
            _: 1
          }), ce("div", g5, [ce("div", m5, [Ze(se(Vh), {
            as: "template",
            enter: "ease-out duration-300",
            "enter-from": "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95",
            "enter-to": "opacity-100 translate-y-0 sm:scale-100",
            leave: "ease-in duration-200",
            "leave-from": "opacity-100 translate-y-0 sm:scale-100",
            "leave-to": "opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
          }, {
            default: Qe(() => [Ze(se(YN), {
              class: "relative transform overflow-hidden rounded-lg bg-white text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg"
            }, {
              default: Qe(() => [ce("div", v5, [ce("div", b5, [ce("div", y5, [Ze(se(f5), {
                class: "h-6 w-6 text-red-600",
                "aria-hidden": "true"
              })]), ce("div", x5, [Ze(se(zN), {
                as: "h3",
                class: "text-base font-semibold leading-6 text-gray-900"
              }, {
                default: Qe(() => [$t(st(a.label), 1)]),
                _: 1
              }), ce("div", w5, [ce("p", k5, st(a.description), 1)])])])]), ce("div", _5, [i.value ? (be(), Ne("button", S5, C5)) : (be(), Ne("button", {
                key: 0,
                type: "button",
                class: "inline-flex w-full justify-center rounded-md bg-red-600 px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-red-500 sm:ml-3 sm:w-auto",
                onClick: m[0] || (m[0] = qn(k => l(), ["stop"]))
              }, st(p.$t("Delete")), 1)), ce("button", {
                type: "button",
                class: "mt-3 inline-flex w-full justify-center rounded-md bg-white px-3 py-2 text-sm font-semibold text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50 sm:mt-0 sm:w-auto",
                onClick: qn(h, ["self"]),
                ref: "cancelButtonRef"
              }, st(p.$t("Cancel")), 513)])]),
              _: 1
            })]),
            _: 1
          })])])]),
          _: 1
        })]),
        _: 1
      }, 8, ["show"]))
    }
  };

function S1() {
  const e = _e(!1),
    t = _e(null);

  function a(o) {
    e.value = !0, t.value = o
  }
  async function i(o) {
    try {
      e.value = !1, await o(t.value)
    } catch {}
    t.value = null
  }
  return {
    isOpenAlert: e,
    selectedItem: t,
    openAlert: a,
    confirmAlert: i
  }
}
const T5 = {
    name: "Pagination",
    props: {
      pagination: {
        type: Object,
        default: () => ({
          total: 0,
          per_page: 10,
          current_page: 1,
          last_page: 1
        })
      }
    },
    data() {
      var e;
      return {
        page: ((e = this.pagination) == null ? void 0 : e.current_page) || 1
      }
    },
    watch: {
      "pagination.current_page": function (e) {
        this.page = e
      }
    },
    methods: {
      loadPage(e) {
        this.$emit("page-changed", e)
      }
    },
    computed: {
      noPreviousPage() {
        return this.pagination && this.pagination.current_page - 1 <= 0
      },
      noNextPage() {
        return this.pagination && this.pagination.current_page + 1 > this.pagination.last_page
      }
    }
  },
  E5 = {
    class: "inline-flex justify-center items-center"
  },
  P5 = {
    key: 0,
    class: "hidden mr-2 text-sm text-gray-600 lg:block"
  },
  L5 = {
    key: 1,
    class: "flex space-x-1 items-top"
  },
  O5 = ["disabled"],
  M5 = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    class: "w-4 h-4 lg:h-3 lg:w-3",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, [ce("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M11 19l-7-7 7-7m8 14l-7-7 7-7"
  })], -1),
  I5 = [M5],
  R5 = ["disabled"],
  D5 = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    class: "w-4 h-4 lg:h-3 lg:w-3",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, [ce("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M15 19l-7-7 7-7"
  })], -1),
  N5 = [D5],
  F5 = {
    class: "flex flex-row items-center space-x-1"
  },
  $5 = {
    class: "pl-2 text-gray-600 lg:text-sm"
  },
  B5 = {
    class: "pr-2 text-gray-600 lg:text-sm"
  },
  H5 = ["disabled"],
  Y5 = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    class: "w-4 h-4 lg:h-3 lg:w-3",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, [ce("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M9 5l7 7-7 7"
  })], -1),
  z5 = [Y5],
  X5 = ["disabled"],
  W5 = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    class: "w-4 h-4 lg:h-3 lg:w-3",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, [ce("path", {
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M13 5l7 7-7 7M5 5l7 7-7 7"
  })], -1),
  V5 = [W5];

function j5(e, t, a, i, o, l) {
  return be(), Ne("div", E5, [a.pagination.last_page > 1 ? (be(), Ne("div", P5, st(a.pagination.total) + " items", 1)) : Ke("", !0), a.pagination.last_page > 1 ? (be(), Ne("div", L5, [ce("button", {
    disabled: l.noPreviousPage,
    class: ut([{
      "opacity-50": l.noPreviousPage
    }, "inline-flex justify-center items-center w-11 h-11 text-gray-700 bg-white rounded border border-gray-200 shadow-sm outline-none hover:bg-gray-50 lg:h-9 lg:w-9 lg:text-sm focus:ring-1 focus:ring-blue-500 focus:border-blue-500"]),
    onClick: t[0] || (t[0] = h => l.loadPage(1))
  }, I5, 10, O5), ce("button", {
    disabled: l.noPreviousPage,
    class: ut([{
      "opacity-50": l.noPreviousPage
    }, "inline-flex justify-center items-center w-11 h-11 text-gray-700 bg-white rounded border border-gray-200 shadow-sm outline-none hover:bg-gray-50 lg:h-9 lg:w-9 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"]),
    onClick: t[1] || (t[1] = h => l.loadPage(a.pagination.current_page - 1))
  }, N5, 10, R5), ce("div", F5, [ce("div", $5, st(o.page), 1), ce("div", B5, "of " + st(a.pagination.last_page), 1)]), ce("button", {
    disabled: l.noNextPage,
    class: ut([{
      "opacity-50": l.noNextPage
    }, "inline-flex justify-center items-center w-11 h-11 text-gray-700 bg-white rounded border border-gray-300 shadow-sm outline-none hover:bg-gray-50 lg:h-9 lg:w-9 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"]),
    onClick: t[2] || (t[2] = h => l.loadPage(a.pagination.current_page + 1))
  }, z5, 10, H5), ce("button", {
    disabled: l.noNextPage,
    class: ut([{
      "opacity-50": l.noNextPage
    }, "inline-flex justify-center items-center w-11 h-11 text-gray-700 bg-white rounded border border-gray-300 shadow-sm outline-none hover:bg-gray-50 lg:h-9 lg:w-9 focus:ring-1 focus:ring-blue-500 focus:border-blue-500"]),
    onClick: t[3] || (t[3] = h => l.loadPage(a.pagination.last_page))
  }, V5, 10, X5)])) : Ke("", !0)])
}
const A1 = ys(T5, [
    ["render", j5]
  ]),
  U5 = {
    class: "w-full"
  },
  C1 = {
    __name: "Table",
    props: {
      rows: Object,
      className: String
    },
    setup(e) {
      return (t, a) => (be(), Ne(vt, null, [ce("div", {
        class: ut(["bg-slate-100 md:bg-white rounded-[0.5rem]", e.className])
      }, [ce("table", U5, [lt(t.$slots, "default")])], 2), Ze(A1, {
        class: "mt-3",
        pagination: e.rows.meta
      }, null, 8, ["pagination"])], 64))
    }
  },
  G5 = {},
  q5 = {
    class: "md:table-header-group hidden"
  };

function K5(e, t) {
  return be(), Ne("thead", q5, [lt(e.$slots, "default")])
}
const T1 = ys(G5, [
    ["render", K5]
  ]),
  Z5 = {},
  Q5 = {
    class: "text-sm tracking-[0.1px]"
  };

function J5(e, t) {
  return be(), Ne("tr", Q5, [lt(e.$slots, "default")])
}
const E1 = ys(Z5, [
    ["render", J5]
  ]),
  Wr = {
    __name: "TableHeaderRowItem",
    props: {
      position: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e,
        a = () => t.position === "first" ? "font-normal pl-4 py-4 text-left" : t.position === "last" ? "pr-4" : "font-normal py-4 text-left";
      return (i, o) => (be(), Ne("th", {
        class: ut(a())
      }, [lt(i.$slots, "default")], 2))
    }
  },
  eF = {};

function tF(e, t) {
  return be(), Ne("tbody", null, [lt(e.$slots, "default")])
}
const P1 = ys(eF, [
    ["render", tF]
  ]),
  aF = {},
  rF = {
    class: "hover:bg-slate-50 md:border-b-0 md:border-t border-[#d1d5db] text-sm"
  };

function nF(e, t) {
  return be(), Ne("tr", rF, [lt(e.$slots, "default")])
}
const L1 = ys(aF, [
    ["render", nF]
  ]),
  iF = {
    class: "text-left w-full h-full"
  },
  Vr = {
    __name: "TableBodyRowItem",
    props: {
      position: {
        type: String,
        default: null
      }
    },
    setup(e) {
      const t = e,
        a = () => {
          if (t.position === "first") return "pl-4 py-4";
          if (t.position === "last") return "pr-4 float-right"
        };
      return (i, o) => (be(), Ne("td", {
        class: ut(a())
      }, [ce("div", iF, [lt(i.$slots, "default")])], 2))
    }
  },
  O1 = {
    __name: "Dropdown",
    props: {
      align: {
        type: String,
        default: "right"
      }
    },
    setup(e) {
      const t = e;
      return (a, i) => (be(), yt(se(a5), {
        as: "div",
        class: "relative inline-block text-left"
      }, {
        default: Qe(() => [ce("div", null, [Ze(se(r5), {
          as: "template"
        }, {
          default: Qe(() => [lt(a.$slots, "default")]),
          _: 3
        })]), Ze(In, {
          "enter-active-class": "transition duration-100 ease-out",
          "enter-from-class": "transform scale-95 opacity-0",
          "enter-to-class": "transform scale-100 opacity-100",
          "leave-active-class": "transition duration-75 ease-in",
          "leave-from-class": "transform scale-100 opacity-100",
          "leave-to-class": "transform scale-95 opacity-0"
        }, {
          default: Qe(() => [Ze(se(n5), {
            class: ut([{
              "right-0 origin-top-right": t.align === "right",
              "left-0 origin-top-left": t.align === "left",
              "top-[-135px] left-0 origin-top-left": t.align === "top-left"
            }, "z-10 absolute mt-2 w-32 divide-y divide-gray-100 rounded-md bg-white shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none"])
          }, {
            default: Qe(() => [lt(a.$slots, "items")]),
            _: 3
          }, 8, ["class"])]),
          _: 3
        })]),
        _: 3
      }))
    }
  },
  sF = {
    class: "px-1 py-1"
  },
  M1 = {
    __name: "DropdownItemGroup",
    setup(e) {
      return (t, a) => (be(), Ne("div", sF, [lt(t.$slots, "default")]))
    }
  },
  jc = {
    __name: "DropdownItem",
    props: {
      as: {
        type: String,
        default: "a"
      }
    },
    setup(e) {
      const t = e;
      return (a, i) => (be(), yt(se(i5), null, {
        default: Qe(({
          active: o
        }) => [t.as != "a" ? (be(), yt(Al(t.as), {
          key: 0,
          class: ut([o ? "bg-blue-700 text-white" : "text-gray-900", "group flex w-full rounded-md px-2 py-2 text-sm text-left"])
        }, {
          default: Qe(() => [lt(a.$slots, "default")]),
          _: 2
        }, 1032, ["class"])) : (be(), yt(se(Wx), {
          key: 1,
          is: t.as,
          class: ut([o ? "bg-blue-700 text-white" : "text-gray-900", "group flex w-full rounded-md px-2 py-2 text-sm"])
        }, {
          default: Qe(() => [lt(a.$slots, "default")]),
          _: 2
        }, 1032, ["is", "class"]))]),
        _: 3
      }))
    }
  },
  oF = {
    class: "flex items-center gap-x-3"
  },
  lF = ["src"],
  cF = {
    key: 1,
    class: "h-20 w-20 text-gray-300",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true"
  },
  uF = ce("path", {
    "fill-rule": "evenodd",
    d: "M18.685 19.097A9.723 9.723 0 0021.75 12c0-5.385-4.365-9.75-9.75-9.75S2.25 6.615 2.25 12a9.723 9.723 0 003.065 7.097A9.716 9.716 0 0012 21.75a9.716 9.716 0 006.685-2.653zm-12.54-1.285A7.486 7.486 0 0112 15a7.486 7.486 0 015.855 2.812A8.224 8.224 0 0112 20.25a8.224 8.224 0 01-5.855-2.438zM15.75 9a3.75 3.75 0 11-7.5 0 3.75 3.75 0 017.5 0z",
    "clip-rule": "evenodd"
  }, null, -1),
  dF = [uF],
  hF = ["disabled"],
  fF = {
    for: "file-upload",
    class: "cursor-pointer rounded-md bg-white px-2.5 py-1.5 text-sm text-gray-900 shadow-sm ring-1 ring-inset ring-gray-300 hover:bg-gray-50"
  },
  pF = {
    key: 0,
    class: "form-error text-[#b91c1c] text-xs"
  },
  gF = {
    __name: "FormImage",
    props: {
      modelValue: File,
      name: String,
      label: String,
      className: String,
      error: String,
      disabled: Boolean,
      imageUrl: String
    },
    emits: ["update:modelValue"],
    setup(e, {
      emit: t
    }) {
      const a = e,
        i = _e(a.imageUrl),
        o = t,
        l = h => {
          const m = h.target.files[0];
          if (m && m.size > 5242880) alert("File size exceeds the limit. Max allowed size: 5242880 bytes"), h.target.value = null;
          else {
            const k = new FileReader;
            k.onload = w => {
              i.value = w.target.result
            }, o("update:modelValue", m), k.readAsDataURL(m)
          }
        };
      return (h, p) => (be(), Ne("div", {
        class: ut(e.className)
      }, [ce("div", oF, [i.value ? (be(), Ne("img", {
        key: 0,
        src: i.value,
        alt: "",
        class: "w-20 h-20 rounded-full dark:bg-gray-500"
      }, null, 8, lF)) : (be(), Ne("svg", cF, dF)), ce("input", {
        type: "file",
        class: "sr-only",
        accept: ".png, .jpg",
        id: "file-upload",
        onChange: l,
        disabled: e.disabled
      }, null, 40, hF), ce("label", fF, st(a.label), 1)]), e.error ? (be(), Ne("div", pF, st(e.error), 1)) : Ke("", !0)], 2))
    }
  },
  mF = {
    style: {
      padding: "1px"
    },
    class: "outline-none focus-none focus-within-none block w-full rounded-md border-0 text-gray-900 shadow-sm ring-1 ring-gray-300 ring-inset placeholder:text-gray-400 sm:text-sm sm:leading-6"
  },
  vF = {
    key: 0,
    class: "form-error text-[#b91c1c] text-xs"
  },
  bF = {
    __name: "FormPhoneInput",
    props: {
      modelValue: [String, Number],
      name: String,
      type: String,
      className: String,
      labelClass: String,
      required: Boolean,
      error: String,
      disabled: Boolean
    },
    emits: ["update:modelValue"],
    setup(e, {
      emit: t
    }) {
      const i = _e(e.modelValue),
        o = t,
        l = h => {
          o("update:modelValue", h.target.value)
        };
      return (h, p) => {
        const m = Mn("vue-tel-input");
        return be(), Ne("div", {
          class: ut(e.className)
        }, [ce("label", {
          for: "name",
          class: ut(["block text-sm leading-6 text-gray-900", e.labelClass])
        }, st(e.name), 3), ce("div", null, [ce("div", mF, [Ze(m, {
          inputOptions: {
            autocomplete: "off"
          },
          modelValue: i.value,
          "onUpdate:modelValue": p[0] || (p[0] = k => i.value = k),
          autoFormat: !0,
          mode: "international",
          validCharactersOnly: !0,
          onInput: l
        }, null, 8, ["modelValue"])])]), e.error ? (be(), Ne("div", vF, st(e.error), 1)) : Ke("", !0)], 2)
      }
    }
  };

function yF(e, t) {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [ce("path", {
    "fill-rule": "evenodd",
    d: "M16.704 4.153a.75.75 0 0 1 .143 1.052l-8 10.5a.75.75 0 0 1-1.127.075l-4.5-4.5a.75.75 0 0 1 1.06-1.06l3.894 3.893 7.48-9.817a.75.75 0 0 1 1.05-.143Z",
    "clip-rule": "evenodd"
  })])
}

function xF(e, t) {
  return be(), Ne("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [ce("path", {
    "fill-rule": "evenodd",
    d: "M10.53 3.47a.75.75 0 0 0-1.06 0L6.22 6.72a.75.75 0 0 0 1.06 1.06L10 5.06l2.72 2.72a.75.75 0 1 0 1.06-1.06l-3.25-3.25Zm-4.31 9.81 3.25 3.25a.75.75 0 0 0 1.06 0l3.25-3.25a.75.75 0 1 0-1.06-1.06L10 14.94l-2.72-2.72a.75.75 0 0 0-1.06 1.06Z",
    "clip-rule": "evenodd"
  })])
}
const wF = {
    for: "name",
    class: "block text-sm leading-6 text-gray-900"
  },
  kF = {
    class: ""
  },
  _F = {
    class: "relative"
  },
  SF = {
    key: 0,
    class: "block truncate"
  },
  AF = {
    key: 1,
    class: "text-gray-500"
  },
  CF = {
    class: "pointer-events-none absolute inset-y-0 right-0 flex items-center pr-2"
  },
  TF = {
    key: 0,
    class: "absolute inset-y-0 left-0 flex items-center pl-3 text-amber-600"
  },
  EF = {
    key: 0,
    class: "form-error text-[#b91c1c] text-xs"
  },
  PF = {
    __name: "FormSelect",
    props: {
      options: Array,
      modelValue: [String, Number, Array],
      name: String,
      className: String,
      optionClassName: String,
      placeholder: {
        type: String,
        default: "Select option"
      },
      multiple: Boolean,
      required: Boolean,
      error: String
    },
    emits: ["update:modelValue"],
    setup(e, {
      emit: t
    }) {
      const a = e,
        i = t,
        o = Oe(() => a.options.filter(l => Array.isArray(a.modelValue) ? a.modelValue.includes(l.value) : a.modelValue === l.value).map(l => l.label).join(", "));
      return (l, h) => (be(), Ne("div", {
        class: ut(e.className)
      }, [ce("label", wF, st(e.name), 1), ce("div", kF, [Ze(se(qN), {
        multiple: a.multiple,
        "onUpdate:modelValue": h[0] || (h[0] = p => i("update:modelValue", p)),
        "model-value": a.modelValue
      }, {
        default: Qe(() => [ce("div", _F, [Ze(se(KN), {
          class: ut(["relative w-full cursor-default rounded-lg bg-white py-2 px-5 pr-10 shadow-sm text-left ring-1 ring-inset focus:outline-none focus-visible:border-indigo-500 focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75 focus-visible:ring-offset-2 focus-visible:ring-offset-orange-300 sm:text-sm", e.error ? "ring-[#b91c1c]" : "ring-gray-300"])
        }, {
          default: Qe(() => [o.value ? (be(), Ne("span", SF, st(o.value), 1)) : (be(), Ne("span", AF, st(a.placeholder), 1)), ce("span", CF, [Ze(se(xF), {
            class: "h-5 w-5 text-gray-400",
            "aria-hidden": "true"
          })])]),
          _: 1
        }, 8, ["class"]), Ze(In, {
          "leave-active-class": "transition duration-100 ease-in",
          "leave-from-class": "opacity-100",
          "leave-to-class": "opacity-0"
        }, {
          default: Qe(() => [Ze(se(ZN), {
            class: ut(["z-10 absolute mt-1 max-h-60 w-full overflow-auto rounded-md bg-white py-1 text-base shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none sm:text-sm", e.optionClassName])
          }, {
            default: Qe(() => [(be(!0), Ne(vt, null, la(a.options, p => (be(), yt(se(QN), {
              key: p.label,
              value: p.value,
              as: "template"
            }, {
              default: Qe(({
                active: m,
                selected: k
              }) => [ce("li", {
                class: ut([m ? "bg-amber-100 text-amber-900" : "text-gray-900", "relative cursor-default select-none py-2 pl-10 pr-4"])
              }, [ce("span", {
                class: ut([k ? "font-medium" : "font-normal", "block truncate"])
              }, st(p.label), 3), k ? (be(), Ne("span", TF, [Ze(se(yF), {
                class: "h-5 w-5",
                "aria-hidden": "true"
              })])) : Ke("", !0)], 2)]),
              _: 2
            }, 1032, ["value"]))), 128))]),
            _: 1
          }, 8, ["class"])]),
          _: 1
        })])]),
        _: 1
      }, 8, ["multiple", "model-value"])]), e.error ? (be(), Ne("div", EF, st(e.error), 1)) : Ke("", !0)], 2))
    }
  },
  LF = {
    class: "bg-white md:bg-inherit pt-0 px-4 md:pt-8 md:p-8 rounded-[5px] text-[#000] overflow-y-scroll"
  },
  OF = {
    class: "md:flex justify-between hidden"
  },
  MF = {
    key: 0,
    class: "text-xl mb-1"
  },
  IF = {
    key: 1,
    class: "text-xl mb-1"
  },
  RF = {
    class: "mb-6 flex items-center text-sm leading-6 text-gray-600"
  },
  DF = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "18",
    height: "18",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M12 11v5m0 5a9 9 0 1 1 0-18a9 9 0 0 1 0 18Zm.05-13v.1h-.1V8h.1Z"
  })], -1),
  NF = {
    key: 0,
    class: "ml-1 mt-1"
  },
  FF = {
    key: 1,
    class: "ml-1 mt-1"
  },
  $F = {
    class: "sm:flex border-b py-5"
  },
  BF = {
    class: "hidden sm:block sm:w-[40%] mb-1"
  },
  HF = {
    class: "text-sm text-gray-500 tracking-[0px]"
  },
  YF = {
    class: "sm:w-[60%] sm:flex space-x-6"
  },
  zF = {
    class: "sm:w-[80%] grid gap-x-6 gap-y-4 sm:grid-cols-6"
  },
  XF = {
    class: "sm:flex py-5"
  },
  WF = {
    class: "hidden sm:block w-[40%] mb-1"
  },
  VF = {
    class: "text-sm text-gray-500 tracking-[0px]"
  },
  jF = {
    class: "sm:w-[60%] sm:flex space-x-6"
  },
  UF = {
    class: "sm:w-[80%] grid gap-x-6 gap-y-4 sm:grid-cols-6"
  },
  GF = {
    class: "py-6"
  },
  qF = {
    type: "submit",
    class: "float-right flex items-center space-x-4 rounded-md bg-black px-3 py-2 text-sm text-white shadow-sm hover:bg-slate-600 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600"
  },
  vp = {
    __name: "Show",
    props: {
      title: String,
      user: Object,
      roles: Object
    },
    setup(e) {
      var h, p, m, k, w, S, A, E, M, D, B;
      const t = e;
      _e(null);
      const a = (z, I) => {
          if (z) {
            const N = JSON.parse(z);
            return (N == null ? void 0 : N[I]) ?? null
          } else return null
        },
        i = K3({
          first_name: (h = t.user) == null ? void 0 : h.first_name,
          last_name: (p = t.user) == null ? void 0 : p.last_name,
          email: (m = t.user) == null ? void 0 : m.email,
          phone: (k = t.user) == null ? void 0 : k.phone,
          role: (S = (w = t.user) == null ? void 0 : w.role) == null ? void 0 : S.uuid,
          password: null,
          password_confirmation: null,
          avatar: null,
          street: a((A = t.user) == null ? void 0 : A.address, "street"),
          city: a((E = t.user) == null ? void 0 : E.address, "city"),
          state: a((M = t.user) == null ? void 0 : M.address, "state"),
          zip: a((D = t.user) == null ? void 0 : D.address, "zip"),
          country: a((B = t.user) == null ? void 0 : B.address, "country")
        }),
        o = () => t.roles.map(z => ({
          value: z.uuid,
          label: z.name
        })),
        l = async () => {
          const z = t.user ? window.location.pathname : "/admin/team/users";
          i[t.user ? "put" : "post"](z, {
            preserveScroll: !0
          })
        };
      return (z, I) => (be(), yt(yu, null, {
        default: Qe(() => {
          var N, U;
          return [ce("div", LF, [ce("div", OF, [ce("div", null, [t.user === null ? (be(), Ne("h1", MF, st(z.$t("Create user")), 1)) : (be(), Ne("h1", IF, st(z.$t("Update user")), 1)), ce("p", RF, [DF, t.user === null ? (be(), Ne("span", NF, st(z.$t("Create administrative user and assign role")), 1)) : (be(), Ne("span", FF, st(z.$t("Update administrative user and assign role")), 1))])]), ce("div", null, [Ze(se(Wx), {
            href: "/admin/team/users",
            class: "rounded-md bg-indigo-600 px-3 py-2 text-sm text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600"
          }, {
            default: Qe(() => [$t(st(z.$t("Back")), 1)]),
            _: 1
          })])]), ce("form", {
            onSubmit: I[13] || (I[13] = qn(W => l(), ["prevent"])),
            class: "bg-white md:border py-5 px-5 rounded-[0.5rem]"
          }, [ce("div", $F, [ce("div", BF, [ce("h1", HF, st(z.$t("Personally identifiable information")), 1)]), ce("div", YF, [ce("div", zF, [Ze(gF, {
            modelValue: se(i).avatar,
            "onUpdate:modelValue": I[0] || (I[0] = W => se(i).avatar = W),
            name: "Avatar",
            error: se(i).errors.avatar,
            label: z.$t("Upload image"),
            imageUrl: (N = t.user) != null && N.avatar ? "/media/" + ((U = t.user) == null ? void 0 : U.avatar) : null,
            class: ut("sm:col-span-6")
          }, null, 8, ["modelValue", "error", "label", "imageUrl"]), Ze(Zr, {
            modelValue: se(i).first_name,
            "onUpdate:modelValue": I[1] || (I[1] = W => se(i).first_name = W),
            name: z.$t("First name"),
            error: se(i).errors.first_name,
            type: "text",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"]), Ze(Zr, {
            modelValue: se(i).last_name,
            "onUpdate:modelValue": I[2] || (I[2] = W => se(i).last_name = W),
            name: z.$t("Last name"),
            error: se(i).errors.last_name,
            type: "text",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"]), Ze(Zr, {
            modelValue: se(i).email,
            "onUpdate:modelValue": I[3] || (I[3] = W => se(i).email = W),
            name: z.$t("Email"),
            error: se(i).errors.email,
            type: "text",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"]), Ze(bF, {
            modelValue: se(i).phone,
            "onUpdate:modelValue": I[4] || (I[4] = W => se(i).phone = W),
            name: z.$t("Phone"),
            error: se(i).errors.phone,
            type: "text",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"]), Ze(PF, {
            modelValue: se(i).role,
            "onUpdate:modelValue": I[5] || (I[5] = W => se(i).role = W),
            name: z.$t("Role"),
            error: se(i).errors.role,
            options: o(),
            type: "text",
            class: ut("sm:col-span-6")
          }, null, 8, ["modelValue", "name", "error", "options"]), t.user ? Ke("", !0) : (be(), yt(Zr, {
            key: 0,
            modelValue: se(i).password,
            "onUpdate:modelValue": I[6] || (I[6] = W => se(i).password = W),
            name: z.$t("Password"),
            error: se(i).errors.password,
            type: "password",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"])), t.user ? Ke("", !0) : (be(), yt(Zr, {
            key: 1,
            modelValue: se(i).password_confirmation,
            "onUpdate:modelValue": I[7] || (I[7] = W => se(i).password_confirmation = W),
            name: z.$t("Confirm password"),
            error: se(i).errors.password_confirmation,
            type: "password",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"]))])])]), ce("div", XF, [ce("div", WF, [ce("h1", VF, st(z.$t("Address details")), 1)]), ce("div", jF, [ce("div", UF, [Ze(Zr, {
            modelValue: se(i).street,
            "onUpdate:modelValue": I[8] || (I[8] = W => se(i).street = W),
            name: z.$t("Street"),
            error: se(i).errors.street,
            type: "text",
            class: ut("sm:col-span-6")
          }, null, 8, ["modelValue", "name", "error"]), Ze(Zr, {
            modelValue: se(i).city,
            "onUpdate:modelValue": I[9] || (I[9] = W => se(i).city = W),
            name: z.$t("City"),
            error: se(i).errors.city,
            type: "text",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"]), Ze(Zr, {
            modelValue: se(i).state,
            "onUpdate:modelValue": I[10] || (I[10] = W => se(i).state = W),
            name: z.$t("State"),
            error: se(i).errors.state,
            type: "text",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"]), Ze(Zr, {
            modelValue: se(i).zip,
            "onUpdate:modelValue": I[11] || (I[11] = W => se(i).zip = W),
            name: z.$t("Zip code"),
            error: se(i).errors.zip,
            type: "text",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"]), Ze(Zr, {
            modelValue: se(i).country,
            "onUpdate:modelValue": I[12] || (I[12] = W => se(i).country = W),
            name: z.$t("Country"),
            error: se(i).errors.country,
            type: "text",
            class: ut("sm:col-span-3")
          }, null, 8, ["modelValue", "name", "error"])])])]), ce("div", GF, [ce("button", qF, st(z.$t("Save")), 1)])], 32)])]
        }),
        _: 1
      }))
    }
  },
  KF = {
    class: "md:bg-white flex items-center border border-primary md:border-none md:shadow-sm h-12 md:h-10 md:w-80 rounded-[0.5rem] mb-6 text-xl md:text-sm"
  },
  ZF = ce("span", {
    class: "pl-3"
  }, [ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "m15 15l6 6m-11-4a7 7 0 1 1 0-14a7 7 0 0 1 0 14Z"
  })])], -1),
  QF = ["placeholder"],
  JF = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "currentColor",
    d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10s10-4.5 10-10S17.5 2 12 2zm3.7 12.3c.4.4.4 1 0 1.4c-.4-.4-1 .4-1.4 0L12 13.4l-2.3 2.3c-.4.4-1 .4-1.4 0c-.4-.4-.4-1 0-1.4l2.3-2.3l-2.3-2.3c-.4-.4-.4-1 0-1.4c.4-.4 1-.4 1.4 0l2.3 2.3l2.3-2.3c.4-.4 1-.4 1.4 0c.4.4.4 1 0 1.4L13.4 12l2.3 2.3z"
  })], -1),
  e4 = [JF],
  t4 = {
    key: 1,
    class: "pr-2"
  },
  a4 = Tl('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="3.5" r="1.5" fill="currentColor" opacity="0"><animateTransform attributeName="transform" calcMode="discrete" dur="2.4s" repeatCount="indefinite" type="rotate" values="0 12 12;90 12 12;180 12 12;270 12 12"></animateTransform><animate attributeName="opacity" dur="0.6s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1;1;0"></animate></circle><circle cx="12" cy="3.5" r="1.5" fill="currentColor" opacity="0"><animateTransform attributeName="transform" begin="0.2s" calcMode="discrete" dur="2.4s" repeatCount="indefinite" type="rotate" values="30 12 12;120 12 12;210 12 12;300 12 12"></animateTransform><animate attributeName="opacity" begin="0.2s" dur="0.6s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1;1;0"></animate></circle><circle cx="12" cy="3.5" r="1.5" fill="currentColor" opacity="0"><animateTransform attributeName="transform" begin="0.4s" calcMode="discrete" dur="2.4s" repeatCount="indefinite" type="rotate" values="60 12 12;150 12 12;240 12 12;330 12 12"></animateTransform><animate attributeName="opacity" begin="0.4s" dur="0.6s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1;1;0"></animate></circle></svg>', 1),
  r4 = [a4],
  n4 = {
    class: ""
  },
  i4 = {
    class: "float-right"
  },
  s4 = {
    class: "py-1 rounded-[5px] text-xs px-3 bg-[#ddebf7] text-slate-700"
  },
  o4 = {
    class: "float-right"
  },
  l4 = ce("button", {
    class: "inline-flex w-full justify-center rounded-md text-sm font-medium text-black hover:bg-opacity-30 focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75"
  }, [ce("span", {
    class: "hover:bg-[#F6F7F9] hover:rounded-full w-[fit-content] p-2"
  }, [ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "currentColor",
    d: "M12 16a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2m0-6a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2m0-6a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2Z"
  })])])], -1),
  c4 = {
    key: 0,
    class: "fixed z-10 inset-0 overflow-y-auto"
  },
  u4 = {
    class: "flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0"
  },
  d4 = ce("div", {
    class: "fixed inset-0 transition-opacity",
    "aria-hidden": "true"
  }, [ce("div", {
    class: "absolute inset-0 bg-gray-500 opacity-75"
  })], -1),
  h4 = ce("span", {
    class: "hidden sm:inline-block sm:align-middle sm:h-screen",
    "aria-hidden": "true"
  }, "​", -1),
  f4 = {
    class: "inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full"
  },
  p4 = {
    class: "bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4"
  },
  g4 = {
    class: "sm:flex sm:items-start"
  },
  m4 = {
    class: "mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left"
  },
  v4 = ce("h3", {
    class: "text-lg leading-6 font-medium text-gray-900",
    id: "modal-title"
  }, " User Details ", -1),
  b4 = {
    class: "mt-2"
  },
  y4 = {
    class: "bg-gray-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse"
  },
  x4 = {
    __name: "UserTable",
    props: {
      rows: {
        type: Object,
        required: !0
      },
      filters: {
        type: Object
      },
      type: {
        type: String
      },
      showDeleteBtn: {
        type: Boolean,
        default: !0
      },
      showRole: {
        type: Boolean,
        default: !1
      }
    },
    emits: ["delete"],
    setup(e, {
      emit: t
    }) {
      var z;
      const a = e,
        {
          isOpenAlert: i,
          openAlert: o,
          confirmAlert: l
        } = S1(),
        h = _e(!1),
        p = _e(null),
        m = I => {
          form.delete(a.type === "admin" ? "/admin/team/users/" + I : "/admin/users/" + I)
        },
        k = _e({
          search: ((z = a.filters) == null ? void 0 : z.search) || ""
        }),
        w = _e(!1),
        S = () => {
          k.value.search = ""
        },
        A = I => I === a.rows.data.length - 1,
        E = qx(() => {
          w.value = !0, w.value = !1
        }, 500),
        M = I => I === 1 ? "Active" : I === 0 ? "Inactive" : I,
        D = Oe(() => {
          if (!k.value.search) return a.rows.data;
          const I = k.value.search.toLowerCase();
          return a.rows.data.filter(N => N.first_name.toLowerCase().includes(I) || N.last_name.toLowerCase().includes(I) || N.email.toLowerCase().includes(I))
        }),
        B = I => {
          p.value = I, h.value = !0
        };
      return (I, N) => (be(), Ne(vt, null, [ce("div", KF, [ZF, Vs(ce("input", {
        onInput: N[0] || (N[0] = (...U) => se(E) && se(E)(...U)),
        "onUpdate:modelValue": N[1] || (N[1] = U => k.value.search = U),
        type: "text",
        class: "outline-none px-4 w-full bg-inherit",
        placeholder: I.$t("Search users")
      }, null, 40, QF), [
        [h0, k.value.search]
      ]), w.value === !1 && k.value.search ? (be(), Ne("button", {
        key: 0,
        onClick: S,
        type: "button",
        class: "pr-2"
      }, e4)) : Ke("", !0), w.value ? (be(), Ne("span", t4, r4)) : Ke("", !0)]), Ze(C1, {
        rows: e.rows
      }, {
        default: Qe(() => [Ze(T1, null, {
          default: Qe(() => [Ze(E1, null, {
            default: Qe(() => [Ze(Wr, {
              position: "first"
            }, {
              default: Qe(() => [$t(st(I.$t("Name")), 1)]),
              _: 1
            }), Ze(Wr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(I.$t("Email")), 1)]),
              _: 1
            }), e.type === "admin" || e.showRole === !0 ? (be(), yt(Wr, {
              key: 0,
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(I.$t("Role")), 1)]),
              _: 1
            })) : Ke("", !0), Ze(Wr, null, {
              default: Qe(() => [ce("span", n4, st(I.$t("Status")), 1)]),
              _: 1
            }), Ze(Wr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [ce("span", i4, st(I.$t("Last updated")), 1)]),
              _: 1
            }), Ze(Wr, {
              position: "last"
            })]),
            _: 1
          })]),
          _: 1
        }), Ze(P1, null, {
          default: Qe(() => [(be(!0), Ne(vt, null, la(D.value, (U, W) => (be(), yt(L1, {
            key: W,
            class: ut(A(W) ? "" : "border-b")
          }, {
            default: Qe(() => [Ze(Vr, {
              position: "first",
              class: "capitalize",
              onClick: X => B(U)
            }, {
              default: Qe(() => [$t(st(U.first_name) + " " + st(U.last_name), 1)]),
              _: 2
            }, 1032, ["onClick"]), Ze(Vr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(U.email), 1)]),
              _: 2
            }, 1024), e.type === "admin" || e.showRole === !0 ? (be(), yt(Vr, {
              key: 0,
              class: "hidden sm:table-cell capitalize"
            }, {
              default: Qe(() => [$t(st(U.role), 1)]),
              _: 2
            }, 1024)) : Ke("", !0), Ze(Vr, {
              class: "capitalize"
            }, {
              default: Qe(() => [ce("span", s4, st(M(U.status)), 1)]),
              _: 2
            }, 1024), Ze(Vr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [ce("span", o4, st(U.updated_at), 1)]),
              _: 2
            }, 1024), Ze(Vr, {
              position: "last"
            }, {
              default: Qe(() => [U.role != "admin" ? (be(), yt(O1, {
                key: 0,
                align: "right",
                class: "mt-2"
              }, {
                items: Qe(() => [Ze(M1, null, {
                  default: Qe(() => [Ze(jc, {
                    href: e.type === "admin" ? "/admin/team/users/" + U.id : "/admin/users/" + U.id
                  }, {
                    default: Qe(() => [$t(st(I.$t("View/edit")), 1)]),
                    _: 2
                  }, 1032, ["href"]), e.showDeleteBtn ? (be(), yt(jc, {
                    key: 0,
                    as: "button",
                    onClick: X => se(o)(U.id)
                  }, {
                    default: Qe(() => [$t(st(I.$t("Delete")), 1)]),
                    _: 2
                  }, 1032, ["onClick"])) : Ke("", !0)]),
                  _: 2
                }, 1024)]),
                default: Qe(() => [l4]),
                _: 2
              }, 1024)) : Ke("", !0)]),
              _: 2
            }, 1024)]),
            _: 2
          }, 1032, ["class"]))), 128))]),
          _: 1
        })]),
        _: 1
      }, 8, ["rows"]), h.value ? (be(), Ne("div", c4, [ce("div", u4, [d4, h4, ce("div", f4, [ce("div", p4, [ce("div", g4, [ce("div", m4, [v4, ce("div", b4, [Ze(vp, {
        user: p.value
      }, null, 8, ["user"])])])])]), ce("div", y4, [ce("button", {
        onClick: N[2] || (N[2] = U => h.value = !1),
        type: "button",
        class: "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm"
      }, " Close ")])])])])) : Ke("", !0), Ze(_1, {
        modelValue: se(i),
        "onUpdate:modelValue": N[3] || (N[3] = U => Fa(i) ? i.value = U : null),
        onConfirm: N[4] || (N[4] = () => se(l)(m)),
        label: I.$t("Delete row"),
        description: I.$t("Are you sure you want to delete this row? This action can not be undone")
      }, null, 8, ["modelValue", "label", "description"])], 64))
    }
  },
  w4 = {
    class: "bg-white md:bg-inherit pt-10 px-4 md:pt-8 md:p-8 rounded-[5px] text-[#000] h-full md:overflow-y-auto"
  },
  k4 = {
    class: "flex justify-between"
  },
  _4 = {
    class: "text-xl mb-1"
  },
  S4 = {
    class: "mb-6 flex items-center text-sm leading-6 text-gray-600"
  },
  A4 = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "18",
    height: "18",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M12 11v5m0 5a9 9 0 1 1 0-18a9 9 0 0 1 0 18Zm.05-13v.1h-.1V8h.1Z"
  })], -1),
  C4 = {
    class: "ml-1 mt-1"
  },
  T4 = {
    __name: "Index",
    setup(e) {
      const t = _e([]),
        a = _e({
          search: ""
        }),
        i = _e(!0);
      async function o() {
        try {
          const l = await Qt.get("http://localhost:3000/api/users", {
            params: {
              search: a.value.search
            }
          });
          console.log("Fetched users:", l.data), t.value = {
            data: l.data
          }
        } catch (l) {
          console.error("Failed to fetch users:", l)
        } finally {
          i.value = !1
        }
      }
      return Dt(() => {
        o()
      }), Xt(a, () => {
        o()
      }), (l, h) => {
        const p = Mn("Link"),
          m = Mn("Spinner");
        return be(), yt(yu, null, {
          default: Qe(() => [ce("div", w4, [ce("div", k4, [ce("div", null, [ce("h1", _4, st(l.$t("Users")), 1), ce("p", S4, [A4, ce("span", C4, st(l.$t("Manage admin accounts")), 1)])]), ce("div", null, [Ze(p, {
            href: "/admin/team/users/create",
            class: "rounded-md bg-indigo-600 px-3 py-2 text-sm text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600"
          }, {
            default: Qe(() => [$t(st(l.$t("Add User")), 1)]),
            _: 1
          })])]), i.value ? (be(), yt(m, {
            key: 1
          })) : (be(), yt(x4, {
            key: 0,
            rows: t.value,
            filters: a.value,
            type: "admin"
          }, null, 8, ["rows", "filters"]))])]),
          _: 1
        })
      }
    }
  },
  E4 = {
    class: "md:bg-white flex items-center border border-primary md:border-none md:shadow-sm h-12 md:h-10 md:w-80 rounded-[0.5rem] mb-6 text-xl md:text-sm"
  },
  P4 = ce("span", {
    class: "pl-3"
  }, [ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "m15 15l6 6m-11-4a7 7 0 1 1 0-14a7 7 0 0 1 0 14Z"
  })])], -1),
  L4 = ["placeholder"],
  O4 = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "currentColor",
    d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10s10-4.5 10-10S17.5 2 12 2zm3.7 12.3c.4.4.4 1 0 1.4c-.4.4-1 .4-1.4 0L12 13.4l-2.3 2.3c-.4.4-1 .4-1.4 0c-.4-.4-.4-1 0-1.4l2.3-2.3l-2.3-2.3c-.4-.4-.4-1 0-1.4c.4-.4 1-.4 1.4 0l2.3 2.3l2.3-2.3c.4-.4 1-.4 1.4 0c.4.4.4 1 0 1.4L13.4 12l2.3 2.3z"
  })], -1),
  M4 = [O4],
  I4 = {
    key: 1,
    class: "pr-2"
  },
  R4 = Tl('<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="3.5" r="1.5" fill="currentColor" opacity="0"><animateTransform attributeName="transform" calcMode="discrete" dur="2.4s" repeatCount="indefinite" type="rotate" values="0 12 12;90 12 12;180 12 12;270 12 12"></animateTransform><animate attributeName="opacity" dur="0.6s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1;1;0"></animate></circle><circle cx="12" cy="3.5" r="1.5" fill="currentColor" opacity="0"><animateTransform attributeName="transform" begin="0.2s" calcMode="discrete" dur="2.4s" repeatCount="indefinite" type="rotate" values="30 12 12;120 12 12;210 12 12;300 12 12"></animateTransform><animate attributeName="opacity" begin="0.2s" dur="0.6s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1;1;0"></animate></circle><circle cx="12" cy="3.5" r="1.5" fill="currentColor" opacity="0"><animateTransform attributeName="transform" begin="0.4s" calcMode="discrete" dur="2.4s" repeatCount="indefinite" type="rotate" values="60 12 12;150 12 12;240 12 12;330 12 12"></animateTransform><animate attributeName="opacity" begin="0.4s" dur="0.6s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1;1;0"></animate></circle></svg>', 1),
  D4 = [R4],
  N4 = {
    class: ""
  },
  F4 = {
    class: "float-right"
  },
  $4 = {
    class: "py-1 rounded-[5px] text-xs px-3 bg-[#ddebf7] text-slate-700"
  },
  B4 = {
    class: "float-right"
  },
  H4 = ce("button", {
    class: "inline-flex w-full justify-center rounded-md text-sm font-medium text-black hover:bg-opacity-30 focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75"
  }, [ce("span", {
    class: "hover:bg-[#F6F7F9] hover:rounded-full w-[fit-content] p-2"
  }, [ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "currentColor",
    d: "M12 16a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2m0-6a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2m0-6a2 2 0 0 1 2 2a2 2 0 0 1-2 2a2 2 0 0 1-2-2a2 2 0 0 1 2-2Z"
  })])])], -1),
  Y4 = {
    key: 0,
    class: "fixed z-10 inset-0 overflow-y-auto"
  },
  z4 = {
    class: "flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0"
  },
  X4 = ce("div", {
    class: "fixed inset-0 transition-opacity",
    "aria-hidden": "true"
  }, [ce("div", {
    class: "absolute inset-0 bg-gray-500 opacity-75"
  })], -1),
  W4 = ce("span", {
    class: "hidden sm:inline-block sm:align-middle sm:h-screen",
    "aria-hidden": "true"
  }, "​", -1),
  V4 = {
    class: "inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full"
  },
  j4 = {
    class: "bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4"
  },
  U4 = {
    class: "sm:flex sm:items-start"
  },
  G4 = {
    class: "mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left"
  },
  q4 = ce("h3", {
    class: "text-lg leading-6 font-medium text-gray-900",
    id: "modal-title"
  }, " Student Details ", -1),
  K4 = {
    class: "mt-2"
  },
  Z4 = {
    class: "bg-gray-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse"
  },
  Q4 = {
    __name: "StudentTable",
    props: {
      rows: {
        type: Object,
        required: !0
      },
      filters: {
        type: Object
      },
      type: {
        type: String
      },
      showDeleteBtn: {
        type: Boolean,
        default: !0
      },
      showRole: {
        type: Boolean,
        default: !1
      }
    },
    emits: ["delete"],
    setup(e, {
      emit: t
    }) {
      var D;
      const a = e,
        {
          isOpenAlert: i,
          openAlert: o,
          confirmAlert: l
        } = S1(),
        h = _e(!1),
        p = _e(null),
        m = _e({
          search: ((D = a.filters) == null ? void 0 : D.search) || ""
        }),
        k = _e(!1),
        w = () => {
          m.value.search = ""
        },
        S = B => B === a.rows.data.length - 1,
        A = qx(() => {
          k.value = !0, k.value = !1
        }, 500),
        E = Oe(() => {
          if (!m.value.search) return a.rows.data;
          const B = m.value.search.toLowerCase();
          return a.rows.data.filter(z => z.first_name.toLowerCase().includes(B) || z.last_name.toLowerCase().includes(B) || z.phone.toLowerCase().includes(B))
        }),
        M = B => {
          p.value = B, h.value = !0
        };
      return (B, z) => (be(), Ne(vt, null, [ce("div", E4, [P4, Vs(ce("input", {
        onInput: z[0] || (z[0] = (...I) => se(A) && se(A)(...I)),
        "onUpdate:modelValue": z[1] || (z[1] = I => m.value.search = I),
        type: "text",
        class: "outline-none px-4 w-full bg-inherit",
        placeholder: B.$t("Search students")
      }, null, 40, L4), [
        [h0, m.value.search]
      ]), k.value === !1 && m.value.search ? (be(), Ne("button", {
        key: 0,
        onClick: w,
        type: "button",
        class: "pr-2"
      }, M4)) : Ke("", !0), k.value ? (be(), Ne("span", I4, D4)) : Ke("", !0)]), Ze(C1, {
        rows: e.rows
      }, {
        default: Qe(() => [Ze(T1, null, {
          default: Qe(() => [Ze(E1, null, {
            default: Qe(() => [Ze(Wr, {
              position: "first"
            }, {
              default: Qe(() => [$t(st(B.$t("Name")), 1)]),
              _: 1
            }), Ze(Wr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(B.$t("Phone")), 1)]),
              _: 1
            }), Ze(Wr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(B.$t("Class")), 1)]),
              _: 1
            }), Ze(Wr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(B.$t("State")), 1)]),
              _: 1
            }), Ze(Wr, null, {
              default: Qe(() => [ce("span", N4, st(B.$t("Gender")), 1)]),
              _: 1
            }), Ze(Wr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [ce("span", F4, st(B.$t("Last updated")), 1)]),
              _: 1
            }), Ze(Wr, {
              position: "last"
            })]),
            _: 1
          })]),
          _: 1
        }), Ze(P1, null, {
          default: Qe(() => [(be(!0), Ne(vt, null, la(E.value, (I, N) => (be(), yt(L1, {
            key: N,
            class: ut(S(N) ? "" : "border-b")
          }, {
            default: Qe(() => [Ze(Vr, {
              position: "first",
              class: "capitalize",
              onClick: U => M(I)
            }, {
              default: Qe(() => [$t(st(I.first_name) + " " + st(I.last_name), 1)]),
              _: 2
            }, 1032, ["onClick"]), Ze(Vr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(I.phone), 1)]),
              _: 2
            }, 1024), Ze(Vr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(I.class), 1)]),
              _: 2
            }, 1024), Ze(Vr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [$t(st(I.state), 1)]),
              _: 2
            }, 1024), Ze(Vr, {
              class: "capitalize"
            }, {
              default: Qe(() => [ce("span", $4, st(I.gender), 1)]),
              _: 2
            }, 1024), Ze(Vr, {
              class: "hidden sm:table-cell"
            }, {
              default: Qe(() => [ce("span", B4, st(I.updated_at), 1)]),
              _: 2
            }, 1024), Ze(Vr, {
              position: "last"
            }, {
              default: Qe(() => [Ze(O1, {
                align: "right",
                class: "mt-2"
              }, {
                items: Qe(() => [Ze(M1, null, {
                  default: Qe(() => [Ze(jc, {
                    onClick: U => M(I)
                  }, {
                    default: Qe(() => [$t(st(B.$t("View/edit")), 1)]),
                    _: 2
                  }, 1032, ["onClick"]), e.showDeleteBtn ? (be(), yt(jc, {
                    key: 0,
                    as: "button",
                    onClick: U => se(o)(I.id)
                  }, {
                    default: Qe(() => [$t(st(B.$t("Delete")), 1)]),
                    _: 2
                  }, 1032, ["onClick"])) : Ke("", !0)]),
                  _: 2
                }, 1024)]),
                default: Qe(() => [H4]),
                _: 2
              }, 1024)]),
              _: 2
            }, 1024)]),
            _: 2
          }, 1032, ["class"]))), 128))]),
          _: 1
        })]),
        _: 1
      }, 8, ["rows"]), h.value ? (be(), Ne("div", Y4, [ce("div", z4, [X4, W4, ce("div", V4, [ce("div", j4, [ce("div", U4, [ce("div", G4, [q4, ce("div", K4, [Ze(vp, {
        user: p.value
      }, null, 8, ["user"])])])])]), ce("div", Z4, [ce("button", {
        onClick: z[2] || (z[2] = I => h.value = !1),
        type: "button",
        class: "w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm"
      }, " Close ")])])])])) : Ke("", !0), Ze(_1, {
        modelValue: se(i),
        "onUpdate:modelValue": z[3] || (z[3] = I => Fa(i) ? i.value = I : null),
        onConfirm: z[4] || (z[4] = () => se(l)(B.deleteAction)),
        label: B.$t("Delete row"),
        description: B.$t("Are you sure you want to delete this row? This action can not be undone")
      }, null, 8, ["modelValue", "label", "description"])], 64))
    }
  },
  J4 = {
    class: "bg-white md:bg-inherit pt-10 px-4 md:pt-8 md:p-8 rounded-[5px] text-[#000] h-full md:overflow-y-auto"
  },
  e$ = {
    class: "flex justify-between"
  },
  t$ = {
    class: "text-xl mb-1"
  },
  a$ = {
    class: "mb-6 flex items-center text-sm leading-6 text-gray-600"
  },
  r$ = ce("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "18",
    height: "18",
    viewBox: "0 0 24 24"
  }, [ce("path", {
    fill: "none",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    "stroke-width": "2",
    d: "M12 11v5m0 5a9 9 0 1 1 0-18a9 9 0 0 1 0 18Zm.05-13v.1h-.1V8h.1Z"
  })], -1),
  n$ = {
    class: "ml-1 mt-1"
  },
  i$ = {
    __name: "Students",
    setup(e) {
      const t = _e([]),
        a = _e({
          search: ""
        }),
        i = _e({
          total: 0,
          per_page: 20,
          current_page: 1,
          last_page: 1
        }),
        o = _e(!0);
      async function l(h = 1) {
        try {
          const p = await Qt.get("http://localhost:3000/api/list-students", {
            params: {
              search: a.value.search,
              limit: i.value.per_page,
              page: h
            }
          });
          console.log("Fetched users:", p.data), t.value = {
            data: p.data.data
          }, i.value = p.data.pagination
        } catch (p) {
          console.error("Failed to fetch users:", p)
        } finally {
          o.value = !1
        }
      }
      return Dt(() => {
        l()
      }), Xt(a, () => {
        l(1)
      }), (h, p) => {
        const m = Mn("Link"),
          k = Mn("Spinner");
        return be(), yt(yu, null, {
          default: Qe(() => [ce("div", J4, [ce("div", e$, [ce("div", null, [ce("h1", t$, st(h.$t("Users")), 1), ce("p", a$, [r$, ce("span", n$, st(h.$t("Manage students accounts")), 1)])]), ce("div", null, [Ze(m, {
            href: "/students/create",
            class: "rounded-md bg-indigo-600 px-3 py-2 text-sm text-white shadow-sm hover:bg-indigo-500 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-indigo-600"
          }, {
            default: Qe(() => [$t(st(h.$t("Add User")), 1)]),
            _: 1
          })])]), o.value ? (be(), yt(k, {
            key: 1
          })) : (be(), yt(Q4, {
            key: 0,
            rows: t.value,
            filters: a.value,
            type: "admin"
          }, null, 8, ["rows", "filters"])), Ze(A1, {
            pagination: i.value,
            onPageChanged: l
          }, null, 8, ["pagination"])])]),
          _: 1
        })
      }
    }
  },
  s$ = [{
    path: "/",
    redirect: "/login",
    meta: {
      title: "DigiLearns"
    }
  }, {
    path: "/login",
    component: hC,
    meta: {
      title: "Login - DigiLearns"
    }
  }, {
    path: "/dashboard",
    component: Md,
    meta: {
      title: "Dashboard"
    }
  }, {
    path: "/admin/organizations/create",
    component: Md,
    meta: {
      title: "Create Organization - My Application"
    }
  }, {
    path: "/admin/users/create",
    component: Md,
    meta: {
      title: "Create User - My Application"
    }
  }, {
    path: "/users",
    component: T4,
    meta: {
      title: "Manage Users"
    }
  }, {
    path: "/students",
    component: i$,
    meta: {
      title: "Manage Students"
    }
  }, {
    path: "/users/:id",
    component: vp,
    meta: {
      title: "User Details"
    }
  }],
  I1 = $A({
    history: hA(),
    routes: s$
  });
I1.beforeEach((e, t, a) => {
  const o = !!localStorage.getItem("khdgisiygkdagdikbkadlnlho3y4973u");
  e.path !== "/login" && !o ? a("/login") : e.path === "/login" && o ? a("/dashboard") : (e.meta.title && (document.title = e.meta.title), a())
});
const o$ = sS({
  state: {
    user: {
      first_name: "",
      last_name: ""
    }
  },
  mutations: {
    setUser(e, t) {
      e.user = t
    }
  },
  actions: {
    setUser({
      commit: e
    }, t) {
      e("setUser", t)
    }
  },
  getters: {
    getUser: e => e.user
  }
});
/*!
 * shared v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
const Uc = typeof window < "u",
  Hi = (e, t = !1) => t ? Symbol.for(e) : Symbol(e),
  l$ = (e, t, a) => c$({
    l: e,
    k: t,
    s: a
  }),
  c$ = e => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
  Va = e => typeof e == "number" && isFinite(e),
  u$ = e => D1(e) === "[object Date]",
  Pi = e => D1(e) === "[object RegExp]",
  Iu = e => Lt(e) && Object.keys(e).length === 0,
  or = Object.assign;
let uv;
const Vn = () => uv || (uv = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function dv(e) {
  return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const d$ = Object.prototype.hasOwnProperty;

function Gc(e, t) {
  return d$.call(e, t)
}
const ya = Array.isArray,
  ha = e => typeof e == "function",
  ht = e => typeof e == "string",
  Bt = e => typeof e == "boolean",
  aa = e => e !== null && typeof e == "object",
  h$ = e => aa(e) && ha(e.then) && ha(e.catch),
  R1 = Object.prototype.toString,
  D1 = e => R1.call(e),
  Lt = e => {
    if (!aa(e)) return !1;
    const t = Object.getPrototypeOf(e);
    return t === null || t.constructor === Object
  },
  f$ = e => e == null ? "" : ya(e) || Lt(e) && e.toString === R1 ? JSON.stringify(e, null, 2) : String(e);

function p$(e, t = "") {
  return e.reduce((a, i, o) => o === 0 ? a + i : a + t + i, "")
}

function Ru(e) {
  let t = e;
  return () => ++t
}

function g$(e, t) {
  typeof console < "u" && (console.warn("[intlify] " + e), t && console.warn(t.stack))
}
const cc = e => !aa(e) || ya(e);

function kc(e, t) {
  if (cc(e) || cc(t)) throw new Error("Invalid value");
  const a = [{
    src: e,
    des: t
  }];
  for (; a.length;) {
    const {
      src: i,
      des: o
    } = a.pop();
    Object.keys(i).forEach(l => {
      cc(i[l]) || cc(o[l]) ? o[l] = i[l] : a.push({
        src: i[l],
        des: o[l]
      })
    })
  }
}
/*!
 * message-compiler v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
function m$(e, t, a) {
  return {
    line: e,
    column: t,
    offset: a
  }
}

function qc(e, t, a) {
  return {
    start: e,
    end: t
  }
}
const v$ = /\{([0-9a-zA-Z]+)\}/g;

function N1(e, ...t) {
  return t.length === 1 && b$(t[0]) && (t = t[0]), (!t || !t.hasOwnProperty) && (t = {}), e.replace(v$, (a, i) => t.hasOwnProperty(i) ? t[i] : "")
}
const F1 = Object.assign,
  hv = e => typeof e == "string",
  b$ = e => e !== null && typeof e == "object";

function $1(e, t = "") {
  return e.reduce((a, i, o) => o === 0 ? a + i : a + t + i, "")
}
const bp = {
    USE_MODULO_SYNTAX: 1,
    __EXTEND_POINT__: 2
  },
  y$ = {
    [bp.USE_MODULO_SYNTAX]: "Use modulo before '{{0}}'."
  };

function x$(e, t, ...a) {
  const i = N1(y$[e], ...a || []),
    o = {
      message: String(i),
      code: e
    };
  return t && (o.location = t), o
}
const St = {
    EXPECTED_TOKEN: 1,
    INVALID_TOKEN_IN_PLACEHOLDER: 2,
    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
    UNKNOWN_ESCAPE_SEQUENCE: 4,
    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
    UNBALANCED_CLOSING_BRACE: 6,
    UNTERMINATED_CLOSING_BRACE: 7,
    EMPTY_PLACEHOLDER: 8,
    NOT_ALLOW_NEST_PLACEHOLDER: 9,
    INVALID_LINKED_FORMAT: 10,
    MUST_HAVE_MESSAGES_IN_PLURAL: 11,
    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
    UNEXPECTED_EMPTY_LINKED_KEY: 13,
    UNEXPECTED_LEXICAL_ANALYSIS: 14,
    UNHANDLED_CODEGEN_NODE_TYPE: 15,
    UNHANDLED_MINIFIER_NODE_TYPE: 16,
    __EXTEND_POINT__: 17
  },
  w$ = {
    [St.EXPECTED_TOKEN]: "Expected token: '{0}'",
    [St.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
    [St.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
    [St.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
    [St.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
    [St.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
    [St.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
    [St.EMPTY_PLACEHOLDER]: "Empty placeholder",
    [St.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
    [St.INVALID_LINKED_FORMAT]: "Invalid linked format",
    [St.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
    [St.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
    [St.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
    [St.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
    [St.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
    [St.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
  };

function xo(e, t, a = {}) {
  const {
    domain: i,
    messages: o,
    args: l
  } = a, h = N1((o || w$)[e] || "", ...l || []), p = new SyntaxError(String(h));
  return p.code = e, t && (p.location = t), p.domain = i, p
}

function k$(e) {
  throw e
}
const Hn = " ",
  _$ = "\r",
  Sr = `
`,
  S$ = "\u2028",
  A$ = "\u2029";

function C$(e) {
  const t = e;
  let a = 0,
    i = 1,
    o = 1,
    l = 0;
  const h = V => t[V] === _$ && t[V + 1] === Sr,
    p = V => t[V] === Sr,
    m = V => t[V] === A$,
    k = V => t[V] === S$,
    w = V => h(V) || p(V) || m(V) || k(V),
    S = () => a,
    A = () => i,
    E = () => o,
    M = () => l,
    D = V => h(V) || m(V) || k(V) ? Sr : t[V],
    B = () => D(a),
    z = () => D(a + l);

  function I() {
    return l = 0, w(a) && (i++, o = 0), h(a) && a++, a++, o++, t[a]
  }

  function N() {
    return h(a + l) && l++, l++, t[a + l]
  }

  function U() {
    a = 0, i = 1, o = 1, l = 0
  }

  function W(V = 0) {
    l = V
  }

  function X() {
    const V = a + l;
    for (; V !== a;) I();
    l = 0
  }
  return {
    index: S,
    line: A,
    column: E,
    peekOffset: M,
    charAt: D,
    currentChar: B,
    currentPeek: z,
    next: I,
    peek: N,
    reset: U,
    resetPeek: W,
    skipToPeek: X
  }
}
const di = void 0,
  T$ = ".",
  fv = "'",
  E$ = "tokenizer";

function P$(e, t = {}) {
  const a = t.location !== !1,
    i = C$(e),
    o = () => i.index(),
    l = () => m$(i.line(), i.column(), i.index()),
    h = l(),
    p = o(),
    m = {
      currentType: 14,
      offset: p,
      startLoc: h,
      endLoc: h,
      lastType: 14,
      lastOffset: p,
      lastStartLoc: h,
      lastEndLoc: h,
      braceNest: 0,
      inLinked: !1,
      text: ""
    },
    k = () => m,
    {
      onError: w
    } = t;

  function S(K, ae, xe, ...Ce) {
    const tt = k();
    if (ae.column += xe, ae.offset += xe, w) {
      const qe = a ? qc(tt.startLoc, ae) : null,
        Te = xo(K, qe, {
          domain: E$,
          args: Ce
        });
      w(Te)
    }
  }

  function A(K, ae, xe) {
    K.endLoc = l(), K.currentType = ae;
    const Ce = {
      type: ae
    };
    return a && (Ce.loc = qc(K.startLoc, K.endLoc)), xe != null && (Ce.value = xe), Ce
  }
  const E = K => A(K, 14);

  function M(K, ae) {
    return K.currentChar() === ae ? (K.next(), ae) : (S(St.EXPECTED_TOKEN, l(), 0, ae), "")
  }

  function D(K) {
    let ae = "";
    for (; K.currentPeek() === Hn || K.currentPeek() === Sr;) ae += K.currentPeek(), K.peek();
    return ae
  }

  function B(K) {
    const ae = D(K);
    return K.skipToPeek(), ae
  }

  function z(K) {
    if (K === di) return !1;
    const ae = K.charCodeAt(0);
    return ae >= 97 && ae <= 122 || ae >= 65 && ae <= 90 || ae === 95
  }

  function I(K) {
    if (K === di) return !1;
    const ae = K.charCodeAt(0);
    return ae >= 48 && ae <= 57
  }

  function N(K, ae) {
    const {
      currentType: xe
    } = ae;
    if (xe !== 2) return !1;
    D(K);
    const Ce = z(K.currentPeek());
    return K.resetPeek(), Ce
  }

  function U(K, ae) {
    const {
      currentType: xe
    } = ae;
    if (xe !== 2) return !1;
    D(K);
    const Ce = K.currentPeek() === "-" ? K.peek() : K.currentPeek(),
      tt = I(Ce);
    return K.resetPeek(), tt
  }

  function W(K, ae) {
    const {
      currentType: xe
    } = ae;
    if (xe !== 2) return !1;
    D(K);
    const Ce = K.currentPeek() === fv;
    return K.resetPeek(), Ce
  }

  function X(K, ae) {
    const {
      currentType: xe
    } = ae;
    if (xe !== 8) return !1;
    D(K);
    const Ce = K.currentPeek() === ".";
    return K.resetPeek(), Ce
  }

  function V(K, ae) {
    const {
      currentType: xe
    } = ae;
    if (xe !== 9) return !1;
    D(K);
    const Ce = z(K.currentPeek());
    return K.resetPeek(), Ce
  }

  function ne(K, ae) {
    const {
      currentType: xe
    } = ae;
    if (!(xe === 8 || xe === 12)) return !1;
    D(K);
    const Ce = K.currentPeek() === ":";
    return K.resetPeek(), Ce
  }

  function Z(K, ae) {
    const {
      currentType: xe
    } = ae;
    if (xe !== 10) return !1;
    const Ce = () => {
        const qe = K.currentPeek();
        return qe === "{" ? z(K.peek()) : qe === "@" || qe === "%" || qe === "|" || qe === ":" || qe === "." || qe === Hn || !qe ? !1 : qe === Sr ? (K.peek(), Ce()) : le(K, !1)
      },
      tt = Ce();
    return K.resetPeek(), tt
  }

  function ie(K) {
    D(K);
    const ae = K.currentPeek() === "|";
    return K.resetPeek(), ae
  }

  function fe(K) {
    const ae = D(K),
      xe = K.currentPeek() === "%" && K.peek() === "{";
    return K.resetPeek(), {
      isModulo: xe,
      hasSpace: ae.length > 0
    }
  }

  function le(K, ae = !0) {
    const xe = (tt = !1, qe = "", Te = !1) => {
        const $e = K.currentPeek();
        return $e === "{" ? qe === "%" ? !1 : tt : $e === "@" || !$e ? qe === "%" ? !0 : tt : $e === "%" ? (K.peek(), xe(tt, "%", !0)) : $e === "|" ? qe === "%" || Te ? !0 : !(qe === Hn || qe === Sr) : $e === Hn ? (K.peek(), xe(!0, Hn, Te)) : $e === Sr ? (K.peek(), xe(!0, Sr, Te)) : !0
      },
      Ce = xe();
    return ae && K.resetPeek(), Ce
  }

  function Ee(K, ae) {
    const xe = K.currentChar();
    return xe === di ? di : ae(xe) ? (K.next(), xe) : null
  }

  function ye(K) {
    const ae = K.charCodeAt(0);
    return ae >= 97 && ae <= 122 || ae >= 65 && ae <= 90 || ae >= 48 && ae <= 57 || ae === 95 || ae === 36
  }

  function ve(K) {
    return Ee(K, ye)
  }

  function me(K) {
    const ae = K.charCodeAt(0);
    return ae >= 97 && ae <= 122 || ae >= 65 && ae <= 90 || ae >= 48 && ae <= 57 || ae === 95 || ae === 36 || ae === 45
  }

  function Ae(K) {
    return Ee(K, me)
  }

  function He(K) {
    const ae = K.charCodeAt(0);
    return ae >= 48 && ae <= 57
  }

  function De(K) {
    return Ee(K, He)
  }

  function Ye(K) {
    const ae = K.charCodeAt(0);
    return ae >= 48 && ae <= 57 || ae >= 65 && ae <= 70 || ae >= 97 && ae <= 102
  }

  function Je(K) {
    return Ee(K, Ye)
  }

  function he(K) {
    let ae = "",
      xe = "";
    for (; ae = De(K);) xe += ae;
    return xe
  }

  function ke(K) {
    B(K);
    const ae = K.currentChar();
    return ae !== "%" && S(St.EXPECTED_TOKEN, l(), 0, ae), K.next(), "%"
  }

  function re(K) {
    let ae = "";
    for (;;) {
      const xe = K.currentChar();
      if (xe === "{" || xe === "}" || xe === "@" || xe === "|" || !xe) break;
      if (xe === "%")
        if (le(K)) ae += xe, K.next();
        else break;
      else if (xe === Hn || xe === Sr)
        if (le(K)) ae += xe, K.next();
        else {
          if (ie(K)) break;
          ae += xe, K.next()
        }
      else ae += xe, K.next()
    }
    return ae
  }

  function Se(K) {
    B(K);
    let ae = "",
      xe = "";
    for (; ae = Ae(K);) xe += ae;
    return K.currentChar() === di && S(St.UNTERMINATED_CLOSING_BRACE, l(), 0), xe
  }

  function Be(K) {
    B(K);
    let ae = "";
    return K.currentChar() === "-" ? (K.next(), ae += `-${he(K)}`) : ae += he(K), K.currentChar() === di && S(St.UNTERMINATED_CLOSING_BRACE, l(), 0), ae
  }

  function J(K) {
    return K !== fv && K !== Sr
  }

  function Re(K) {
    B(K), M(K, "'");
    let ae = "",
      xe = "";
    for (; ae = Ee(K, J);) ae === "\\" ? xe += Xe(K) : xe += ae;
    const Ce = K.currentChar();
    return Ce === Sr || Ce === di ? (S(St.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, l(), 0), Ce === Sr && (K.next(), M(K, "'")), xe) : (M(K, "'"), xe)
  }

  function Xe(K) {
    const ae = K.currentChar();
    switch (ae) {
      case "\\":
      case "'":
        return K.next(), `\\${ae}`;
      case "u":
        return nt(K, ae, 4);
      case "U":
        return nt(K, ae, 6);
      default:
        return S(St.UNKNOWN_ESCAPE_SEQUENCE, l(), 0, ae), ""
    }
  }

  function nt(K, ae, xe) {
    M(K, ae);
    let Ce = "";
    for (let tt = 0; tt < xe; tt++) {
      const qe = Je(K);
      if (!qe) {
        S(St.INVALID_UNICODE_ESCAPE_SEQUENCE, l(), 0, `\\${ae}${Ce}${K.currentChar()}`);
        break
      }
      Ce += qe
    }
    return `\\${ae}${Ce}`
  }

  function Pe(K) {
    return K !== "{" && K !== "}" && K !== Hn && K !== Sr
  }

  function We(K) {
    B(K);
    let ae = "",
      xe = "";
    for (; ae = Ee(K, Pe);) xe += ae;
    return xe
  }

  function F(K) {
    let ae = "",
      xe = "";
    for (; ae = ve(K);) xe += ae;
    return xe
  }

  function j(K) {
    const ae = xe => {
      const Ce = K.currentChar();
      return Ce === "{" || Ce === "%" || Ce === "@" || Ce === "|" || Ce === "(" || Ce === ")" || !Ce || Ce === Hn ? xe : (xe += Ce, K.next(), ae(xe))
    };
    return ae("")
  }

  function oe(K) {
    B(K);
    const ae = M(K, "|");
    return B(K), ae
  }

  function de(K, ae) {
    let xe = null;
    switch (K.currentChar()) {
      case "{":
        return ae.braceNest >= 1 && S(St.NOT_ALLOW_NEST_PLACEHOLDER, l(), 0), K.next(), xe = A(ae, 2, "{"), B(K), ae.braceNest++, xe;
      case "}":
        return ae.braceNest > 0 && ae.currentType === 2 && S(St.EMPTY_PLACEHOLDER, l(), 0), K.next(), xe = A(ae, 3, "}"), ae.braceNest--, ae.braceNest > 0 && B(K), ae.inLinked && ae.braceNest === 0 && (ae.inLinked = !1), xe;
      case "@":
        return ae.braceNest > 0 && S(St.UNTERMINATED_CLOSING_BRACE, l(), 0), xe = Ie(K, ae) || E(ae), ae.braceNest = 0, xe;
      default: {
        let tt = !0,
          qe = !0,
          Te = !0;
        if (ie(K)) return ae.braceNest > 0 && S(St.UNTERMINATED_CLOSING_BRACE, l(), 0), xe = A(ae, 1, oe(K)), ae.braceNest = 0, ae.inLinked = !1, xe;
        if (ae.braceNest > 0 && (ae.currentType === 5 || ae.currentType === 6 || ae.currentType === 7)) return S(St.UNTERMINATED_CLOSING_BRACE, l(), 0), ae.braceNest = 0, ue(K, ae);
        if (tt = N(K, ae)) return xe = A(ae, 5, Se(K)), B(K), xe;
        if (qe = U(K, ae)) return xe = A(ae, 6, Be(K)), B(K), xe;
        if (Te = W(K, ae)) return xe = A(ae, 7, Re(K)), B(K), xe;
        if (!tt && !qe && !Te) return xe = A(ae, 13, We(K)), S(St.INVALID_TOKEN_IN_PLACEHOLDER, l(), 0, xe.value), B(K), xe;
        break
      }
    }
    return xe
  }

  function Ie(K, ae) {
    const {
      currentType: xe
    } = ae;
    let Ce = null;
    const tt = K.currentChar();
    switch ((xe === 8 || xe === 9 || xe === 12 || xe === 10) && (tt === Sr || tt === Hn) && S(St.INVALID_LINKED_FORMAT, l(), 0), tt) {
      case "@":
        return K.next(), Ce = A(ae, 8, "@"), ae.inLinked = !0, Ce;
      case ".":
        return B(K), K.next(), A(ae, 9, ".");
      case ":":
        return B(K), K.next(), A(ae, 10, ":");
      default:
        return ie(K) ? (Ce = A(ae, 1, oe(K)), ae.braceNest = 0, ae.inLinked = !1, Ce) : X(K, ae) || ne(K, ae) ? (B(K), Ie(K, ae)) : V(K, ae) ? (B(K), A(ae, 12, F(K))) : Z(K, ae) ? (B(K), tt === "{" ? de(K, ae) || Ce : A(ae, 11, j(K))) : (xe === 8 && S(St.INVALID_LINKED_FORMAT, l(), 0), ae.braceNest = 0, ae.inLinked = !1, ue(K, ae))
    }
  }

  function ue(K, ae) {
    let xe = {
      type: 14
    };
    if (ae.braceNest > 0) return de(K, ae) || E(ae);
    if (ae.inLinked) return Ie(K, ae) || E(ae);
    switch (K.currentChar()) {
      case "{":
        return de(K, ae) || E(ae);
      case "}":
        return S(St.UNBALANCED_CLOSING_BRACE, l(), 0), K.next(), A(ae, 3, "}");
      case "@":
        return Ie(K, ae) || E(ae);
      default: {
        if (ie(K)) return xe = A(ae, 1, oe(K)), ae.braceNest = 0, ae.inLinked = !1, xe;
        const {
          isModulo: tt,
          hasSpace: qe
        } = fe(K);
        if (tt) return qe ? A(ae, 0, re(K)) : A(ae, 4, ke(K));
        if (le(K)) return A(ae, 0, re(K));
        break
      }
    }
    return xe
  }

  function Le() {
    const {
      currentType: K,
      offset: ae,
      startLoc: xe,
      endLoc: Ce
    } = m;
    return m.lastType = K, m.lastOffset = ae, m.lastStartLoc = xe, m.lastEndLoc = Ce, m.offset = o(), m.startLoc = l(), i.currentChar() === di ? A(m, 14) : ue(i, m)
  }
  return {
    nextToken: Le,
    currentOffset: o,
    currentPosition: l,
    context: k
  }
}
const L$ = "parser",
  O$ = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function M$(e, t, a) {
  switch (e) {
    case "\\\\":
      return "\\";
    case "\\'":
      return "'";
    default: {
      const i = parseInt(t || a, 16);
      return i <= 55295 || i >= 57344 ? String.fromCodePoint(i) : "�"
    }
  }
}

function I$(e = {}) {
  const t = e.location !== !1,
    {
      onError: a,
      onWarn: i
    } = e;

  function o(N, U, W, X, ...V) {
    const ne = N.currentPosition();
    if (ne.offset += X, ne.column += X, a) {
      const Z = t ? qc(W, ne) : null,
        ie = xo(U, Z, {
          domain: L$,
          args: V
        });
      a(ie)
    }
  }

  function l(N, U, W, X, ...V) {
    const ne = N.currentPosition();
    if (ne.offset += X, ne.column += X, i) {
      const Z = t ? qc(W, ne) : null;
      i(x$(U, Z, V))
    }
  }

  function h(N, U, W) {
    const X = {
      type: N
    };
    return t && (X.start = U, X.end = U, X.loc = {
      start: W,
      end: W
    }), X
  }

  function p(N, U, W, X) {
    t && (N.end = U, N.loc && (N.loc.end = W))
  }

  function m(N, U) {
    const W = N.context(),
      X = h(3, W.offset, W.startLoc);
    return X.value = U, p(X, N.currentOffset(), N.currentPosition()), X
  }

  function k(N, U) {
    const W = N.context(),
      {
        lastOffset: X,
        lastStartLoc: V
      } = W,
      ne = h(5, X, V);
    return ne.index = parseInt(U, 10), N.nextToken(), p(ne, N.currentOffset(), N.currentPosition()), ne
  }

  function w(N, U, W) {
    const X = N.context(),
      {
        lastOffset: V,
        lastStartLoc: ne
      } = X,
      Z = h(4, V, ne);
    return Z.key = U, W === !0 && (Z.modulo = !0), N.nextToken(), p(Z, N.currentOffset(), N.currentPosition()), Z
  }

  function S(N, U) {
    const W = N.context(),
      {
        lastOffset: X,
        lastStartLoc: V
      } = W,
      ne = h(9, X, V);
    return ne.value = U.replace(O$, M$), N.nextToken(), p(ne, N.currentOffset(), N.currentPosition()), ne
  }

  function A(N) {
    const U = N.nextToken(),
      W = N.context(),
      {
        lastOffset: X,
        lastStartLoc: V
      } = W,
      ne = h(8, X, V);
    return U.type !== 12 ? (o(N, St.UNEXPECTED_EMPTY_LINKED_MODIFIER, W.lastStartLoc, 0), ne.value = "", p(ne, X, V), {
      nextConsumeToken: U,
      node: ne
    }) : (U.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, W.lastStartLoc, 0, an(U)), ne.value = U.value || "", p(ne, N.currentOffset(), N.currentPosition()), {
      node: ne
    })
  }

  function E(N, U) {
    const W = N.context(),
      X = h(7, W.offset, W.startLoc);
    return X.value = U, p(X, N.currentOffset(), N.currentPosition()), X
  }

  function M(N) {
    const U = N.context(),
      W = h(6, U.offset, U.startLoc);
    let X = N.nextToken();
    if (X.type === 9) {
      const V = A(N);
      W.modifier = V.node, X = V.nextConsumeToken || N.nextToken()
    }
    switch (X.type !== 10 && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(X)), X = N.nextToken(), X.type === 2 && (X = N.nextToken()), X.type) {
      case 11:
        X.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(X)), W.key = E(N, X.value || "");
        break;
      case 5:
        X.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(X)), W.key = w(N, X.value || "");
        break;
      case 6:
        X.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(X)), W.key = k(N, X.value || "");
        break;
      case 7:
        X.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(X)), W.key = S(N, X.value || "");
        break;
      default: {
        o(N, St.UNEXPECTED_EMPTY_LINKED_KEY, U.lastStartLoc, 0);
        const V = N.context(),
          ne = h(7, V.offset, V.startLoc);
        return ne.value = "", p(ne, V.offset, V.startLoc), W.key = ne, p(W, V.offset, V.startLoc), {
          nextConsumeToken: X,
          node: W
        }
      }
    }
    return p(W, N.currentOffset(), N.currentPosition()), {
      node: W
    }
  }

  function D(N) {
    const U = N.context(),
      W = U.currentType === 1 ? N.currentOffset() : U.offset,
      X = U.currentType === 1 ? U.endLoc : U.startLoc,
      V = h(2, W, X);
    V.items = [];
    let ne = null,
      Z = null;
    do {
      const le = ne || N.nextToken();
      switch (ne = null, le.type) {
        case 0:
          le.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(le)), V.items.push(m(N, le.value || ""));
          break;
        case 6:
          le.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(le)), V.items.push(k(N, le.value || ""));
          break;
        case 4:
          Z = !0;
          break;
        case 5:
          le.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(le)), V.items.push(w(N, le.value || "", !!Z)), Z && (l(N, bp.USE_MODULO_SYNTAX, U.lastStartLoc, 0, an(le)), Z = null);
          break;
        case 7:
          le.value == null && o(N, St.UNEXPECTED_LEXICAL_ANALYSIS, U.lastStartLoc, 0, an(le)), V.items.push(S(N, le.value || ""));
          break;
        case 8: {
          const Ee = M(N);
          V.items.push(Ee.node), ne = Ee.nextConsumeToken || null;
          break
        }
      }
    } while (U.currentType !== 14 && U.currentType !== 1);
    const ie = U.currentType === 1 ? U.lastOffset : N.currentOffset(),
      fe = U.currentType === 1 ? U.lastEndLoc : N.currentPosition();
    return p(V, ie, fe), V
  }

  function B(N, U, W, X) {
    const V = N.context();
    let ne = X.items.length === 0;
    const Z = h(1, U, W);
    Z.cases = [], Z.cases.push(X);
    do {
      const ie = D(N);
      ne || (ne = ie.items.length === 0), Z.cases.push(ie)
    } while (V.currentType !== 14);
    return ne && o(N, St.MUST_HAVE_MESSAGES_IN_PLURAL, W, 0), p(Z, N.currentOffset(), N.currentPosition()), Z
  }

  function z(N) {
    const U = N.context(),
      {
        offset: W,
        startLoc: X
      } = U,
      V = D(N);
    return U.currentType === 14 ? V : B(N, W, X, V)
  }

  function I(N) {
    const U = P$(N, F1({}, e)),
      W = U.context(),
      X = h(0, W.offset, W.startLoc);
    return t && X.loc && (X.loc.source = N), X.body = z(U), e.onCacheKey && (X.cacheKey = e.onCacheKey(N)), W.currentType !== 14 && o(U, St.UNEXPECTED_LEXICAL_ANALYSIS, W.lastStartLoc, 0, N[W.offset] || ""), p(X, U.currentOffset(), U.currentPosition()), X
  }
  return {
    parse: I
  }
}

function an(e) {
  if (e.type === 14) return "EOF";
  const t = (e.value || "").replace(/\r?\n/gu, "\\n");
  return t.length > 10 ? t.slice(0, 9) + "…" : t
}

function R$(e, t = {}) {
  const a = {
    ast: e,
    helpers: new Set
  };
  return {
    context: () => a,
    helper: l => (a.helpers.add(l), l)
  }
}

function pv(e, t) {
  for (let a = 0; a < e.length; a++) yp(e[a], t)
}

function yp(e, t) {
  switch (e.type) {
    case 1:
      pv(e.cases, t), t.helper("plural");
      break;
    case 2:
      pv(e.items, t);
      break;
    case 6: {
      yp(e.key, t), t.helper("linked"), t.helper("type");
      break
    }
    case 5:
      t.helper("interpolate"), t.helper("list");
      break;
    case 4:
      t.helper("interpolate"), t.helper("named");
      break
  }
}

function D$(e, t = {}) {
  const a = R$(e);
  a.helper("normalize"), e.body && yp(e.body, a);
  const i = a.context();
  e.helpers = Array.from(i.helpers)
}

function N$(e) {
  const t = e.body;
  return t.type === 2 ? gv(t) : t.cases.forEach(a => gv(a)), e
}

function gv(e) {
  if (e.items.length === 1) {
    const t = e.items[0];
    (t.type === 3 || t.type === 9) && (e.static = t.value, delete t.value)
  } else {
    const t = [];
    for (let a = 0; a < e.items.length; a++) {
      const i = e.items[a];
      if (!(i.type === 3 || i.type === 9) || i.value == null) break;
      t.push(i.value)
    }
    if (t.length === e.items.length) {
      e.static = $1(t);
      for (let a = 0; a < e.items.length; a++) {
        const i = e.items[a];
        (i.type === 3 || i.type === 9) && delete i.value
      }
    }
  }
}
const F$ = "minifier";

function $s(e) {
  switch (e.t = e.type, e.type) {
    case 0: {
      const t = e;
      $s(t.body), t.b = t.body, delete t.body;
      break
    }
    case 1: {
      const t = e,
        a = t.cases;
      for (let i = 0; i < a.length; i++) $s(a[i]);
      t.c = a, delete t.cases;
      break
    }
    case 2: {
      const t = e,
        a = t.items;
      for (let i = 0; i < a.length; i++) $s(a[i]);
      t.i = a, delete t.items, t.static && (t.s = t.static, delete t.static);
      break
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const t = e;
      t.value && (t.v = t.value, delete t.value);
      break
    }
    case 6: {
      const t = e;
      $s(t.key), t.k = t.key, delete t.key, t.modifier && ($s(t.modifier), t.m = t.modifier, delete t.modifier);
      break
    }
    case 5: {
      const t = e;
      t.i = t.index, delete t.index;
      break
    }
    case 4: {
      const t = e;
      t.k = t.key, delete t.key;
      break
    }
    default:
      throw xo(St.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: F$,
        args: [e.type]
      })
  }
  delete e.type
}
const $$ = "parser";

function B$(e, t) {
  const {
    sourceMap: a,
    filename: i,
    breakLineCode: o,
    needIndent: l
  } = t, h = t.location !== !1, p = {
    filename: i,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode: o,
    needIndent: l,
    indentLevel: 0
  };
  h && e.loc && (p.source = e.loc.source);
  const m = () => p;

  function k(B, z) {
    p.code += B
  }

  function w(B, z = !0) {
    const I = z ? o : "";
    k(l ? I + "  ".repeat(B) : I)
  }

  function S(B = !0) {
    const z = ++p.indentLevel;
    B && w(z)
  }

  function A(B = !0) {
    const z = --p.indentLevel;
    B && w(z)
  }

  function E() {
    w(p.indentLevel)
  }
  return {
    context: m,
    push: k,
    indent: S,
    deindent: A,
    newline: E,
    helper: B => `_${B}`,
    needIndent: () => p.needIndent
  }
}

function H$(e, t) {
  const {
    helper: a
  } = e;
  e.push(`${a("linked")}(`), co(e, t.key), t.modifier ? (e.push(", "), co(e, t.modifier), e.push(", _type")) : e.push(", undefined, _type"), e.push(")")
}

function Y$(e, t) {
  const {
    helper: a,
    needIndent: i
  } = e;
  e.push(`${a("normalize")}([`), e.indent(i());
  const o = t.items.length;
  for (let l = 0; l < o && (co(e, t.items[l]), l !== o - 1); l++) e.push(", ");
  e.deindent(i()), e.push("])")
}

function z$(e, t) {
  const {
    helper: a,
    needIndent: i
  } = e;
  if (t.cases.length > 1) {
    e.push(`${a("plural")}([`), e.indent(i());
    const o = t.cases.length;
    for (let l = 0; l < o && (co(e, t.cases[l]), l !== o - 1); l++) e.push(", ");
    e.deindent(i()), e.push("])")
  }
}

function X$(e, t) {
  t.body ? co(e, t.body) : e.push("null")
}

function co(e, t) {
  const {
    helper: a
  } = e;
  switch (t.type) {
    case 0:
      X$(e, t);
      break;
    case 1:
      z$(e, t);
      break;
    case 2:
      Y$(e, t);
      break;
    case 6:
      H$(e, t);
      break;
    case 8:
      e.push(JSON.stringify(t.value), t);
      break;
    case 7:
      e.push(JSON.stringify(t.value), t);
      break;
    case 5:
      e.push(`${a("interpolate")}(${a("list")}(${t.index}))`, t);
      break;
    case 4:
      e.push(`${a("interpolate")}(${a("named")}(${JSON.stringify(t.key)}))`, t);
      break;
    case 9:
      e.push(JSON.stringify(t.value), t);
      break;
    case 3:
      e.push(JSON.stringify(t.value), t);
      break;
    default:
      throw xo(St.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: $$,
        args: [t.type]
      })
  }
}
const W$ = (e, t = {}) => {
  const a = hv(t.mode) ? t.mode : "normal",
    i = hv(t.filename) ? t.filename : "message.intl",
    o = !!t.sourceMap,
    l = t.breakLineCode != null ? t.breakLineCode : a === "arrow" ? ";" : `
`,
    h = t.needIndent ? t.needIndent : a !== "arrow",
    p = e.helpers || [],
    m = B$(e, {
      mode: a,
      filename: i,
      sourceMap: o,
      breakLineCode: l,
      needIndent: h
    });
  m.push(a === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), m.indent(h), p.length > 0 && (m.push(`const { ${$1(p.map(S=>`${S}: _${S}`),", ")} } = ctx`), m.newline()), m.push("return "), co(m, e), m.deindent(h), m.push("}"), delete e.helpers;
  const {
    code: k,
    map: w
  } = m.context();
  return {
    ast: e,
    code: k,
    map: w ? w.toJSON() : void 0
  }
};

function V$(e, t = {}) {
  const a = F1({}, t),
    i = !!a.jit,
    o = !!a.minify,
    l = a.optimize == null ? !0 : a.optimize,
    p = I$(a).parse(e);
  return i ? (l && N$(p), o && $s(p), {
    ast: p,
    code: ""
  }) : (D$(p, a), W$(p, a))
}
/*!
 * core-base v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
function j$() {
  typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Vn().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Vn().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Vn().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1)
}
const Yi = [];
Yi[0] = {
  w: [0],
  i: [3, 0],
  "[": [4],
  o: [7]
};
Yi[1] = {
  w: [1],
  ".": [2],
  "[": [4],
  o: [7]
};
Yi[2] = {
  w: [2],
  i: [3, 0],
  0: [3, 0]
};
Yi[3] = {
  i: [3, 0],
  0: [3, 0],
  w: [1, 1],
  ".": [2, 1],
  "[": [4, 1],
  o: [7, 1]
};
Yi[4] = {
  "'": [5, 0],
  '"': [6, 0],
  "[": [4, 2],
  "]": [1, 3],
  o: 8,
  l: [4, 0]
};
Yi[5] = {
  "'": [4, 0],
  o: 8,
  l: [5, 0]
};
Yi[6] = {
  '"': [4, 0],
  o: 8,
  l: [6, 0]
};
const U$ = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function G$(e) {
  return U$.test(e)
}

function q$(e) {
  const t = e.charCodeAt(0),
    a = e.charCodeAt(e.length - 1);
  return t === a && (t === 34 || t === 39) ? e.slice(1, -1) : e
}

function K$(e) {
  if (e == null) return "o";
  switch (e.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return e;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w"
  }
  return "i"
}

function Z$(e) {
  const t = e.trim();
  return e.charAt(0) === "0" && isNaN(parseInt(e)) ? !1 : G$(t) ? q$(t) : "*" + t
}

function Q$(e) {
  const t = [];
  let a = -1,
    i = 0,
    o = 0,
    l, h, p, m, k, w, S;
  const A = [];
  A[0] = () => {
    h === void 0 ? h = p : h += p
  }, A[1] = () => {
    h !== void 0 && (t.push(h), h = void 0)
  }, A[2] = () => {
    A[0](), o++
  }, A[3] = () => {
    if (o > 0) o--, i = 4, A[0]();
    else {
      if (o = 0, h === void 0 || (h = Z$(h), h === !1)) return !1;
      A[1]()
    }
  };

  function E() {
    const M = e[a + 1];
    if (i === 5 && M === "'" || i === 6 && M === '"') return a++, p = "\\" + M, A[0](), !0
  }
  for (; i !== null;)
    if (a++, l = e[a], !(l === "\\" && E())) {
      if (m = K$(l), S = Yi[i], k = S[m] || S.l || 8, k === 8 || (i = k[0], k[1] !== void 0 && (w = A[k[1]], w && (p = l, w() === !1)))) return;
      if (i === 7) return t
    }
}
const mv = new Map;

function J$(e, t) {
  return aa(e) ? e[t] : null
}

function e8(e, t) {
  if (!aa(e)) return null;
  let a = mv.get(t);
  if (a || (a = Q$(t), a && mv.set(t, a)), !a) return null;
  const i = a.length;
  let o = e,
    l = 0;
  for (; l < i;) {
    const h = o[a[l]];
    if (h === void 0 || ha(o)) return null;
    o = h, l++
  }
  return o
}
const t8 = e => e,
  a8 = e => "",
  r8 = "text",
  n8 = e => e.length === 0 ? "" : p$(e),
  i8 = f$;

function vv(e, t) {
  return e = Math.abs(e), t === 2 ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0
}

function s8(e) {
  const t = Va(e.pluralIndex) ? e.pluralIndex : -1;
  return e.named && (Va(e.named.count) || Va(e.named.n)) ? Va(e.named.count) ? e.named.count : Va(e.named.n) ? e.named.n : t : t
}

function o8(e, t) {
  t.count || (t.count = e), t.n || (t.n = e)
}

function l8(e = {}) {
  const t = e.locale,
    a = s8(e),
    i = aa(e.pluralRules) && ht(t) && ha(e.pluralRules[t]) ? e.pluralRules[t] : vv,
    o = aa(e.pluralRules) && ht(t) && ha(e.pluralRules[t]) ? vv : void 0,
    l = z => z[i(a, z.length, o)],
    h = e.list || [],
    p = z => h[z],
    m = e.named || {};
  Va(e.pluralIndex) && o8(a, m);
  const k = z => m[z];

  function w(z) {
    const I = ha(e.messages) ? e.messages(z) : aa(e.messages) ? e.messages[z] : !1;
    return I || (e.parent ? e.parent.message(z) : a8)
  }
  const S = z => e.modifiers ? e.modifiers[z] : t8,
    A = Lt(e.processor) && ha(e.processor.normalize) ? e.processor.normalize : n8,
    E = Lt(e.processor) && ha(e.processor.interpolate) ? e.processor.interpolate : i8,
    M = Lt(e.processor) && ht(e.processor.type) ? e.processor.type : r8,
    B = {
      list: p,
      named: k,
      plural: l,
      linked: (z, ...I) => {
        const [N, U] = I;
        let W = "text",
          X = "";
        I.length === 1 ? aa(N) ? (X = N.modifier || X, W = N.type || W) : ht(N) && (X = N || X) : I.length === 2 && (ht(N) && (X = N || X), ht(U) && (W = U || W));
        const V = w(z)(B),
          ne = W === "vnode" && ya(V) && X ? V[0] : V;
        return X ? S(X)(ne, W) : ne
      },
      message: w,
      type: M,
      interpolate: E,
      normalize: A,
      values: or({}, h, m)
    };
  return B
}
let wl = null;

function c8(e) {
  wl = e
}

function u8(e, t, a) {
  wl && wl.emit("i18n:init", {
    timestamp: Date.now(),
    i18n: e,
    version: t,
    meta: a
  })
}
const d8 = h8("function:translate");

function h8(e) {
  return t => wl && wl.emit(e, t)
}
const B1 = bp.__EXTEND_POINT__,
  Ki = Ru(B1),
  f8 = {
    NOT_FOUND_KEY: B1,
    FALLBACK_TO_TRANSLATE: Ki(),
    CANNOT_FORMAT_NUMBER: Ki(),
    FALLBACK_TO_NUMBER_FORMAT: Ki(),
    CANNOT_FORMAT_DATE: Ki(),
    FALLBACK_TO_DATE_FORMAT: Ki(),
    EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: Ki(),
    __EXTEND_POINT__: Ki()
  },
  H1 = St.__EXTEND_POINT__,
  Zi = Ru(H1),
  on = {
    INVALID_ARGUMENT: H1,
    INVALID_DATE_ARGUMENT: Zi(),
    INVALID_ISO_DATE_ARGUMENT: Zi(),
    NOT_SUPPORT_NON_STRING_MESSAGE: Zi(),
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: Zi(),
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: Zi(),
    NOT_SUPPORT_LOCALE_TYPE: Zi(),
    __EXTEND_POINT__: Zi()
  };

function Ln(e) {
  return xo(e, null, void 0)
}

function xp(e, t) {
  return t.locale != null ? bv(t.locale) : bv(e.locale)
}
let qd;

function bv(e) {
  if (ht(e)) return e;
  if (ha(e)) {
    if (e.resolvedOnce && qd != null) return qd;
    if (e.constructor.name === "Function") {
      const t = e();
      if (h$(t)) throw Ln(on.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
      return qd = t
    } else throw Ln(on.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
  } else throw Ln(on.NOT_SUPPORT_LOCALE_TYPE)
}

function p8(e, t, a) {
  return [...new Set([a, ...ya(t) ? t : aa(t) ? Object.keys(t) : ht(t) ? [t] : [a]])]
}

function Y1(e, t, a) {
  const i = ht(a) ? a : uo,
    o = e;
  o.__localeChainCache || (o.__localeChainCache = new Map);
  let l = o.__localeChainCache.get(i);
  if (!l) {
    l = [];
    let h = [a];
    for (; ya(h);) h = yv(l, h, t);
    const p = ya(t) || !Lt(t) ? t : t.default ? t.default : null;
    h = ht(p) ? [p] : p, ya(h) && yv(l, h, !1), o.__localeChainCache.set(i, l)
  }
  return l
}

function yv(e, t, a) {
  let i = !0;
  for (let o = 0; o < t.length && Bt(i); o++) {
    const l = t[o];
    ht(l) && (i = g8(e, t[o], a))
  }
  return i
}

function g8(e, t, a) {
  let i;
  const o = t.split("-");
  do {
    const l = o.join("-");
    i = m8(e, l, a), o.splice(-1, 1)
  } while (o.length && i === !0);
  return i
}

function m8(e, t, a) {
  let i = !1;
  if (!e.includes(t) && (i = !0, t)) {
    i = t[t.length - 1] !== "!";
    const o = t.replace(/!/g, "");
    e.push(o), (ya(a) || Lt(a)) && a[o] && (i = a[o])
  }
  return i
}
const v8 = "9.13.1",
  Du = -1,
  uo = "en-US",
  xv = "",
  wv = e => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;

function b8() {
  return {
    upper: (e, t) => t === "text" && ht(e) ? e.toUpperCase() : t === "vnode" && aa(e) && "__v_isVNode" in e ? e.children.toUpperCase() : e,
    lower: (e, t) => t === "text" && ht(e) ? e.toLowerCase() : t === "vnode" && aa(e) && "__v_isVNode" in e ? e.children.toLowerCase() : e,
    capitalize: (e, t) => t === "text" && ht(e) ? wv(e) : t === "vnode" && aa(e) && "__v_isVNode" in e ? wv(e.children) : e
  }
}
let z1;

function kv(e) {
  z1 = e
}
let X1;

function y8(e) {
  X1 = e
}
let W1;

function x8(e) {
  W1 = e
}
let V1 = null;
const w8 = e => {
    V1 = e
  },
  k8 = () => V1;
let j1 = null;
const _v = e => {
    j1 = e
  },
  _8 = () => j1;
let Sv = 0;

function S8(e = {}) {
  const t = ha(e.onWarn) ? e.onWarn : g$,
    a = ht(e.version) ? e.version : v8,
    i = ht(e.locale) || ha(e.locale) ? e.locale : uo,
    o = ha(i) ? uo : i,
    l = ya(e.fallbackLocale) || Lt(e.fallbackLocale) || ht(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : o,
    h = Lt(e.messages) ? e.messages : {
      [o]: {}
    },
    p = Lt(e.datetimeFormats) ? e.datetimeFormats : {
      [o]: {}
    },
    m = Lt(e.numberFormats) ? e.numberFormats : {
      [o]: {}
    },
    k = or({}, e.modifiers || {}, b8()),
    w = e.pluralRules || {},
    S = ha(e.missing) ? e.missing : null,
    A = Bt(e.missingWarn) || Pi(e.missingWarn) ? e.missingWarn : !0,
    E = Bt(e.fallbackWarn) || Pi(e.fallbackWarn) ? e.fallbackWarn : !0,
    M = !!e.fallbackFormat,
    D = !!e.unresolving,
    B = ha(e.postTranslation) ? e.postTranslation : null,
    z = Lt(e.processor) ? e.processor : null,
    I = Bt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
    N = !!e.escapeParameter,
    U = ha(e.messageCompiler) ? e.messageCompiler : z1,
    W = ha(e.messageResolver) ? e.messageResolver : X1 || J$,
    X = ha(e.localeFallbacker) ? e.localeFallbacker : W1 || p8,
    V = aa(e.fallbackContext) ? e.fallbackContext : void 0,
    ne = e,
    Z = aa(ne.__datetimeFormatters) ? ne.__datetimeFormatters : new Map,
    ie = aa(ne.__numberFormatters) ? ne.__numberFormatters : new Map,
    fe = aa(ne.__meta) ? ne.__meta : {};
  Sv++;
  const le = {
    version: a,
    cid: Sv,
    locale: i,
    fallbackLocale: l,
    messages: h,
    modifiers: k,
    pluralRules: w,
    missing: S,
    missingWarn: A,
    fallbackWarn: E,
    fallbackFormat: M,
    unresolving: D,
    postTranslation: B,
    processor: z,
    warnHtmlMessage: I,
    escapeParameter: N,
    messageCompiler: U,
    messageResolver: W,
    localeFallbacker: X,
    fallbackContext: V,
    onWarn: t,
    __meta: fe
  };
  return le.datetimeFormats = p, le.numberFormats = m, le.__datetimeFormatters = Z, le.__numberFormatters = ie, __INTLIFY_PROD_DEVTOOLS__ && u8(le, a, fe), le
}

function wp(e, t, a, i, o) {
  const {
    missing: l,
    onWarn: h
  } = e;
  if (l !== null) {
    const p = l(e, a, t, o);
    return ht(p) ? p : t
  } else return t
}

function zo(e, t, a) {
  const i = e;
  i.__localeChainCache = new Map, e.localeFallbacker(e, a, t)
}

function A8(e, t) {
  return e === t ? !1 : e.split("-")[0] === t.split("-")[0]
}

function C8(e, t) {
  const a = t.indexOf(e);
  if (a === -1) return !1;
  for (let i = a + 1; i < t.length; i++)
    if (A8(e, t[i])) return !0;
  return !1
}

function Kd(e) {
  return a => T8(a, e)
}

function T8(e, t) {
  const a = t.b || t.body;
  if ((a.t || a.type) === 1) {
    const i = a,
      o = i.c || i.cases;
    return e.plural(o.reduce((l, h) => [...l, Av(e, h)], []))
  } else return Av(e, a)
}

function Av(e, t) {
  const a = t.s || t.static;
  if (a) return e.type === "text" ? a : e.normalize([a]); {
    const i = (t.i || t.items).reduce((o, l) => [...o, jh(e, l)], []);
    return e.normalize(i)
  }
}

function jh(e, t) {
  const a = t.t || t.type;
  switch (a) {
    case 3: {
      const i = t;
      return i.v || i.value
    }
    case 9: {
      const i = t;
      return i.v || i.value
    }
    case 4: {
      const i = t;
      return e.interpolate(e.named(i.k || i.key))
    }
    case 5: {
      const i = t;
      return e.interpolate(e.list(i.i != null ? i.i : i.index))
    }
    case 6: {
      const i = t,
        o = i.m || i.modifier;
      return e.linked(jh(e, i.k || i.key), o ? jh(e, o) : void 0, e.type)
    }
    case 7: {
      const i = t;
      return i.v || i.value
    }
    case 8: {
      const i = t;
      return i.v || i.value
    }
    default:
      throw new Error(`unhandled node type on format message part: ${a}`)
  }
}
const U1 = e => e;
let Ys = Object.create(null);
const ho = e => aa(e) && (e.t === 0 || e.type === 0) && ("b" in e || "body" in e);

function G1(e, t = {}) {
  let a = !1;
  const i = t.onError || k$;
  return t.onError = o => {
    a = !0, i(o)
  }, {
    ...V$(e, t),
    detectError: a
  }
}
const E8 = (e, t) => {
  if (!ht(e)) throw Ln(on.NOT_SUPPORT_NON_STRING_MESSAGE); {
    Bt(t.warnHtmlMessage) && t.warnHtmlMessage;
    const i = (t.onCacheKey || U1)(e),
      o = Ys[i];
    if (o) return o;
    const {
      code: l,
      detectError: h
    } = G1(e, t), p = new Function(`return ${l}`)();
    return h ? p : Ys[i] = p
  }
};

function P8(e, t) {
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && ht(e)) {
    Bt(t.warnHtmlMessage) && t.warnHtmlMessage;
    const i = (t.onCacheKey || U1)(e),
      o = Ys[i];
    if (o) return o;
    const {
      ast: l,
      detectError: h
    } = G1(e, {
      ...t,
      location: !1,
      jit: !0
    }), p = Kd(l);
    return h ? p : Ys[i] = p
  } else {
    const a = e.cacheKey;
    if (a) {
      const i = Ys[a];
      return i || (Ys[a] = Kd(e))
    } else return Kd(e)
  }
}
const Cv = () => "",
  Qr = e => ha(e);

function Tv(e, ...t) {
  const {
    fallbackFormat: a,
    postTranslation: i,
    unresolving: o,
    messageCompiler: l,
    fallbackLocale: h,
    messages: p
  } = e, [m, k] = Uh(...t), w = Bt(k.missingWarn) ? k.missingWarn : e.missingWarn, S = Bt(k.fallbackWarn) ? k.fallbackWarn : e.fallbackWarn, A = Bt(k.escapeParameter) ? k.escapeParameter : e.escapeParameter, E = !!k.resolvedMessage, M = ht(k.default) || Bt(k.default) ? Bt(k.default) ? l ? m : () => m : k.default : a ? l ? m : () => m : "", D = a || M !== "", B = xp(e, k);
  A && L8(k);
  let [z, I, N] = E ? [m, B, p[B] || {}] : q1(e, m, B, h, S, w), U = z, W = m;
  if (!E && !(ht(U) || ho(U) || Qr(U)) && D && (U = M, W = U), !E && (!(ht(U) || ho(U) || Qr(U)) || !ht(I))) return o ? Du : m;
  let X = !1;
  const V = () => {
      X = !0
    },
    ne = Qr(U) ? U : K1(e, m, I, U, W, V);
  if (X) return U;
  const Z = I8(e, I, N, k),
    ie = l8(Z),
    fe = O8(e, ne, ie),
    le = i ? i(fe, m) : fe;
  if (__INTLIFY_PROD_DEVTOOLS__) {
    const Ee = {
      timestamp: Date.now(),
      key: ht(m) ? m : Qr(U) ? U.key : "",
      locale: I || (Qr(U) ? U.locale : ""),
      format: ht(U) ? U : Qr(U) ? U.source : "",
      message: le
    };
    Ee.meta = or({}, e.__meta, k8() || {}), d8(Ee)
  }
  return le
}

function L8(e) {
  ya(e.list) ? e.list = e.list.map(t => ht(t) ? dv(t) : t) : aa(e.named) && Object.keys(e.named).forEach(t => {
    ht(e.named[t]) && (e.named[t] = dv(e.named[t]))
  })
}

function q1(e, t, a, i, o, l) {
  const {
    messages: h,
    onWarn: p,
    messageResolver: m,
    localeFallbacker: k
  } = e, w = k(e, i, a);
  let S = {},
    A, E = null;
  const M = "translate";
  for (let D = 0; D < w.length && (A = w[D], S = h[A] || {}, (E = m(S, t)) === null && (E = S[t]), !(ht(E) || ho(E) || Qr(E))); D++)
    if (!C8(A, w)) {
      const B = wp(e, t, A, l, M);
      B !== t && (E = B)
    } return [E, A, S]
}

function K1(e, t, a, i, o, l) {
  const {
    messageCompiler: h,
    warnHtmlMessage: p
  } = e;
  if (Qr(i)) {
    const k = i;
    return k.locale = k.locale || a, k.key = k.key || t, k
  }
  if (h == null) {
    const k = () => i;
    return k.locale = a, k.key = t, k
  }
  const m = h(i, M8(e, a, o, i, p, l));
  return m.locale = a, m.key = t, m.source = i, m
}

function O8(e, t, a) {
  return t(a)
}

function Uh(...e) {
  const [t, a, i] = e, o = {};
  if (!ht(t) && !Va(t) && !Qr(t) && !ho(t)) throw Ln(on.INVALID_ARGUMENT);
  const l = Va(t) ? String(t) : (Qr(t), t);
  return Va(a) ? o.plural = a : ht(a) ? o.default = a : Lt(a) && !Iu(a) ? o.named = a : ya(a) && (o.list = a), Va(i) ? o.plural = i : ht(i) ? o.default = i : Lt(i) && or(o, i), [l, o]
}

function M8(e, t, a, i, o, l) {
  return {
    locale: t,
    key: a,
    warnHtmlMessage: o,
    onError: h => {
      throw l && l(h), h
    },
    onCacheKey: h => l$(t, a, h)
  }
}

function I8(e, t, a, i) {
  const {
    modifiers: o,
    pluralRules: l,
    messageResolver: h,
    fallbackLocale: p,
    fallbackWarn: m,
    missingWarn: k,
    fallbackContext: w
  } = e, A = {
    locale: t,
    modifiers: o,
    pluralRules: l,
    messages: E => {
      let M = h(a, E);
      if (M == null && w) {
        const [, , D] = q1(w, E, t, p, m, k);
        M = h(D, E)
      }
      if (ht(M) || ho(M)) {
        let D = !1;
        const z = K1(e, E, t, M, E, () => {
          D = !0
        });
        return D ? Cv : z
      } else return Qr(M) ? M : Cv
    }
  };
  return e.processor && (A.processor = e.processor), i.list && (A.list = i.list), i.named && (A.named = i.named), Va(i.plural) && (A.pluralIndex = i.plural), A
}

function Ev(e, ...t) {
  const {
    datetimeFormats: a,
    unresolving: i,
    fallbackLocale: o,
    onWarn: l,
    localeFallbacker: h
  } = e, {
    __datetimeFormatters: p
  } = e, [m, k, w, S] = Gh(...t), A = Bt(w.missingWarn) ? w.missingWarn : e.missingWarn;
  Bt(w.fallbackWarn) ? w.fallbackWarn : e.fallbackWarn;
  const E = !!w.part,
    M = xp(e, w),
    D = h(e, o, M);
  if (!ht(m) || m === "") return new Intl.DateTimeFormat(M, S).format(k);
  let B = {},
    z, I = null;
  const N = "datetime format";
  for (let X = 0; X < D.length && (z = D[X], B = a[z] || {}, I = B[m], !Lt(I)); X++) wp(e, m, z, A, N);
  if (!Lt(I) || !ht(z)) return i ? Du : m;
  let U = `${z}__${m}`;
  Iu(S) || (U = `${U}__${JSON.stringify(S)}`);
  let W = p.get(U);
  return W || (W = new Intl.DateTimeFormat(z, or({}, I, S)), p.set(U, W)), E ? W.formatToParts(k) : W.format(k)
}
const Z1 = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

function Gh(...e) {
  const [t, a, i, o] = e, l = {};
  let h = {},
    p;
  if (ht(t)) {
    const m = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!m) throw Ln(on.INVALID_ISO_DATE_ARGUMENT);
    const k = m[3] ? m[3].trim().startsWith("T") ? `${m[1].trim()}${m[3].trim()}` : `${m[1].trim()}T${m[3].trim()}` : m[1].trim();
    p = new Date(k);
    try {
      p.toISOString()
    } catch {
      throw Ln(on.INVALID_ISO_DATE_ARGUMENT)
    }
  } else if (u$(t)) {
    if (isNaN(t.getTime())) throw Ln(on.INVALID_DATE_ARGUMENT);
    p = t
  } else if (Va(t)) p = t;
  else throw Ln(on.INVALID_ARGUMENT);
  return ht(a) ? l.key = a : Lt(a) && Object.keys(a).forEach(m => {
    Z1.includes(m) ? h[m] = a[m] : l[m] = a[m]
  }), ht(i) ? l.locale = i : Lt(i) && (h = i), Lt(o) && (h = o), [l.key || "", p, l, h]
}

function Pv(e, t, a) {
  const i = e;
  for (const o in a) {
    const l = `${t}__${o}`;
    i.__datetimeFormatters.has(l) && i.__datetimeFormatters.delete(l)
  }
}

function Lv(e, ...t) {
  const {
    numberFormats: a,
    unresolving: i,
    fallbackLocale: o,
    onWarn: l,
    localeFallbacker: h
  } = e, {
    __numberFormatters: p
  } = e, [m, k, w, S] = qh(...t), A = Bt(w.missingWarn) ? w.missingWarn : e.missingWarn;
  Bt(w.fallbackWarn) ? w.fallbackWarn : e.fallbackWarn;
  const E = !!w.part,
    M = xp(e, w),
    D = h(e, o, M);
  if (!ht(m) || m === "") return new Intl.NumberFormat(M, S).format(k);
  let B = {},
    z, I = null;
  const N = "number format";
  for (let X = 0; X < D.length && (z = D[X], B = a[z] || {}, I = B[m], !Lt(I)); X++) wp(e, m, z, A, N);
  if (!Lt(I) || !ht(z)) return i ? Du : m;
  let U = `${z}__${m}`;
  Iu(S) || (U = `${U}__${JSON.stringify(S)}`);
  let W = p.get(U);
  return W || (W = new Intl.NumberFormat(z, or({}, I, S)), p.set(U, W)), E ? W.formatToParts(k) : W.format(k)
}
const Q1 = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

function qh(...e) {
  const [t, a, i, o] = e, l = {};
  let h = {};
  if (!Va(t)) throw Ln(on.INVALID_ARGUMENT);
  const p = t;
  return ht(a) ? l.key = a : Lt(a) && Object.keys(a).forEach(m => {
    Q1.includes(m) ? h[m] = a[m] : l[m] = a[m]
  }), ht(i) ? l.locale = i : Lt(i) && (h = i), Lt(o) && (h = o), [l.key || "", p, l, h]
}

function Ov(e, t, a) {
  const i = e;
  for (const o in a) {
    const l = `${t}__${o}`;
    i.__numberFormatters.has(l) && i.__numberFormatters.delete(l)
  }
}
j$();
/*!
 * vue-i18n v9.13.1
 * (c) 2024 kazuya kawaguchi
 * Released under the MIT License.
 */
const R8 = "9.13.1";

function D8() {
  typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Vn().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Vn().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_JIT_COMPILATION__ != "boolean" && (Vn().__INTLIFY_JIT_COMPILATION__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Vn().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Vn().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const J1 = f8.__EXTEND_POINT__,
  Yn = Ru(J1);
Yn(), Yn(), Yn(), Yn(), Yn(), Yn(), Yn(), Yn(), Yn();
const ew = on.__EXTEND_POINT__,
  Rr = Ru(ew),
  Ga = {
    UNEXPECTED_RETURN_TYPE: ew,
    INVALID_ARGUMENT: Rr(),
    MUST_BE_CALL_SETUP_TOP: Rr(),
    NOT_INSTALLED: Rr(),
    NOT_AVAILABLE_IN_LEGACY_MODE: Rr(),
    REQUIRED_VALUE: Rr(),
    INVALID_VALUE: Rr(),
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: Rr(),
    NOT_INSTALLED_WITH_PROVIDE: Rr(),
    UNEXPECTED_ERROR: Rr(),
    NOT_COMPATIBLE_LEGACY_VUE_I18N: Rr(),
    BRIDGE_SUPPORT_VUE_2_ONLY: Rr(),
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: Rr(),
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: Rr(),
    __EXTEND_POINT__: Rr()
  };

function tr(e, ...t) {
  return xo(e, null, void 0)
}
const Kh = Hi("__translateVNode"),
  Zh = Hi("__datetimeParts"),
  Qh = Hi("__numberParts"),
  tw = Hi("__setPluralRules"),
  aw = Hi("__injectWithOption"),
  Jh = Hi("__dispose");

function kl(e) {
  if (!aa(e)) return e;
  for (const t in e)
    if (Gc(e, t))
      if (!t.includes(".")) aa(e[t]) && kl(e[t]);
      else {
        const a = t.split("."),
          i = a.length - 1;
        let o = e,
          l = !1;
        for (let h = 0; h < i; h++) {
          if (a[h] in o || (o[a[h]] = {}), !aa(o[a[h]])) {
            l = !0;
            break
          }
          o = o[a[h]]
        }
        l || (o[a[i]] = e[t], delete e[t]), aa(o[a[i]]) && kl(o[a[i]])
      } return e
}

function Nu(e, t) {
  const {
    messages: a,
    __i18n: i,
    messageResolver: o,
    flatJson: l
  } = t, h = Lt(a) ? a : ya(i) ? {} : {
    [e]: {}
  };
  if (ya(i) && i.forEach(p => {
      if ("locale" in p && "resource" in p) {
        const {
          locale: m,
          resource: k
        } = p;
        m ? (h[m] = h[m] || {}, kc(k, h[m])) : kc(k, h)
      } else ht(p) && kc(JSON.parse(p), h)
    }), o == null && l)
    for (const p in h) Gc(h, p) && kl(h[p]);
  return h
}

function rw(e) {
  return e.type
}

function nw(e, t, a) {
  let i = aa(t.messages) ? t.messages : {};
  "__i18nGlobal" in a && (i = Nu(e.locale.value, {
    messages: i,
    __i18n: a.__i18nGlobal
  }));
  const o = Object.keys(i);
  o.length && o.forEach(l => {
    e.mergeLocaleMessage(l, i[l])
  }); {
    if (aa(t.datetimeFormats)) {
      const l = Object.keys(t.datetimeFormats);
      l.length && l.forEach(h => {
        e.mergeDateTimeFormat(h, t.datetimeFormats[h])
      })
    }
    if (aa(t.numberFormats)) {
      const l = Object.keys(t.numberFormats);
      l.length && l.forEach(h => {
        e.mergeNumberFormat(h, t.numberFormats[h])
      })
    }
  }
}

function Mv(e) {
  return Ze(Cl, null, e, 0)
}
const Iv = "__INTLIFY_META__",
  Rv = () => [],
  N8 = () => !1;
let Dv = 0;

function Nv(e) {
  return (t, a, i, o) => e(a, i, hn() || void 0, o)
}
const F8 = () => {
  const e = hn();
  let t = null;
  return e && (t = rw(e)[Iv]) ? {
    [Iv]: t
  } : null
};

function kp(e = {}, t) {
  const {
    __root: a,
    __injectWithOption: i
  } = e, o = a === void 0, l = e.flatJson, h = Uc ? _e : Sl, p = !!e.translateExistCompatible;
  let m = Bt(e.inheritLocale) ? e.inheritLocale : !0;
  const k = h(a && m ? a.locale.value : ht(e.locale) ? e.locale : uo),
    w = h(a && m ? a.fallbackLocale.value : ht(e.fallbackLocale) || ya(e.fallbackLocale) || Lt(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : k.value),
    S = h(Nu(k.value, e)),
    A = h(Lt(e.datetimeFormats) ? e.datetimeFormats : {
      [k.value]: {}
    }),
    E = h(Lt(e.numberFormats) ? e.numberFormats : {
      [k.value]: {}
    });
  let M = a ? a.missingWarn : Bt(e.missingWarn) || Pi(e.missingWarn) ? e.missingWarn : !0,
    D = a ? a.fallbackWarn : Bt(e.fallbackWarn) || Pi(e.fallbackWarn) ? e.fallbackWarn : !0,
    B = a ? a.fallbackRoot : Bt(e.fallbackRoot) ? e.fallbackRoot : !0,
    z = !!e.fallbackFormat,
    I = ha(e.missing) ? e.missing : null,
    N = ha(e.missing) ? Nv(e.missing) : null,
    U = ha(e.postTranslation) ? e.postTranslation : null,
    W = a ? a.warnHtmlMessage : Bt(e.warnHtmlMessage) ? e.warnHtmlMessage : !0,
    X = !!e.escapeParameter;
  const V = a ? a.modifiers : Lt(e.modifiers) ? e.modifiers : {};
  let ne = e.pluralRules || a && a.pluralRules,
    Z;
  Z = (() => {
    o && _v(null);
    const Te = {
      version: R8,
      locale: k.value,
      fallbackLocale: w.value,
      messages: S.value,
      modifiers: V,
      pluralRules: ne,
      missing: N === null ? void 0 : N,
      missingWarn: M,
      fallbackWarn: D,
      fallbackFormat: z,
      unresolving: !0,
      postTranslation: U === null ? void 0 : U,
      warnHtmlMessage: W,
      escapeParameter: X,
      messageResolver: e.messageResolver,
      messageCompiler: e.messageCompiler,
      __meta: {
        framework: "vue"
      }
    };
    Te.datetimeFormats = A.value, Te.numberFormats = E.value, Te.__datetimeFormatters = Lt(Z) ? Z.__datetimeFormatters : void 0, Te.__numberFormatters = Lt(Z) ? Z.__numberFormatters : void 0;
    const $e = S8(Te);
    return o && _v($e), $e
  })(), zo(Z, k.value, w.value);

  function fe() {
    return [k.value, w.value, S.value, A.value, E.value]
  }
  const le = Oe({
      get: () => k.value,
      set: Te => {
        k.value = Te, Z.locale = k.value
      }
    }),
    Ee = Oe({
      get: () => w.value,
      set: Te => {
        w.value = Te, Z.fallbackLocale = w.value, zo(Z, k.value, Te)
      }
    }),
    ye = Oe(() => S.value),
    ve = Oe(() => A.value),
    me = Oe(() => E.value);

  function Ae() {
    return ha(U) ? U : null
  }

  function He(Te) {
    U = Te, Z.postTranslation = Te
  }

  function De() {
    return I
  }

  function Ye(Te) {
    Te !== null && (N = Nv(Te)), I = Te, Z.missing = N
  }
  const Je = (Te, $e, ft, gt, Ct, ia) => {
    fe();
    let xa;
    try {
      __INTLIFY_PROD_DEVTOOLS__,
      o || (Z.fallbackContext = a ? _8() : void 0),
      xa = Te(Z)
    }
    finally {
      __INTLIFY_PROD_DEVTOOLS__,
      o || (Z.fallbackContext = void 0)
    }
    if (ft !== "translate exists" && Va(xa) && xa === Du || ft === "translate exists" && !xa) {
      const [yr, qa] = $e();
      return a && B ? gt(a) : Ct(yr)
    } else {
      if (ia(xa)) return xa;
      throw tr(Ga.UNEXPECTED_RETURN_TYPE)
    }
  };

  function he(...Te) {
    return Je($e => Reflect.apply(Tv, null, [$e, ...Te]), () => Uh(...Te), "translate", $e => Reflect.apply($e.t, $e, [...Te]), $e => $e, $e => ht($e))
  }

  function ke(...Te) {
    const [$e, ft, gt] = Te;
    if (gt && !aa(gt)) throw tr(Ga.INVALID_ARGUMENT);
    return he($e, ft, or({
      resolvedMessage: !0
    }, gt || {}))
  }

  function re(...Te) {
    return Je($e => Reflect.apply(Ev, null, [$e, ...Te]), () => Gh(...Te), "datetime format", $e => Reflect.apply($e.d, $e, [...Te]), () => xv, $e => ht($e))
  }

  function Se(...Te) {
    return Je($e => Reflect.apply(Lv, null, [$e, ...Te]), () => qh(...Te), "number format", $e => Reflect.apply($e.n, $e, [...Te]), () => xv, $e => ht($e))
  }

  function Be(Te) {
    return Te.map($e => ht($e) || Va($e) || Bt($e) ? Mv(String($e)) : $e)
  }
  const Re = {
    normalize: Be,
    interpolate: Te => Te,
    type: "vnode"
  };

  function Xe(...Te) {
    return Je($e => {
      let ft;
      const gt = $e;
      try {
        gt.processor = Re, ft = Reflect.apply(Tv, null, [gt, ...Te])
      } finally {
        gt.processor = null
      }
      return ft
    }, () => Uh(...Te), "translate", $e => $e[Kh](...Te), $e => [Mv($e)], $e => ya($e))
  }

  function nt(...Te) {
    return Je($e => Reflect.apply(Lv, null, [$e, ...Te]), () => qh(...Te), "number format", $e => $e[Qh](...Te), Rv, $e => ht($e) || ya($e))
  }

  function Pe(...Te) {
    return Je($e => Reflect.apply(Ev, null, [$e, ...Te]), () => Gh(...Te), "datetime format", $e => $e[Zh](...Te), Rv, $e => ht($e) || ya($e))
  }

  function We(Te) {
    ne = Te, Z.pluralRules = ne
  }

  function F(Te, $e) {
    return Je(() => {
      if (!Te) return !1;
      const ft = ht($e) ? $e : k.value,
        gt = de(ft),
        Ct = Z.messageResolver(gt, Te);
      return p ? Ct != null : ho(Ct) || Qr(Ct) || ht(Ct)
    }, () => [Te], "translate exists", ft => Reflect.apply(ft.te, ft, [Te, $e]), N8, ft => Bt(ft))
  }

  function j(Te) {
    let $e = null;
    const ft = Y1(Z, w.value, k.value);
    for (let gt = 0; gt < ft.length; gt++) {
      const Ct = S.value[ft[gt]] || {},
        ia = Z.messageResolver(Ct, Te);
      if (ia != null) {
        $e = ia;
        break
      }
    }
    return $e
  }

  function oe(Te) {
    const $e = j(Te);
    return $e ?? (a ? a.tm(Te) || {} : {})
  }

  function de(Te) {
    return S.value[Te] || {}
  }

  function Ie(Te, $e) {
    if (l) {
      const ft = {
        [Te]: $e
      };
      for (const gt in ft) Gc(ft, gt) && kl(ft[gt]);
      $e = ft[Te]
    }
    S.value[Te] = $e, Z.messages = S.value
  }

  function ue(Te, $e) {
    S.value[Te] = S.value[Te] || {};
    const ft = {
      [Te]: $e
    };
    if (l)
      for (const gt in ft) Gc(ft, gt) && kl(ft[gt]);
    $e = ft[Te], kc($e, S.value[Te]), Z.messages = S.value
  }

  function Le(Te) {
    return A.value[Te] || {}
  }

  function K(Te, $e) {
    A.value[Te] = $e, Z.datetimeFormats = A.value, Pv(Z, Te, $e)
  }

  function ae(Te, $e) {
    A.value[Te] = or(A.value[Te] || {}, $e), Z.datetimeFormats = A.value, Pv(Z, Te, $e)
  }

  function xe(Te) {
    return E.value[Te] || {}
  }

  function Ce(Te, $e) {
    E.value[Te] = $e, Z.numberFormats = E.value, Ov(Z, Te, $e)
  }

  function tt(Te, $e) {
    E.value[Te] = or(E.value[Te] || {}, $e), Z.numberFormats = E.value, Ov(Z, Te, $e)
  }
  Dv++, a && Uc && (Xt(a.locale, Te => {
    m && (k.value = Te, Z.locale = Te, zo(Z, k.value, w.value))
  }), Xt(a.fallbackLocale, Te => {
    m && (w.value = Te, Z.fallbackLocale = Te, zo(Z, k.value, w.value))
  }));
  const qe = {
    id: Dv,
    locale: le,
    fallbackLocale: Ee,
    get inheritLocale() {
      return m
    },
    set inheritLocale(Te) {
      m = Te, Te && a && (k.value = a.locale.value, w.value = a.fallbackLocale.value, zo(Z, k.value, w.value))
    },
    get availableLocales() {
      return Object.keys(S.value).sort()
    },
    messages: ye,
    get modifiers() {
      return V
    },
    get pluralRules() {
      return ne || {}
    },
    get isGlobal() {
      return o
    },
    get missingWarn() {
      return M
    },
    set missingWarn(Te) {
      M = Te, Z.missingWarn = M
    },
    get fallbackWarn() {
      return D
    },
    set fallbackWarn(Te) {
      D = Te, Z.fallbackWarn = D
    },
    get fallbackRoot() {
      return B
    },
    set fallbackRoot(Te) {
      B = Te
    },
    get fallbackFormat() {
      return z
    },
    set fallbackFormat(Te) {
      z = Te, Z.fallbackFormat = z
    },
    get warnHtmlMessage() {
      return W
    },
    set warnHtmlMessage(Te) {
      W = Te, Z.warnHtmlMessage = Te
    },
    get escapeParameter() {
      return X
    },
    set escapeParameter(Te) {
      X = Te, Z.escapeParameter = Te
    },
    t: he,
    getLocaleMessage: de,
    setLocaleMessage: Ie,
    mergeLocaleMessage: ue,
    getPostTranslationHandler: Ae,
    setPostTranslationHandler: He,
    getMissingHandler: De,
    setMissingHandler: Ye,
    [tw]: We
  };
  return qe.datetimeFormats = ve, qe.numberFormats = me, qe.rt = ke, qe.te = F, qe.tm = oe, qe.d = re, qe.n = Se, qe.getDateTimeFormat = Le, qe.setDateTimeFormat = K, qe.mergeDateTimeFormat = ae, qe.getNumberFormat = xe, qe.setNumberFormat = Ce, qe.mergeNumberFormat = tt, qe[aw] = i, qe[Kh] = Xe, qe[Zh] = Pe, qe[Qh] = nt, qe
}

function $8(e) {
  const t = ht(e.locale) ? e.locale : uo,
    a = ht(e.fallbackLocale) || ya(e.fallbackLocale) || Lt(e.fallbackLocale) || e.fallbackLocale === !1 ? e.fallbackLocale : t,
    i = ha(e.missing) ? e.missing : void 0,
    o = Bt(e.silentTranslationWarn) || Pi(e.silentTranslationWarn) ? !e.silentTranslationWarn : !0,
    l = Bt(e.silentFallbackWarn) || Pi(e.silentFallbackWarn) ? !e.silentFallbackWarn : !0,
    h = Bt(e.fallbackRoot) ? e.fallbackRoot : !0,
    p = !!e.formatFallbackMessages,
    m = Lt(e.modifiers) ? e.modifiers : {},
    k = e.pluralizationRules,
    w = ha(e.postTranslation) ? e.postTranslation : void 0,
    S = ht(e.warnHtmlInMessage) ? e.warnHtmlInMessage !== "off" : !0,
    A = !!e.escapeParameterHtml,
    E = Bt(e.sync) ? e.sync : !0;
  let M = e.messages;
  if (Lt(e.sharedMessages)) {
    const X = e.sharedMessages;
    M = Object.keys(X).reduce((ne, Z) => {
      const ie = ne[Z] || (ne[Z] = {});
      return or(ie, X[Z]), ne
    }, M || {})
  }
  const {
    __i18n: D,
    __root: B,
    __injectWithOption: z
  } = e, I = e.datetimeFormats, N = e.numberFormats, U = e.flatJson, W = e.translateExistCompatible;
  return {
    locale: t,
    fallbackLocale: a,
    messages: M,
    flatJson: U,
    datetimeFormats: I,
    numberFormats: N,
    missing: i,
    missingWarn: o,
    fallbackWarn: l,
    fallbackRoot: h,
    fallbackFormat: p,
    modifiers: m,
    pluralRules: k,
    postTranslation: w,
    warnHtmlMessage: S,
    escapeParameter: A,
    messageResolver: e.messageResolver,
    inheritLocale: E,
    translateExistCompatible: W,
    __i18n: D,
    __root: B,
    __injectWithOption: z
  }
}

function ef(e = {}, t) {
  {
    const a = kp($8(e)),
      {
        __extender: i
      } = e,
      o = {
        id: a.id,
        get locale() {
          return a.locale.value
        },
        set locale(l) {
          a.locale.value = l
        },
        get fallbackLocale() {
          return a.fallbackLocale.value
        },
        set fallbackLocale(l) {
          a.fallbackLocale.value = l
        },
        get messages() {
          return a.messages.value
        },
        get datetimeFormats() {
          return a.datetimeFormats.value
        },
        get numberFormats() {
          return a.numberFormats.value
        },
        get availableLocales() {
          return a.availableLocales
        },
        get formatter() {
          return {
            interpolate() {
              return []
            }
          }
        },
        set formatter(l) {},
        get missing() {
          return a.getMissingHandler()
        },
        set missing(l) {
          a.setMissingHandler(l)
        },
        get silentTranslationWarn() {
          return Bt(a.missingWarn) ? !a.missingWarn : a.missingWarn
        },
        set silentTranslationWarn(l) {
          a.missingWarn = Bt(l) ? !l : l
        },
        get silentFallbackWarn() {
          return Bt(a.fallbackWarn) ? !a.fallbackWarn : a.fallbackWarn
        },
        set silentFallbackWarn(l) {
          a.fallbackWarn = Bt(l) ? !l : l
        },
        get modifiers() {
          return a.modifiers
        },
        get formatFallbackMessages() {
          return a.fallbackFormat
        },
        set formatFallbackMessages(l) {
          a.fallbackFormat = l
        },
        get postTranslation() {
          return a.getPostTranslationHandler()
        },
        set postTranslation(l) {
          a.setPostTranslationHandler(l)
        },
        get sync() {
          return a.inheritLocale
        },
        set sync(l) {
          a.inheritLocale = l
        },
        get warnHtmlInMessage() {
          return a.warnHtmlMessage ? "warn" : "off"
        },
        set warnHtmlInMessage(l) {
          a.warnHtmlMessage = l !== "off"
        },
        get escapeParameterHtml() {
          return a.escapeParameter
        },
        set escapeParameterHtml(l) {
          a.escapeParameter = l
        },
        get preserveDirectiveContent() {
          return !0
        },
        set preserveDirectiveContent(l) {},
        get pluralizationRules() {
          return a.pluralRules || {}
        },
        __composer: a,
        t(...l) {
          const [h, p, m] = l, k = {};
          let w = null,
            S = null;
          if (!ht(h)) throw tr(Ga.INVALID_ARGUMENT);
          const A = h;
          return ht(p) ? k.locale = p : ya(p) ? w = p : Lt(p) && (S = p), ya(m) ? w = m : Lt(m) && (S = m), Reflect.apply(a.t, a, [A, w || S || {}, k])
        },
        rt(...l) {
          return Reflect.apply(a.rt, a, [...l])
        },
        tc(...l) {
          const [h, p, m] = l, k = {
            plural: 1
          };
          let w = null,
            S = null;
          if (!ht(h)) throw tr(Ga.INVALID_ARGUMENT);
          const A = h;
          return ht(p) ? k.locale = p : Va(p) ? k.plural = p : ya(p) ? w = p : Lt(p) && (S = p), ht(m) ? k.locale = m : ya(m) ? w = m : Lt(m) && (S = m), Reflect.apply(a.t, a, [A, w || S || {}, k])
        },
        te(l, h) {
          return a.te(l, h)
        },
        tm(l) {
          return a.tm(l)
        },
        getLocaleMessage(l) {
          return a.getLocaleMessage(l)
        },
        setLocaleMessage(l, h) {
          a.setLocaleMessage(l, h)
        },
        mergeLocaleMessage(l, h) {
          a.mergeLocaleMessage(l, h)
        },
        d(...l) {
          return Reflect.apply(a.d, a, [...l])
        },
        getDateTimeFormat(l) {
          return a.getDateTimeFormat(l)
        },
        setDateTimeFormat(l, h) {
          a.setDateTimeFormat(l, h)
        },
        mergeDateTimeFormat(l, h) {
          a.mergeDateTimeFormat(l, h)
        },
        n(...l) {
          return Reflect.apply(a.n, a, [...l])
        },
        getNumberFormat(l) {
          return a.getNumberFormat(l)
        },
        setNumberFormat(l, h) {
          a.setNumberFormat(l, h)
        },
        mergeNumberFormat(l, h) {
          a.mergeNumberFormat(l, h)
        },
        getChoiceIndex(l, h) {
          return -1
        }
      };
    return o.__extender = i, o
  }
}
const _p = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    validator: e => e === "parent" || e === "global",
    default: "parent"
  },
  i18n: {
    type: Object
  }
};

function B8({
  slots: e
}, t) {
  return t.length === 1 && t[0] === "default" ? (e.default ? e.default() : []).reduce((i, o) => [...i, ...o.type === vt ? o.children : [o]], []) : t.reduce((a, i) => {
    const o = e[i];
    return o && (a[i] = o()), a
  }, {})
}

function iw(e) {
  return vt
}
const H8 = Ot({
    name: "i18n-t",
    props: or({
      keypath: {
        type: String,
        required: !0
      },
      plural: {
        type: [Number, String],
        validator: e => Va(e) || !isNaN(e)
      }
    }, _p),
    setup(e, t) {
      const {
        slots: a,
        attrs: i
      } = t, o = e.i18n || Sp({
        useScope: e.scope,
        __useComponent: !0
      });
      return () => {
        const l = Object.keys(a).filter(S => S !== "_"),
          h = {};
        e.locale && (h.locale = e.locale), e.plural !== void 0 && (h.plural = ht(e.plural) ? +e.plural : e.plural);
        const p = B8(t, l),
          m = o[Kh](e.keypath, p, h),
          k = or({}, i),
          w = ht(e.tag) || aa(e.tag) ? e.tag : iw();
        return oa(w, k, m)
      }
    }
  }),
  Fv = H8;

function Y8(e) {
  return ya(e) && !ht(e[0])
}

function sw(e, t, a, i) {
  const {
    slots: o,
    attrs: l
  } = t;
  return () => {
    const h = {
      part: !0
    };
    let p = {};
    e.locale && (h.locale = e.locale), ht(e.format) ? h.key = e.format : aa(e.format) && (ht(e.format.key) && (h.key = e.format.key), p = Object.keys(e.format).reduce((A, E) => a.includes(E) ? or({}, A, {
      [E]: e.format[E]
    }) : A, {}));
    const m = i(e.value, h, p);
    let k = [h.key];
    ya(m) ? k = m.map((A, E) => {
      const M = o[A.type],
        D = M ? M({
          [A.type]: A.value,
          index: E,
          parts: m
        }) : [A.value];
      return Y8(D) && (D[0].key = `${A.type}-${E}`), D
    }) : ht(m) && (k = [m]);
    const w = or({}, l),
      S = ht(e.tag) || aa(e.tag) ? e.tag : iw();
    return oa(S, w, k)
  }
}
const z8 = Ot({
    name: "i18n-n",
    props: or({
      value: {
        type: Number,
        required: !0
      },
      format: {
        type: [String, Object]
      }
    }, _p),
    setup(e, t) {
      const a = e.i18n || Sp({
        useScope: e.scope,
        __useComponent: !0
      });
      return sw(e, t, Q1, (...i) => a[Qh](...i))
    }
  }),
  $v = z8,
  X8 = Ot({
    name: "i18n-d",
    props: or({
      value: {
        type: [Number, Date],
        required: !0
      },
      format: {
        type: [String, Object]
      }
    }, _p),
    setup(e, t) {
      const a = e.i18n || Sp({
        useScope: e.scope,
        __useComponent: !0
      });
      return sw(e, t, Z1, (...i) => a[Zh](...i))
    }
  }),
  Bv = X8;

function W8(e, t) {
  const a = e;
  if (e.mode === "composition") return a.__getInstance(t) || e.global; {
    const i = a.__getInstance(t);
    return i != null ? i.__composer : e.global.__composer
  }
}

function V8(e) {
  const t = h => {
    const {
      instance: p,
      modifiers: m,
      value: k
    } = h;
    if (!p || !p.$) throw tr(Ga.UNEXPECTED_ERROR);
    const w = W8(e, p.$),
      S = Hv(k);
    return [Reflect.apply(w.t, w, [...Yv(S)]), w]
  };
  return {
    created: (h, p) => {
      const [m, k] = t(p);
      Uc && e.global === k && (h.__i18nWatcher = Xt(k.locale, () => {
        p.instance && p.instance.$forceUpdate()
      })), h.__composer = k, h.textContent = m
    },
    unmounted: h => {
      Uc && h.__i18nWatcher && (h.__i18nWatcher(), h.__i18nWatcher = void 0, delete h.__i18nWatcher), h.__composer && (h.__composer = void 0, delete h.__composer)
    },
    beforeUpdate: (h, {
      value: p
    }) => {
      if (h.__composer) {
        const m = h.__composer,
          k = Hv(p);
        h.textContent = Reflect.apply(m.t, m, [...Yv(k)])
      }
    },
    getSSRProps: h => {
      const [p] = t(h);
      return {
        textContent: p
      }
    }
  }
}

function Hv(e) {
  if (ht(e)) return {
    path: e
  };
  if (Lt(e)) {
    if (!("path" in e)) throw tr(Ga.REQUIRED_VALUE, "path");
    return e
  } else throw tr(Ga.INVALID_VALUE)
}

function Yv(e) {
  const {
    path: t,
    locale: a,
    args: i,
    choice: o,
    plural: l
  } = e, h = {}, p = i || {};
  return ht(a) && (h.locale = a), Va(o) && (h.plural = o), Va(l) && (h.plural = l), [t, p, h]
}

function j8(e, t, ...a) {
  const i = Lt(a[0]) ? a[0] : {},
    o = !!i.useI18nComponentName;
  (Bt(i.globalInstall) ? i.globalInstall : !0) && ([o ? "i18n" : Fv.name, "I18nT"].forEach(h => e.component(h, Fv)), [$v.name, "I18nN"].forEach(h => e.component(h, $v)), [Bv.name, "I18nD"].forEach(h => e.component(h, Bv))), e.directive("t", V8(t))
}

function U8(e, t, a) {
  return {
    beforeCreate() {
      const i = hn();
      if (!i) throw tr(Ga.UNEXPECTED_ERROR);
      const o = this.$options;
      if (o.i18n) {
        const l = o.i18n;
        if (o.__i18n && (l.__i18n = o.__i18n), l.__root = t, this === this.$root) this.$i18n = zv(e, l);
        else {
          l.__injectWithOption = !0, l.__extender = a.__vueI18nExtend, this.$i18n = ef(l);
          const h = this.$i18n;
          h.__extender && (h.__disposer = h.__extender(this.$i18n))
        }
      } else if (o.__i18n)
        if (this === this.$root) this.$i18n = zv(e, o);
        else {
          this.$i18n = ef({
            __i18n: o.__i18n,
            __injectWithOption: !0,
            __extender: a.__vueI18nExtend,
            __root: t
          });
          const l = this.$i18n;
          l.__extender && (l.__disposer = l.__extender(this.$i18n))
        }
      else this.$i18n = e;
      o.__i18nGlobal && nw(t, o, o), this.$t = (...l) => this.$i18n.t(...l), this.$rt = (...l) => this.$i18n.rt(...l), this.$tc = (...l) => this.$i18n.tc(...l), this.$te = (l, h) => this.$i18n.te(l, h), this.$d = (...l) => this.$i18n.d(...l), this.$n = (...l) => this.$i18n.n(...l), this.$tm = l => this.$i18n.tm(l), a.__setInstance(i, this.$i18n)
    },
    mounted() {},
    unmounted() {
      const i = hn();
      if (!i) throw tr(Ga.UNEXPECTED_ERROR);
      const o = this.$i18n;
      delete this.$t, delete this.$rt, delete this.$tc, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, o.__disposer && (o.__disposer(), delete o.__disposer, delete o.__extender), a.__deleteInstance(i), delete this.$i18n
    }
  }
}

function zv(e, t) {
  e.locale = t.locale || e.locale, e.fallbackLocale = t.fallbackLocale || e.fallbackLocale, e.missing = t.missing || e.missing, e.silentTranslationWarn = t.silentTranslationWarn || e.silentFallbackWarn, e.silentFallbackWarn = t.silentFallbackWarn || e.silentFallbackWarn, e.formatFallbackMessages = t.formatFallbackMessages || e.formatFallbackMessages, e.postTranslation = t.postTranslation || e.postTranslation, e.warnHtmlInMessage = t.warnHtmlInMessage || e.warnHtmlInMessage, e.escapeParameterHtml = t.escapeParameterHtml || e.escapeParameterHtml, e.sync = t.sync || e.sync, e.__composer[tw](t.pluralizationRules || e.pluralizationRules);
  const a = Nu(e.locale, {
    messages: t.messages,
    __i18n: t.__i18n
  });
  return Object.keys(a).forEach(i => e.mergeLocaleMessage(i, a[i])), t.datetimeFormats && Object.keys(t.datetimeFormats).forEach(i => e.mergeDateTimeFormat(i, t.datetimeFormats[i])), t.numberFormats && Object.keys(t.numberFormats).forEach(i => e.mergeNumberFormat(i, t.numberFormats[i])), e
}
const G8 = Hi("global-vue-i18n");

function q8(e = {}, t) {
  const a = __VUE_I18N_LEGACY_API__ && Bt(e.legacy) ? e.legacy : __VUE_I18N_LEGACY_API__,
    i = Bt(e.globalInjection) ? e.globalInjection : !0,
    o = __VUE_I18N_LEGACY_API__ && a ? !!e.allowComposition : !0,
    l = new Map,
    [h, p] = K8(e, a),
    m = Hi("");

  function k(A) {
    return l.get(A) || null
  }

  function w(A, E) {
    l.set(A, E)
  }

  function S(A) {
    l.delete(A)
  } {
    const A = {
      get mode() {
        return __VUE_I18N_LEGACY_API__ && a ? "legacy" : "composition"
      },
      get allowComposition() {
        return o
      },
      async install(E, ...M) {
        if (E.__VUE_I18N_SYMBOL__ = m, E.provide(E.__VUE_I18N_SYMBOL__, A), Lt(M[0])) {
          const z = M[0];
          A.__composerExtend = z.__composerExtend, A.__vueI18nExtend = z.__vueI18nExtend
        }
        let D = null;
        !a && i && (D = i6(E, A.global)), __VUE_I18N_FULL_INSTALL__ && j8(E, A, ...M), __VUE_I18N_LEGACY_API__ && a && E.mixin(U8(p, p.__composer, A));
        const B = E.unmount;
        E.unmount = () => {
          D && D(), A.dispose(), B()
        }
      },
      get global() {
        return p
      },
      dispose() {
        h.stop()
      },
      __instances: l,
      __getInstance: k,
      __setInstance: w,
      __deleteInstance: S
    };
    return A
  }
}

function Sp(e = {}) {
  const t = hn();
  if (t == null) throw tr(Ga.MUST_BE_CALL_SETUP_TOP);
  if (!t.isCE && t.appContext.app != null && !t.appContext.app.__VUE_I18N_SYMBOL__) throw tr(Ga.NOT_INSTALLED);
  const a = Z8(t),
    i = J8(a),
    o = rw(t),
    l = Q8(e, o);
  if (__VUE_I18N_LEGACY_API__ && a.mode === "legacy" && !e.__useComponent) {
    if (!a.allowComposition) throw tr(Ga.NOT_AVAILABLE_IN_LEGACY_MODE);
    return r6(t, l, i, e)
  }
  if (l === "global") return nw(i, e, o), i;
  if (l === "parent") {
    let m = e6(a, t, e.__useComponent);
    return m == null && (m = i), m
  }
  const h = a;
  let p = h.__getInstance(t);
  if (p == null) {
    const m = or({}, e);
    "__i18n" in o && (m.__i18n = o.__i18n), i && (m.__root = i), p = kp(m), h.__composerExtend && (p[Jh] = h.__composerExtend(p)), a6(h, t, p), h.__setInstance(t, p)
  }
  return p
}

function K8(e, t, a) {
  const i = rb(); {
    const o = __VUE_I18N_LEGACY_API__ && t ? i.run(() => ef(e)) : i.run(() => kp(e));
    if (o == null) throw tr(Ga.UNEXPECTED_ERROR);
    return [i, o]
  }
}

function Z8(e) {
  {
    const t = fa(e.isCE ? G8 : e.appContext.app.__VUE_I18N_SYMBOL__);
    if (!t) throw tr(e.isCE ? Ga.NOT_INSTALLED_WITH_PROVIDE : Ga.UNEXPECTED_ERROR);
    return t
  }
}

function Q8(e, t) {
  return Iu(e) ? "__i18n" in t ? "local" : "global" : e.useScope ? e.useScope : "local"
}

function J8(e) {
  return e.mode === "composition" ? e.global : e.global.__composer
}

function e6(e, t, a = !1) {
  let i = null;
  const o = t.root;
  let l = t6(t, a);
  for (; l != null;) {
    const h = e;
    if (e.mode === "composition") i = h.__getInstance(l);
    else if (__VUE_I18N_LEGACY_API__) {
      const p = h.__getInstance(l);
      p != null && (i = p.__composer, a && i && !i[aw] && (i = null))
    }
    if (i != null || o === l) break;
    l = l.parent
  }
  return i
}

function t6(e, t = !1) {
  return e == null ? null : t && e.vnode.ctx || e.parent
}

function a6(e, t, a) {
  Dt(() => {}, t), Ha(() => {
    const i = a;
    e.__deleteInstance(t);
    const o = i[Jh];
    o && (o(), delete i[Jh])
  }, t)
}

function r6(e, t, a, i = {}) {
  const o = t === "local",
    l = Sl(null);
  if (o && e.proxy && !(e.proxy.$options.i18n || e.proxy.$options.__i18n)) throw tr(Ga.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  const h = Bt(i.inheritLocale) ? i.inheritLocale : !ht(i.locale),
    p = _e(!o || h ? a.locale.value : ht(i.locale) ? i.locale : uo),
    m = _e(!o || h ? a.fallbackLocale.value : ht(i.fallbackLocale) || ya(i.fallbackLocale) || Lt(i.fallbackLocale) || i.fallbackLocale === !1 ? i.fallbackLocale : p.value),
    k = _e(Nu(p.value, i)),
    w = _e(Lt(i.datetimeFormats) ? i.datetimeFormats : {
      [p.value]: {}
    }),
    S = _e(Lt(i.numberFormats) ? i.numberFormats : {
      [p.value]: {}
    }),
    A = o ? a.missingWarn : Bt(i.missingWarn) || Pi(i.missingWarn) ? i.missingWarn : !0,
    E = o ? a.fallbackWarn : Bt(i.fallbackWarn) || Pi(i.fallbackWarn) ? i.fallbackWarn : !0,
    M = o ? a.fallbackRoot : Bt(i.fallbackRoot) ? i.fallbackRoot : !0,
    D = !!i.fallbackFormat,
    B = ha(i.missing) ? i.missing : null,
    z = ha(i.postTranslation) ? i.postTranslation : null,
    I = o ? a.warnHtmlMessage : Bt(i.warnHtmlMessage) ? i.warnHtmlMessage : !0,
    N = !!i.escapeParameter,
    U = o ? a.modifiers : Lt(i.modifiers) ? i.modifiers : {},
    W = i.pluralRules || o && a.pluralRules;

  function X() {
    return [p.value, m.value, k.value, w.value, S.value]
  }
  const V = Oe({
      get: () => l.value ? l.value.locale.value : p.value,
      set: j => {
        l.value && (l.value.locale.value = j), p.value = j
      }
    }),
    ne = Oe({
      get: () => l.value ? l.value.fallbackLocale.value : m.value,
      set: j => {
        l.value && (l.value.fallbackLocale.value = j), m.value = j
      }
    }),
    Z = Oe(() => l.value ? l.value.messages.value : k.value),
    ie = Oe(() => w.value),
    fe = Oe(() => S.value);

  function le() {
    return l.value ? l.value.getPostTranslationHandler() : z
  }

  function Ee(j) {
    l.value && l.value.setPostTranslationHandler(j)
  }

  function ye() {
    return l.value ? l.value.getMissingHandler() : B
  }

  function ve(j) {
    l.value && l.value.setMissingHandler(j)
  }

  function me(j) {
    return X(), j()
  }

  function Ae(...j) {
    return l.value ? me(() => Reflect.apply(l.value.t, null, [...j])) : me(() => "")
  }

  function He(...j) {
    return l.value ? Reflect.apply(l.value.rt, null, [...j]) : ""
  }

  function De(...j) {
    return l.value ? me(() => Reflect.apply(l.value.d, null, [...j])) : me(() => "")
  }

  function Ye(...j) {
    return l.value ? me(() => Reflect.apply(l.value.n, null, [...j])) : me(() => "")
  }

  function Je(j) {
    return l.value ? l.value.tm(j) : {}
  }

  function he(j, oe) {
    return l.value ? l.value.te(j, oe) : !1
  }

  function ke(j) {
    return l.value ? l.value.getLocaleMessage(j) : {}
  }

  function re(j, oe) {
    l.value && (l.value.setLocaleMessage(j, oe), k.value[j] = oe)
  }

  function Se(j, oe) {
    l.value && l.value.mergeLocaleMessage(j, oe)
  }

  function Be(j) {
    return l.value ? l.value.getDateTimeFormat(j) : {}
  }

  function J(j, oe) {
    l.value && (l.value.setDateTimeFormat(j, oe), w.value[j] = oe)
  }

  function Re(j, oe) {
    l.value && l.value.mergeDateTimeFormat(j, oe)
  }

  function Xe(j) {
    return l.value ? l.value.getNumberFormat(j) : {}
  }

  function nt(j, oe) {
    l.value && (l.value.setNumberFormat(j, oe), S.value[j] = oe)
  }

  function Pe(j, oe) {
    l.value && l.value.mergeNumberFormat(j, oe)
  }
  const We = {
    get id() {
      return l.value ? l.value.id : -1
    },
    locale: V,
    fallbackLocale: ne,
    messages: Z,
    datetimeFormats: ie,
    numberFormats: fe,
    get inheritLocale() {
      return l.value ? l.value.inheritLocale : h
    },
    set inheritLocale(j) {
      l.value && (l.value.inheritLocale = j)
    },
    get availableLocales() {
      return l.value ? l.value.availableLocales : Object.keys(k.value)
    },
    get modifiers() {
      return l.value ? l.value.modifiers : U
    },
    get pluralRules() {
      return l.value ? l.value.pluralRules : W
    },
    get isGlobal() {
      return l.value ? l.value.isGlobal : !1
    },
    get missingWarn() {
      return l.value ? l.value.missingWarn : A
    },
    set missingWarn(j) {
      l.value && (l.value.missingWarn = j)
    },
    get fallbackWarn() {
      return l.value ? l.value.fallbackWarn : E
    },
    set fallbackWarn(j) {
      l.value && (l.value.missingWarn = j)
    },
    get fallbackRoot() {
      return l.value ? l.value.fallbackRoot : M
    },
    set fallbackRoot(j) {
      l.value && (l.value.fallbackRoot = j)
    },
    get fallbackFormat() {
      return l.value ? l.value.fallbackFormat : D
    },
    set fallbackFormat(j) {
      l.value && (l.value.fallbackFormat = j)
    },
    get warnHtmlMessage() {
      return l.value ? l.value.warnHtmlMessage : I
    },
    set warnHtmlMessage(j) {
      l.value && (l.value.warnHtmlMessage = j)
    },
    get escapeParameter() {
      return l.value ? l.value.escapeParameter : N
    },
    set escapeParameter(j) {
      l.value && (l.value.escapeParameter = j)
    },
    t: Ae,
    getPostTranslationHandler: le,
    setPostTranslationHandler: Ee,
    getMissingHandler: ye,
    setMissingHandler: ve,
    rt: He,
    d: De,
    n: Ye,
    tm: Je,
    te: he,
    getLocaleMessage: ke,
    setLocaleMessage: re,
    mergeLocaleMessage: Se,
    getDateTimeFormat: Be,
    setDateTimeFormat: J,
    mergeDateTimeFormat: Re,
    getNumberFormat: Xe,
    setNumberFormat: nt,
    mergeNumberFormat: Pe
  };

  function F(j) {
    j.locale.value = p.value, j.fallbackLocale.value = m.value, Object.keys(k.value).forEach(oe => {
      j.mergeLocaleMessage(oe, k.value[oe])
    }), Object.keys(w.value).forEach(oe => {
      j.mergeDateTimeFormat(oe, w.value[oe])
    }), Object.keys(S.value).forEach(oe => {
      j.mergeNumberFormat(oe, S.value[oe])
    }), j.escapeParameter = N, j.fallbackFormat = D, j.fallbackRoot = M, j.fallbackWarn = E, j.missingWarn = A, j.warnHtmlMessage = I
  }
  return mf(() => {
    if (e.proxy == null || e.proxy.$i18n == null) throw tr(Ga.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    const j = l.value = e.proxy.$i18n.__composer;
    t === "global" ? (p.value = j.locale.value, m.value = j.fallbackLocale.value, k.value = j.messages.value, w.value = j.datetimeFormats.value, S.value = j.numberFormats.value) : o && F(j)
  }), We
}
const n6 = ["locale", "fallbackLocale", "availableLocales"],
  Xv = ["t", "rt", "d", "n", "tm", "te"];

function i6(e, t) {
  const a = Object.create(null);
  return n6.forEach(o => {
    const l = Object.getOwnPropertyDescriptor(t, o);
    if (!l) throw tr(Ga.UNEXPECTED_ERROR);
    const h = Fa(l.value) ? {
      get() {
        return l.value.value
      },
      set(p) {
        l.value.value = p
      }
    } : {
      get() {
        return l.get && l.get()
      }
    };
    Object.defineProperty(a, o, h)
  }), e.config.globalProperties.$i18n = a, Xv.forEach(o => {
    const l = Object.getOwnPropertyDescriptor(t, o);
    if (!l || !l.value) throw tr(Ga.UNEXPECTED_ERROR);
    Object.defineProperty(e.config.globalProperties, `$${o}`, l)
  }), () => {
    delete e.config.globalProperties.$i18n, Xv.forEach(o => {
      delete e.config.globalProperties[`$${o}`]
    })
  }
}
D8();
__INTLIFY_JIT_COMPILATION__ ? kv(P8) : kv(E8);
y8(e8);
x8(Y1);
if (__INTLIFY_PROD_DEVTOOLS__) {
  const e = Vn();
  e.__INTLIFY__ = !0, c8(e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
/**
 * vue-meta v3.0.0-alpha.2
 * (c) 2021
 * - Pim (@pimlie)
 * - All the amazing contributors
 * @license MIT
 */
const s6 = {
  title: {
    attributes: !1
  },
  base: {
    contentAsAttribute: !0,
    attributes: ["href", "target"]
  },
  meta: {
    contentAsAttribute: !0,
    keyAttribute: "name",
    attributes: ["content", "name", "http-equiv", "charset"]
  },
  link: {
    contentAsAttribute: !0,
    attributes: ["href", "crossorigin", "rel", "media", "integrity", "hreflang", "type", "referrerpolicy", "sizes", "imagesrcset", "imagesizes", "as", "color"]
  },
  style: {
    attributes: ["media"]
  },
  script: {
    attributes: ["src", "type", "nomodule", "async", "defer", "crossorigin", "integrity", "referrerpolicy"]
  },
  noscript: {
    attributes: !1
  }
};

function o6(e, t) {
  for (const a of e) {
    const i = s6[a];
    if (a && i) return i[t]
  }
}
const un = Array.isArray,
  Kc = e => typeof e == "function",
  Wv = e => typeof e == "string",
  Ap = e => e !== null && typeof e == "object",
  l6 = Object.prototype.toString,
  c6 = e => l6.call(e),
  Zc = e => c6(e) === "[object Object]",
  Vv = Symbol("kIsProxy"),
  u6 = Symbol("kProxySources"),
  ow = Symbol("kProxyTarget"),
  Bs = Symbol("kResolveContext");

function _l(e) {
  if (un(e)) return e.map(_l);
  if (Ap(e)) {
    const t = {};
    for (const a in e) a === "context" ? t[a] = e[a] : t[a] = _l(e[a]);
    return t
  }
  return e
}
const _c = (e, t, a) => {
    const i = [];
    for (const o of e) t in o && (i.push(o[t]), a && a(o));
    return i
  },
  d6 = (e, ...t) => {
    const a = e ? Object.keys(e) : [];
    if (t) {
      for (const i of t)
        if (!(!i || !Ap(i)))
          for (const o in i) a.includes(o) || a.push(o)
    }
    return a
  },
  Cp = (e, t, a, i = []) => {
    if (i.length || (a || (a = e.active), t || (t = e.sources)), !a || !t) return;
    const o = d6(...t),
      l = Object.keys(a);
    for (const h of l) o.includes(h) || delete a[h];
    for (const h of o) {
      if (Zc(t[0][h])) {
        a[h] || (a[h] = {});
        const w = [];
        for (const S of t) h in S && w.push(S[h]);
        Cp(e, w, a[h], [...i, h]);
        continue
      }!a[h] && un(t[0][h]) && (a[h] = []);
      const p = [],
        m = _c(t, h, w => p.push(w[Bs]));
      let k = e.resolve(m, p, a[h], h, i);
      Zc(k) && (k = _l(k)), a[h] = k
    }
  },
  lw = (e, t, a, i = []) => {
    const o = h6(e, a, i),
      l = yb(new Proxy(t, o));
    return !i.length && e.sources && e.sources.push(l), l
  },
  h6 = (e, t, a = []) => ({
    get: (i, o, l) => {
      if (o === Vv) return !0;
      if (o === u6) return e.sources;
      if (o === ow) return i;
      if (o === Bs) return t;
      let h = Reflect.get(i, o, l);
      if (!Ap(h)) return h;
      if (!h[Vv]) {
        const p = [...a, o];
        h = lw(e, h, t, p), i[o] = h
      }
      return h
    },
    set: (i, o, l) => {
      const h = Reflect.set(i, o, l);
      if (h) {
        const p = un(i);
        let m = !1,
          {
            sources: k,
            active: w
          } = e,
          S, A = 0;
        for (const B of a) {
          if (k = _c(k, B), p && A === a.length - 1) {
            S = B;
            break
          }
          un(w) && (m = !0), w = w[B], A++
        }
        if (m) return Cp(e), h;
        let E = [],
          M;
        p ? (M = k, E = k.map(B => B[Bs])) : M = _c(k, o, B => E.push(B[Bs]));
        let D = e.resolve(M, E, w, o, a);
        Zc(D) && (D = _l(D)), p && S ? w[S] = D : w[o] = D
      }
      return h
    },
    deleteProperty: (i, o) => {
      const l = Reflect.deleteProperty(i, o);
      if (l) {
        const h = un(i);
        let p, m = e.sources,
          k = e.active,
          w = 0;
        for (const S of a) {
          if (m = m.map(A => A[S]), h && w === a.length - 1) {
            p = S;
            break
          }
          k = k[S], w++
        }
        if (m.some(S => o in S)) {
          let S = [],
            A;
          h ? (A = m, S = m.map(M => M[Bs])) : A = _c(m, o, M => S.push(M[Bs]));
          let E = e.resolve(A, S, k, o, a);
          Zc(E) && (E = _l(E)), h && p ? k[p] = E : k[o] = E
        } else delete k[o]
      }
      return l
    }
  }),
  f6 = (e, t = {}) => {
    const a = [];
    t || (t = {});
    const i = {
        active: t,
        resolve: e,
        sources: a
      },
      o = () => Cp(i);
    return {
      context: i,
      compute: o,
      addSource: (l, h, p = !1) => {
        const m = lw(i, l, h || {});
        return p && o(), m
      },
      delSource: (l, h = !0) => {
        const p = a.findIndex(m => m === l || m[ow] === l);
        return p > -1 ? (a.splice(p, 1), h && o(), !0) : !1
      }
    }
  };

function p6(e, t, a, i) {
  return "attributesFor" in i ? m6(e, t, a, i) : "group" in i ? g6(e, t, a, i) : Qc(e, t, a, i)
}

function g6(e, t, a, i) {
  return un(a) ? [] : Object.keys(a).map(o => {
    const l = {
      group: t,
      data: a
    };
    if (i.namespaced) l.tagNamespace = i.namespaced === !0 ? t : i.namespaced;
    else if (i.namespacedAttribute) {
      const h = i.namespacedAttribute === !0 ? t : i.namespacedAttribute;
      l.fullName = `${h}:${o}`, l.slotName = `${h}(${o})`
    }
    return Qc(e, t, a[o], i, l)
  }).flat()
}

function Qc(e, t, a, i = {}, o) {
  const l = ["content", "json", "rawContent"],
    h = B => o6([p, i.tag], B);
  if (un(a)) return a.map(B => Qc(e, t, B, i, o)).flat();
  const {
    tag: p = i.tag || t
  } = a;
  let m = "",
    k = !1,
    w = !1;
  if (Wv(a)) m = a;
  else if (a.children && un(a.children)) k = !0, m = a.children.map(B => {
    const z = Qc(e, t, B, i, o);
    return un(z) ? z.map(({
      vnode: I
    }) => I) : z.vnode
  });
  else {
    let B = 0;
    for (const z of l) {
      if (!m && a[z]) {
        B === 1 ? m = JSON.stringify(a[z]) : m = a[z], w = B > 1;
        break
      }
      B++
    }
  }
  const S = o && o.fullName || t,
    A = o && o.slotName || t;
  let {
    attrs: E
  } = a;
  if (!E && typeof a == "object") {
    E = {
      ...a
    }, delete E.tag, delete E.children, delete E.to;
    for (const B of l) delete E[B]
  } else E || (E = {});
  if (k) m = Zd(e, A, m, a);
  else {
    const B = !!h("contentAsAttribute");
    let {
      valueAttribute: z
    } = i;
    if (!z && B) {
      const [I] = h("attributes");
      z = Wv(B) ? B : I
    }
    if (!z) m = Zd(e, A, m, a);
    else {
      const {
        nameless: I,
        keyAttribute: N
      } = i;
      I || N && (E[N] = S), E[z] = Zd(e, A, E[z] || m, o), m = ""
    }
  }
  const M = o && o.tagNamespace ? `${o.tagNamespace}:${p}` : p;
  w && m && (E.innerHTML = m);
  const D = oa(M, E, m || void 0);
  return {
    to: a.to,
    vnode: D
  }
}

function m6(e, t, a, i) {
  const {
    attributesFor: o
  } = i;
  if (o) return {
    to: "",
    vnode: oa(`ssr-${o}`, a)
  }
}

function Zd({
  metainfo: e,
  slots: t
}, a, i, o) {
  const l = t && t[a];
  if (!l || !Kc(l)) return i;
  const h = {
    content: i,
    metainfo: e
  };
  if (o && o.group) {
    const {
      group: m,
      data: k
    } = o;
    h[m] = k
  }
  const p = l(h);
  if (p && p.length) {
    const {
      children: m
    } = p[0];
    return m ? m.toString() : ""
  }
  return i
}
const v6 = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol",
  b6 = e => v6 ? Symbol(e) : "_vm_" + e,
  y6 = b6("ma");

function x6(e) {
  if (e || (e = hn() || void 0), !!e) return e.appContext.config.globalProperties.$metaManager
}
const w6 = Ot({
    name: "Metainfo",
    inheritAttrs: !1,
    setup(e, {
      slots: t
    }) {
      return () => {
        const a = x6();
        if (a) return a.render({
          slots: t
        })
      }
    }
  }),
  k6 = w6,
  _6 = "data-vm-ssr",
  es = qr({});

function jv(e, t, a) {
  const i = un(a) ? a : [a];
  t.endsWith("Attrs") || i.forEach(o => {
    o.props || (o.props = {}), o.props[_6] = !0
  }), e[t] || (e[t] = []), e[t].push(...i)
}
const S6 = (e, t) => tf.create(e, t);
class tf {
  constructor(t, a, i) {
    this.ssrCleanedUp = !1, this.config = t, this.target = a, i && "setup" in i && Kc(i.setup) && (this.resolver = i)
  }
  install(t) {
    t.component("Metainfo", k6), t.config.globalProperties.$metaManager = this, t.provide(y6, es)
  }
  addMeta(t, a) {
    a || (a = hn() || void 0);
    const i = {
        removed: []
      },
      o = {
        vm: a
      };
    this.resolver && this.resolver.setup(o);
    const l = this.target.addSource(t, o, !0),
      h = m => i.removed.push(m),
      p = m => this.unmount(!!m, l, i, a);
    return a && Ha(p), {
      meta: l,
      onRemoved: h,
      unmount: p
    }
  }
  unmount(t, a, i, o) {
    if (o) {
      const {
        $el: l
      } = o.proxy;
      if (l && l.offsetParent) {
        let h = new MutationObserver(p => {
          for (const {
              removedNodes: m
            }
            of p) m && m.forEach(k => {
            k === l && h && (h.disconnect(), h = void 0, this.reallyUnmount(t, a, i))
          })
        });
        h.observe(l.parentNode, {
          childList: !0
        });
        return
      }
    }
    this.reallyUnmount(t, a, i)
  }
  async reallyUnmount(t, a, i) {
    this.target.delSource(a), !t && i && await Promise.all(i.removed.map(o => o()))
  }
  render({
    slots: t
  } = {}) {
    const a = {};
    for (const i in es) {
      const o = this.config[i] || {};
      let l = p6({
        metainfo: es,
        slots: t
      }, i, es[i], o);
      if (!l) continue;
      un(l) || (l = [l]);
      let h = i !== "base" && es[i].to;
      !h && "to" in o && (h = o.to), !h && "attributesFor" in o && (h = i);
      for (const {
          to: p,
          vnode: m
        }
        of l) jv(a, p || h || "head", m)
    }
    if (t)
      for (const i in t) {
        const o = i === "default" ? "head" : i;
        if (o !== "head" && o !== "body") continue;
        const l = t[i];
        Kc(l) && jv(a, o, l({
          metainfo: es
        }))
      }
    return Object.keys(a).map(i => oa(xf, {
      to: i
    }, a[i]))
  }
}
tf.create = (e, t) => {
  const i = f6((l, h, p, m, k) => Kc(t) ? t(l, h, p, m, k) : t.resolve(l, h, p, m, k), es);
  return new tf(e, i, t)
};
async function A6() {
  return {
    en: (await Qt.get("/lang/en.json")).data
  }
}
async function C6() {
  const e = await A6(),
    t = q8({
      legacy: !1,
      locale: "en",
      fallbackLocale: "en",
      messages: e
    }),
    a = M_(D2),
    i = S6();
  a.use(o$).use(I1).use(Rc).use(t).use(i), a.mount("#app")
}
C6();
